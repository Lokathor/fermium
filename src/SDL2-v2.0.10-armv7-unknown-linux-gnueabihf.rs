/* automatically generated by rust-bindgen */

pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_JOYSTICK_DISABLED: u32 = 1;
pub const SDL_HAPTIC_DISABLED: u32 = 1;
pub const SDL_SENSOR_DISABLED: u32 = 1;
pub const SDL_LOADSO_DISABLED: u32 = 1;
pub const SDL_THREADS_DISABLED: u32 = 1;
pub const SDL_TIMERS_DISABLED: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_FILESYSTEM_DUMMY: u32 = 1;
pub const SDL_PRIs64: &'static [u8; 4usize] = b"lld\0";
pub const SDL_PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const SDL_PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const SDL_PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_AUDIOCVT_MAX_FILTERS: u32 = 9;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_SIMD_ALIGNED: u32 = 8;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
  b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
  b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &'static [u8; 28usize] =
  b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &'static [u8; 29usize] =
  b"SDL_RENDER_LOGICAL_SIZE_MODE\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
  b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &'static [u8; 26usize] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &'static [u8; 39usize] =
  b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &'static [u8; 44usize] =
  b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &'static [u8; 29usize] =
  b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &'static [u8; 35usize] =
  b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &'static [u8; 31usize] =
  b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &'static [u8; 28usize] =
  b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &'static [u8; 30usize] =
  b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &'static [u8; 29usize] =
  b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &'static [u8; 31usize] =
  b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
  b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &'static [u8; 29usize] =
  b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &'static [u8; 23usize] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_MOUSE_TOUCH_EVENTS: &'static [u8; 23usize] = b"SDL_MOUSE_TOUCH_EVENTS\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
  b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &'static [u8; 34usize] =
  b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &'static [u8; 35usize] =
  b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &'static [u8; 28usize] =
  b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
  b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &'static [u8; 26usize] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &'static [u8; 36usize] =
  b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG_FILE: &'static [u8; 30usize] =
  b"SDL_GAMECONTROLLERCONFIG_FILE\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &'static [u8; 34usize] =
  b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &'static [u8; 41usize] =
  b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
  b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &'static [u8; 20usize] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &'static [u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &'static [u8; 31usize] =
  b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &'static [u8; 26usize] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &'static [u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &'static [u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_ENABLE_STEAM_CONTROLLERS: &'static [u8; 29usize] =
  b"SDL_ENABLE_STEAM_CONTROLLERS\0";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &'static [u8; 34usize] =
  b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &'static [u8; 27usize] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &'static [u8; 22usize] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize] =
  b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
  b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &'static [u8; 29usize] =
  b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &'static [u8; 31usize] =
  b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &'static [u8; 29usize] =
  b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
  b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &'static [u8; 23usize] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION: &'static [u8; 44usize] =
  b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION: &'static [u8; 45usize] =
  b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &'static [u8; 25usize] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &'static [u8; 29usize] =
  b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE: &'static [u8; 27usize] = b"SDL_ANDROID_BLOCK_ON_PAUSE\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &'static [u8; 25usize] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &'static [u8; 32usize] =
  b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &'static [u8; 23usize] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &'static [u8; 31usize] =
  b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &'static [u8; 27usize] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &'static [u8; 34usize] =
  b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &'static [u8; 20usize] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &'static [u8; 24usize] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &'static [u8; 21usize] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &'static [u8; 26usize] = b"SDL_AUDIO_RESAMPLING_MODE\0";
pub const SDL_HINT_AUDIO_CATEGORY: &'static [u8; 19usize] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_HINT_RENDER_BATCHING: &'static [u8; 20usize] = b"SDL_RENDER_BATCHING\0";
pub const SDL_HINT_EVENT_LOGGING: &'static [u8; 18usize] = b"SDL_EVENT_LOGGING\0";
pub const SDL_HINT_WAVE_RIFF_CHUNK_SIZE: &'static [u8; 25usize] = b"SDL_WAVE_RIFF_CHUNK_SIZE\0";
pub const SDL_HINT_WAVE_TRUNCATION: &'static [u8; 20usize] = b"SDL_WAVE_TRUNCATION\0";
pub const SDL_HINT_WAVE_FACT_CHUNK: &'static [u8; 20usize] = b"SDL_WAVE_FACT_CHUNK\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 10;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 62001;
extern "C" {
  pub fn SDL_GetPlatform() -> *const libc::c_char;
}
pub type wchar_t = libc::c_uint;
pub type va_list = __builtin_va_list;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub mod SDL_bool {
  pub type Type = u32;
  pub const SDL_FALSE: Type = 0;
  pub const SDL_TRUE: Type = 1;
}
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [libc::c_int; 1usize];
pub mod SDL_DUMMY_ENUM {
  pub type Type = u32;
  pub const DUMMY_ENUM_VALUE: Type = 0;
}
pub type SDL_compile_time_assert_enum = [libc::c_int; 1usize];
extern "C" {
  pub fn SDL_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_realloc(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_free(mem: *mut libc::c_void);
}
pub type SDL_malloc_func =
  ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut libc::c_void>;
pub type SDL_calloc_func =
  ::core::option::Option<unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut libc::c_void>;
pub type SDL_realloc_func = ::core::option::Option<
  unsafe extern "C" fn(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void,
>;
pub type SDL_free_func = ::core::option::Option<unsafe extern "C" fn(mem: *mut libc::c_void)>;
extern "C" {
  pub fn SDL_GetMemoryFunctions(
    malloc_func: *mut SDL_malloc_func,
    calloc_func: *mut SDL_calloc_func,
    realloc_func: *mut SDL_realloc_func,
    free_func: *mut SDL_free_func,
  );
}
extern "C" {
  pub fn SDL_SetMemoryFunctions(
    malloc_func: SDL_malloc_func,
    calloc_func: SDL_calloc_func,
    realloc_func: SDL_realloc_func,
    free_func: SDL_free_func,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetNumAllocations() -> libc::c_int;
}
extern "C" {
  pub fn SDL_getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_setenv(
    name: *const libc::c_char,
    value: *const libc::c_char,
    overwrite: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_qsort(
    base: *mut libc::c_void,
    nmemb: usize,
    size: usize,
    compare: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  );
}
extern "C" {
  pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_memcpy(
    dst: *mut libc::c_void,
    src: *const libc::c_void,
    len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_memmove(
    dst: *mut libc::c_void,
    src: *const libc::c_void,
    len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: usize) -> libc::c_int;
}
extern "C" {
  pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
  pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strlen(str: *const libc::c_char) -> usize;
}
extern "C" {
  pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_utf8strlcpy(
    dst: *mut libc::c_char,
    src: *const libc::c_char,
    dst_bytes: usize,
  ) -> usize;
}
extern "C" {
  pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_strdup(str: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strrev(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strupr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strlwr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strrchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strstr(
    haystack: *const libc::c_char,
    needle: *const libc::c_char,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_utf8strlen(str: *const libc::c_char) -> usize;
}
extern "C" {
  pub fn SDL_itoa(
    value: libc::c_int,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_uitoa(
    value: libc::c_uint,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_ltoa(
    value: libc::c_long,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_ultoa(
    value: libc::c_ulong,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_lltoa(value: Sint64, str: *mut libc::c_char, radix: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_ulltoa(value: Uint64, str: *mut libc::c_char, radix: libc::c_int)
    -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_atoi(str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_atof(str: *const libc::c_char) -> f64;
}
extern "C" {
  pub fn SDL_strtol(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> libc::c_long;
}
extern "C" {
  pub fn SDL_strtoul(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> libc::c_ulong;
}
extern "C" {
  pub fn SDL_strtoll(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> Sint64;
}
extern "C" {
  pub fn SDL_strtoull(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> Uint64;
}
extern "C" {
  pub fn SDL_strtod(str: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
extern "C" {
  pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strncmp(
    str1: *const libc::c_char,
    str2: *const libc::c_char,
    maxlen: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strncasecmp(
    str1: *const libc::c_char,
    str2: *const libc::c_char,
    len: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  pub fn SDL_vsscanf(
    text: *const libc::c_char,
    fmt: *const libc::c_char,
    ap: va_list,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_snprintf(
    text: *mut libc::c_char,
    maxlen: usize,
    fmt: *const libc::c_char,
    ...
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_vsnprintf(
    text: *mut libc::c_char,
    maxlen: usize,
    fmt: *const libc::c_char,
    ap: va_list,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_atan2f(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
  pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
  pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_iconv_t {
  _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
  pub fn SDL_iconv_open(tocode: *const libc::c_char, fromcode: *const libc::c_char) -> SDL_iconv_t;
}
extern "C" {
  pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
extern "C" {
  pub fn SDL_iconv(
    cd: SDL_iconv_t,
    inbuf: *mut *const libc::c_char,
    inbytesleft: *mut usize,
    outbuf: *mut *mut libc::c_char,
    outbytesleft: *mut usize,
  ) -> usize;
}
extern "C" {
  pub fn SDL_iconv_string(
    tocode: *const libc::c_char,
    fromcode: *const libc::c_char,
    inbuf: *const libc::c_char,
    inbytesleft: usize,
  ) -> *mut libc::c_char;
}
pub type SDL_main_func = ::core::option::Option<
  unsafe extern "C" fn(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int,
>;
extern "C" {
  pub fn SDL_main(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetMainReady();
}
pub mod SDL_AssertState {
  pub type Type = u32;
  pub const SDL_ASSERTION_RETRY: Type = 0;
  pub const SDL_ASSERTION_BREAK: Type = 1;
  pub const SDL_ASSERTION_ABORT: Type = 2;
  pub const SDL_ASSERTION_IGNORE: Type = 3;
  pub const SDL_ASSERTION_ALWAYS_IGNORE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AssertData {
  pub always_ignore: libc::c_int,
  pub trigger_count: libc::c_uint,
  pub condition: *const libc::c_char,
  pub filename: *const libc::c_char,
  pub linenum: libc::c_int,
  pub function: *const libc::c_char,
  pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AssertData>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_AssertData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AssertData>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_AssertData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).always_ignore as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(always_ignore)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).trigger_count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(trigger_count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).condition as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(condition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).filename as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(filename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).linenum as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(linenum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).function as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(function)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).next as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(next)
    )
  );
}
impl Default for SDL_AssertData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_ReportAssertion(
    arg1: *mut SDL_AssertData,
    arg2: *const libc::c_char,
    arg3: *const libc::c_char,
    arg4: libc::c_int,
  ) -> SDL_AssertState::Type;
}
pub type SDL_AssertionHandler = ::core::option::Option<
  unsafe extern "C" fn(
    data: *const SDL_AssertData,
    userdata: *mut libc::c_void,
  ) -> SDL_AssertState::Type,
>;
extern "C" {
  pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
extern "C" {
  pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
  pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
extern "C" {
  pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
  pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = libc::c_int;
extern "C" {
  pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
  pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
  pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
  pub fn SDL_MemoryBarrierAcquireFunction();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_atomic_t {
  pub value: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
  assert_eq!(
    ::core::mem::size_of::<SDL_atomic_t>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_atomic_t))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_atomic_t>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_atomic_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_atomic_t>())).value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_atomic_t),
      "::",
      stringify!(value)
    )
  );
}
extern "C" {
  pub fn SDL_AtomicCAS(
    a: *mut SDL_atomic_t,
    oldval: libc::c_int,
    newval: libc::c_int,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AtomicCASPtr(
    a: *mut *mut libc::c_void,
    oldval: *mut libc::c_void,
    newval: *mut libc::c_void,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_AtomicSetPtr(a: *mut *mut libc::c_void, v: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_AtomicGetPtr(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetError() -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_ClearError();
}
pub mod SDL_errorcode {
  pub type Type = u32;
  pub const SDL_ENOMEM: Type = 0;
  pub const SDL_EFREAD: Type = 1;
  pub const SDL_EFWRITE: Type = 2;
  pub const SDL_EFSEEK: Type = 3;
  pub const SDL_UNSUPPORTED: Type = 4;
  pub const SDL_LASTERROR: Type = 5;
}
extern "C" {
  pub fn SDL_Error(code: SDL_errorcode::Type) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
  _unused: [u8; 0],
}
extern "C" {
  pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
  pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
  _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
  pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
  pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
  pub fn SDL_SemWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SemPost(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
  _unused: [u8; 0],
}
extern "C" {
  pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
  pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
  pub fn SDL_CondSignal(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CondWaitTimeout(cond: *mut SDL_cond, mutex: *mut SDL_mutex, ms: Uint32)
    -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
  _unused: [u8; 0],
}
pub type SDL_threadID = libc::c_ulong;
pub type SDL_TLSID = libc::c_uint;
pub mod SDL_ThreadPriority {
  pub type Type = u32;
  pub const SDL_THREAD_PRIORITY_LOW: Type = 0;
  pub const SDL_THREAD_PRIORITY_NORMAL: Type = 1;
  pub const SDL_THREAD_PRIORITY_HIGH: Type = 2;
  pub const SDL_THREAD_PRIORITY_TIME_CRITICAL: Type = 3;
}
pub type SDL_ThreadFunction =
  ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> libc::c_int>;
extern "C" {
  pub fn SDL_CreateThread(
    fn_: SDL_ThreadFunction,
    name: *const libc::c_char,
    data: *mut libc::c_void,
  ) -> *mut SDL_Thread;
}
extern "C" {
  pub fn SDL_CreateThreadWithStackSize(
    fn_: SDL_ThreadFunction,
    name: *const libc::c_char,
    stacksize: usize,
    data: *mut libc::c_void,
  ) -> *mut SDL_Thread;
}
extern "C" {
  pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
  pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
  pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority::Type) -> libc::c_int;
}
extern "C" {
  pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
extern "C" {
  pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
  pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
  pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_TLSSet(
    id: SDL_TLSID,
    value: *const libc::c_void,
    destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
  ) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
  pub size: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
  pub seek: ::core::option::Option<
    unsafe extern "C" fn(context: *mut SDL_RWops, offset: Sint64, whence: libc::c_int) -> Sint64,
  >,
  pub read: ::core::option::Option<
    unsafe extern "C" fn(
      context: *mut SDL_RWops,
      ptr: *mut libc::c_void,
      size: usize,
      maxnum: usize,
    ) -> usize,
  >,
  pub write: ::core::option::Option<
    unsafe extern "C" fn(
      context: *mut SDL_RWops,
      ptr: *const libc::c_void,
      size: usize,
      num: usize,
    ) -> usize,
  >,
  pub close: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> libc::c_int>,
  pub type_: Uint32,
  pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
  pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
  pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
  pub base: *mut Uint8,
  pub here: *mut Uint8,
  pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).base as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).here as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(here)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).stop as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(stop)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
  pub data1: *mut libc::c_void,
  pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).data1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).data2 as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(data2)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).mem as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(mem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).unknown as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(unknown)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_RWops__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_RWops__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_RWops))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_RWops))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).seek as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(seek)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).read as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(read)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).write as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(write)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).close as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(close)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).type_ as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).hidden as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(hidden)
    )
  );
}
impl Default for SDL_RWops {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_RWops {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "SDL_RWops {{ size: {:?}, seek: {:?}, read: {:?}, write: {:?}, close: {:?}, type: {:?}, hidden: {:?} }}" , self . size , self . seek , self . read , self . write , self . close , self . type_ , self . hidden )
  }
}
extern "C" {
  pub fn SDL_RWFromFile(file: *const libc::c_char, mode: *const libc::c_char) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_RWFromFP(fp: *mut libc::c_void, autoclose: SDL_bool::Type) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_RWFromMem(mem: *mut libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_RWFromConstMem(mem: *const libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
  pub fn SDL_RWsize(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
  pub fn SDL_RWseek(context: *mut SDL_RWops, offset: Sint64, whence: libc::c_int) -> Sint64;
}
extern "C" {
  pub fn SDL_RWtell(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
  pub fn SDL_RWread(
    context: *mut SDL_RWops,
    ptr: *mut libc::c_void,
    size: usize,
    maxnum: usize,
  ) -> usize;
}
extern "C" {
  pub fn SDL_RWwrite(
    context: *mut SDL_RWops,
    ptr: *const libc::c_void,
    size: usize,
    num: usize,
  ) -> usize;
}
extern "C" {
  pub fn SDL_RWclose(context: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  pub fn SDL_LoadFile_RW(
    src: *mut SDL_RWops,
    datasize: *mut usize,
    freesrc: libc::c_int,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_LoadFile(file: *const libc::c_char, datasize: *mut usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
  pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
  pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
  pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
  pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
  pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
  pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
  pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
  pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
  pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
  pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
  pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
  pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
  pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
pub type SDL_AudioFormat = Uint16;
pub type SDL_AudioCallback = ::core::option::Option<
  unsafe extern "C" fn(userdata: *mut libc::c_void, stream: *mut Uint8, len: libc::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AudioSpec {
  pub freq: libc::c_int,
  pub format: SDL_AudioFormat,
  pub channels: Uint8,
  pub silence: Uint8,
  pub samples: Uint16,
  pub padding: Uint16,
  pub size: Uint32,
  pub callback: SDL_AudioCallback,
  pub userdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioSpec>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_AudioSpec))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioSpec>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_AudioSpec))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).freq as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(freq)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).channels as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).silence as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(silence)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).samples as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).padding as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).size as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).callback as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(callback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).userdata as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(userdata)
    )
  );
}
impl Default for SDL_AudioSpec {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SDL_AudioFilter =
  ::core::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AudioCVT {
  pub needed: libc::c_int,
  pub src_format: SDL_AudioFormat,
  pub dst_format: SDL_AudioFormat,
  pub rate_incr: f64,
  pub buf: *mut Uint8,
  pub len: libc::c_int,
  pub len_cvt: libc::c_int,
  pub len_mult: libc::c_int,
  pub len_ratio: f64,
  pub filters: [SDL_AudioFilter; 10usize],
  pub filter_index: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioCVT>(),
    84usize,
    concat!("Size of: ", stringify!(SDL_AudioCVT))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioCVT>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_AudioCVT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).needed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(needed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).src_format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(src_format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).dst_format as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(dst_format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).rate_incr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(rate_incr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).buf as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_cvt as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_cvt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_mult as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_mult)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_ratio as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_ratio)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filters as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(filters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filter_index as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(filter_index)
    )
  );
}
impl Default for SDL_AudioCVT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_AudioInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AudioQuit();
}
extern "C" {
  pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec, obtained: *mut SDL_AudioSpec) -> libc::c_int;
}
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
  pub fn SDL_GetNumAudioDevices(iscapture: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetAudioDeviceName(index: libc::c_int, iscapture: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_OpenAudioDevice(
    device: *const libc::c_char,
    iscapture: libc::c_int,
    desired: *const SDL_AudioSpec,
    obtained: *mut SDL_AudioSpec,
    allowed_changes: libc::c_int,
  ) -> SDL_AudioDeviceID;
}
pub mod SDL_AudioStatus {
  pub type Type = u32;
  pub const SDL_AUDIO_STOPPED: Type = 0;
  pub const SDL_AUDIO_PLAYING: Type = 1;
  pub const SDL_AUDIO_PAUSED: Type = 2;
}
extern "C" {
  pub fn SDL_GetAudioStatus() -> SDL_AudioStatus::Type;
}
extern "C" {
  pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus::Type;
}
extern "C" {
  pub fn SDL_PauseAudio(pause_on: libc::c_int);
}
extern "C" {
  pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: libc::c_int);
}
extern "C" {
  pub fn SDL_LoadWAV_RW(
    src: *mut SDL_RWops,
    freesrc: libc::c_int,
    spec: *mut SDL_AudioSpec,
    audio_buf: *mut *mut Uint8,
    audio_len: *mut Uint32,
  ) -> *mut SDL_AudioSpec;
}
extern "C" {
  pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
  pub fn SDL_BuildAudioCVT(
    cvt: *mut SDL_AudioCVT,
    src_format: SDL_AudioFormat,
    src_channels: Uint8,
    src_rate: libc::c_int,
    dst_format: SDL_AudioFormat,
    dst_channels: Uint8,
    dst_rate: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_AudioStream {
  _unused: [u8; 0],
}
pub type SDL_AudioStream = _SDL_AudioStream;
extern "C" {
  pub fn SDL_NewAudioStream(
    src_format: SDL_AudioFormat,
    src_channels: Uint8,
    src_rate: libc::c_int,
    dst_format: SDL_AudioFormat,
    dst_channels: Uint8,
    dst_rate: libc::c_int,
  ) -> *mut SDL_AudioStream;
}
extern "C" {
  pub fn SDL_AudioStreamPut(
    stream: *mut SDL_AudioStream,
    buf: *const libc::c_void,
    len: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AudioStreamGet(
    stream: *mut SDL_AudioStream,
    buf: *mut libc::c_void,
    len: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AudioStreamFlush(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AudioStreamClear(stream: *mut SDL_AudioStream);
}
extern "C" {
  pub fn SDL_FreeAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
  pub fn SDL_MixAudio(dst: *mut Uint8, src: *const Uint8, len: Uint32, volume: libc::c_int);
}
extern "C" {
  pub fn SDL_MixAudioFormat(
    dst: *mut Uint8,
    src: *const Uint8,
    format: SDL_AudioFormat,
    len: Uint32,
    volume: libc::c_int,
  );
}
extern "C" {
  pub fn SDL_QueueAudio(
    dev: SDL_AudioDeviceID,
    data: *const libc::c_void,
    len: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID, data: *mut libc::c_void, len: Uint32) -> Uint32;
}
extern "C" {
  pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
  pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
  pub fn SDL_LockAudio();
}
extern "C" {
  pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  pub fn SDL_UnlockAudio();
}
extern "C" {
  pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  pub fn SDL_CloseAudio();
}
extern "C" {
  pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  pub fn SDL_SetClipboardText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_HasClipboardText() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetCPUCount() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
extern "C" {
  pub fn SDL_HasRDTSC() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasAltiVec() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasMMX() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_Has3DNow() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasSSE() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasSSE2() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasSSE3() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasSSE41() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasSSE42() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasAVX() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasAVX2() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasAVX512F() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasNEON() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetSystemRAM() -> libc::c_int;
}
extern "C" {
  pub fn SDL_SIMDGetAlignment() -> usize;
}
extern "C" {
  pub fn SDL_SIMDAlloc(len: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_SIMDFree(ptr: *mut libc::c_void);
}
pub mod _bindgen_ty_1 {
  pub type Type = u32;
  pub const SDL_PIXELTYPE_UNKNOWN: Type = 0;
  pub const SDL_PIXELTYPE_INDEX1: Type = 1;
  pub const SDL_PIXELTYPE_INDEX4: Type = 2;
  pub const SDL_PIXELTYPE_INDEX8: Type = 3;
  pub const SDL_PIXELTYPE_PACKED8: Type = 4;
  pub const SDL_PIXELTYPE_PACKED16: Type = 5;
  pub const SDL_PIXELTYPE_PACKED32: Type = 6;
  pub const SDL_PIXELTYPE_ARRAYU8: Type = 7;
  pub const SDL_PIXELTYPE_ARRAYU16: Type = 8;
  pub const SDL_PIXELTYPE_ARRAYU32: Type = 9;
  pub const SDL_PIXELTYPE_ARRAYF16: Type = 10;
  pub const SDL_PIXELTYPE_ARRAYF32: Type = 11;
}
pub mod _bindgen_ty_2 {
  pub type Type = u32;
  pub const SDL_BITMAPORDER_NONE: Type = 0;
  pub const SDL_BITMAPORDER_4321: Type = 1;
  pub const SDL_BITMAPORDER_1234: Type = 2;
}
pub mod _bindgen_ty_3 {
  pub type Type = u32;
  pub const SDL_PACKEDORDER_NONE: Type = 0;
  pub const SDL_PACKEDORDER_XRGB: Type = 1;
  pub const SDL_PACKEDORDER_RGBX: Type = 2;
  pub const SDL_PACKEDORDER_ARGB: Type = 3;
  pub const SDL_PACKEDORDER_RGBA: Type = 4;
  pub const SDL_PACKEDORDER_XBGR: Type = 5;
  pub const SDL_PACKEDORDER_BGRX: Type = 6;
  pub const SDL_PACKEDORDER_ABGR: Type = 7;
  pub const SDL_PACKEDORDER_BGRA: Type = 8;
}
pub mod _bindgen_ty_4 {
  pub type Type = u32;
  pub const SDL_ARRAYORDER_NONE: Type = 0;
  pub const SDL_ARRAYORDER_RGB: Type = 1;
  pub const SDL_ARRAYORDER_RGBA: Type = 2;
  pub const SDL_ARRAYORDER_ARGB: Type = 3;
  pub const SDL_ARRAYORDER_BGR: Type = 4;
  pub const SDL_ARRAYORDER_BGRA: Type = 5;
  pub const SDL_ARRAYORDER_ABGR: Type = 6;
}
pub mod _bindgen_ty_5 {
  pub type Type = u32;
  pub const SDL_PACKEDLAYOUT_NONE: Type = 0;
  pub const SDL_PACKEDLAYOUT_332: Type = 1;
  pub const SDL_PACKEDLAYOUT_4444: Type = 2;
  pub const SDL_PACKEDLAYOUT_1555: Type = 3;
  pub const SDL_PACKEDLAYOUT_5551: Type = 4;
  pub const SDL_PACKEDLAYOUT_565: Type = 5;
  pub const SDL_PACKEDLAYOUT_8888: Type = 6;
  pub const SDL_PACKEDLAYOUT_2101010: Type = 7;
  pub const SDL_PACKEDLAYOUT_1010102: Type = 8;
}
pub mod SDL_PixelFormatEnum {
  pub type Type = u32;
  pub const SDL_PIXELFORMAT_UNKNOWN: Type = 0;
  pub const SDL_PIXELFORMAT_INDEX1LSB: Type = 286261504;
  pub const SDL_PIXELFORMAT_INDEX1MSB: Type = 287310080;
  pub const SDL_PIXELFORMAT_INDEX4LSB: Type = 303039488;
  pub const SDL_PIXELFORMAT_INDEX4MSB: Type = 304088064;
  pub const SDL_PIXELFORMAT_INDEX8: Type = 318769153;
  pub const SDL_PIXELFORMAT_RGB332: Type = 336660481;
  pub const SDL_PIXELFORMAT_RGB444: Type = 353504258;
  pub const SDL_PIXELFORMAT_RGB555: Type = 353570562;
  pub const SDL_PIXELFORMAT_BGR555: Type = 357764866;
  pub const SDL_PIXELFORMAT_ARGB4444: Type = 355602434;
  pub const SDL_PIXELFORMAT_RGBA4444: Type = 356651010;
  pub const SDL_PIXELFORMAT_ABGR4444: Type = 359796738;
  pub const SDL_PIXELFORMAT_BGRA4444: Type = 360845314;
  pub const SDL_PIXELFORMAT_ARGB1555: Type = 355667970;
  pub const SDL_PIXELFORMAT_RGBA5551: Type = 356782082;
  pub const SDL_PIXELFORMAT_ABGR1555: Type = 359862274;
  pub const SDL_PIXELFORMAT_BGRA5551: Type = 360976386;
  pub const SDL_PIXELFORMAT_RGB565: Type = 353701890;
  pub const SDL_PIXELFORMAT_BGR565: Type = 357896194;
  pub const SDL_PIXELFORMAT_RGB24: Type = 386930691;
  pub const SDL_PIXELFORMAT_BGR24: Type = 390076419;
  pub const SDL_PIXELFORMAT_RGB888: Type = 370546692;
  pub const SDL_PIXELFORMAT_RGBX8888: Type = 371595268;
  pub const SDL_PIXELFORMAT_BGR888: Type = 374740996;
  pub const SDL_PIXELFORMAT_BGRX8888: Type = 375789572;
  pub const SDL_PIXELFORMAT_ARGB8888: Type = 372645892;
  pub const SDL_PIXELFORMAT_RGBA8888: Type = 373694468;
  pub const SDL_PIXELFORMAT_ABGR8888: Type = 376840196;
  pub const SDL_PIXELFORMAT_BGRA8888: Type = 377888772;
  pub const SDL_PIXELFORMAT_ARGB2101010: Type = 372711428;
  pub const SDL_PIXELFORMAT_RGBA32: Type = 376840196;
  pub const SDL_PIXELFORMAT_ARGB32: Type = 377888772;
  pub const SDL_PIXELFORMAT_BGRA32: Type = 372645892;
  pub const SDL_PIXELFORMAT_ABGR32: Type = 373694468;
  pub const SDL_PIXELFORMAT_YV12: Type = 842094169;
  pub const SDL_PIXELFORMAT_IYUV: Type = 1448433993;
  pub const SDL_PIXELFORMAT_YUY2: Type = 844715353;
  pub const SDL_PIXELFORMAT_UYVY: Type = 1498831189;
  pub const SDL_PIXELFORMAT_YVYU: Type = 1431918169;
  pub const SDL_PIXELFORMAT_NV12: Type = 842094158;
  pub const SDL_PIXELFORMAT_NV21: Type = 825382478;
  pub const SDL_PIXELFORMAT_EXTERNAL_OES: Type = 542328143;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Color {
  pub r: Uint8,
  pub g: Uint8,
  pub b: Uint8,
  pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Color>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_Color))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Color>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_Color))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(b)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).a as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(a)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Palette {
  pub ncolors: libc::c_int,
  pub colors: *mut SDL_Color,
  pub version: Uint32,
  pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Palette>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Palette))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Palette>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Palette))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).ncolors as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(ncolors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).colors as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(colors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).version as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).refcount as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(refcount)
    )
  );
}
impl Default for SDL_Palette {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_PixelFormat {
  pub format: Uint32,
  pub palette: *mut SDL_Palette,
  pub BitsPerPixel: Uint8,
  pub BytesPerPixel: Uint8,
  pub padding: [Uint8; 2usize],
  pub Rmask: Uint32,
  pub Gmask: Uint32,
  pub Bmask: Uint32,
  pub Amask: Uint32,
  pub Rloss: Uint8,
  pub Gloss: Uint8,
  pub Bloss: Uint8,
  pub Aloss: Uint8,
  pub Rshift: Uint8,
  pub Gshift: Uint8,
  pub Bshift: Uint8,
  pub Ashift: Uint8,
  pub refcount: libc::c_int,
  pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
  assert_eq!(
    ::core::mem::size_of::<SDL_PixelFormat>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_PixelFormat))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_PixelFormat>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_PixelFormat))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).format as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).palette as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(palette)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BitsPerPixel as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(BitsPerPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BytesPerPixel as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(BytesPerPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).padding as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rmask as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gmask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bmask as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Amask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Amask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rloss as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gloss as *const _ as usize },
    29usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bloss as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Aloss as *const _ as usize },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Aloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rshift as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gshift as *const _ as usize },
    33usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bshift as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Ashift as *const _ as usize },
    35usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Ashift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).refcount as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).next as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(next)
    )
  );
}
impl Default for SDL_PixelFormat {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_GetPixelFormatName(format: Uint32) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_PixelFormatEnumToMasks(
    format: Uint32,
    bpp: *mut libc::c_int,
    Rmask: *mut Uint32,
    Gmask: *mut Uint32,
    Bmask: *mut Uint32,
    Amask: *mut Uint32,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_MasksToPixelFormatEnum(
    bpp: libc::c_int,
    Rmask: Uint32,
    Gmask: Uint32,
    Bmask: Uint32,
    Amask: Uint32,
  ) -> Uint32;
}
extern "C" {
  pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
  pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
  pub fn SDL_AllocPalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
extern "C" {
  pub fn SDL_SetPixelFormatPalette(
    format: *mut SDL_PixelFormat,
    palette: *mut SDL_Palette,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetPaletteColors(
    palette: *mut SDL_Palette,
    colors: *const SDL_Color,
    firstcolor: libc::c_int,
    ncolors: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
  pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
  pub fn SDL_MapRGBA(
    format: *const SDL_PixelFormat,
    r: Uint8,
    g: Uint8,
    b: Uint8,
    a: Uint8,
  ) -> Uint32;
}
extern "C" {
  pub fn SDL_GetRGB(
    pixel: Uint32,
    format: *const SDL_PixelFormat,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
  );
}
extern "C" {
  pub fn SDL_GetRGBA(
    pixel: Uint32,
    format: *const SDL_PixelFormat,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
    a: *mut Uint8,
  );
}
extern "C" {
  pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Point {
  pub x: libc::c_int,
  pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Point>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_Point))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Point>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Point))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Point>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Point),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Point>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Point),
      "::",
      stringify!(y)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_FPoint {
  pub x: f32,
  pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_FPoint() {
  assert_eq!(
    ::core::mem::size_of::<SDL_FPoint>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_FPoint))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_FPoint>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_FPoint))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_FPoint>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_FPoint),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_FPoint>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_FPoint),
      "::",
      stringify!(y)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Rect {
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub w: libc::c_int,
  pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Rect>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Rect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Rect>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Rect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).w as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).h as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(h)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_FRect {
  pub x: f32,
  pub y: f32,
  pub w: f32,
  pub h: f32,
}
#[test]
fn bindgen_test_layout_SDL_FRect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_FRect>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_FRect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_FRect>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_FRect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_FRect>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_FRect),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_FRect>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_FRect),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_FRect>())).w as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_FRect),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_FRect>())).h as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_FRect),
      "::",
      stringify!(h)
    )
  );
}
extern "C" {
  pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_IntersectRect(
    A: *const SDL_Rect,
    B: *const SDL_Rect,
    result: *mut SDL_Rect,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
  pub fn SDL_EnclosePoints(
    points: *const SDL_Point,
    count: libc::c_int,
    clip: *const SDL_Rect,
    result: *mut SDL_Rect,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_IntersectRectAndLine(
    rect: *const SDL_Rect,
    X1: *mut libc::c_int,
    Y1: *mut libc::c_int,
    X2: *mut libc::c_int,
    Y2: *mut libc::c_int,
  ) -> SDL_bool::Type;
}
pub mod SDL_BlendMode {
  pub type Type = u32;
  pub const SDL_BLENDMODE_NONE: Type = 0;
  pub const SDL_BLENDMODE_BLEND: Type = 1;
  pub const SDL_BLENDMODE_ADD: Type = 2;
  pub const SDL_BLENDMODE_MOD: Type = 4;
  pub const SDL_BLENDMODE_INVALID: Type = 2147483647;
}
pub mod SDL_BlendOperation {
  pub type Type = u32;
  pub const SDL_BLENDOPERATION_ADD: Type = 1;
  pub const SDL_BLENDOPERATION_SUBTRACT: Type = 2;
  pub const SDL_BLENDOPERATION_REV_SUBTRACT: Type = 3;
  pub const SDL_BLENDOPERATION_MINIMUM: Type = 4;
  pub const SDL_BLENDOPERATION_MAXIMUM: Type = 5;
}
pub mod SDL_BlendFactor {
  pub type Type = u32;
  pub const SDL_BLENDFACTOR_ZERO: Type = 1;
  pub const SDL_BLENDFACTOR_ONE: Type = 2;
  pub const SDL_BLENDFACTOR_SRC_COLOR: Type = 3;
  pub const SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR: Type = 4;
  pub const SDL_BLENDFACTOR_SRC_ALPHA: Type = 5;
  pub const SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: Type = 6;
  pub const SDL_BLENDFACTOR_DST_COLOR: Type = 7;
  pub const SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR: Type = 8;
  pub const SDL_BLENDFACTOR_DST_ALPHA: Type = 9;
  pub const SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA: Type = 10;
}
extern "C" {
  pub fn SDL_ComposeCustomBlendMode(
    srcColorFactor: SDL_BlendFactor::Type,
    dstColorFactor: SDL_BlendFactor::Type,
    colorOperation: SDL_BlendOperation::Type,
    srcAlphaFactor: SDL_BlendFactor::Type,
    dstAlphaFactor: SDL_BlendFactor::Type,
    alphaOperation: SDL_BlendOperation::Type,
  ) -> SDL_BlendMode::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Surface {
  pub flags: Uint32,
  pub format: *mut SDL_PixelFormat,
  pub w: libc::c_int,
  pub h: libc::c_int,
  pub pitch: libc::c_int,
  pub pixels: *mut libc::c_void,
  pub userdata: *mut libc::c_void,
  pub locked: libc::c_int,
  pub lock_data: *mut libc::c_void,
  pub clip_rect: SDL_Rect,
  pub map: *mut SDL_BlitMap,
  pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Surface>(),
    60usize,
    concat!("Size of: ", stringify!(SDL_Surface))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Surface>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Surface))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).w as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).h as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pitch as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(pitch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pixels as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(pixels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).userdata as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(userdata)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).locked as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(locked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).lock_data as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(lock_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).clip_rect as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(clip_rect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).map as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(map)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).refcount as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(refcount)
    )
  );
}
impl Default for SDL_Surface {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SDL_blit = ::core::option::Option<
  unsafe extern "C" fn(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int,
>;
pub mod SDL_YUV_CONVERSION_MODE {
  pub type Type = u32;
  pub const SDL_YUV_CONVERSION_JPEG: Type = 0;
  pub const SDL_YUV_CONVERSION_BT601: Type = 1;
  pub const SDL_YUV_CONVERSION_BT709: Type = 2;
  pub const SDL_YUV_CONVERSION_AUTOMATIC: Type = 3;
}
extern "C" {
  pub fn SDL_CreateRGBSurface(
    flags: Uint32,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    Rmask: Uint32,
    Gmask: Uint32,
    Bmask: Uint32,
    Amask: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_CreateRGBSurfaceWithFormat(
    flags: Uint32,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    format: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_CreateRGBSurfaceFrom(
    pixels: *mut libc::c_void,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    pitch: libc::c_int,
    Rmask: Uint32,
    Gmask: Uint32,
    Bmask: Uint32,
    Amask: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_CreateRGBSurfaceWithFormatFrom(
    pixels: *mut libc::c_void,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    pitch: libc::c_int,
    format: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
  pub fn SDL_SetSurfacePalette(surface: *mut SDL_Surface, palette: *mut SDL_Palette)
    -> libc::c_int;
}
extern "C" {
  pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
  pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: libc::c_int) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_SaveBMP_RW(
    surface: *mut SDL_Surface,
    dst: *mut SDL_RWops,
    freedst: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, flag: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetColorKey(surface: *mut SDL_Surface, flag: libc::c_int, key: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HasColorKey(surface: *mut SDL_Surface) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetSurfaceColorMod(
    surface: *mut SDL_Surface,
    r: Uint8,
    g: Uint8,
    b: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetSurfaceColorMod(
    surface: *mut SDL_Surface,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetSurfaceBlendMode(
    surface: *mut SDL_Surface,
    blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetSurfaceBlendMode(
    surface: *mut SDL_Surface,
    blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
  pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_ConvertSurface(
    src: *mut SDL_Surface,
    fmt: *const SDL_PixelFormat,
    flags: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_ConvertSurfaceFormat(
    src: *mut SDL_Surface,
    pixel_format: Uint32,
    flags: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_ConvertPixels(
    width: libc::c_int,
    height: libc::c_int,
    src_format: Uint32,
    src: *const libc::c_void,
    src_pitch: libc::c_int,
    dst_format: Uint32,
    dst: *mut libc::c_void,
    dst_pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_FillRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_FillRects(
    dst: *mut SDL_Surface,
    rects: *const SDL_Rect,
    count: libc::c_int,
    color: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UpperBlit(
    src: *mut SDL_Surface,
    srcrect: *const SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_LowerBlit(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SoftStretch(
    src: *mut SDL_Surface,
    srcrect: *const SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *const SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UpperBlitScaled(
    src: *mut SDL_Surface,
    srcrect: *const SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_LowerBlitScaled(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE::Type);
}
extern "C" {
  pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE::Type;
}
extern "C" {
  pub fn SDL_GetYUVConversionModeForResolution(
    width: libc::c_int,
    height: libc::c_int,
  ) -> SDL_YUV_CONVERSION_MODE::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_DisplayMode {
  pub format: Uint32,
  pub w: libc::c_int,
  pub h: libc::c_int,
  pub refresh_rate: libc::c_int,
  pub driverdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DisplayMode>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_DisplayMode))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DisplayMode>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_DisplayMode))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).format as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).w as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).h as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).refresh_rate as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(refresh_rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).driverdata as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(driverdata)
    )
  );
}
impl Default for SDL_DisplayMode {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
  _unused: [u8; 0],
}
pub mod SDL_WindowFlags {
  pub type Type = u32;
  pub const SDL_WINDOW_FULLSCREEN: Type = 1;
  pub const SDL_WINDOW_OPENGL: Type = 2;
  pub const SDL_WINDOW_SHOWN: Type = 4;
  pub const SDL_WINDOW_HIDDEN: Type = 8;
  pub const SDL_WINDOW_BORDERLESS: Type = 16;
  pub const SDL_WINDOW_RESIZABLE: Type = 32;
  pub const SDL_WINDOW_MINIMIZED: Type = 64;
  pub const SDL_WINDOW_MAXIMIZED: Type = 128;
  pub const SDL_WINDOW_INPUT_GRABBED: Type = 256;
  pub const SDL_WINDOW_INPUT_FOCUS: Type = 512;
  pub const SDL_WINDOW_MOUSE_FOCUS: Type = 1024;
  pub const SDL_WINDOW_FULLSCREEN_DESKTOP: Type = 4097;
  pub const SDL_WINDOW_FOREIGN: Type = 2048;
  pub const SDL_WINDOW_ALLOW_HIGHDPI: Type = 8192;
  pub const SDL_WINDOW_MOUSE_CAPTURE: Type = 16384;
  pub const SDL_WINDOW_ALWAYS_ON_TOP: Type = 32768;
  pub const SDL_WINDOW_SKIP_TASKBAR: Type = 65536;
  pub const SDL_WINDOW_UTILITY: Type = 131072;
  pub const SDL_WINDOW_TOOLTIP: Type = 262144;
  pub const SDL_WINDOW_POPUP_MENU: Type = 524288;
  pub const SDL_WINDOW_VULKAN: Type = 268435456;
}
pub mod SDL_WindowEventID {
  pub type Type = u32;
  pub const SDL_WINDOWEVENT_NONE: Type = 0;
  pub const SDL_WINDOWEVENT_SHOWN: Type = 1;
  pub const SDL_WINDOWEVENT_HIDDEN: Type = 2;
  pub const SDL_WINDOWEVENT_EXPOSED: Type = 3;
  pub const SDL_WINDOWEVENT_MOVED: Type = 4;
  pub const SDL_WINDOWEVENT_RESIZED: Type = 5;
  pub const SDL_WINDOWEVENT_SIZE_CHANGED: Type = 6;
  pub const SDL_WINDOWEVENT_MINIMIZED: Type = 7;
  pub const SDL_WINDOWEVENT_MAXIMIZED: Type = 8;
  pub const SDL_WINDOWEVENT_RESTORED: Type = 9;
  pub const SDL_WINDOWEVENT_ENTER: Type = 10;
  pub const SDL_WINDOWEVENT_LEAVE: Type = 11;
  pub const SDL_WINDOWEVENT_FOCUS_GAINED: Type = 12;
  pub const SDL_WINDOWEVENT_FOCUS_LOST: Type = 13;
  pub const SDL_WINDOWEVENT_CLOSE: Type = 14;
  pub const SDL_WINDOWEVENT_TAKE_FOCUS: Type = 15;
  pub const SDL_WINDOWEVENT_HIT_TEST: Type = 16;
}
pub mod SDL_DisplayEventID {
  pub type Type = u32;
  pub const SDL_DISPLAYEVENT_NONE: Type = 0;
  pub const SDL_DISPLAYEVENT_ORIENTATION: Type = 1;
}
pub mod SDL_DisplayOrientation {
  pub type Type = u32;
  pub const SDL_ORIENTATION_UNKNOWN: Type = 0;
  pub const SDL_ORIENTATION_LANDSCAPE: Type = 1;
  pub const SDL_ORIENTATION_LANDSCAPE_FLIPPED: Type = 2;
  pub const SDL_ORIENTATION_PORTRAIT: Type = 3;
  pub const SDL_ORIENTATION_PORTRAIT_FLIPPED: Type = 4;
}
pub type SDL_GLContext = *mut libc::c_void;
pub mod SDL_GLattr {
  pub type Type = u32;
  pub const SDL_GL_RED_SIZE: Type = 0;
  pub const SDL_GL_GREEN_SIZE: Type = 1;
  pub const SDL_GL_BLUE_SIZE: Type = 2;
  pub const SDL_GL_ALPHA_SIZE: Type = 3;
  pub const SDL_GL_BUFFER_SIZE: Type = 4;
  pub const SDL_GL_DOUBLEBUFFER: Type = 5;
  pub const SDL_GL_DEPTH_SIZE: Type = 6;
  pub const SDL_GL_STENCIL_SIZE: Type = 7;
  pub const SDL_GL_ACCUM_RED_SIZE: Type = 8;
  pub const SDL_GL_ACCUM_GREEN_SIZE: Type = 9;
  pub const SDL_GL_ACCUM_BLUE_SIZE: Type = 10;
  pub const SDL_GL_ACCUM_ALPHA_SIZE: Type = 11;
  pub const SDL_GL_STEREO: Type = 12;
  pub const SDL_GL_MULTISAMPLEBUFFERS: Type = 13;
  pub const SDL_GL_MULTISAMPLESAMPLES: Type = 14;
  pub const SDL_GL_ACCELERATED_VISUAL: Type = 15;
  pub const SDL_GL_RETAINED_BACKING: Type = 16;
  pub const SDL_GL_CONTEXT_MAJOR_VERSION: Type = 17;
  pub const SDL_GL_CONTEXT_MINOR_VERSION: Type = 18;
  pub const SDL_GL_CONTEXT_EGL: Type = 19;
  pub const SDL_GL_CONTEXT_FLAGS: Type = 20;
  pub const SDL_GL_CONTEXT_PROFILE_MASK: Type = 21;
  pub const SDL_GL_SHARE_WITH_CURRENT_CONTEXT: Type = 22;
  pub const SDL_GL_FRAMEBUFFER_SRGB_CAPABLE: Type = 23;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR: Type = 24;
  pub const SDL_GL_CONTEXT_RESET_NOTIFICATION: Type = 25;
  pub const SDL_GL_CONTEXT_NO_ERROR: Type = 26;
}
pub mod SDL_GLprofile {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_PROFILE_CORE: Type = 1;
  pub const SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: Type = 2;
  pub const SDL_GL_CONTEXT_PROFILE_ES: Type = 4;
}
pub mod SDL_GLcontextFlag {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_DEBUG_FLAG: Type = 1;
  pub const SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: Type = 2;
  pub const SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: Type = 4;
  pub const SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: Type = 8;
}
pub mod SDL_GLcontextReleaseFlag {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: Type = 0;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: Type = 1;
}
pub mod SDL_GLContextResetNotification {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_RESET_NO_NOTIFICATION: Type = 0;
  pub const SDL_GL_CONTEXT_RESET_LOSE_CONTEXT: Type = 1;
}
extern "C" {
  pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_VideoInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_VideoQuit();
}
extern "C" {
  pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GetNumVideoDisplays() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetDisplayName(displayIndex: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GetDisplayBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetDisplayUsableBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetDisplayDPI(
    displayIndex: libc::c_int,
    ddpi: *mut f32,
    hdpi: *mut f32,
    vdpi: *mut f32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetDisplayOrientation(displayIndex: libc::c_int) -> SDL_DisplayOrientation::Type;
}
extern "C" {
  pub fn SDL_GetNumDisplayModes(displayIndex: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetDisplayMode(
    displayIndex: libc::c_int,
    modeIndex: libc::c_int,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetDesktopDisplayMode(
    displayIndex: libc::c_int,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetCurrentDisplayMode(
    displayIndex: libc::c_int,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetClosestDisplayMode(
    displayIndex: libc::c_int,
    mode: *const SDL_DisplayMode,
    closest: *mut SDL_DisplayMode,
  ) -> *mut SDL_DisplayMode;
}
extern "C" {
  pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetWindowDisplayMode(
    window: *mut SDL_Window,
    mode: *const SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetWindowDisplayMode(
    window: *mut SDL_Window,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  pub fn SDL_CreateWindow(
    title: *const libc::c_char,
    x: libc::c_int,
    y: libc::c_int,
    w: libc::c_int,
    h: libc::c_int,
    flags: Uint32,
  ) -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_CreateWindowFrom(data: *const libc::c_void) -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char);
}
extern "C" {
  pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
  pub fn SDL_SetWindowData(
    window: *mut SDL_Window,
    name: *const libc::c_char,
    userdata: *mut libc::c_void,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_GetWindowData(window: *mut SDL_Window, name: *const libc::c_char)
    -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_SetWindowPosition(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
  pub fn SDL_GetWindowPosition(window: *mut SDL_Window, x: *mut libc::c_int, y: *mut libc::c_int);
}
extern "C" {
  pub fn SDL_SetWindowSize(window: *mut SDL_Window, w: libc::c_int, h: libc::c_int);
}
extern "C" {
  pub fn SDL_GetWindowSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
  pub fn SDL_GetWindowBordersSize(
    window: *mut SDL_Window,
    top: *mut libc::c_int,
    left: *mut libc::c_int,
    bottom: *mut libc::c_int,
    right: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetWindowMinimumSize(window: *mut SDL_Window, min_w: libc::c_int, min_h: libc::c_int);
}
extern "C" {
  pub fn SDL_GetWindowMinimumSize(
    window: *mut SDL_Window,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
extern "C" {
  pub fn SDL_SetWindowMaximumSize(window: *mut SDL_Window, max_w: libc::c_int, max_h: libc::c_int);
}
extern "C" {
  pub fn SDL_GetWindowMaximumSize(
    window: *mut SDL_Window,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
extern "C" {
  pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool::Type);
}
extern "C" {
  pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool::Type);
}
extern "C" {
  pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UpdateWindowSurfaceRects(
    window: *mut SDL_Window,
    rects: *const SDL_Rect,
    numrects: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool::Type);
}
extern "C" {
  pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_SetWindowBrightness(window: *mut SDL_Window, brightness: f32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
  pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetWindowOpacity(window: *mut SDL_Window, out_opacity: *mut f32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetWindowModalFor(
    modal_window: *mut SDL_Window,
    parent_window: *mut SDL_Window,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetWindowGammaRamp(
    window: *mut SDL_Window,
    red: *const Uint16,
    green: *const Uint16,
    blue: *const Uint16,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetWindowGammaRamp(
    window: *mut SDL_Window,
    red: *mut Uint16,
    green: *mut Uint16,
    blue: *mut Uint16,
  ) -> libc::c_int;
}
pub mod SDL_HitTestResult {
  pub type Type = u32;
  pub const SDL_HITTEST_NORMAL: Type = 0;
  pub const SDL_HITTEST_DRAGGABLE: Type = 1;
  pub const SDL_HITTEST_RESIZE_TOPLEFT: Type = 2;
  pub const SDL_HITTEST_RESIZE_TOP: Type = 3;
  pub const SDL_HITTEST_RESIZE_TOPRIGHT: Type = 4;
  pub const SDL_HITTEST_RESIZE_RIGHT: Type = 5;
  pub const SDL_HITTEST_RESIZE_BOTTOMRIGHT: Type = 6;
  pub const SDL_HITTEST_RESIZE_BOTTOM: Type = 7;
  pub const SDL_HITTEST_RESIZE_BOTTOMLEFT: Type = 8;
  pub const SDL_HITTEST_RESIZE_LEFT: Type = 9;
}
pub type SDL_HitTest = ::core::option::Option<
  unsafe extern "C" fn(
    win: *mut SDL_Window,
    area: *const SDL_Point,
    data: *mut libc::c_void,
  ) -> SDL_HitTestResult::Type,
>;
extern "C" {
  pub fn SDL_SetWindowHitTest(
    window: *mut SDL_Window,
    callback: SDL_HitTest,
    callback_data: *mut libc::c_void,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_IsScreenSaverEnabled() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_EnableScreenSaver();
}
extern "C" {
  pub fn SDL_DisableScreenSaver();
}
extern "C" {
  pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
  pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GL_ResetAttributes();
}
extern "C" {
  pub fn SDL_GL_SetAttribute(attr: SDL_GLattr::Type, value: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_GetAttribute(attr: SDL_GLattr::Type, value: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
  pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
  pub fn SDL_GL_GetDrawableSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
  pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_GetSwapInterval() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
  pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
pub mod SDL_Scancode {
  pub type Type = u32;
  pub const SDL_SCANCODE_UNKNOWN: Type = 0;
  pub const SDL_SCANCODE_A: Type = 4;
  pub const SDL_SCANCODE_B: Type = 5;
  pub const SDL_SCANCODE_C: Type = 6;
  pub const SDL_SCANCODE_D: Type = 7;
  pub const SDL_SCANCODE_E: Type = 8;
  pub const SDL_SCANCODE_F: Type = 9;
  pub const SDL_SCANCODE_G: Type = 10;
  pub const SDL_SCANCODE_H: Type = 11;
  pub const SDL_SCANCODE_I: Type = 12;
  pub const SDL_SCANCODE_J: Type = 13;
  pub const SDL_SCANCODE_K: Type = 14;
  pub const SDL_SCANCODE_L: Type = 15;
  pub const SDL_SCANCODE_M: Type = 16;
  pub const SDL_SCANCODE_N: Type = 17;
  pub const SDL_SCANCODE_O: Type = 18;
  pub const SDL_SCANCODE_P: Type = 19;
  pub const SDL_SCANCODE_Q: Type = 20;
  pub const SDL_SCANCODE_R: Type = 21;
  pub const SDL_SCANCODE_S: Type = 22;
  pub const SDL_SCANCODE_T: Type = 23;
  pub const SDL_SCANCODE_U: Type = 24;
  pub const SDL_SCANCODE_V: Type = 25;
  pub const SDL_SCANCODE_W: Type = 26;
  pub const SDL_SCANCODE_X: Type = 27;
  pub const SDL_SCANCODE_Y: Type = 28;
  pub const SDL_SCANCODE_Z: Type = 29;
  pub const SDL_SCANCODE_1: Type = 30;
  pub const SDL_SCANCODE_2: Type = 31;
  pub const SDL_SCANCODE_3: Type = 32;
  pub const SDL_SCANCODE_4: Type = 33;
  pub const SDL_SCANCODE_5: Type = 34;
  pub const SDL_SCANCODE_6: Type = 35;
  pub const SDL_SCANCODE_7: Type = 36;
  pub const SDL_SCANCODE_8: Type = 37;
  pub const SDL_SCANCODE_9: Type = 38;
  pub const SDL_SCANCODE_0: Type = 39;
  pub const SDL_SCANCODE_RETURN: Type = 40;
  pub const SDL_SCANCODE_ESCAPE: Type = 41;
  pub const SDL_SCANCODE_BACKSPACE: Type = 42;
  pub const SDL_SCANCODE_TAB: Type = 43;
  pub const SDL_SCANCODE_SPACE: Type = 44;
  pub const SDL_SCANCODE_MINUS: Type = 45;
  pub const SDL_SCANCODE_EQUALS: Type = 46;
  pub const SDL_SCANCODE_LEFTBRACKET: Type = 47;
  pub const SDL_SCANCODE_RIGHTBRACKET: Type = 48;
  pub const SDL_SCANCODE_BACKSLASH: Type = 49;
  pub const SDL_SCANCODE_NONUSHASH: Type = 50;
  pub const SDL_SCANCODE_SEMICOLON: Type = 51;
  pub const SDL_SCANCODE_APOSTROPHE: Type = 52;
  pub const SDL_SCANCODE_GRAVE: Type = 53;
  pub const SDL_SCANCODE_COMMA: Type = 54;
  pub const SDL_SCANCODE_PERIOD: Type = 55;
  pub const SDL_SCANCODE_SLASH: Type = 56;
  pub const SDL_SCANCODE_CAPSLOCK: Type = 57;
  pub const SDL_SCANCODE_F1: Type = 58;
  pub const SDL_SCANCODE_F2: Type = 59;
  pub const SDL_SCANCODE_F3: Type = 60;
  pub const SDL_SCANCODE_F4: Type = 61;
  pub const SDL_SCANCODE_F5: Type = 62;
  pub const SDL_SCANCODE_F6: Type = 63;
  pub const SDL_SCANCODE_F7: Type = 64;
  pub const SDL_SCANCODE_F8: Type = 65;
  pub const SDL_SCANCODE_F9: Type = 66;
  pub const SDL_SCANCODE_F10: Type = 67;
  pub const SDL_SCANCODE_F11: Type = 68;
  pub const SDL_SCANCODE_F12: Type = 69;
  pub const SDL_SCANCODE_PRINTSCREEN: Type = 70;
  pub const SDL_SCANCODE_SCROLLLOCK: Type = 71;
  pub const SDL_SCANCODE_PAUSE: Type = 72;
  pub const SDL_SCANCODE_INSERT: Type = 73;
  pub const SDL_SCANCODE_HOME: Type = 74;
  pub const SDL_SCANCODE_PAGEUP: Type = 75;
  pub const SDL_SCANCODE_DELETE: Type = 76;
  pub const SDL_SCANCODE_END: Type = 77;
  pub const SDL_SCANCODE_PAGEDOWN: Type = 78;
  pub const SDL_SCANCODE_RIGHT: Type = 79;
  pub const SDL_SCANCODE_LEFT: Type = 80;
  pub const SDL_SCANCODE_DOWN: Type = 81;
  pub const SDL_SCANCODE_UP: Type = 82;
  pub const SDL_SCANCODE_NUMLOCKCLEAR: Type = 83;
  pub const SDL_SCANCODE_KP_DIVIDE: Type = 84;
  pub const SDL_SCANCODE_KP_MULTIPLY: Type = 85;
  pub const SDL_SCANCODE_KP_MINUS: Type = 86;
  pub const SDL_SCANCODE_KP_PLUS: Type = 87;
  pub const SDL_SCANCODE_KP_ENTER: Type = 88;
  pub const SDL_SCANCODE_KP_1: Type = 89;
  pub const SDL_SCANCODE_KP_2: Type = 90;
  pub const SDL_SCANCODE_KP_3: Type = 91;
  pub const SDL_SCANCODE_KP_4: Type = 92;
  pub const SDL_SCANCODE_KP_5: Type = 93;
  pub const SDL_SCANCODE_KP_6: Type = 94;
  pub const SDL_SCANCODE_KP_7: Type = 95;
  pub const SDL_SCANCODE_KP_8: Type = 96;
  pub const SDL_SCANCODE_KP_9: Type = 97;
  pub const SDL_SCANCODE_KP_0: Type = 98;
  pub const SDL_SCANCODE_KP_PERIOD: Type = 99;
  pub const SDL_SCANCODE_NONUSBACKSLASH: Type = 100;
  pub const SDL_SCANCODE_APPLICATION: Type = 101;
  pub const SDL_SCANCODE_POWER: Type = 102;
  pub const SDL_SCANCODE_KP_EQUALS: Type = 103;
  pub const SDL_SCANCODE_F13: Type = 104;
  pub const SDL_SCANCODE_F14: Type = 105;
  pub const SDL_SCANCODE_F15: Type = 106;
  pub const SDL_SCANCODE_F16: Type = 107;
  pub const SDL_SCANCODE_F17: Type = 108;
  pub const SDL_SCANCODE_F18: Type = 109;
  pub const SDL_SCANCODE_F19: Type = 110;
  pub const SDL_SCANCODE_F20: Type = 111;
  pub const SDL_SCANCODE_F21: Type = 112;
  pub const SDL_SCANCODE_F22: Type = 113;
  pub const SDL_SCANCODE_F23: Type = 114;
  pub const SDL_SCANCODE_F24: Type = 115;
  pub const SDL_SCANCODE_EXECUTE: Type = 116;
  pub const SDL_SCANCODE_HELP: Type = 117;
  pub const SDL_SCANCODE_MENU: Type = 118;
  pub const SDL_SCANCODE_SELECT: Type = 119;
  pub const SDL_SCANCODE_STOP: Type = 120;
  pub const SDL_SCANCODE_AGAIN: Type = 121;
  pub const SDL_SCANCODE_UNDO: Type = 122;
  pub const SDL_SCANCODE_CUT: Type = 123;
  pub const SDL_SCANCODE_COPY: Type = 124;
  pub const SDL_SCANCODE_PASTE: Type = 125;
  pub const SDL_SCANCODE_FIND: Type = 126;
  pub const SDL_SCANCODE_MUTE: Type = 127;
  pub const SDL_SCANCODE_VOLUMEUP: Type = 128;
  pub const SDL_SCANCODE_VOLUMEDOWN: Type = 129;
  pub const SDL_SCANCODE_KP_COMMA: Type = 133;
  pub const SDL_SCANCODE_KP_EQUALSAS400: Type = 134;
  pub const SDL_SCANCODE_INTERNATIONAL1: Type = 135;
  pub const SDL_SCANCODE_INTERNATIONAL2: Type = 136;
  pub const SDL_SCANCODE_INTERNATIONAL3: Type = 137;
  pub const SDL_SCANCODE_INTERNATIONAL4: Type = 138;
  pub const SDL_SCANCODE_INTERNATIONAL5: Type = 139;
  pub const SDL_SCANCODE_INTERNATIONAL6: Type = 140;
  pub const SDL_SCANCODE_INTERNATIONAL7: Type = 141;
  pub const SDL_SCANCODE_INTERNATIONAL8: Type = 142;
  pub const SDL_SCANCODE_INTERNATIONAL9: Type = 143;
  pub const SDL_SCANCODE_LANG1: Type = 144;
  pub const SDL_SCANCODE_LANG2: Type = 145;
  pub const SDL_SCANCODE_LANG3: Type = 146;
  pub const SDL_SCANCODE_LANG4: Type = 147;
  pub const SDL_SCANCODE_LANG5: Type = 148;
  pub const SDL_SCANCODE_LANG6: Type = 149;
  pub const SDL_SCANCODE_LANG7: Type = 150;
  pub const SDL_SCANCODE_LANG8: Type = 151;
  pub const SDL_SCANCODE_LANG9: Type = 152;
  pub const SDL_SCANCODE_ALTERASE: Type = 153;
  pub const SDL_SCANCODE_SYSREQ: Type = 154;
  pub const SDL_SCANCODE_CANCEL: Type = 155;
  pub const SDL_SCANCODE_CLEAR: Type = 156;
  pub const SDL_SCANCODE_PRIOR: Type = 157;
  pub const SDL_SCANCODE_RETURN2: Type = 158;
  pub const SDL_SCANCODE_SEPARATOR: Type = 159;
  pub const SDL_SCANCODE_OUT: Type = 160;
  pub const SDL_SCANCODE_OPER: Type = 161;
  pub const SDL_SCANCODE_CLEARAGAIN: Type = 162;
  pub const SDL_SCANCODE_CRSEL: Type = 163;
  pub const SDL_SCANCODE_EXSEL: Type = 164;
  pub const SDL_SCANCODE_KP_00: Type = 176;
  pub const SDL_SCANCODE_KP_000: Type = 177;
  pub const SDL_SCANCODE_THOUSANDSSEPARATOR: Type = 178;
  pub const SDL_SCANCODE_DECIMALSEPARATOR: Type = 179;
  pub const SDL_SCANCODE_CURRENCYUNIT: Type = 180;
  pub const SDL_SCANCODE_CURRENCYSUBUNIT: Type = 181;
  pub const SDL_SCANCODE_KP_LEFTPAREN: Type = 182;
  pub const SDL_SCANCODE_KP_RIGHTPAREN: Type = 183;
  pub const SDL_SCANCODE_KP_LEFTBRACE: Type = 184;
  pub const SDL_SCANCODE_KP_RIGHTBRACE: Type = 185;
  pub const SDL_SCANCODE_KP_TAB: Type = 186;
  pub const SDL_SCANCODE_KP_BACKSPACE: Type = 187;
  pub const SDL_SCANCODE_KP_A: Type = 188;
  pub const SDL_SCANCODE_KP_B: Type = 189;
  pub const SDL_SCANCODE_KP_C: Type = 190;
  pub const SDL_SCANCODE_KP_D: Type = 191;
  pub const SDL_SCANCODE_KP_E: Type = 192;
  pub const SDL_SCANCODE_KP_F: Type = 193;
  pub const SDL_SCANCODE_KP_XOR: Type = 194;
  pub const SDL_SCANCODE_KP_POWER: Type = 195;
  pub const SDL_SCANCODE_KP_PERCENT: Type = 196;
  pub const SDL_SCANCODE_KP_LESS: Type = 197;
  pub const SDL_SCANCODE_KP_GREATER: Type = 198;
  pub const SDL_SCANCODE_KP_AMPERSAND: Type = 199;
  pub const SDL_SCANCODE_KP_DBLAMPERSAND: Type = 200;
  pub const SDL_SCANCODE_KP_VERTICALBAR: Type = 201;
  pub const SDL_SCANCODE_KP_DBLVERTICALBAR: Type = 202;
  pub const SDL_SCANCODE_KP_COLON: Type = 203;
  pub const SDL_SCANCODE_KP_HASH: Type = 204;
  pub const SDL_SCANCODE_KP_SPACE: Type = 205;
  pub const SDL_SCANCODE_KP_AT: Type = 206;
  pub const SDL_SCANCODE_KP_EXCLAM: Type = 207;
  pub const SDL_SCANCODE_KP_MEMSTORE: Type = 208;
  pub const SDL_SCANCODE_KP_MEMRECALL: Type = 209;
  pub const SDL_SCANCODE_KP_MEMCLEAR: Type = 210;
  pub const SDL_SCANCODE_KP_MEMADD: Type = 211;
  pub const SDL_SCANCODE_KP_MEMSUBTRACT: Type = 212;
  pub const SDL_SCANCODE_KP_MEMMULTIPLY: Type = 213;
  pub const SDL_SCANCODE_KP_MEMDIVIDE: Type = 214;
  pub const SDL_SCANCODE_KP_PLUSMINUS: Type = 215;
  pub const SDL_SCANCODE_KP_CLEAR: Type = 216;
  pub const SDL_SCANCODE_KP_CLEARENTRY: Type = 217;
  pub const SDL_SCANCODE_KP_BINARY: Type = 218;
  pub const SDL_SCANCODE_KP_OCTAL: Type = 219;
  pub const SDL_SCANCODE_KP_DECIMAL: Type = 220;
  pub const SDL_SCANCODE_KP_HEXADECIMAL: Type = 221;
  pub const SDL_SCANCODE_LCTRL: Type = 224;
  pub const SDL_SCANCODE_LSHIFT: Type = 225;
  pub const SDL_SCANCODE_LALT: Type = 226;
  pub const SDL_SCANCODE_LGUI: Type = 227;
  pub const SDL_SCANCODE_RCTRL: Type = 228;
  pub const SDL_SCANCODE_RSHIFT: Type = 229;
  pub const SDL_SCANCODE_RALT: Type = 230;
  pub const SDL_SCANCODE_RGUI: Type = 231;
  pub const SDL_SCANCODE_MODE: Type = 257;
  pub const SDL_SCANCODE_AUDIONEXT: Type = 258;
  pub const SDL_SCANCODE_AUDIOPREV: Type = 259;
  pub const SDL_SCANCODE_AUDIOSTOP: Type = 260;
  pub const SDL_SCANCODE_AUDIOPLAY: Type = 261;
  pub const SDL_SCANCODE_AUDIOMUTE: Type = 262;
  pub const SDL_SCANCODE_MEDIASELECT: Type = 263;
  pub const SDL_SCANCODE_WWW: Type = 264;
  pub const SDL_SCANCODE_MAIL: Type = 265;
  pub const SDL_SCANCODE_CALCULATOR: Type = 266;
  pub const SDL_SCANCODE_COMPUTER: Type = 267;
  pub const SDL_SCANCODE_AC_SEARCH: Type = 268;
  pub const SDL_SCANCODE_AC_HOME: Type = 269;
  pub const SDL_SCANCODE_AC_BACK: Type = 270;
  pub const SDL_SCANCODE_AC_FORWARD: Type = 271;
  pub const SDL_SCANCODE_AC_STOP: Type = 272;
  pub const SDL_SCANCODE_AC_REFRESH: Type = 273;
  pub const SDL_SCANCODE_AC_BOOKMARKS: Type = 274;
  pub const SDL_SCANCODE_BRIGHTNESSDOWN: Type = 275;
  pub const SDL_SCANCODE_BRIGHTNESSUP: Type = 276;
  pub const SDL_SCANCODE_DISPLAYSWITCH: Type = 277;
  pub const SDL_SCANCODE_KBDILLUMTOGGLE: Type = 278;
  pub const SDL_SCANCODE_KBDILLUMDOWN: Type = 279;
  pub const SDL_SCANCODE_KBDILLUMUP: Type = 280;
  pub const SDL_SCANCODE_EJECT: Type = 281;
  pub const SDL_SCANCODE_SLEEP: Type = 282;
  pub const SDL_SCANCODE_APP1: Type = 283;
  pub const SDL_SCANCODE_APP2: Type = 284;
  pub const SDL_SCANCODE_AUDIOREWIND: Type = 285;
  pub const SDL_SCANCODE_AUDIOFASTFORWARD: Type = 286;
  pub const SDL_NUM_SCANCODES: Type = 512;
}
pub type SDL_Keycode = Sint32;
pub mod _bindgen_ty_6 {
  pub type Type = u32;
  pub const SDLK_UNKNOWN: Type = 0;
  pub const SDLK_RETURN: Type = 13;
  pub const SDLK_ESCAPE: Type = 27;
  pub const SDLK_BACKSPACE: Type = 8;
  pub const SDLK_TAB: Type = 9;
  pub const SDLK_SPACE: Type = 32;
  pub const SDLK_EXCLAIM: Type = 33;
  pub const SDLK_QUOTEDBL: Type = 34;
  pub const SDLK_HASH: Type = 35;
  pub const SDLK_PERCENT: Type = 37;
  pub const SDLK_DOLLAR: Type = 36;
  pub const SDLK_AMPERSAND: Type = 38;
  pub const SDLK_QUOTE: Type = 39;
  pub const SDLK_LEFTPAREN: Type = 40;
  pub const SDLK_RIGHTPAREN: Type = 41;
  pub const SDLK_ASTERISK: Type = 42;
  pub const SDLK_PLUS: Type = 43;
  pub const SDLK_COMMA: Type = 44;
  pub const SDLK_MINUS: Type = 45;
  pub const SDLK_PERIOD: Type = 46;
  pub const SDLK_SLASH: Type = 47;
  pub const SDLK_0: Type = 48;
  pub const SDLK_1: Type = 49;
  pub const SDLK_2: Type = 50;
  pub const SDLK_3: Type = 51;
  pub const SDLK_4: Type = 52;
  pub const SDLK_5: Type = 53;
  pub const SDLK_6: Type = 54;
  pub const SDLK_7: Type = 55;
  pub const SDLK_8: Type = 56;
  pub const SDLK_9: Type = 57;
  pub const SDLK_COLON: Type = 58;
  pub const SDLK_SEMICOLON: Type = 59;
  pub const SDLK_LESS: Type = 60;
  pub const SDLK_EQUALS: Type = 61;
  pub const SDLK_GREATER: Type = 62;
  pub const SDLK_QUESTION: Type = 63;
  pub const SDLK_AT: Type = 64;
  pub const SDLK_LEFTBRACKET: Type = 91;
  pub const SDLK_BACKSLASH: Type = 92;
  pub const SDLK_RIGHTBRACKET: Type = 93;
  pub const SDLK_CARET: Type = 94;
  pub const SDLK_UNDERSCORE: Type = 95;
  pub const SDLK_BACKQUOTE: Type = 96;
  pub const SDLK_a: Type = 97;
  pub const SDLK_b: Type = 98;
  pub const SDLK_c: Type = 99;
  pub const SDLK_d: Type = 100;
  pub const SDLK_e: Type = 101;
  pub const SDLK_f: Type = 102;
  pub const SDLK_g: Type = 103;
  pub const SDLK_h: Type = 104;
  pub const SDLK_i: Type = 105;
  pub const SDLK_j: Type = 106;
  pub const SDLK_k: Type = 107;
  pub const SDLK_l: Type = 108;
  pub const SDLK_m: Type = 109;
  pub const SDLK_n: Type = 110;
  pub const SDLK_o: Type = 111;
  pub const SDLK_p: Type = 112;
  pub const SDLK_q: Type = 113;
  pub const SDLK_r: Type = 114;
  pub const SDLK_s: Type = 115;
  pub const SDLK_t: Type = 116;
  pub const SDLK_u: Type = 117;
  pub const SDLK_v: Type = 118;
  pub const SDLK_w: Type = 119;
  pub const SDLK_x: Type = 120;
  pub const SDLK_y: Type = 121;
  pub const SDLK_z: Type = 122;
  pub const SDLK_CAPSLOCK: Type = 1073741881;
  pub const SDLK_F1: Type = 1073741882;
  pub const SDLK_F2: Type = 1073741883;
  pub const SDLK_F3: Type = 1073741884;
  pub const SDLK_F4: Type = 1073741885;
  pub const SDLK_F5: Type = 1073741886;
  pub const SDLK_F6: Type = 1073741887;
  pub const SDLK_F7: Type = 1073741888;
  pub const SDLK_F8: Type = 1073741889;
  pub const SDLK_F9: Type = 1073741890;
  pub const SDLK_F10: Type = 1073741891;
  pub const SDLK_F11: Type = 1073741892;
  pub const SDLK_F12: Type = 1073741893;
  pub const SDLK_PRINTSCREEN: Type = 1073741894;
  pub const SDLK_SCROLLLOCK: Type = 1073741895;
  pub const SDLK_PAUSE: Type = 1073741896;
  pub const SDLK_INSERT: Type = 1073741897;
  pub const SDLK_HOME: Type = 1073741898;
  pub const SDLK_PAGEUP: Type = 1073741899;
  pub const SDLK_DELETE: Type = 127;
  pub const SDLK_END: Type = 1073741901;
  pub const SDLK_PAGEDOWN: Type = 1073741902;
  pub const SDLK_RIGHT: Type = 1073741903;
  pub const SDLK_LEFT: Type = 1073741904;
  pub const SDLK_DOWN: Type = 1073741905;
  pub const SDLK_UP: Type = 1073741906;
  pub const SDLK_NUMLOCKCLEAR: Type = 1073741907;
  pub const SDLK_KP_DIVIDE: Type = 1073741908;
  pub const SDLK_KP_MULTIPLY: Type = 1073741909;
  pub const SDLK_KP_MINUS: Type = 1073741910;
  pub const SDLK_KP_PLUS: Type = 1073741911;
  pub const SDLK_KP_ENTER: Type = 1073741912;
  pub const SDLK_KP_1: Type = 1073741913;
  pub const SDLK_KP_2: Type = 1073741914;
  pub const SDLK_KP_3: Type = 1073741915;
  pub const SDLK_KP_4: Type = 1073741916;
  pub const SDLK_KP_5: Type = 1073741917;
  pub const SDLK_KP_6: Type = 1073741918;
  pub const SDLK_KP_7: Type = 1073741919;
  pub const SDLK_KP_8: Type = 1073741920;
  pub const SDLK_KP_9: Type = 1073741921;
  pub const SDLK_KP_0: Type = 1073741922;
  pub const SDLK_KP_PERIOD: Type = 1073741923;
  pub const SDLK_APPLICATION: Type = 1073741925;
  pub const SDLK_POWER: Type = 1073741926;
  pub const SDLK_KP_EQUALS: Type = 1073741927;
  pub const SDLK_F13: Type = 1073741928;
  pub const SDLK_F14: Type = 1073741929;
  pub const SDLK_F15: Type = 1073741930;
  pub const SDLK_F16: Type = 1073741931;
  pub const SDLK_F17: Type = 1073741932;
  pub const SDLK_F18: Type = 1073741933;
  pub const SDLK_F19: Type = 1073741934;
  pub const SDLK_F20: Type = 1073741935;
  pub const SDLK_F21: Type = 1073741936;
  pub const SDLK_F22: Type = 1073741937;
  pub const SDLK_F23: Type = 1073741938;
  pub const SDLK_F24: Type = 1073741939;
  pub const SDLK_EXECUTE: Type = 1073741940;
  pub const SDLK_HELP: Type = 1073741941;
  pub const SDLK_MENU: Type = 1073741942;
  pub const SDLK_SELECT: Type = 1073741943;
  pub const SDLK_STOP: Type = 1073741944;
  pub const SDLK_AGAIN: Type = 1073741945;
  pub const SDLK_UNDO: Type = 1073741946;
  pub const SDLK_CUT: Type = 1073741947;
  pub const SDLK_COPY: Type = 1073741948;
  pub const SDLK_PASTE: Type = 1073741949;
  pub const SDLK_FIND: Type = 1073741950;
  pub const SDLK_MUTE: Type = 1073741951;
  pub const SDLK_VOLUMEUP: Type = 1073741952;
  pub const SDLK_VOLUMEDOWN: Type = 1073741953;
  pub const SDLK_KP_COMMA: Type = 1073741957;
  pub const SDLK_KP_EQUALSAS400: Type = 1073741958;
  pub const SDLK_ALTERASE: Type = 1073741977;
  pub const SDLK_SYSREQ: Type = 1073741978;
  pub const SDLK_CANCEL: Type = 1073741979;
  pub const SDLK_CLEAR: Type = 1073741980;
  pub const SDLK_PRIOR: Type = 1073741981;
  pub const SDLK_RETURN2: Type = 1073741982;
  pub const SDLK_SEPARATOR: Type = 1073741983;
  pub const SDLK_OUT: Type = 1073741984;
  pub const SDLK_OPER: Type = 1073741985;
  pub const SDLK_CLEARAGAIN: Type = 1073741986;
  pub const SDLK_CRSEL: Type = 1073741987;
  pub const SDLK_EXSEL: Type = 1073741988;
  pub const SDLK_KP_00: Type = 1073742000;
  pub const SDLK_KP_000: Type = 1073742001;
  pub const SDLK_THOUSANDSSEPARATOR: Type = 1073742002;
  pub const SDLK_DECIMALSEPARATOR: Type = 1073742003;
  pub const SDLK_CURRENCYUNIT: Type = 1073742004;
  pub const SDLK_CURRENCYSUBUNIT: Type = 1073742005;
  pub const SDLK_KP_LEFTPAREN: Type = 1073742006;
  pub const SDLK_KP_RIGHTPAREN: Type = 1073742007;
  pub const SDLK_KP_LEFTBRACE: Type = 1073742008;
  pub const SDLK_KP_RIGHTBRACE: Type = 1073742009;
  pub const SDLK_KP_TAB: Type = 1073742010;
  pub const SDLK_KP_BACKSPACE: Type = 1073742011;
  pub const SDLK_KP_A: Type = 1073742012;
  pub const SDLK_KP_B: Type = 1073742013;
  pub const SDLK_KP_C: Type = 1073742014;
  pub const SDLK_KP_D: Type = 1073742015;
  pub const SDLK_KP_E: Type = 1073742016;
  pub const SDLK_KP_F: Type = 1073742017;
  pub const SDLK_KP_XOR: Type = 1073742018;
  pub const SDLK_KP_POWER: Type = 1073742019;
  pub const SDLK_KP_PERCENT: Type = 1073742020;
  pub const SDLK_KP_LESS: Type = 1073742021;
  pub const SDLK_KP_GREATER: Type = 1073742022;
  pub const SDLK_KP_AMPERSAND: Type = 1073742023;
  pub const SDLK_KP_DBLAMPERSAND: Type = 1073742024;
  pub const SDLK_KP_VERTICALBAR: Type = 1073742025;
  pub const SDLK_KP_DBLVERTICALBAR: Type = 1073742026;
  pub const SDLK_KP_COLON: Type = 1073742027;
  pub const SDLK_KP_HASH: Type = 1073742028;
  pub const SDLK_KP_SPACE: Type = 1073742029;
  pub const SDLK_KP_AT: Type = 1073742030;
  pub const SDLK_KP_EXCLAM: Type = 1073742031;
  pub const SDLK_KP_MEMSTORE: Type = 1073742032;
  pub const SDLK_KP_MEMRECALL: Type = 1073742033;
  pub const SDLK_KP_MEMCLEAR: Type = 1073742034;
  pub const SDLK_KP_MEMADD: Type = 1073742035;
  pub const SDLK_KP_MEMSUBTRACT: Type = 1073742036;
  pub const SDLK_KP_MEMMULTIPLY: Type = 1073742037;
  pub const SDLK_KP_MEMDIVIDE: Type = 1073742038;
  pub const SDLK_KP_PLUSMINUS: Type = 1073742039;
  pub const SDLK_KP_CLEAR: Type = 1073742040;
  pub const SDLK_KP_CLEARENTRY: Type = 1073742041;
  pub const SDLK_KP_BINARY: Type = 1073742042;
  pub const SDLK_KP_OCTAL: Type = 1073742043;
  pub const SDLK_KP_DECIMAL: Type = 1073742044;
  pub const SDLK_KP_HEXADECIMAL: Type = 1073742045;
  pub const SDLK_LCTRL: Type = 1073742048;
  pub const SDLK_LSHIFT: Type = 1073742049;
  pub const SDLK_LALT: Type = 1073742050;
  pub const SDLK_LGUI: Type = 1073742051;
  pub const SDLK_RCTRL: Type = 1073742052;
  pub const SDLK_RSHIFT: Type = 1073742053;
  pub const SDLK_RALT: Type = 1073742054;
  pub const SDLK_RGUI: Type = 1073742055;
  pub const SDLK_MODE: Type = 1073742081;
  pub const SDLK_AUDIONEXT: Type = 1073742082;
  pub const SDLK_AUDIOPREV: Type = 1073742083;
  pub const SDLK_AUDIOSTOP: Type = 1073742084;
  pub const SDLK_AUDIOPLAY: Type = 1073742085;
  pub const SDLK_AUDIOMUTE: Type = 1073742086;
  pub const SDLK_MEDIASELECT: Type = 1073742087;
  pub const SDLK_WWW: Type = 1073742088;
  pub const SDLK_MAIL: Type = 1073742089;
  pub const SDLK_CALCULATOR: Type = 1073742090;
  pub const SDLK_COMPUTER: Type = 1073742091;
  pub const SDLK_AC_SEARCH: Type = 1073742092;
  pub const SDLK_AC_HOME: Type = 1073742093;
  pub const SDLK_AC_BACK: Type = 1073742094;
  pub const SDLK_AC_FORWARD: Type = 1073742095;
  pub const SDLK_AC_STOP: Type = 1073742096;
  pub const SDLK_AC_REFRESH: Type = 1073742097;
  pub const SDLK_AC_BOOKMARKS: Type = 1073742098;
  pub const SDLK_BRIGHTNESSDOWN: Type = 1073742099;
  pub const SDLK_BRIGHTNESSUP: Type = 1073742100;
  pub const SDLK_DISPLAYSWITCH: Type = 1073742101;
  pub const SDLK_KBDILLUMTOGGLE: Type = 1073742102;
  pub const SDLK_KBDILLUMDOWN: Type = 1073742103;
  pub const SDLK_KBDILLUMUP: Type = 1073742104;
  pub const SDLK_EJECT: Type = 1073742105;
  pub const SDLK_SLEEP: Type = 1073742106;
  pub const SDLK_APP1: Type = 1073742107;
  pub const SDLK_APP2: Type = 1073742108;
  pub const SDLK_AUDIOREWIND: Type = 1073742109;
  pub const SDLK_AUDIOFASTFORWARD: Type = 1073742110;
}
pub mod SDL_Keymod {
  pub type Type = u32;
  pub const KMOD_NONE: Type = 0;
  pub const KMOD_LSHIFT: Type = 1;
  pub const KMOD_RSHIFT: Type = 2;
  pub const KMOD_LCTRL: Type = 64;
  pub const KMOD_RCTRL: Type = 128;
  pub const KMOD_LALT: Type = 256;
  pub const KMOD_RALT: Type = 512;
  pub const KMOD_LGUI: Type = 1024;
  pub const KMOD_RGUI: Type = 2048;
  pub const KMOD_NUM: Type = 4096;
  pub const KMOD_CAPS: Type = 8192;
  pub const KMOD_MODE: Type = 16384;
  pub const KMOD_RESERVED: Type = 32768;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Keysym {
  pub scancode: SDL_Scancode::Type,
  pub sym: SDL_Keycode,
  pub mod_: Uint16,
  pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Keysym>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Keysym))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Keysym>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Keysym))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).scancode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(scancode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).sym as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(sym)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).mod_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(mod_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).unused as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(unused)
    )
  );
}
impl Default for SDL_Keysym {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const Uint8;
}
extern "C" {
  pub fn SDL_GetModState() -> SDL_Keymod::Type;
}
extern "C" {
  pub fn SDL_SetModState(modstate: SDL_Keymod::Type);
}
extern "C" {
  pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode::Type) -> SDL_Keycode;
}
extern "C" {
  pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode::Type;
}
extern "C" {
  pub fn SDL_GetScancodeName(scancode: SDL_Scancode::Type) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode::Type;
}
extern "C" {
  pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
extern "C" {
  pub fn SDL_StartTextInput();
}
extern "C" {
  pub fn SDL_IsTextInputActive() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_StopTextInput();
}
extern "C" {
  pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
  pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
  _unused: [u8; 0],
}
pub mod SDL_SystemCursor {
  pub type Type = u32;
  pub const SDL_SYSTEM_CURSOR_ARROW: Type = 0;
  pub const SDL_SYSTEM_CURSOR_IBEAM: Type = 1;
  pub const SDL_SYSTEM_CURSOR_WAIT: Type = 2;
  pub const SDL_SYSTEM_CURSOR_CROSSHAIR: Type = 3;
  pub const SDL_SYSTEM_CURSOR_WAITARROW: Type = 4;
  pub const SDL_SYSTEM_CURSOR_SIZENWSE: Type = 5;
  pub const SDL_SYSTEM_CURSOR_SIZENESW: Type = 6;
  pub const SDL_SYSTEM_CURSOR_SIZEWE: Type = 7;
  pub const SDL_SYSTEM_CURSOR_SIZENS: Type = 8;
  pub const SDL_SYSTEM_CURSOR_SIZEALL: Type = 9;
  pub const SDL_SYSTEM_CURSOR_NO: Type = 10;
  pub const SDL_SYSTEM_CURSOR_HAND: Type = 11;
  pub const SDL_NUM_SYSTEM_CURSORS: Type = 12;
}
pub mod SDL_MouseWheelDirection {
  pub type Type = u32;
  pub const SDL_MOUSEWHEEL_NORMAL: Type = 0;
  pub const SDL_MOUSEWHEEL_FLIPPED: Type = 1;
}
extern "C" {
  pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_GetMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  pub fn SDL_GetGlobalMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  pub fn SDL_GetRelativeMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
  pub fn SDL_WarpMouseGlobal(x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool::Type) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CaptureMouse(enabled: SDL_bool::Type) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetRelativeMouseMode() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_CreateCursor(
    data: *const Uint8,
    mask: *const Uint8,
    w: libc::c_int,
    h: libc::c_int,
    hot_x: libc::c_int,
    hot_y: libc::c_int,
  ) -> *mut SDL_Cursor;
}
extern "C" {
  pub fn SDL_CreateColorCursor(
    surface: *mut SDL_Surface,
    hot_x: libc::c_int,
    hot_y: libc::c_int,
  ) -> *mut SDL_Cursor;
}
extern "C" {
  pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor::Type) -> *mut SDL_Cursor;
}
extern "C" {
  pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
  pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
  pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
  pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
  pub fn SDL_ShowCursor(toggle: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
  _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoystickGUID {
  pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoystickGUID>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoystickGUID))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoystickGUID>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_JoystickGUID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoystickGUID>())).data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoystickGUID),
      "::",
      stringify!(data)
    )
  );
}
pub type SDL_JoystickID = Sint32;
pub mod SDL_JoystickType {
  pub type Type = u32;
  pub const SDL_JOYSTICK_TYPE_UNKNOWN: Type = 0;
  pub const SDL_JOYSTICK_TYPE_GAMECONTROLLER: Type = 1;
  pub const SDL_JOYSTICK_TYPE_WHEEL: Type = 2;
  pub const SDL_JOYSTICK_TYPE_ARCADE_STICK: Type = 3;
  pub const SDL_JOYSTICK_TYPE_FLIGHT_STICK: Type = 4;
  pub const SDL_JOYSTICK_TYPE_DANCE_PAD: Type = 5;
  pub const SDL_JOYSTICK_TYPE_GUITAR: Type = 6;
  pub const SDL_JOYSTICK_TYPE_DRUM_KIT: Type = 7;
  pub const SDL_JOYSTICK_TYPE_ARCADE_PAD: Type = 8;
  pub const SDL_JOYSTICK_TYPE_THROTTLE: Type = 9;
}
pub mod SDL_JoystickPowerLevel {
  pub type Type = i32;
  pub const SDL_JOYSTICK_POWER_UNKNOWN: Type = -1;
  pub const SDL_JOYSTICK_POWER_EMPTY: Type = 0;
  pub const SDL_JOYSTICK_POWER_LOW: Type = 1;
  pub const SDL_JOYSTICK_POWER_MEDIUM: Type = 2;
  pub const SDL_JOYSTICK_POWER_FULL: Type = 3;
  pub const SDL_JOYSTICK_POWER_WIRED: Type = 4;
  pub const SDL_JOYSTICK_POWER_MAX: Type = 5;
}
extern "C" {
  pub fn SDL_LockJoysticks();
}
extern "C" {
  pub fn SDL_UnlockJoysticks();
}
extern "C" {
  pub fn SDL_NumJoysticks() -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickNameForIndex(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_JoystickGetDevicePlayerIndex(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickGetDeviceGUID(device_index: libc::c_int) -> SDL_JoystickGUID;
}
extern "C" {
  pub fn SDL_JoystickGetDeviceVendor(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  pub fn SDL_JoystickGetDeviceProduct(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  pub fn SDL_JoystickGetDeviceProductVersion(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  pub fn SDL_JoystickGetDeviceType(device_index: libc::c_int) -> SDL_JoystickType::Type;
}
extern "C" {
  pub fn SDL_JoystickGetDeviceInstanceID(device_index: libc::c_int) -> SDL_JoystickID;
}
extern "C" {
  pub fn SDL_JoystickOpen(device_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
  pub fn SDL_JoystickFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
  pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_JoystickGetPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
  pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick) -> SDL_JoystickType::Type;
}
extern "C" {
  pub fn SDL_JoystickGetGUIDString(
    guid: SDL_JoystickGUID,
    pszGUID: *mut libc::c_char,
    cbGUID: libc::c_int,
  );
}
extern "C" {
  pub fn SDL_JoystickGetGUIDFromString(pchGUID: *const libc::c_char) -> SDL_JoystickGUID;
}
extern "C" {
  pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
  pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickUpdate();
}
extern "C" {
  pub fn SDL_JoystickEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
extern "C" {
  pub fn SDL_JoystickGetAxisInitialState(
    joystick: *mut SDL_Joystick,
    axis: libc::c_int,
    state: *mut Sint16,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
extern "C" {
  pub fn SDL_JoystickGetBall(
    joystick: *mut SDL_Joystick,
    ball: libc::c_int,
    dx: *mut libc::c_int,
    dy: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> Uint8;
}
extern "C" {
  pub fn SDL_JoystickRumble(
    joystick: *mut SDL_Joystick,
    low_frequency_rumble: Uint16,
    high_frequency_rumble: Uint16,
    duration_ms: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
  pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick)
    -> SDL_JoystickPowerLevel::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_GameController {
  _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
pub mod SDL_GameControllerBindType {
  pub type Type = u32;
  pub const SDL_CONTROLLER_BINDTYPE_NONE: Type = 0;
  pub const SDL_CONTROLLER_BINDTYPE_BUTTON: Type = 1;
  pub const SDL_CONTROLLER_BINDTYPE_AXIS: Type = 2;
  pub const SDL_CONTROLLER_BINDTYPE_HAT: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
  pub bindType: SDL_GameControllerBindType::Type,
  pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
  pub button: libc::c_int,
  pub axis: libc::c_int,
  pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
  pub hat: libc::c_int,
  pub hat_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hat)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat_mask
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hat_mask)
    )
  );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).button as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).axis as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).hat as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(hat)
    )
  );
}
impl Default for SDL_GameControllerButtonBind__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_GameControllerButtonBind__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_GameControllerButtonBind__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).bindType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind),
      "::",
      stringify!(bindType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).value as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind),
      "::",
      stringify!(value)
    )
  );
}
impl Default for SDL_GameControllerButtonBind {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_GameControllerButtonBind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_GameControllerButtonBind {{ bindType: {:?}, value: {:?} }}",
      self.bindType, self.value
    )
  }
}
extern "C" {
  pub fn SDL_GameControllerAddMappingsFromRW(
    rw: *mut SDL_RWops,
    freerw: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GameControllerAddMapping(mappingString: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GameControllerNumMappings() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GameControllerMappingForIndex(mapping_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerMapping(gamecontroller: *mut SDL_GameController) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_IsGameController(joystick_index: libc::c_int) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GameControllerNameForIndex(joystick_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerMappingForDeviceIndex(joystick_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerOpen(joystick_index: libc::c_int) -> *mut SDL_GameController;
}
extern "C" {
  pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_GameController;
}
extern "C" {
  pub fn SDL_GameControllerName(gamecontroller: *mut SDL_GameController) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerGetPlayerIndex(gamecontroller: *mut SDL_GameController) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GameControllerGetVendor(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  pub fn SDL_GameControllerGetProduct(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  pub fn SDL_GameControllerGetProductVersion(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GameControllerGetJoystick(
    gamecontroller: *mut SDL_GameController,
  ) -> *mut SDL_Joystick;
}
extern "C" {
  pub fn SDL_GameControllerEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GameControllerUpdate();
}
pub mod SDL_GameControllerAxis {
  pub type Type = i32;
  pub const SDL_CONTROLLER_AXIS_INVALID: Type = -1;
  pub const SDL_CONTROLLER_AXIS_LEFTX: Type = 0;
  pub const SDL_CONTROLLER_AXIS_LEFTY: Type = 1;
  pub const SDL_CONTROLLER_AXIS_RIGHTX: Type = 2;
  pub const SDL_CONTROLLER_AXIS_RIGHTY: Type = 3;
  pub const SDL_CONTROLLER_AXIS_TRIGGERLEFT: Type = 4;
  pub const SDL_CONTROLLER_AXIS_TRIGGERRIGHT: Type = 5;
  pub const SDL_CONTROLLER_AXIS_MAX: Type = 6;
}
extern "C" {
  pub fn SDL_GameControllerGetAxisFromString(
    pchString: *const libc::c_char,
  ) -> SDL_GameControllerAxis::Type;
}
extern "C" {
  pub fn SDL_GameControllerGetStringForAxis(
    axis: SDL_GameControllerAxis::Type,
  ) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerGetBindForAxis(
    gamecontroller: *mut SDL_GameController,
    axis: SDL_GameControllerAxis::Type,
  ) -> SDL_GameControllerButtonBind;
}
extern "C" {
  pub fn SDL_GameControllerGetAxis(
    gamecontroller: *mut SDL_GameController,
    axis: SDL_GameControllerAxis::Type,
  ) -> Sint16;
}
pub mod SDL_GameControllerButton {
  pub type Type = i32;
  pub const SDL_CONTROLLER_BUTTON_INVALID: Type = -1;
  pub const SDL_CONTROLLER_BUTTON_A: Type = 0;
  pub const SDL_CONTROLLER_BUTTON_B: Type = 1;
  pub const SDL_CONTROLLER_BUTTON_X: Type = 2;
  pub const SDL_CONTROLLER_BUTTON_Y: Type = 3;
  pub const SDL_CONTROLLER_BUTTON_BACK: Type = 4;
  pub const SDL_CONTROLLER_BUTTON_GUIDE: Type = 5;
  pub const SDL_CONTROLLER_BUTTON_START: Type = 6;
  pub const SDL_CONTROLLER_BUTTON_LEFTSTICK: Type = 7;
  pub const SDL_CONTROLLER_BUTTON_RIGHTSTICK: Type = 8;
  pub const SDL_CONTROLLER_BUTTON_LEFTSHOULDER: Type = 9;
  pub const SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: Type = 10;
  pub const SDL_CONTROLLER_BUTTON_DPAD_UP: Type = 11;
  pub const SDL_CONTROLLER_BUTTON_DPAD_DOWN: Type = 12;
  pub const SDL_CONTROLLER_BUTTON_DPAD_LEFT: Type = 13;
  pub const SDL_CONTROLLER_BUTTON_DPAD_RIGHT: Type = 14;
  pub const SDL_CONTROLLER_BUTTON_MAX: Type = 15;
}
extern "C" {
  pub fn SDL_GameControllerGetButtonFromString(
    pchString: *const libc::c_char,
  ) -> SDL_GameControllerButton::Type;
}
extern "C" {
  pub fn SDL_GameControllerGetStringForButton(
    button: SDL_GameControllerButton::Type,
  ) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GameControllerGetBindForButton(
    gamecontroller: *mut SDL_GameController,
    button: SDL_GameControllerButton::Type,
  ) -> SDL_GameControllerButtonBind;
}
extern "C" {
  pub fn SDL_GameControllerGetButton(
    gamecontroller: *mut SDL_GameController,
    button: SDL_GameControllerButton::Type,
  ) -> Uint8;
}
extern "C" {
  pub fn SDL_GameControllerRumble(
    gamecontroller: *mut SDL_GameController,
    low_frequency_rumble: Uint16,
    high_frequency_rumble: Uint16,
    duration_ms: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
pub mod SDL_TouchDeviceType {
  pub type Type = i32;
  pub const SDL_TOUCH_DEVICE_INVALID: Type = -1;
  pub const SDL_TOUCH_DEVICE_DIRECT: Type = 0;
  pub const SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE: Type = 1;
  pub const SDL_TOUCH_DEVICE_INDIRECT_RELATIVE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Finger {
  pub id: SDL_FingerID,
  pub x: f32,
  pub y: f32,
  pub pressure: f32,
  pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Finger>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_Finger))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Finger>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Finger))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).id as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).x as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).y as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).pressure as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(pressure)
    )
  );
}
extern "C" {
  pub fn SDL_GetNumTouchDevices() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetTouchDevice(index: libc::c_int) -> SDL_TouchID;
}
extern "C" {
  pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType::Type;
}
extern "C" {
  pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetTouchFinger(touchID: SDL_TouchID, index: libc::c_int) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
  pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SaveDollarTemplate(gestureId: SDL_GestureID, dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  pub fn SDL_LoadDollarTemplates(touchId: SDL_TouchID, src: *mut SDL_RWops) -> libc::c_int;
}
pub mod SDL_EventType {
  pub type Type = u32;
  pub const SDL_FIRSTEVENT: Type = 0;
  pub const SDL_QUIT: Type = 256;
  pub const SDL_APP_TERMINATING: Type = 257;
  pub const SDL_APP_LOWMEMORY: Type = 258;
  pub const SDL_APP_WILLENTERBACKGROUND: Type = 259;
  pub const SDL_APP_DIDENTERBACKGROUND: Type = 260;
  pub const SDL_APP_WILLENTERFOREGROUND: Type = 261;
  pub const SDL_APP_DIDENTERFOREGROUND: Type = 262;
  pub const SDL_DISPLAYEVENT: Type = 336;
  pub const SDL_WINDOWEVENT: Type = 512;
  pub const SDL_SYSWMEVENT: Type = 513;
  pub const SDL_KEYDOWN: Type = 768;
  pub const SDL_KEYUP: Type = 769;
  pub const SDL_TEXTEDITING: Type = 770;
  pub const SDL_TEXTINPUT: Type = 771;
  pub const SDL_KEYMAPCHANGED: Type = 772;
  pub const SDL_MOUSEMOTION: Type = 1024;
  pub const SDL_MOUSEBUTTONDOWN: Type = 1025;
  pub const SDL_MOUSEBUTTONUP: Type = 1026;
  pub const SDL_MOUSEWHEEL: Type = 1027;
  pub const SDL_JOYAXISMOTION: Type = 1536;
  pub const SDL_JOYBALLMOTION: Type = 1537;
  pub const SDL_JOYHATMOTION: Type = 1538;
  pub const SDL_JOYBUTTONDOWN: Type = 1539;
  pub const SDL_JOYBUTTONUP: Type = 1540;
  pub const SDL_JOYDEVICEADDED: Type = 1541;
  pub const SDL_JOYDEVICEREMOVED: Type = 1542;
  pub const SDL_CONTROLLERAXISMOTION: Type = 1616;
  pub const SDL_CONTROLLERBUTTONDOWN: Type = 1617;
  pub const SDL_CONTROLLERBUTTONUP: Type = 1618;
  pub const SDL_CONTROLLERDEVICEADDED: Type = 1619;
  pub const SDL_CONTROLLERDEVICEREMOVED: Type = 1620;
  pub const SDL_CONTROLLERDEVICEREMAPPED: Type = 1621;
  pub const SDL_FINGERDOWN: Type = 1792;
  pub const SDL_FINGERUP: Type = 1793;
  pub const SDL_FINGERMOTION: Type = 1794;
  pub const SDL_DOLLARGESTURE: Type = 2048;
  pub const SDL_DOLLARRECORD: Type = 2049;
  pub const SDL_MULTIGESTURE: Type = 2050;
  pub const SDL_CLIPBOARDUPDATE: Type = 2304;
  pub const SDL_DROPFILE: Type = 4096;
  pub const SDL_DROPTEXT: Type = 4097;
  pub const SDL_DROPBEGIN: Type = 4098;
  pub const SDL_DROPCOMPLETE: Type = 4099;
  pub const SDL_AUDIODEVICEADDED: Type = 4352;
  pub const SDL_AUDIODEVICEREMOVED: Type = 4353;
  pub const SDL_SENSORUPDATE: Type = 4608;
  pub const SDL_RENDER_TARGETS_RESET: Type = 8192;
  pub const SDL_RENDER_DEVICE_RESET: Type = 8193;
  pub const SDL_USEREVENT: Type = 32768;
  pub const SDL_LASTEVENT: Type = 65535;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_CommonEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_CommonEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_CommonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_CommonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_CommonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_CommonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_CommonEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_DisplayEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub display: Uint32,
  pub event: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DisplayEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_DisplayEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DisplayEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_DisplayEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).display as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).event as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(data1)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_WindowEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub event: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  pub data1: Sint32,
  pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowEvent>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_WindowEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_WindowEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).event as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data2 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(data2)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_KeyboardEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub state: Uint8,
  pub repeat: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_KeyboardEvent>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_KeyboardEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_KeyboardEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).state as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).repeat as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(repeat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).keysym as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(keysym)
    )
  );
}
impl Default for SDL_KeyboardEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TextEditingEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub text: [libc::c_char; 32usize],
  pub start: Sint32,
  pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TextEditingEvent>(),
    52usize,
    concat!("Size of: ", stringify!(SDL_TextEditingEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TextEditingEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).text as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(text)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).start as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(start)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).length as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(length)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TextInputEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub text: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TextInputEvent>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_TextInputEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TextInputEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_TextInputEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).text as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(text)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseMotionEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub which: Uint32,
  pub state: Uint32,
  pub x: Sint32,
  pub y: Sint32,
  pub xrel: Sint32,
  pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseMotionEvent>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseMotionEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).state as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).xrel as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(xrel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).yrel as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(yrel)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseButtonEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub which: Uint32,
  pub button: Uint8,
  pub state: Uint8,
  pub clicks: Uint8,
  pub padding1: Uint8,
  pub x: Sint32,
  pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseButtonEvent>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).button as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).state as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).clicks as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(clicks)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).padding1 as *const _ as usize },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(y)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseWheelEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub which: Uint32,
  pub x: Sint32,
  pub y: Sint32,
  pub direction: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseWheelEvent>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseWheelEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).x as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).y as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).direction as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(direction)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyAxisEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: SDL_JoystickID,
  pub axis: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  pub value: Sint16,
  pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyAxisEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyAxisEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).axis as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding4 as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding4)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyBallEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: SDL_JoystickID,
  pub ball: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  pub xrel: Sint16,
  pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyBallEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_JoyBallEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyBallEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).ball as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(ball)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).xrel as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(xrel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).yrel as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(yrel)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyHatEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: SDL_JoystickID,
  pub hat: Uint8,
  pub value: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyHatEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoyHatEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyHatEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).hat as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(hat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).value as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyButtonEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: SDL_JoystickID,
  pub button: Uint8,
  pub state: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyButtonEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).button as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).state as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyDeviceEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyDeviceEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(which)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerAxisEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: SDL_JoystickID,
  pub axis: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  pub value: Sint16,
  pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerAxisEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerAxisEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).axis as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding4 as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding4)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerButtonEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: SDL_JoystickID,
  pub button: Uint8,
  pub state: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerButtonEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).timestamp as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).button as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).state as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerDeviceEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerDeviceEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).timestamp as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(which)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_AudioDeviceEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: Uint32,
  pub iscapture: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioDeviceEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).iscapture as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(iscapture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding3)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TouchFingerEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub touchId: SDL_TouchID,
  pub fingerId: SDL_FingerID,
  pub x: f32,
  pub y: f32,
  pub dx: f32,
  pub dy: f32,
  pub pressure: f32,
  pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TouchFingerEvent>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TouchFingerEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).fingerId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(fingerId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dx as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(dx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dy as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(dy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).pressure as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(pressure)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MultiGestureEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub touchId: SDL_TouchID,
  pub dTheta: f32,
  pub dDist: f32,
  pub x: f32,
  pub y: f32,
  pub numFingers: Uint16,
  pub padding: Uint16,
  pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MultiGestureEvent>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MultiGestureEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dTheta as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(dTheta)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dDist as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(dDist)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).numFingers as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(numFingers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).padding as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(padding)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_DollarGestureEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub touchId: SDL_TouchID,
  pub gestureId: SDL_GestureID,
  pub numFingers: Uint32,
  pub error: f32,
  pub x: f32,
  pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DollarGestureEvent>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DollarGestureEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).gestureId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(gestureId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).numFingers as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(numFingers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).error as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(y)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_DropEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub file: *mut libc::c_char,
  pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DropEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_DropEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DropEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_DropEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).file as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(file)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).windowID as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(windowID)
    )
  );
}
impl Default for SDL_DropEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_SensorEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub which: Sint32,
  pub data: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SensorEvent>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_SensorEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SensorEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SensorEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).data as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(data)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_QuitEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_QuitEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_QuitEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_QuitEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_QuitEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_QuitEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_QuitEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_OSEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_OSEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_OSEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_OSEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_OSEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_OSEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_OSEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_UserEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub windowID: Uint32,
  pub code: Sint32,
  pub data1: *mut libc::c_void,
  pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_UserEvent>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_UserEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_UserEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_UserEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).code as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data2 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(data2)
    )
  );
}
impl Default for SDL_UserEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMEvent {
  pub type_: Uint32,
  pub timestamp: Uint32,
  pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_SysWMEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SysWMEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).msg as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(msg)
    )
  );
}
impl Default for SDL_SysWMEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
  pub type_: Uint32,
  pub common: SDL_CommonEvent,
  pub display: SDL_DisplayEvent,
  pub window: SDL_WindowEvent,
  pub key: SDL_KeyboardEvent,
  pub edit: SDL_TextEditingEvent,
  pub text: SDL_TextInputEvent,
  pub motion: SDL_MouseMotionEvent,
  pub button: SDL_MouseButtonEvent,
  pub wheel: SDL_MouseWheelEvent,
  pub jaxis: SDL_JoyAxisEvent,
  pub jball: SDL_JoyBallEvent,
  pub jhat: SDL_JoyHatEvent,
  pub jbutton: SDL_JoyButtonEvent,
  pub jdevice: SDL_JoyDeviceEvent,
  pub caxis: SDL_ControllerAxisEvent,
  pub cbutton: SDL_ControllerButtonEvent,
  pub cdevice: SDL_ControllerDeviceEvent,
  pub adevice: SDL_AudioDeviceEvent,
  pub sensor: SDL_SensorEvent,
  pub quit: SDL_QuitEvent,
  pub user: SDL_UserEvent,
  pub syswm: SDL_SysWMEvent,
  pub tfinger: SDL_TouchFingerEvent,
  pub mgesture: SDL_MultiGestureEvent,
  pub dgesture: SDL_DollarGestureEvent,
  pub drop: SDL_DropEvent,
  pub padding: [Uint8; 56usize],
  _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Event>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_Event))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Event>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Event))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).common as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(common)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).display as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).window as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).key as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(key)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).edit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(edit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).text as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(text)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).motion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(motion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).button as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).wheel as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(wheel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jaxis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jaxis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jball as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jball)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jhat as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jhat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jdevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jdevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).caxis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(caxis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).cbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(cbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).cdevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(cdevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).adevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(adevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).sensor as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(sensor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).quit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(quit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).user as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(user)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).syswm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(syswm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).tfinger as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(tfinger)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).mgesture as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(mgesture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).dgesture as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(dgesture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).drop as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(drop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).padding as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(padding)
    )
  );
}
impl Default for SDL_Event {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_Event {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_Event {{ union }}")
  }
}
pub type SDL_compile_time_assert_SDL_Event = [libc::c_int; 1usize];
extern "C" {
  pub fn SDL_PumpEvents();
}
pub mod SDL_eventaction {
  pub type Type = u32;
  pub const SDL_ADDEVENT: Type = 0;
  pub const SDL_PEEKEVENT: Type = 1;
  pub const SDL_GETEVENT: Type = 2;
}
extern "C" {
  pub fn SDL_PeepEvents(
    events: *mut SDL_Event,
    numevents: libc::c_int,
    action: SDL_eventaction::Type,
    minType: Uint32,
    maxType: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
  pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
  pub fn SDL_PollEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
  pub fn SDL_WaitEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
  pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeout: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_PushEvent(event: *mut SDL_Event) -> libc::c_int;
}
pub type SDL_EventFilter = ::core::option::Option<
  unsafe extern "C" fn(userdata: *mut libc::c_void, event: *mut SDL_Event) -> libc::c_int,
>;
extern "C" {
  pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  pub fn SDL_GetEventFilter(
    filter: *mut SDL_EventFilter,
    userdata: *mut *mut libc::c_void,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  pub fn SDL_EventState(type_: Uint32, state: libc::c_int) -> Uint8;
}
extern "C" {
  pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
extern "C" {
  pub fn SDL_GetBasePath() -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Haptic {
  _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticDirection {
  pub type_: Uint8,
  pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticDirection>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_HapticDirection))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticDirection>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticDirection))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticDirection),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).dir as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticDirection),
      "::",
      stringify!(dir)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticConstant {
  pub type_: Uint16,
  pub direction: SDL_HapticDirection,
  pub length: Uint32,
  pub delay: Uint16,
  pub button: Uint16,
  pub interval: Uint16,
  pub level: Sint16,
  pub attack_length: Uint16,
  pub attack_level: Uint16,
  pub fade_length: Uint16,
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticConstant>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_HapticConstant))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticConstant>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticConstant))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).level as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_length as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_level as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_length as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_level as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(fade_level)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticPeriodic {
  pub type_: Uint16,
  pub direction: SDL_HapticDirection,
  pub length: Uint32,
  pub delay: Uint16,
  pub button: Uint16,
  pub interval: Uint16,
  pub period: Uint16,
  pub magnitude: Sint16,
  pub offset: Sint16,
  pub phase: Uint16,
  pub attack_length: Uint16,
  pub attack_level: Uint16,
  pub fade_length: Uint16,
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticPeriodic>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_HapticPeriodic))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticPeriodic>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).period as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(period)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).magnitude as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(magnitude)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).offset as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).phase as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(phase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_length as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_level as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_length as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_level as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(fade_level)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticCondition {
  pub type_: Uint16,
  pub direction: SDL_HapticDirection,
  pub length: Uint32,
  pub delay: Uint16,
  pub button: Uint16,
  pub interval: Uint16,
  pub right_sat: [Uint16; 3usize],
  pub left_sat: [Uint16; 3usize],
  pub right_coeff: [Sint16; 3usize],
  pub left_coeff: [Sint16; 3usize],
  pub deadband: [Uint16; 3usize],
  pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticCondition>(),
    68usize,
    concat!("Size of: ", stringify!(SDL_HapticCondition))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticCondition>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticCondition))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_sat as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(right_sat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_sat as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(left_sat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_coeff as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(right_coeff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_coeff as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(left_coeff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).deadband as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(deadband)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).center as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(center)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticRamp {
  pub type_: Uint16,
  pub direction: SDL_HapticDirection,
  pub length: Uint32,
  pub delay: Uint16,
  pub button: Uint16,
  pub interval: Uint16,
  pub start: Sint16,
  pub end: Sint16,
  pub attack_length: Uint16,
  pub attack_level: Uint16,
  pub fade_length: Uint16,
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticRamp>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_HapticRamp))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticRamp>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticRamp))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).start as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(start)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).end as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(end)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_length as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_level as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_length as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_level as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(fade_level)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticLeftRight {
  pub type_: Uint16,
  pub length: Uint32,
  pub large_magnitude: Uint16,
  pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticLeftRight>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_HapticLeftRight))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticLeftRight>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).length as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_HapticLeftRight>())).large_magnitude as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(large_magnitude)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_HapticLeftRight>())).small_magnitude as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(small_magnitude)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_HapticCustom {
  pub type_: Uint16,
  pub direction: SDL_HapticDirection,
  pub length: Uint32,
  pub delay: Uint16,
  pub button: Uint16,
  pub interval: Uint16,
  pub channels: Uint8,
  pub period: Uint16,
  pub samples: Uint16,
  pub data: *mut Uint16,
  pub attack_length: Uint16,
  pub attack_level: Uint16,
  pub fade_length: Uint16,
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticCustom>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_HapticCustom))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticCustom>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticCustom))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).channels as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).period as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(period)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).samples as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).data as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_length as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_level as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_length as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_level as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(fade_level)
    )
  );
}
impl Default for SDL_HapticCustom {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
  pub type_: Uint16,
  pub constant: SDL_HapticConstant,
  pub periodic: SDL_HapticPeriodic,
  pub condition: SDL_HapticCondition,
  pub ramp: SDL_HapticRamp,
  pub leftright: SDL_HapticLeftRight,
  pub custom: SDL_HapticCustom,
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticEffect>(),
    68usize,
    concat!("Size of: ", stringify!(SDL_HapticEffect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticEffect>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticEffect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).constant as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(constant)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).periodic as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(periodic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).condition as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(condition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).ramp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(ramp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).leftright as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(leftright)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).custom as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(custom)
    )
  );
}
impl Default for SDL_HapticEffect {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_HapticEffect {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_HapticEffect {{ union }}")
  }
}
extern "C" {
  pub fn SDL_NumHaptics() -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_HapticOpen(device_index: libc::c_int) -> *mut SDL_Haptic;
}
extern "C" {
  pub fn SDL_HapticOpened(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_MouseIsHaptic() -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
  pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
  pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
  pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> libc::c_uint;
}
extern "C" {
  pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticEffectSupported(
    haptic: *mut SDL_Haptic,
    effect: *mut SDL_HapticEffect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticNewEffect(haptic: *mut SDL_Haptic, effect: *mut SDL_HapticEffect)
    -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticUpdateEffect(
    haptic: *mut SDL_Haptic,
    effect: libc::c_int,
    data: *mut SDL_HapticEffect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticRunEffect(
    haptic: *mut SDL_Haptic,
    effect: libc::c_int,
    iterations: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
extern "C" {
  pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticRumblePlay(
    haptic: *mut SDL_Haptic,
    strength: f32,
    length: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> libc::c_int;
}
pub mod SDL_HintPriority {
  pub type Type = u32;
  pub const SDL_HINT_DEFAULT: Type = 0;
  pub const SDL_HINT_NORMAL: Type = 1;
  pub const SDL_HINT_OVERRIDE: Type = 2;
}
extern "C" {
  pub fn SDL_SetHintWithPriority(
    name: *const libc::c_char,
    value: *const libc::c_char,
    priority: SDL_HintPriority::Type,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GetHintBoolean(
    name: *const libc::c_char,
    default_value: SDL_bool::Type,
  ) -> SDL_bool::Type;
}
pub type SDL_HintCallback = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    name: *const libc::c_char,
    oldValue: *const libc::c_char,
    newValue: *const libc::c_char,
  ),
>;
extern "C" {
  pub fn SDL_AddHintCallback(
    name: *const libc::c_char,
    callback: SDL_HintCallback,
    userdata: *mut libc::c_void,
  );
}
extern "C" {
  pub fn SDL_DelHintCallback(
    name: *const libc::c_char,
    callback: SDL_HintCallback,
    userdata: *mut libc::c_void,
  );
}
extern "C" {
  pub fn SDL_ClearHints();
}
extern "C" {
  pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_LoadFunction(
    handle: *mut libc::c_void,
    name: *const libc::c_char,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_UnloadObject(handle: *mut libc::c_void);
}
pub mod _bindgen_ty_7 {
  pub type Type = u32;
  pub const SDL_LOG_CATEGORY_APPLICATION: Type = 0;
  pub const SDL_LOG_CATEGORY_ERROR: Type = 1;
  pub const SDL_LOG_CATEGORY_ASSERT: Type = 2;
  pub const SDL_LOG_CATEGORY_SYSTEM: Type = 3;
  pub const SDL_LOG_CATEGORY_AUDIO: Type = 4;
  pub const SDL_LOG_CATEGORY_VIDEO: Type = 5;
  pub const SDL_LOG_CATEGORY_RENDER: Type = 6;
  pub const SDL_LOG_CATEGORY_INPUT: Type = 7;
  pub const SDL_LOG_CATEGORY_TEST: Type = 8;
  pub const SDL_LOG_CATEGORY_RESERVED1: Type = 9;
  pub const SDL_LOG_CATEGORY_RESERVED2: Type = 10;
  pub const SDL_LOG_CATEGORY_RESERVED3: Type = 11;
  pub const SDL_LOG_CATEGORY_RESERVED4: Type = 12;
  pub const SDL_LOG_CATEGORY_RESERVED5: Type = 13;
  pub const SDL_LOG_CATEGORY_RESERVED6: Type = 14;
  pub const SDL_LOG_CATEGORY_RESERVED7: Type = 15;
  pub const SDL_LOG_CATEGORY_RESERVED8: Type = 16;
  pub const SDL_LOG_CATEGORY_RESERVED9: Type = 17;
  pub const SDL_LOG_CATEGORY_RESERVED10: Type = 18;
  pub const SDL_LOG_CATEGORY_CUSTOM: Type = 19;
}
pub mod SDL_LogPriority {
  pub type Type = u32;
  pub const SDL_LOG_PRIORITY_VERBOSE: Type = 1;
  pub const SDL_LOG_PRIORITY_DEBUG: Type = 2;
  pub const SDL_LOG_PRIORITY_INFO: Type = 3;
  pub const SDL_LOG_PRIORITY_WARN: Type = 4;
  pub const SDL_LOG_PRIORITY_ERROR: Type = 5;
  pub const SDL_LOG_PRIORITY_CRITICAL: Type = 6;
  pub const SDL_NUM_LOG_PRIORITIES: Type = 7;
}
extern "C" {
  pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority::Type);
}
extern "C" {
  pub fn SDL_LogSetPriority(category: libc::c_int, priority: SDL_LogPriority::Type);
}
extern "C" {
  pub fn SDL_LogGetPriority(category: libc::c_int) -> SDL_LogPriority::Type;
}
extern "C" {
  pub fn SDL_LogResetPriorities();
}
extern "C" {
  pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  pub fn SDL_LogMessage(
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    fmt: *const libc::c_char,
    ...
  );
}
extern "C" {
  pub fn SDL_LogMessageV(
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    fmt: *const libc::c_char,
    ap: va_list,
  );
}
pub type SDL_LogOutputFunction = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    message: *const libc::c_char,
  ),
>;
extern "C" {
  pub fn SDL_LogGetOutputFunction(
    callback: *mut SDL_LogOutputFunction,
    userdata: *mut *mut libc::c_void,
  );
}
extern "C" {
  pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
pub mod SDL_MessageBoxFlags {
  pub type Type = u32;
  pub const SDL_MESSAGEBOX_ERROR: Type = 16;
  pub const SDL_MESSAGEBOX_WARNING: Type = 32;
  pub const SDL_MESSAGEBOX_INFORMATION: Type = 64;
}
pub mod SDL_MessageBoxButtonFlags {
  pub type Type = u32;
  pub const SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT: Type = 1;
  pub const SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxButtonData {
  pub flags: Uint32,
  pub buttonid: libc::c_int,
  pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxButtonData>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxButtonData>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).buttonid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(buttonid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).text as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(text)
    )
  );
}
impl Default for SDL_MessageBoxButtonData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxColor {
  pub r: Uint8,
  pub g: Uint8,
  pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxColor>(),
    3usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxColor))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxColor>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(b)
    )
  );
}
pub mod SDL_MessageBoxColorType {
  pub type Type = u32;
  pub const SDL_MESSAGEBOX_COLOR_BACKGROUND: Type = 0;
  pub const SDL_MESSAGEBOX_COLOR_TEXT: Type = 1;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_BORDER: Type = 2;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND: Type = 3;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED: Type = 4;
  pub const SDL_MESSAGEBOX_COLOR_MAX: Type = 5;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxColorScheme {
  pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxColorScheme>(),
    15usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxColorScheme>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColorScheme>())).colors as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColorScheme),
      "::",
      stringify!(colors)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxData {
  pub flags: Uint32,
  pub window: *mut SDL_Window,
  pub title: *const libc::c_char,
  pub message: *const libc::c_char,
  pub numbuttons: libc::c_int,
  pub buttons: *const SDL_MessageBoxButtonData,
  pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxData>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxData>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).window as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).title as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(title)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).message as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).numbuttons as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(numbuttons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).buttons as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(buttons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).colorScheme as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(colorScheme)
    )
  );
}
impl Default for SDL_MessageBoxData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_ShowMessageBox(
    messageboxdata: *const SDL_MessageBoxData,
    buttonid: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_ShowSimpleMessageBox(
    flags: Uint32,
    title: *const libc::c_char,
    message: *const libc::c_char,
    window: *mut SDL_Window,
  ) -> libc::c_int;
}
pub mod SDL_PowerState {
  pub type Type = u32;
  pub const SDL_POWERSTATE_UNKNOWN: Type = 0;
  pub const SDL_POWERSTATE_ON_BATTERY: Type = 1;
  pub const SDL_POWERSTATE_NO_BATTERY: Type = 2;
  pub const SDL_POWERSTATE_CHARGING: Type = 3;
  pub const SDL_POWERSTATE_CHARGED: Type = 4;
}
extern "C" {
  pub fn SDL_GetPowerInfo(secs: *mut libc::c_int, pct: *mut libc::c_int) -> SDL_PowerState::Type;
}
pub mod SDL_RendererFlags {
  pub type Type = u32;
  pub const SDL_RENDERER_SOFTWARE: Type = 1;
  pub const SDL_RENDERER_ACCELERATED: Type = 2;
  pub const SDL_RENDERER_PRESENTVSYNC: Type = 4;
  pub const SDL_RENDERER_TARGETTEXTURE: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RendererInfo {
  pub name: *const libc::c_char,
  pub flags: Uint32,
  pub num_texture_formats: Uint32,
  pub texture_formats: [Uint32; 16usize],
  pub max_texture_width: libc::c_int,
  pub max_texture_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RendererInfo>(),
    84usize,
    concat!("Size of: ", stringify!(SDL_RendererInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RendererInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_RendererInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RendererInfo>())).num_texture_formats as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(num_texture_formats)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).texture_formats as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(texture_formats)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_width as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(max_texture_width)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_height as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(max_texture_height)
    )
  );
}
impl Default for SDL_RendererInfo {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub mod SDL_TextureAccess {
  pub type Type = u32;
  pub const SDL_TEXTUREACCESS_STATIC: Type = 0;
  pub const SDL_TEXTUREACCESS_STREAMING: Type = 1;
  pub const SDL_TEXTUREACCESS_TARGET: Type = 2;
}
pub mod SDL_TextureModulate {
  pub type Type = u32;
  pub const SDL_TEXTUREMODULATE_NONE: Type = 0;
  pub const SDL_TEXTUREMODULATE_COLOR: Type = 1;
  pub const SDL_TEXTUREMODULATE_ALPHA: Type = 2;
}
pub mod SDL_RendererFlip {
  pub type Type = u32;
  pub const SDL_FLIP_NONE: Type = 0;
  pub const SDL_FLIP_HORIZONTAL: Type = 1;
  pub const SDL_FLIP_VERTICAL: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Renderer {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Texture {
  _unused: [u8; 0],
}
extern "C" {
  pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetRenderDriverInfo(index: libc::c_int, info: *mut SDL_RendererInfo) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CreateWindowAndRenderer(
    width: libc::c_int,
    height: libc::c_int,
    window_flags: Uint32,
    window: *mut *mut SDL_Window,
    renderer: *mut *mut SDL_Renderer,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CreateRenderer(
    window: *mut SDL_Window,
    index: libc::c_int,
    flags: Uint32,
  ) -> *mut SDL_Renderer;
}
extern "C" {
  pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
  pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
  pub fn SDL_GetRendererInfo(
    renderer: *mut SDL_Renderer,
    info: *mut SDL_RendererInfo,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetRendererOutputSize(
    renderer: *mut SDL_Renderer,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_CreateTexture(
    renderer: *mut SDL_Renderer,
    format: Uint32,
    access: libc::c_int,
    w: libc::c_int,
    h: libc::c_int,
  ) -> *mut SDL_Texture;
}
extern "C" {
  pub fn SDL_CreateTextureFromSurface(
    renderer: *mut SDL_Renderer,
    surface: *mut SDL_Surface,
  ) -> *mut SDL_Texture;
}
extern "C" {
  pub fn SDL_QueryTexture(
    texture: *mut SDL_Texture,
    format: *mut Uint32,
    access: *mut libc::c_int,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetTextureColorMod(
    texture: *mut SDL_Texture,
    r: Uint8,
    g: Uint8,
    b: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetTextureColorMod(
    texture: *mut SDL_Texture,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetTextureBlendMode(
    texture: *mut SDL_Texture,
    blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetTextureBlendMode(
    texture: *mut SDL_Texture,
    blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UpdateTexture(
    texture: *mut SDL_Texture,
    rect: *const SDL_Rect,
    pixels: *const libc::c_void,
    pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UpdateYUVTexture(
    texture: *mut SDL_Texture,
    rect: *const SDL_Rect,
    Yplane: *const Uint8,
    Ypitch: libc::c_int,
    Uplane: *const Uint8,
    Upitch: libc::c_int,
    Vplane: *const Uint8,
    Vpitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_LockTexture(
    texture: *mut SDL_Texture,
    rect: *const SDL_Rect,
    pixels: *mut *mut libc::c_void,
    pitch: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
  pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_SetRenderTarget(renderer: *mut SDL_Renderer, texture: *mut SDL_Texture)
    -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
  pub fn SDL_RenderSetLogicalSize(
    renderer: *mut SDL_Renderer,
    w: libc::c_int,
    h: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderGetLogicalSize(
    renderer: *mut SDL_Renderer,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
extern "C" {
  pub fn SDL_RenderSetIntegerScale(
    renderer: *mut SDL_Renderer,
    enable: SDL_bool::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_RenderSetViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
  pub fn SDL_RenderSetClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
  pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_RenderSetScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
  pub fn SDL_SetRenderDrawColor(
    renderer: *mut SDL_Renderer,
    r: Uint8,
    g: Uint8,
    b: Uint8,
    a: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetRenderDrawColor(
    renderer: *mut SDL_Renderer,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
    a: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SetRenderDrawBlendMode(
    renderer: *mut SDL_Renderer,
    blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetRenderDrawBlendMode(
    renderer: *mut SDL_Renderer,
    blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawPoint(
    renderer: *mut SDL_Renderer,
    x: libc::c_int,
    y: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawPoints(
    renderer: *mut SDL_Renderer,
    points: *const SDL_Point,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawLine(
    renderer: *mut SDL_Renderer,
    x1: libc::c_int,
    y1: libc::c_int,
    x2: libc::c_int,
    y2: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawLines(
    renderer: *mut SDL_Renderer,
    points: *const SDL_Point,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawRects(
    renderer: *mut SDL_Renderer,
    rects: *const SDL_Rect,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderFillRects(
    renderer: *mut SDL_Renderer,
    rects: *const SDL_Rect,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderCopy(
    renderer: *mut SDL_Renderer,
    texture: *mut SDL_Texture,
    srcrect: *const SDL_Rect,
    dstrect: *const SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderCopyEx(
    renderer: *mut SDL_Renderer,
    texture: *mut SDL_Texture,
    srcrect: *const SDL_Rect,
    dstrect: *const SDL_Rect,
    angle: f64,
    center: *const SDL_Point,
    flip: SDL_RendererFlip::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawPointF(renderer: *mut SDL_Renderer, x: f32, y: f32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawPointsF(
    renderer: *mut SDL_Renderer,
    points: *const SDL_FPoint,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawLineF(
    renderer: *mut SDL_Renderer,
    x1: f32,
    y1: f32,
    x2: f32,
    y2: f32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawLinesF(
    renderer: *mut SDL_Renderer,
    points: *const SDL_FPoint,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawRectF(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderDrawRectsF(
    renderer: *mut SDL_Renderer,
    rects: *const SDL_FRect,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderFillRectF(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderFillRectsF(
    renderer: *mut SDL_Renderer,
    rects: *const SDL_FRect,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderCopyF(
    renderer: *mut SDL_Renderer,
    texture: *mut SDL_Texture,
    srcrect: *const SDL_Rect,
    dstrect: *const SDL_FRect,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderCopyExF(
    renderer: *mut SDL_Renderer,
    texture: *mut SDL_Texture,
    srcrect: *const SDL_Rect,
    dstrect: *const SDL_FRect,
    angle: f64,
    center: *const SDL_FPoint,
    flip: SDL_RendererFlip::Type,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderReadPixels(
    renderer: *mut SDL_Renderer,
    rect: *const SDL_Rect,
    format: Uint32,
    pixels: *mut libc::c_void,
    pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
  pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
  pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
  pub fn SDL_RenderFlush(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_BindTexture(
    texture: *mut SDL_Texture,
    texw: *mut f32,
    texh: *mut f32,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> libc::c_int;
}
extern "C" {
  pub fn SDL_RenderGetMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_RenderGetMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Sensor {
  _unused: [u8; 0],
}
pub type SDL_Sensor = _SDL_Sensor;
pub type SDL_SensorID = Sint32;
pub mod SDL_SensorType {
  pub type Type = i32;
  pub const SDL_SENSOR_INVALID: Type = -1;
  pub const SDL_SENSOR_UNKNOWN: Type = 0;
  pub const SDL_SENSOR_ACCEL: Type = 1;
  pub const SDL_SENSOR_GYRO: Type = 2;
}
extern "C" {
  pub fn SDL_NumSensors() -> libc::c_int;
}
extern "C" {
  pub fn SDL_SensorGetDeviceName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_SensorGetDeviceType(device_index: libc::c_int) -> SDL_SensorType::Type;
}
extern "C" {
  pub fn SDL_SensorGetDeviceNonPortableType(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SensorGetDeviceInstanceID(device_index: libc::c_int) -> SDL_SensorID;
}
extern "C" {
  pub fn SDL_SensorOpen(device_index: libc::c_int) -> *mut SDL_Sensor;
}
extern "C" {
  pub fn SDL_SensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
  pub fn SDL_SensorGetName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_SensorGetType(sensor: *mut SDL_Sensor) -> SDL_SensorType::Type;
}
extern "C" {
  pub fn SDL_SensorGetNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SensorGetInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
  pub fn SDL_SensorGetData(
    sensor: *mut SDL_Sensor,
    data: *mut f32,
    num_values: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_SensorClose(sensor: *mut SDL_Sensor);
}
extern "C" {
  pub fn SDL_SensorUpdate();
}
extern "C" {
  pub fn SDL_CreateShapedWindow(
    title: *const libc::c_char,
    x: libc::c_uint,
    y: libc::c_uint,
    w: libc::c_uint,
    h: libc::c_uint,
    flags: Uint32,
  ) -> *mut SDL_Window;
}
extern "C" {
  pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool::Type;
}
pub mod WindowShapeMode {
  pub type Type = u32;
  pub const ShapeModeDefault: Type = 0;
  pub const ShapeModeBinarizeAlpha: Type = 1;
  pub const ShapeModeReverseBinarizeAlpha: Type = 2;
  pub const ShapeModeColorKey: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
  pub binarizationCutoff: Uint8,
  pub colorKey: SDL_Color,
  _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowShapeParams>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_WindowShapeParams))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowShapeParams>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_WindowShapeParams>())).binarizationCutoff as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeParams),
      "::",
      stringify!(binarizationCutoff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeParams>())).colorKey as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeParams),
      "::",
      stringify!(colorKey)
    )
  );
}
impl Default for SDL_WindowShapeParams {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_WindowShapeParams {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_WindowShapeParams {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
  pub mode: WindowShapeMode::Type,
  pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowShapeMode>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_WindowShapeMode))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowShapeMode>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).mode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeMode),
      "::",
      stringify!(mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).parameters as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeMode),
      "::",
      stringify!(parameters)
    )
  );
}
impl Default for SDL_WindowShapeMode {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_WindowShapeMode {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_WindowShapeMode {{ mode: {:?}, parameters: {:?} }}",
      self.mode, self.parameters
    )
  }
}
extern "C" {
  pub fn SDL_SetWindowShape(
    window: *mut SDL_Window,
    shape: *mut SDL_Surface,
    shape_mode: *mut SDL_WindowShapeMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetShapedWindowMode(
    window: *mut SDL_Window,
    shape_mode: *mut SDL_WindowShapeMode,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_LinuxSetThreadPriority(threadID: Sint64, priority: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_IsTablet() -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
  pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
  pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
  pub fn SDL_Delay(ms: Uint32);
}
pub type SDL_TimerCallback = ::core::option::Option<
  unsafe extern "C" fn(interval: Uint32, param: *mut libc::c_void) -> Uint32,
>;
pub type SDL_TimerID = libc::c_int;
extern "C" {
  pub fn SDL_AddTimer(
    interval: Uint32,
    callback: SDL_TimerCallback,
    param: *mut libc::c_void,
  ) -> SDL_TimerID;
}
extern "C" {
  pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool::Type;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_version {
  pub major: Uint8,
  pub minor: Uint8,
  pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
  assert_eq!(
    ::core::mem::size_of::<SDL_version>(),
    3usize,
    concat!("Size of: ", stringify!(SDL_version))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_version>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_version))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).major as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(major)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).minor as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(minor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).patch as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(patch)
    )
  );
}
extern "C" {
  pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
  pub fn SDL_GetRevision() -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_GetRevisionNumber() -> libc::c_int;
}
extern "C" {
  pub fn SDL_Init(flags: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_InitSubSystem(flags: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
  pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
  pub fn SDL_Quit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
  _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
pub type VkSurfaceKHR = u64;
pub type SDL_vulkanInstance = VkInstance;
pub type SDL_vulkanSurface = VkSurfaceKHR;
extern "C" {
  pub fn SDL_Vulkan_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_Vulkan_GetVkGetInstanceProcAddr() -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_Vulkan_UnloadLibrary();
}
extern "C" {
  pub fn SDL_Vulkan_GetInstanceExtensions(
    window: *mut SDL_Window,
    pCount: *mut libc::c_uint,
    pNames: *mut *const libc::c_char,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_Vulkan_CreateSurface(
    window: *mut SDL_Window,
    instance: VkInstance,
    surface: *mut VkSurfaceKHR,
  ) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_Vulkan_GetDrawableSize(
    window: *mut SDL_Window,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
pub type XID = libc::c_ulong;
pub type Atom = libc::c_ulong;
pub type Time = libc::c_ulong;
pub type Window = XID;
pub type Drawable = XID;
pub type Colormap = XID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XDisplay {
  _unused: [u8; 0],
}
pub type Display = _XDisplay;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XKeyEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub root: Window,
  pub subwindow: Window,
  pub time: Time,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub x_root: libc::c_int,
  pub y_root: libc::c_int,
  pub state: libc::c_uint,
  pub keycode: libc::c_uint,
  pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XKeyEvent() {
  assert_eq!(
    ::core::mem::size_of::<XKeyEvent>(),
    60usize,
    concat!("Size of: ", stringify!(XKeyEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XKeyEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XKeyEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).root as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).subwindow as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(subwindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).time as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).x_root as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(x_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).y_root as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(y_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).state as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).keycode as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(keycode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeyEvent>())).same_screen as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeyEvent),
      "::",
      stringify!(same_screen)
    )
  );
}
impl Default for XKeyEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XButtonEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub root: Window,
  pub subwindow: Window,
  pub time: Time,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub x_root: libc::c_int,
  pub y_root: libc::c_int,
  pub state: libc::c_uint,
  pub button: libc::c_uint,
  pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<XButtonEvent>(),
    60usize,
    concat!("Size of: ", stringify!(XButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).root as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).subwindow as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(subwindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).time as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).x_root as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(x_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).y_root as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(y_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).state as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).button as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XButtonEvent>())).same_screen as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(XButtonEvent),
      "::",
      stringify!(same_screen)
    )
  );
}
impl Default for XButtonEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XMotionEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub root: Window,
  pub subwindow: Window,
  pub time: Time,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub x_root: libc::c_int,
  pub y_root: libc::c_int,
  pub state: libc::c_uint,
  pub is_hint: libc::c_char,
  pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMotionEvent() {
  assert_eq!(
    ::core::mem::size_of::<XMotionEvent>(),
    60usize,
    concat!("Size of: ", stringify!(XMotionEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XMotionEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XMotionEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).root as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).subwindow as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(subwindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).time as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).x_root as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(x_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).y_root as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(y_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).state as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).is_hint as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(is_hint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMotionEvent>())).same_screen as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(XMotionEvent),
      "::",
      stringify!(same_screen)
    )
  );
}
impl Default for XMotionEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XCrossingEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub root: Window,
  pub subwindow: Window,
  pub time: Time,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub x_root: libc::c_int,
  pub y_root: libc::c_int,
  pub mode: libc::c_int,
  pub detail: libc::c_int,
  pub same_screen: libc::c_int,
  pub focus: libc::c_int,
  pub state: libc::c_uint,
}
#[test]
fn bindgen_test_layout_XCrossingEvent() {
  assert_eq!(
    ::core::mem::size_of::<XCrossingEvent>(),
    68usize,
    concat!("Size of: ", stringify!(XCrossingEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XCrossingEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XCrossingEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).root as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).subwindow as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(subwindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).time as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).x_root as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(x_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).y_root as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(y_root)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).mode as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).detail as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(detail)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).same_screen as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(same_screen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).focus as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(focus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).state as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(XCrossingEvent),
      "::",
      stringify!(state)
    )
  );
}
impl Default for XCrossingEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XFocusChangeEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub mode: libc::c_int,
  pub detail: libc::c_int,
}
#[test]
fn bindgen_test_layout_XFocusChangeEvent() {
  assert_eq!(
    ::core::mem::size_of::<XFocusChangeEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XFocusChangeEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XFocusChangeEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XFocusChangeEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).mode as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).detail as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XFocusChangeEvent),
      "::",
      stringify!(detail)
    )
  );
}
impl Default for XFocusChangeEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XKeymapEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub key_vector: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeymapEvent() {
  assert_eq!(
    ::core::mem::size_of::<XKeymapEvent>(),
    52usize,
    concat!("Size of: ", stringify!(XKeymapEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XKeymapEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XKeymapEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeymapEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeymapEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeymapEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeymapEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeymapEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).key_vector as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XKeymapEvent),
      "::",
      stringify!(key_vector)
    )
  );
}
impl Default for XKeymapEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XExposeEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub width: libc::c_int,
  pub height: libc::c_int,
  pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout_XExposeEvent() {
  assert_eq!(
    ::core::mem::size_of::<XExposeEvent>(),
    40usize,
    concat!("Size of: ", stringify!(XExposeEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XExposeEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XExposeEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).width as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).height as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XExposeEvent>())).count as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XExposeEvent),
      "::",
      stringify!(count)
    )
  );
}
impl Default for XExposeEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XGraphicsExposeEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub drawable: Drawable,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub width: libc::c_int,
  pub height: libc::c_int,
  pub count: libc::c_int,
  pub major_code: libc::c_int,
  pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGraphicsExposeEvent() {
  assert_eq!(
    ::core::mem::size_of::<XGraphicsExposeEvent>(),
    48usize,
    concat!("Size of: ", stringify!(XGraphicsExposeEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XGraphicsExposeEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XGraphicsExposeEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).drawable as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(drawable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).width as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).height as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).count as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).major_code as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(major_code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).minor_code as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XGraphicsExposeEvent),
      "::",
      stringify!(minor_code)
    )
  );
}
impl Default for XGraphicsExposeEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XNoExposeEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub drawable: Drawable,
  pub major_code: libc::c_int,
  pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout_XNoExposeEvent() {
  assert_eq!(
    ::core::mem::size_of::<XNoExposeEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XNoExposeEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XNoExposeEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XNoExposeEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).drawable as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(drawable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).major_code as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(major_code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).minor_code as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XNoExposeEvent),
      "::",
      stringify!(minor_code)
    )
  );
}
impl Default for XNoExposeEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XVisibilityEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XVisibilityEvent() {
  assert_eq!(
    ::core::mem::size_of::<XVisibilityEvent>(),
    24usize,
    concat!("Size of: ", stringify!(XVisibilityEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XVisibilityEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XVisibilityEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XVisibilityEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XVisibilityEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XVisibilityEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XVisibilityEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XVisibilityEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).state as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XVisibilityEvent),
      "::",
      stringify!(state)
    )
  );
}
impl Default for XVisibilityEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XCreateWindowEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub parent: Window,
  pub window: Window,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub width: libc::c_int,
  pub height: libc::c_int,
  pub border_width: libc::c_int,
  pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCreateWindowEvent() {
  assert_eq!(
    ::core::mem::size_of::<XCreateWindowEvent>(),
    48usize,
    concat!("Size of: ", stringify!(XCreateWindowEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XCreateWindowEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XCreateWindowEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).parent as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).width as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).height as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).border_width as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(border_width)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<XCreateWindowEvent>())).override_redirect as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XCreateWindowEvent),
      "::",
      stringify!(override_redirect)
    )
  );
}
impl Default for XCreateWindowEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XDestroyWindowEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
}
#[test]
fn bindgen_test_layout_XDestroyWindowEvent() {
  assert_eq!(
    ::core::mem::size_of::<XDestroyWindowEvent>(),
    24usize,
    concat!("Size of: ", stringify!(XDestroyWindowEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XDestroyWindowEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XDestroyWindowEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XDestroyWindowEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XDestroyWindowEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XDestroyWindowEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XDestroyWindowEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XDestroyWindowEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XDestroyWindowEvent),
      "::",
      stringify!(window)
    )
  );
}
impl Default for XDestroyWindowEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XUnmapEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
  pub from_configure: libc::c_int,
}
#[test]
fn bindgen_test_layout_XUnmapEvent() {
  assert_eq!(
    ::core::mem::size_of::<XUnmapEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XUnmapEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XUnmapEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XUnmapEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).from_configure as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XUnmapEvent),
      "::",
      stringify!(from_configure)
    )
  );
}
impl Default for XUnmapEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XMapEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
  pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMapEvent() {
  assert_eq!(
    ::core::mem::size_of::<XMapEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XMapEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XMapEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XMapEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapEvent>())).override_redirect as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapEvent),
      "::",
      stringify!(override_redirect)
    )
  );
}
impl Default for XMapEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XMapRequestEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub parent: Window,
  pub window: Window,
}
#[test]
fn bindgen_test_layout_XMapRequestEvent() {
  assert_eq!(
    ::core::mem::size_of::<XMapRequestEvent>(),
    24usize,
    concat!("Size of: ", stringify!(XMapRequestEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XMapRequestEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XMapRequestEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapRequestEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapRequestEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapRequestEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapRequestEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).parent as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapRequestEvent),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XMapRequestEvent),
      "::",
      stringify!(window)
    )
  );
}
impl Default for XMapRequestEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XReparentEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
  pub parent: Window,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XReparentEvent() {
  assert_eq!(
    ::core::mem::size_of::<XReparentEvent>(),
    40usize,
    concat!("Size of: ", stringify!(XReparentEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XReparentEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XReparentEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).parent as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).x as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).y as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XReparentEvent>())).override_redirect as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XReparentEvent),
      "::",
      stringify!(override_redirect)
    )
  );
}
impl Default for XReparentEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XConfigureEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub width: libc::c_int,
  pub height: libc::c_int,
  pub border_width: libc::c_int,
  pub above: Window,
  pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XConfigureEvent() {
  assert_eq!(
    ::core::mem::size_of::<XConfigureEvent>(),
    52usize,
    concat!("Size of: ", stringify!(XConfigureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XConfigureEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XConfigureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).width as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).height as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).border_width as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(border_width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).above as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(above)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).override_redirect as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureEvent),
      "::",
      stringify!(override_redirect)
    )
  );
}
impl Default for XConfigureEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XGravityEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
  pub x: libc::c_int,
  pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGravityEvent() {
  assert_eq!(
    ::core::mem::size_of::<XGravityEvent>(),
    32usize,
    concat!("Size of: ", stringify!(XGravityEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XGravityEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XGravityEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGravityEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XGravityEvent),
      "::",
      stringify!(y)
    )
  );
}
impl Default for XGravityEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XResizeRequestEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub width: libc::c_int,
  pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_XResizeRequestEvent() {
  assert_eq!(
    ::core::mem::size_of::<XResizeRequestEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XResizeRequestEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XResizeRequestEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XResizeRequestEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).width as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).height as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XResizeRequestEvent),
      "::",
      stringify!(height)
    )
  );
}
impl Default for XResizeRequestEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XConfigureRequestEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub parent: Window,
  pub window: Window,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub width: libc::c_int,
  pub height: libc::c_int,
  pub border_width: libc::c_int,
  pub above: Window,
  pub detail: libc::c_int,
  pub value_mask: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_XConfigureRequestEvent() {
  assert_eq!(
    ::core::mem::size_of::<XConfigureRequestEvent>(),
    56usize,
    concat!("Size of: ", stringify!(XConfigureRequestEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XConfigureRequestEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XConfigureRequestEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).parent as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).width as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).height as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<XConfigureRequestEvent>())).border_width as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(border_width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).above as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(above)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).detail as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(detail)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).value_mask as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(XConfigureRequestEvent),
      "::",
      stringify!(value_mask)
    )
  );
}
impl Default for XConfigureRequestEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XCirculateEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub event: Window,
  pub window: Window,
  pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateEvent() {
  assert_eq!(
    ::core::mem::size_of::<XCirculateEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XCirculateEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XCirculateEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XCirculateEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).event as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).place as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateEvent),
      "::",
      stringify!(place)
    )
  );
}
impl Default for XCirculateEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XCirculateRequestEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub parent: Window,
  pub window: Window,
  pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateRequestEvent() {
  assert_eq!(
    ::core::mem::size_of::<XCirculateRequestEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XCirculateRequestEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XCirculateRequestEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XCirculateRequestEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).parent as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).window as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).place as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XCirculateRequestEvent),
      "::",
      stringify!(place)
    )
  );
}
impl Default for XCirculateRequestEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XPropertyEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub atom: Atom,
  pub time: Time,
  pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XPropertyEvent() {
  assert_eq!(
    ::core::mem::size_of::<XPropertyEvent>(),
    32usize,
    concat!("Size of: ", stringify!(XPropertyEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XPropertyEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XPropertyEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).atom as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(atom)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).state as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XPropertyEvent),
      "::",
      stringify!(state)
    )
  );
}
impl Default for XPropertyEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XSelectionClearEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub selection: Atom,
  pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionClearEvent() {
  assert_eq!(
    ::core::mem::size_of::<XSelectionClearEvent>(),
    28usize,
    concat!("Size of: ", stringify!(XSelectionClearEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XSelectionClearEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XSelectionClearEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).selection as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(selection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionClearEvent),
      "::",
      stringify!(time)
    )
  );
}
impl Default for XSelectionClearEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XSelectionRequestEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub owner: Window,
  pub requestor: Window,
  pub selection: Atom,
  pub target: Atom,
  pub property: Atom,
  pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionRequestEvent() {
  assert_eq!(
    ::core::mem::size_of::<XSelectionRequestEvent>(),
    40usize,
    concat!("Size of: ", stringify!(XSelectionRequestEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XSelectionRequestEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XSelectionRequestEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).owner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).requestor as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(requestor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).selection as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(selection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).target as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(target)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).property as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(property)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).time as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionRequestEvent),
      "::",
      stringify!(time)
    )
  );
}
impl Default for XSelectionRequestEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XSelectionEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub requestor: Window,
  pub selection: Atom,
  pub target: Atom,
  pub property: Atom,
  pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionEvent() {
  assert_eq!(
    ::core::mem::size_of::<XSelectionEvent>(),
    36usize,
    concat!("Size of: ", stringify!(XSelectionEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XSelectionEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XSelectionEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).requestor as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(requestor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).selection as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(selection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).target as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(target)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).property as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(property)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).time as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(XSelectionEvent),
      "::",
      stringify!(time)
    )
  );
}
impl Default for XSelectionEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XColormapEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub colormap: Colormap,
  pub new: libc::c_int,
  pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XColormapEvent() {
  assert_eq!(
    ::core::mem::size_of::<XColormapEvent>(),
    32usize,
    concat!("Size of: ", stringify!(XColormapEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XColormapEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XColormapEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).colormap as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(colormap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).new as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(new)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XColormapEvent>())).state as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XColormapEvent),
      "::",
      stringify!(state)
    )
  );
}
impl Default for XColormapEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XClientMessageEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub message_type: Atom,
  pub format: libc::c_int,
  pub data: XClientMessageEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XClientMessageEvent__bindgen_ty_1 {
  pub b: [libc::c_char; 20usize],
  pub s: [libc::c_short; 10usize],
  pub l: [libc::c_long; 5usize],
  _bindgen_union_align: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_XClientMessageEvent__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<XClientMessageEvent__bindgen_ty_1>(),
    20usize,
    concat!("Size of: ", stringify!(XClientMessageEvent__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<XClientMessageEvent__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(XClientMessageEvent__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).b as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent__bindgen_ty_1),
      "::",
      stringify!(b)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).s as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent__bindgen_ty_1),
      "::",
      stringify!(s)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).l as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent__bindgen_ty_1),
      "::",
      stringify!(l)
    )
  );
}
impl Default for XClientMessageEvent__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for XClientMessageEvent__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "XClientMessageEvent__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_XClientMessageEvent() {
  assert_eq!(
    ::core::mem::size_of::<XClientMessageEvent>(),
    48usize,
    concat!("Size of: ", stringify!(XClientMessageEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XClientMessageEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XClientMessageEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).message_type as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(message_type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).format as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XClientMessageEvent),
      "::",
      stringify!(data)
    )
  );
}
impl Default for XClientMessageEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for XClientMessageEvent {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "XClientMessageEvent {{ type: {:?}, serial: {:?}, send_event: {:?}, display: {:?}, window: {:?}, message_type: {:?}, format: {:?}, data: {:?} }}" , self . type_ , self . serial , self . send_event , self . display , self . window , self . message_type , self . format , self . data )
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XMappingEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
  pub request: libc::c_int,
  pub first_keycode: libc::c_int,
  pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMappingEvent() {
  assert_eq!(
    ::core::mem::size_of::<XMappingEvent>(),
    32usize,
    concat!("Size of: ", stringify!(XMappingEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XMappingEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XMappingEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).request as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(request)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).first_keycode as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(first_keycode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XMappingEvent>())).count as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XMappingEvent),
      "::",
      stringify!(count)
    )
  );
}
impl Default for XMappingEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XErrorEvent {
  pub type_: libc::c_int,
  pub display: *mut Display,
  pub resourceid: XID,
  pub serial: libc::c_ulong,
  pub error_code: libc::c_uchar,
  pub request_code: libc::c_uchar,
  pub minor_code: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_XErrorEvent() {
  assert_eq!(
    ::core::mem::size_of::<XErrorEvent>(),
    20usize,
    concat!("Size of: ", stringify!(XErrorEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XErrorEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XErrorEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).display as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).resourceid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(resourceid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).serial as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).error_code as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(error_code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).request_code as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(request_code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XErrorEvent>())).minor_code as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(XErrorEvent),
      "::",
      stringify!(minor_code)
    )
  );
}
impl Default for XErrorEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XAnyEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub window: Window,
}
#[test]
fn bindgen_test_layout_XAnyEvent() {
  assert_eq!(
    ::core::mem::size_of::<XAnyEvent>(),
    20usize,
    concat!("Size of: ", stringify!(XAnyEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XAnyEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XAnyEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XAnyEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XAnyEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XAnyEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XAnyEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XAnyEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XAnyEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XAnyEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XAnyEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XAnyEvent>())).window as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XAnyEvent),
      "::",
      stringify!(window)
    )
  );
}
impl Default for XAnyEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XGenericEvent {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub extension: libc::c_int,
  pub evtype: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGenericEvent() {
  assert_eq!(
    ::core::mem::size_of::<XGenericEvent>(),
    24usize,
    concat!("Size of: ", stringify!(XGenericEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<XGenericEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(XGenericEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEvent>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEvent),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEvent>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEvent),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEvent>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEvent>())).extension as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEvent),
      "::",
      stringify!(extension)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEvent>())).evtype as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEvent),
      "::",
      stringify!(evtype)
    )
  );
}
impl Default for XGenericEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct XGenericEventCookie {
  pub type_: libc::c_int,
  pub serial: libc::c_ulong,
  pub send_event: libc::c_int,
  pub display: *mut Display,
  pub extension: libc::c_int,
  pub evtype: libc::c_int,
  pub cookie: libc::c_uint,
  pub data: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_XGenericEventCookie() {
  assert_eq!(
    ::core::mem::size_of::<XGenericEventCookie>(),
    32usize,
    concat!("Size of: ", stringify!(XGenericEventCookie))
  );
  assert_eq!(
    ::core::mem::align_of::<XGenericEventCookie>(),
    4usize,
    concat!("Alignment of ", stringify!(XGenericEventCookie))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).serial as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(serial)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).send_event as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(send_event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).display as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).extension as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(extension)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).evtype as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(evtype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).cookie as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(cookie)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(XGenericEventCookie),
      "::",
      stringify!(data)
    )
  );
}
impl Default for XGenericEventCookie {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XEvent {
  pub type_: libc::c_int,
  pub xany: XAnyEvent,
  pub xkey: XKeyEvent,
  pub xbutton: XButtonEvent,
  pub xmotion: XMotionEvent,
  pub xcrossing: XCrossingEvent,
  pub xfocus: XFocusChangeEvent,
  pub xexpose: XExposeEvent,
  pub xgraphicsexpose: XGraphicsExposeEvent,
  pub xnoexpose: XNoExposeEvent,
  pub xvisibility: XVisibilityEvent,
  pub xcreatewindow: XCreateWindowEvent,
  pub xdestroywindow: XDestroyWindowEvent,
  pub xunmap: XUnmapEvent,
  pub xmap: XMapEvent,
  pub xmaprequest: XMapRequestEvent,
  pub xreparent: XReparentEvent,
  pub xconfigure: XConfigureEvent,
  pub xgravity: XGravityEvent,
  pub xresizerequest: XResizeRequestEvent,
  pub xconfigurerequest: XConfigureRequestEvent,
  pub xcirculate: XCirculateEvent,
  pub xcirculaterequest: XCirculateRequestEvent,
  pub xproperty: XPropertyEvent,
  pub xselectionclear: XSelectionClearEvent,
  pub xselectionrequest: XSelectionRequestEvent,
  pub xselection: XSelectionEvent,
  pub xcolormap: XColormapEvent,
  pub xclient: XClientMessageEvent,
  pub xmapping: XMappingEvent,
  pub xerror: XErrorEvent,
  pub xkeymap: XKeymapEvent,
  pub xgeneric: XGenericEvent,
  pub xcookie: XGenericEventCookie,
  pub pad: [libc::c_long; 24usize],
  _bindgen_union_align: [u32; 24usize],
}
#[test]
fn bindgen_test_layout__XEvent() {
  assert_eq!(
    ::core::mem::size_of::<_XEvent>(),
    96usize,
    concat!("Size of: ", stringify!(_XEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<_XEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(_XEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xany as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xany)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xkey as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xkey)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xmotion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xmotion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xcrossing as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xcrossing)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xfocus as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xfocus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xexpose as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xexpose)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xgraphicsexpose as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xgraphicsexpose)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xnoexpose as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xnoexpose)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xvisibility as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xvisibility)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xcreatewindow as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xcreatewindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xdestroywindow as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xdestroywindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xunmap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xunmap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xmap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xmap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xmaprequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xmaprequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xreparent as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xreparent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xconfigure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xconfigure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xgravity as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xgravity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xresizerequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xresizerequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xconfigurerequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xconfigurerequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xcirculate as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xcirculate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xcirculaterequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xcirculaterequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xproperty as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xproperty)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xselectionclear as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xselectionclear)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xselectionrequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xselectionrequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xselection as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xselection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xcolormap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xcolormap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xclient as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xclient)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xmapping as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xmapping)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xerror as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xerror)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xkeymap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xkeymap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xgeneric as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xgeneric)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).xcookie as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(xcookie)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XEvent>())).pad as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XEvent),
      "::",
      stringify!(pad)
    )
  );
}
impl Default for _XEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _XEvent {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_XEvent {{ union }}")
  }
}
pub type XEvent = _XEvent;
pub mod SDL_SYSWM_TYPE {
  pub type Type = u32;
  pub const SDL_SYSWM_UNKNOWN: Type = 0;
  pub const SDL_SYSWM_WINDOWS: Type = 1;
  pub const SDL_SYSWM_X11: Type = 2;
  pub const SDL_SYSWM_DIRECTFB: Type = 3;
  pub const SDL_SYSWM_COCOA: Type = 4;
  pub const SDL_SYSWM_UIKIT: Type = 5;
  pub const SDL_SYSWM_WAYLAND: Type = 6;
  pub const SDL_SYSWM_MIR: Type = 7;
  pub const SDL_SYSWM_WINRT: Type = 8;
  pub const SDL_SYSWM_ANDROID: Type = 9;
  pub const SDL_SYSWM_VIVANTE: Type = 10;
  pub const SDL_SYSWM_OS2: Type = 11;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg {
  pub version: SDL_version,
  pub subsystem: SDL_SYSWM_TYPE::Type,
  pub msg: SDL_SysWMmsg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMmsg__bindgen_ty_1 {
  pub x11: SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1,
  pub dummy: libc::c_int,
  _bindgen_union_align: [u32; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
  pub event: XEvent,
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
    96usize,
    concat!(
      "Size of: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>())).event as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(event)
    )
  );
}
impl Default for SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {{ event: {:?} }}",
      self.event
    )
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1>(),
    96usize,
    concat!("Size of: ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1>())).x11 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1),
      "::",
      stringify!(x11)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1>())).dummy as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1),
      "::",
      stringify!(dummy)
    )
  );
}
impl Default for SDL_SysWMmsg__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMmsg__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_SysWMmsg__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMmsg>(),
    104usize,
    concat!("Size of: ", stringify!(SDL_SysWMmsg))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMmsg>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SysWMmsg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).subsystem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg),
      "::",
      stringify!(subsystem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).msg as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg),
      "::",
      stringify!(msg)
    )
  );
}
impl Default for SDL_SysWMmsg {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMmsg {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_SysWMmsg {{ version: {:?}, subsystem: {:?}, msg: {:?} }}",
      self.version, self.subsystem, self.msg
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo {
  pub version: SDL_version,
  pub subsystem: SDL_SYSWM_TYPE::Type,
  pub info: SDL_SysWMinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMinfo__bindgen_ty_1 {
  pub x11: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1,
  pub wl: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2,
  pub dummy: [Uint8; 64usize],
  _bindgen_union_align: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
  pub display: *mut Display,
  pub window: Window,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).display as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).window as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(window)
    )
  );
}
impl Default for SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2 {
  pub display: *mut wl_display,
  pub surface: *mut wl_surface,
  pub shell_surface: *mut wl_shell_surface,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).display as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).surface as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(surface)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).shell_surface
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(shell_surface)
    )
  );
}
impl Default for SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1>(),
    64usize,
    concat!("Size of: ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).x11 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1),
      "::",
      stringify!(x11)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).wl as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1),
      "::",
      stringify!(wl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).dummy as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1),
      "::",
      stringify!(dummy)
    )
  );
}
impl Default for SDL_SysWMinfo__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMinfo__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_SysWMinfo__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo>(),
    72usize,
    concat!("Size of: ", stringify!(SDL_SysWMinfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SysWMinfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).subsystem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo),
      "::",
      stringify!(subsystem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).info as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo),
      "::",
      stringify!(info)
    )
  );
}
impl Default for SDL_SysWMinfo {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMinfo {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_SysWMinfo {{ version: {:?}, subsystem: {:?}, info: {:?} }}",
      self.version, self.subsystem, self.info
    )
  }
}
extern "C" {
  pub fn SDL_GetWindowWMInfo(window: *mut SDL_Window, info: *mut SDL_SysWMinfo) -> SDL_bool::Type;
}
pub type __builtin_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __va_list {
  pub __ap: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list() {
  assert_eq!(
    ::core::mem::size_of::<__va_list>(),
    4usize,
    concat!("Size of: ", stringify!(__va_list))
  );
  assert_eq!(
    ::core::mem::align_of::<__va_list>(),
    4usize,
    concat!("Alignment of ", stringify!(__va_list))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list>())).__ap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list),
      "::",
      stringify!(__ap)
    )
  );
}
impl Default for __va_list {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_BlitMap {
  pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct wl_display {
  pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct wl_surface {
  pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct wl_shell_surface {
  pub _address: u8,
}
