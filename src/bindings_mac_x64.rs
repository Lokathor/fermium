/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  storage: Storage,
  align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  #[inline]
  pub fn new(storage: Storage) -> Self {
    Self { storage, align: [] }
  }
  #[inline]
  pub fn get_bit(&self, index: usize) -> bool {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = self.storage.as_ref()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    byte & mask == mask
  }
  #[inline]
  pub fn set_bit(&mut self, index: usize, val: bool) {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = &mut self.storage.as_mut()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    if val {
      *byte |= mask;
    } else {
      *byte &= !mask;
    }
  }
  #[inline]
  pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if self.get_bit(i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      self.set_bit(index + bit_offset, val_bit_is_set);
    }
  }
}
pub const MAC_OS_X_VERSION_MIN_REQUIRED: u32 = 1060;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const __AVAILABILITY_MACROS_USES_AVAILABILITY: u32 = 1;
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_BRIDGE: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 1;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_ARM64: u32 = 0;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const __MACOSX__: u32 = 1;
pub const SIZEOF_VOIDP: u32 = 8;
pub const STDC_HEADERS: u32 = 1;
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_CTYPE_H: u32 = 1;
pub const HAVE_FLOAT_H: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_MATH_H: u32 = 1;
pub const HAVE_SIGNAL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_LIBUNWIND_H: u32 = 1;
pub const HAVE_MALLOC: u32 = 1;
pub const HAVE_CALLOC: u32 = 1;
pub const HAVE_REALLOC: u32 = 1;
pub const HAVE_FREE: u32 = 1;
pub const HAVE_ALLOCA: u32 = 1;
pub const HAVE_GETENV: u32 = 1;
pub const HAVE_SETENV: u32 = 1;
pub const HAVE_PUTENV: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_QSORT: u32 = 1;
pub const HAVE_ABS: u32 = 1;
pub const HAVE_BCOPY: u32 = 1;
pub const HAVE_MEMSET: u32 = 1;
pub const HAVE_MEMCPY: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_MEMCMP: u32 = 1;
pub const HAVE_STRLEN: u32 = 1;
pub const HAVE_STRLCPY: u32 = 1;
pub const HAVE_STRLCAT: u32 = 1;
pub const HAVE_STRCHR: u32 = 1;
pub const HAVE_STRRCHR: u32 = 1;
pub const HAVE_STRSTR: u32 = 1;
pub const HAVE_STRTOL: u32 = 1;
pub const HAVE_STRTOUL: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRTOD: u32 = 1;
pub const HAVE_ATOI: u32 = 1;
pub const HAVE_ATOF: u32 = 1;
pub const HAVE_STRCMP: u32 = 1;
pub const HAVE_STRNCMP: u32 = 1;
pub const HAVE_STRCASECMP: u32 = 1;
pub const HAVE_STRNCASECMP: u32 = 1;
pub const HAVE_VSSCANF: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE_M_PI: u32 = 1;
pub const HAVE_ACOS: u32 = 1;
pub const HAVE_ACOSF: u32 = 1;
pub const HAVE_ASIN: u32 = 1;
pub const HAVE_ASINF: u32 = 1;
pub const HAVE_ATAN: u32 = 1;
pub const HAVE_ATANF: u32 = 1;
pub const HAVE_ATAN2: u32 = 1;
pub const HAVE_ATAN2F: u32 = 1;
pub const HAVE_CEIL: u32 = 1;
pub const HAVE_CEILF: u32 = 1;
pub const HAVE_COPYSIGN: u32 = 1;
pub const HAVE_COPYSIGNF: u32 = 1;
pub const HAVE_COS: u32 = 1;
pub const HAVE_COSF: u32 = 1;
pub const HAVE_EXP: u32 = 1;
pub const HAVE_EXPF: u32 = 1;
pub const HAVE_FABS: u32 = 1;
pub const HAVE_FABSF: u32 = 1;
pub const HAVE_FLOOR: u32 = 1;
pub const HAVE_FLOORF: u32 = 1;
pub const HAVE_FMOD: u32 = 1;
pub const HAVE_FMODF: u32 = 1;
pub const HAVE_LOG: u32 = 1;
pub const HAVE_LOGF: u32 = 1;
pub const HAVE_LOG10: u32 = 1;
pub const HAVE_LOG10F: u32 = 1;
pub const HAVE_POW: u32 = 1;
pub const HAVE_POWF: u32 = 1;
pub const HAVE_SCALBN: u32 = 1;
pub const HAVE_SCALBNF: u32 = 1;
pub const HAVE_SIN: u32 = 1;
pub const HAVE_SINF: u32 = 1;
pub const HAVE_SQRT: u32 = 1;
pub const HAVE_SQRTF: u32 = 1;
pub const HAVE_TAN: u32 = 1;
pub const HAVE_TANF: u32 = 1;
pub const HAVE_SIGACTION: u32 = 1;
pub const HAVE_SETJMP: u32 = 1;
pub const HAVE_NANOSLEEP: u32 = 1;
pub const HAVE_SYSCONF: u32 = 1;
pub const HAVE_SYSCTLBYNAME: u32 = 1;
pub const SDL_AUDIO_DRIVER_COREAUDIO: u32 = 1;
pub const SDL_AUDIO_DRIVER_DISK: u32 = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_JOYSTICK_IOKIT: u32 = 1;
pub const SDL_JOYSTICK_HIDAPI: u32 = 1;
pub const SDL_HAPTIC_IOKIT: u32 = 1;
pub const SDL_SENSOR_DUMMY: u32 = 1;
pub const SDL_LOADSO_DLOPEN: u32 = 1;
pub const SDL_THREAD_PTHREAD: u32 = 1;
pub const SDL_THREAD_PTHREAD_RECURSIVE_MUTEX: u32 = 1;
pub const SDL_TIMER_UNIX: u32 = 1;
pub const SDL_VIDEO_DRIVER_COCOA: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC: &'static [u8; 30usize] = b"/usr/X11R6/lib/libX11.6.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT: &'static [u8; 31usize] =
  b"/usr/X11R6/lib/libXext.6.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XINERAMA: &'static [u8; 35usize] =
  b"/usr/X11R6/lib/libXinerama.1.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2: &'static [u8; 29usize] =
  b"/usr/X11R6/lib/libXi.6.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR: &'static [u8; 33usize] =
  b"/usr/X11R6/lib/libXrandr.2.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS: &'static [u8; 30usize] =
  b"/usr/X11R6/lib/libXss.1.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_DYNAMIC_XVIDMODE: &'static [u8; 34usize] =
  b"/usr/X11R6/lib/libXxf86vm.1.dylib\0";
pub const SDL_VIDEO_DRIVER_X11_XDBE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINERAMA: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XRANDR: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XSCRNSAVER: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XSHAPE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XVIDMODE: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_XINPUT2: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS: u32 = 1;
pub const SDL_VIDEO_DRIVER_X11_CONST_PARAM_XEXTADDDISPLAY: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL_ES2: u32 = 1;
pub const SDL_VIDEO_RENDER_METAL: u32 = 1;
pub const SDL_VIDEO_OPENGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL_EGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_CGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_GLX: u32 = 1;
pub const SDL_VIDEO_VULKAN: u32 = 1;
pub const SDL_POWER_MACOSX: u32 = 1;
pub const SDL_FILESYSTEM_COCOA: u32 = 1;
pub const SDL_ASSEMBLY_ROUTINES: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_VERS_1050: u32 = 0;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const __CTERMID_DEFINED: u32 = 1;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_CURRENT: u32 = 4;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &'static [u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const SDL_PRIs64: &'static [u8; 4usize] = b"lld\0";
pub const SDL_PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const SDL_PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const SDL_PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_AUDIOCVT_MAX_FILTERS: u32 = 9;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
  b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
  b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &'static [u8; 28usize] =
  b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &'static [u8; 29usize] =
  b"SDL_RENDER_LOGICAL_SIZE_MODE\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
  b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &'static [u8; 26usize] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &'static [u8; 39usize] =
  b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &'static [u8; 44usize] =
  b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &'static [u8; 29usize] =
  b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &'static [u8; 35usize] =
  b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &'static [u8; 31usize] =
  b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &'static [u8; 28usize] =
  b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &'static [u8; 30usize] =
  b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &'static [u8; 29usize] =
  b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &'static [u8; 31usize] =
  b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
  b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &'static [u8; 29usize] =
  b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &'static [u8; 23usize] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
  b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &'static [u8; 34usize] =
  b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &'static [u8; 35usize] =
  b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &'static [u8; 28usize] =
  b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
  b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &'static [u8; 26usize] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &'static [u8; 36usize] =
  b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &'static [u8; 34usize] =
  b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &'static [u8; 41usize] =
  b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
  b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &'static [u8; 20usize] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &'static [u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &'static [u8; 31usize] =
  b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &'static [u8; 26usize] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &'static [u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &'static [u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_ENABLE_STEAM_CONTROLLERS: &'static [u8; 29usize] =
  b"SDL_ENABLE_STEAM_CONTROLLERS\0";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &'static [u8; 34usize] =
  b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &'static [u8; 27usize] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &'static [u8; 22usize] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize] =
  b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
  b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &'static [u8; 29usize] =
  b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &'static [u8; 31usize] =
  b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &'static [u8; 29usize] =
  b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
  b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &'static [u8; 23usize] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION: &'static [u8; 44usize] =
  b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION: &'static [u8; 45usize] =
  b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &'static [u8; 25usize] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_ANDROID_SEPARATE_MOUSE_AND_TOUCH: &'static [u8; 37usize] =
  b"SDL_ANDROID_SEPARATE_MOUSE_AND_TOUCH\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &'static [u8; 29usize] =
  b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &'static [u8; 25usize] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &'static [u8; 32usize] =
  b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &'static [u8; 23usize] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &'static [u8; 31usize] =
  b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &'static [u8; 27usize] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &'static [u8; 34usize] =
  b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &'static [u8; 20usize] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &'static [u8; 24usize] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &'static [u8; 21usize] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &'static [u8; 26usize] = b"SDL_AUDIO_RESAMPLING_MODE\0";
pub const SDL_HINT_AUDIO_CATEGORY: &'static [u8; 19usize] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 9;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 62001;
extern "C" {
  #[doc = "  \\brief Gets the name of the platform."]
  #[link_name = "\u{1}_SDL_GetPlatform"]
  pub fn SDL_GetPlatform() -> *const libc::c_char;
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __darwin_intptr_t = libc::c_long;
pub type __darwin_natural_t = libc::c_uint;
pub type __darwin_ct_rune_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
  pub __mbstate8: [libc::c_char; 128usize],
  pub _mbstateL: libc::c_longlong,
  _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
  assert_eq!(
    ::core::mem::size_of::<__mbstate_t>(),
    128usize,
    concat!("Size of: ", stringify!(__mbstate_t))
  );
  assert_eq!(
    ::core::mem::align_of::<__mbstate_t>(),
    8usize,
    concat!("Alignment of ", stringify!(__mbstate_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t),
      "::",
      stringify!(__mbstate8)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t),
      "::",
      stringify!(_mbstateL)
    )
  );
}
impl Default for __mbstate_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __mbstate_t {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "__mbstate_t {{ union }}")
  }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = libc::c_long;
pub type __darwin_size_t = libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = libc::c_int;
pub type __darwin_clock_t = libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = libc::c_long;
pub type __darwin_time_t = libc::c_long;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = libc::c_uint;
pub type __darwin_fsfilcnt_t = libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __uint32_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [libc::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __darwin_pthread_handler_rec {
  pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
  pub __arg: *mut libc::c_void,
  pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_pthread_handler_rec>(),
    24usize,
    concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_pthread_handler_rec>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_pthread_handler_rec),
      "::",
      stringify!(__routine)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_pthread_handler_rec),
      "::",
      stringify!(__arg)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_pthread_handler_rec),
      "::",
      stringify!(__next)
    )
  );
}
impl Default for __darwin_pthread_handler_rec {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_attr_t>(),
    64usize,
    concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_attr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_attr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_attr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_attr_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _opaque_pthread_attr_t {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_opaque_pthread_attr_t {{ __sig: {:?}, __opaque: [...] }}",
      self.__sig
    )
  }
}
impl ::core::cmp::PartialEq for _opaque_pthread_attr_t {
  fn eq(&self, other: &_opaque_pthread_attr_t) -> bool {
    self.__sig == other.__sig && &self.__opaque[..] == &other.__opaque[..]
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_cond_t>(),
    48usize,
    concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_cond_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_cond_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_cond_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_cond_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _opaque_pthread_cond_t {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_opaque_pthread_cond_t {{ __sig: {:?}, __opaque: [...] }}",
      self.__sig
    )
  }
}
impl ::core::cmp::PartialEq for _opaque_pthread_cond_t {
  fn eq(&self, other: &_opaque_pthread_cond_t) -> bool {
    self.__sig == other.__sig && &self.__opaque[..] == &other.__opaque[..]
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _opaque_pthread_condattr_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_condattr_t>(),
    16usize,
    concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_condattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_condattr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_condattr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_mutex_t>(),
    64usize,
    concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_mutex_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutex_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutex_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_mutex_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _opaque_pthread_mutex_t {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_opaque_pthread_mutex_t {{ __sig: {:?}, __opaque: [...] }}",
      self.__sig
    )
  }
}
impl ::core::cmp::PartialEq for _opaque_pthread_mutex_t {
  fn eq(&self, other: &_opaque_pthread_mutex_t) -> bool {
    self.__sig == other.__sig && &self.__opaque[..] == &other.__opaque[..]
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _opaque_pthread_mutexattr_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_mutexattr_t>(),
    16usize,
    concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_mutexattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutexattr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutexattr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _opaque_pthread_once_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_once_t>(),
    16usize,
    concat!("Size of: ", stringify!(_opaque_pthread_once_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_once_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_once_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_once_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_rwlock_t>(),
    200usize,
    concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_rwlock_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlock_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlock_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_rwlock_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _opaque_pthread_rwlock_t {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_opaque_pthread_rwlock_t {{ __sig: {:?}, __opaque: [...] }}",
      self.__sig
    )
  }
}
impl ::core::cmp::PartialEq for _opaque_pthread_rwlock_t {
  fn eq(&self, other: &_opaque_pthread_rwlock_t) -> bool {
    self.__sig == other.__sig && &self.__opaque[..] == &other.__opaque[..]
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _opaque_pthread_rwlockattr_t {
  pub __sig: libc::c_long,
  pub __opaque: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
    24usize,
    concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlockattr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlockattr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
  pub __sig: libc::c_long,
  pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
  pub __opaque: [libc::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
  assert_eq!(
    ::core::mem::size_of::<_opaque_pthread_t>(),
    8192usize,
    concat!("Size of: ", stringify!(_opaque_pthread_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_opaque_pthread_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_t),
      "::",
      stringify!(__cleanup_stack)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _opaque_pthread_t {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_opaque_pthread_t {{ __sig: {:?}, __cleanup_stack: {:?}, __opaque: [...] }}",
      self.__sig, self.__cleanup_stack
    )
  }
}
impl ::core::cmp::PartialEq for _opaque_pthread_t {
  fn eq(&self, other: &_opaque_pthread_t) -> bool {
    self.__sig == other.__sig
      && self.__cleanup_stack == other.__cleanup_stack
      && &self.__opaque[..] == &other.__opaque[..]
  }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = libc::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_char = libc::c_uchar;
pub type u_short = libc::c_ushort;
pub type u_int = libc::c_uint;
pub type u_long = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut libc::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct fd_set {
  pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
  assert_eq!(
    ::core::mem::size_of::<fd_set>(),
    128usize,
    concat!("Size of: ", stringify!(fd_set))
  );
  assert_eq!(
    ::core::mem::align_of::<fd_set>(),
    4usize,
    concat!("Alignment of ", stringify!(fd_set))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(fd_set),
      "::",
      stringify!(fds_bits)
    )
  );
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type __darwin_nl_item = libc::c_int;
pub type __darwin_wctrans_t = libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
  #[link_name = "\u{1}_renameat"]
  pub fn renameat(
    arg1: libc::c_int,
    arg2: *const libc::c_char,
    arg3: libc::c_int,
    arg4: *const libc::c_char,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_renamex_np"]
  pub fn renamex_np(
    arg1: *const libc::c_char,
    arg2: *const libc::c_char,
    arg3: libc::c_uint,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_renameatx_np"]
  pub fn renameatx_np(
    arg1: libc::c_int,
    arg2: *const libc::c_char,
    arg3: libc::c_int,
    arg4: *const libc::c_char,
    arg5: libc::c_uint,
  ) -> libc::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __sbuf {
  pub _base: *mut libc::c_uchar,
  pub _size: libc::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
  assert_eq!(
    ::core::mem::size_of::<__sbuf>(),
    16usize,
    concat!("Size of: ", stringify!(__sbuf))
  );
  assert_eq!(
    ::core::mem::align_of::<__sbuf>(),
    8usize,
    concat!("Alignment of ", stringify!(__sbuf))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sbuf>()))._base as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__sbuf),
      "::",
      stringify!(_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sbuf>()))._size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__sbuf),
      "::",
      stringify!(_size)
    )
  );
}
impl Default for __sbuf {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __sFILE {
  pub _p: *mut libc::c_uchar,
  pub _r: libc::c_int,
  pub _w: libc::c_int,
  pub _flags: libc::c_short,
  pub _file: libc::c_short,
  pub _bf: __sbuf,
  pub _lbfsize: libc::c_int,
  pub _cookie: *mut libc::c_void,
  pub _close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
  pub _read: ::core::option::Option<
    unsafe extern "C" fn(
      arg1: *mut libc::c_void,
      arg2: *mut libc::c_char,
      arg3: libc::c_int,
    ) -> libc::c_int,
  >,
  pub _seek: ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int) -> fpos_t,
  >,
  pub _write: ::core::option::Option<
    unsafe extern "C" fn(
      arg1: *mut libc::c_void,
      arg2: *const libc::c_char,
      arg3: libc::c_int,
    ) -> libc::c_int,
  >,
  pub _ub: __sbuf,
  pub _extra: *mut __sFILEX,
  pub _ur: libc::c_int,
  pub _ubuf: [libc::c_uchar; 3usize],
  pub _nbuf: [libc::c_uchar; 1usize],
  pub _lb: __sbuf,
  pub _blksize: libc::c_int,
  pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
  assert_eq!(
    ::core::mem::size_of::<__sFILE>(),
    152usize,
    concat!("Size of: ", stringify!(__sFILE))
  );
  assert_eq!(
    ::core::mem::align_of::<__sFILE>(),
    8usize,
    concat!("Alignment of ", stringify!(__sFILE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._p as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_p)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._r as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._w as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._file as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_file)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._bf as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_bf)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_lbfsize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_cookie)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._close as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_close)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._read as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_read)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._seek as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_seek)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._write as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_write)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._ub as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_ub)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._extra as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_extra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._ur as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_ur)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_ubuf)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
    119usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_nbuf)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._lb as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_lb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_blksize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sFILE>()))._offset as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(__sFILE),
      "::",
      stringify!(_offset)
    )
  );
}
impl Default for __sFILE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type FILE = __sFILE;
extern "C" {
  #[link_name = "\u{1}___stdinp"]
  pub static mut __stdinp: *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}___stdoutp"]
  pub static mut __stdoutp: *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}___stderrp"]
  pub static mut __stderrp: *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_clearerr"]
  pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
  #[link_name = "\u{1}_fclose"]
  pub fn fclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_feof"]
  pub fn feof(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ferror"]
  pub fn ferror(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fflush"]
  pub fn fflush(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fgetc"]
  pub fn fgetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fgetpos"]
  pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fgets"]
  pub fn fgets(arg1: *mut libc::c_char, arg2: libc::c_int, arg3: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_fopen"]
  pub fn fopen(__filename: *const libc::c_char, __mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_fprintf"]
  pub fn fprintf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fputc"]
  pub fn fputc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fputs"]
  pub fn fputs(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fread"]
  pub fn fread(
    __ptr: *mut libc::c_void,
    __size: usize,
    __nitems: usize,
    __stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_freopen"]
  pub fn freopen(
    arg1: *const libc::c_char,
    arg2: *const libc::c_char,
    arg3: *mut FILE,
  ) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_fscanf"]
  pub fn fscanf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fseek"]
  pub fn fseek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fsetpos"]
  pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ftell"]
  pub fn ftell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_fwrite"]
  pub fn fwrite(
    __ptr: *const libc::c_void,
    __size: usize,
    __nitems: usize,
    __stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_getc"]
  pub fn getc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getchar"]
  pub fn getchar() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_gets"]
  pub fn gets(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_perror"]
  pub fn perror(arg1: *const libc::c_char);
}
extern "C" {
  #[link_name = "\u{1}_printf"]
  pub fn printf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_putc"]
  pub fn putc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_putchar"]
  pub fn putchar(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_puts"]
  pub fn puts(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_remove"]
  pub fn remove(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_rename"]
  pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_rewind"]
  pub fn rewind(arg1: *mut FILE);
}
extern "C" {
  #[link_name = "\u{1}_scanf"]
  pub fn scanf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setbuf"]
  pub fn setbuf(arg1: *mut FILE, arg2: *mut libc::c_char);
}
extern "C" {
  #[link_name = "\u{1}_setvbuf"]
  pub fn setvbuf(
    arg1: *mut FILE,
    arg2: *mut libc::c_char,
    arg3: libc::c_int,
    arg4: usize,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_sprintf"]
  pub fn sprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_sscanf"]
  pub fn sscanf(arg1: *const libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_tmpfile"]
  pub fn tmpfile() -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_tmpnam"]
  pub fn tmpnam(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_ungetc"]
  pub fn ungetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vfprintf"]
  pub fn vfprintf(
    arg1: *mut FILE,
    arg2: *const libc::c_char,
    arg3: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vprintf"]
  pub fn vprintf(arg1: *const libc::c_char, arg2: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vsprintf"]
  pub fn vsprintf(
    arg1: *mut libc::c_char,
    arg2: *const libc::c_char,
    arg3: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ctermid"]
  pub fn ctermid(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_fdopen"]
  pub fn fdopen(arg1: libc::c_int, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_fileno"]
  pub fn fileno(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_pclose"]
  pub fn pclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_popen"]
  pub fn popen(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}___srget"]
  pub fn __srget(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}___svfscanf"]
  pub fn __svfscanf(
    arg1: *mut FILE,
    arg2: *const libc::c_char,
    arg3: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}___swbuf"]
  pub fn __swbuf(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_flockfile"]
  pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
  #[link_name = "\u{1}_ftrylockfile"]
  pub fn ftrylockfile(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_funlockfile"]
  pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
  #[link_name = "\u{1}_getc_unlocked"]
  pub fn getc_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getchar_unlocked"]
  pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_putc_unlocked"]
  pub fn putc_unlocked(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_putchar_unlocked"]
  pub fn putchar_unlocked(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getw"]
  pub fn getw(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_putw"]
  pub fn putw(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_tempnam"]
  pub fn tempnam(__dir: *const libc::c_char, __prefix: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_fseeko"]
  pub fn fseeko(__stream: *mut FILE, __offset: off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ftello"]
  pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
  #[link_name = "\u{1}_snprintf"]
  pub fn snprintf(
    __str: *mut libc::c_char,
    __size: libc::c_ulong,
    __format: *const libc::c_char,
    ...
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vfscanf"]
  pub fn vfscanf(
    __stream: *mut FILE,
    __format: *const libc::c_char,
    arg1: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vscanf"]
  pub fn vscanf(__format: *const libc::c_char, arg1: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vsnprintf"]
  pub fn vsnprintf(
    __str: *mut libc::c_char,
    __size: libc::c_ulong,
    __format: *const libc::c_char,
    arg1: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vsscanf"]
  pub fn vsscanf(
    __str: *const libc::c_char,
    __format: *const libc::c_char,
    arg1: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_dprintf"]
  pub fn dprintf(arg1: libc::c_int, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vdprintf"]
  pub fn vdprintf(
    arg1: libc::c_int,
    arg2: *const libc::c_char,
    arg3: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getdelim"]
  pub fn getdelim(
    __linep: *mut *mut libc::c_char,
    __linecapp: *mut usize,
    __delimiter: libc::c_int,
    __stream: *mut FILE,
  ) -> isize;
}
extern "C" {
  #[link_name = "\u{1}_getline"]
  pub fn getline(
    __linep: *mut *mut libc::c_char,
    __linecapp: *mut usize,
    __stream: *mut FILE,
  ) -> isize;
}
extern "C" {
  #[link_name = "\u{1}_fmemopen"]
  pub fn fmemopen(
    __buf: *mut libc::c_void,
    __size: usize,
    __mode: *const libc::c_char,
  ) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_open_memstream"]
  pub fn open_memstream(__bufp: *mut *mut libc::c_char, __sizep: *mut usize) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_sys_nerr"]
  pub static sys_nerr: libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_sys_errlist"]
  pub static mut sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
  #[link_name = "\u{1}_asprintf"]
  pub fn asprintf(arg1: *mut *mut libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ctermid_r"]
  pub fn ctermid_r(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_fgetln"]
  pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_fmtcheck"]
  pub fn fmtcheck(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_fpurge"]
  pub fn fpurge(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setbuffer"]
  pub fn setbuffer(arg1: *mut FILE, arg2: *mut libc::c_char, arg3: libc::c_int);
}
extern "C" {
  #[link_name = "\u{1}_setlinebuf"]
  pub fn setlinebuf(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_vasprintf"]
  pub fn vasprintf(
    arg1: *mut *mut libc::c_char,
    arg2: *const libc::c_char,
    arg3: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_zopen"]
  pub fn zopen(
    arg1: *const libc::c_char,
    arg2: *const libc::c_char,
    arg3: libc::c_int,
  ) -> *mut FILE;
}
extern "C" {
  #[link_name = "\u{1}_funopen"]
  pub fn funopen(
    arg1: *const libc::c_void,
    arg2: ::core::option::Option<
      unsafe extern "C" fn(
        arg1: *mut libc::c_void,
        arg2: *mut libc::c_char,
        arg3: libc::c_int,
      ) -> libc::c_int,
    >,
    arg3: ::core::option::Option<
      unsafe extern "C" fn(
        arg1: *mut libc::c_void,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
      ) -> libc::c_int,
    >,
    arg4: ::core::option::Option<
      unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int) -> fpos_t,
    >,
    arg5: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
  ) -> *mut FILE;
}
pub mod idtype_t {
  pub type Type = u32;
  pub const P_ALL: Type = 0;
  pub const P_PID: Type = 1;
  pub const P_PGID: Type = 2;
}
pub type sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_i386_thread_state {
  pub __eax: libc::c_uint,
  pub __ebx: libc::c_uint,
  pub __ecx: libc::c_uint,
  pub __edx: libc::c_uint,
  pub __edi: libc::c_uint,
  pub __esi: libc::c_uint,
  pub __ebp: libc::c_uint,
  pub __esp: libc::c_uint,
  pub __ss: libc::c_uint,
  pub __eflags: libc::c_uint,
  pub __eip: libc::c_uint,
  pub __cs: libc::c_uint,
  pub __ds: libc::c_uint,
  pub __es: libc::c_uint,
  pub __fs: libc::c_uint,
  pub __gs: libc::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_i386_thread_state>(),
    64usize,
    concat!("Size of: ", stringify!(__darwin_i386_thread_state))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_i386_thread_state>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__eax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__ebx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__ecx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__edx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__edi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__esi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__ebp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__esp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__eflags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__eip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__cs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__ds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__fs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_thread_state),
      "::",
      stringify!(__gs)
    )
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_fp_control {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_fp_control>(),
    2usize,
    concat!("Size of: ", stringify!(__darwin_fp_control))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_fp_control>(),
    2usize,
    concat!("Alignment of ", stringify!(__darwin_fp_control))
  );
}
impl __darwin_fp_control {
  #[inline]
  pub fn __invalid(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___invalid(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __denorm(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___denorm(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __zdiv(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___zdiv(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __ovrfl(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___ovrfl(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __undfl(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___undfl(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __precis(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___precis(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __pc(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
  }
  #[inline]
  pub fn set___pc(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn __rc(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
  }
  #[inline]
  pub fn set___rc(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(10usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    __invalid: libc::c_ushort,
    __denorm: libc::c_ushort,
    __zdiv: libc::c_ushort,
    __ovrfl: libc::c_ushort,
    __undfl: libc::c_ushort,
    __precis: libc::c_ushort,
    __pc: libc::c_ushort,
    __rc: libc::c_ushort,
  ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let __invalid: u16 = unsafe { ::core::mem::transmute(__invalid) };
      __invalid as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let __denorm: u16 = unsafe { ::core::mem::transmute(__denorm) };
      __denorm as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let __zdiv: u16 = unsafe { ::core::mem::transmute(__zdiv) };
      __zdiv as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let __ovrfl: u16 = unsafe { ::core::mem::transmute(__ovrfl) };
      __ovrfl as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let __undfl: u16 = unsafe { ::core::mem::transmute(__undfl) };
      __undfl as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let __precis: u16 = unsafe { ::core::mem::transmute(__precis) };
      __precis as u64
    });
    __bindgen_bitfield_unit.set(8usize, 2u8, {
      let __pc: u16 = unsafe { ::core::mem::transmute(__pc) };
      __pc as u64
    });
    __bindgen_bitfield_unit.set(10usize, 2u8, {
      let __rc: u16 = unsafe { ::core::mem::transmute(__rc) };
      __rc as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_fp_status {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_fp_status>(),
    2usize,
    concat!("Size of: ", stringify!(__darwin_fp_status))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_fp_status>(),
    2usize,
    concat!("Alignment of ", stringify!(__darwin_fp_status))
  );
}
impl __darwin_fp_status {
  #[inline]
  pub fn __invalid(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___invalid(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __denorm(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___denorm(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __zdiv(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___zdiv(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __ovrfl(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___ovrfl(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __undfl(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___undfl(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __precis(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___precis(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __stkflt(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___stkflt(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(6usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __errsumm(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___errsumm(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(7usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __c0(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___c0(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __c1(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___c1(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(9usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __c2(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___c2(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(10usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __tos(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
  }
  #[inline]
  pub fn set___tos(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(11usize, 3u8, val as u64)
    }
  }
  #[inline]
  pub fn __c3(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___c3(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(14usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn __busy(&self) -> libc::c_ushort {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set___busy(&mut self, val: libc::c_ushort) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(15usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    __invalid: libc::c_ushort,
    __denorm: libc::c_ushort,
    __zdiv: libc::c_ushort,
    __ovrfl: libc::c_ushort,
    __undfl: libc::c_ushort,
    __precis: libc::c_ushort,
    __stkflt: libc::c_ushort,
    __errsumm: libc::c_ushort,
    __c0: libc::c_ushort,
    __c1: libc::c_ushort,
    __c2: libc::c_ushort,
    __tos: libc::c_ushort,
    __c3: libc::c_ushort,
    __busy: libc::c_ushort,
  ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let __invalid: u16 = unsafe { ::core::mem::transmute(__invalid) };
      __invalid as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let __denorm: u16 = unsafe { ::core::mem::transmute(__denorm) };
      __denorm as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let __zdiv: u16 = unsafe { ::core::mem::transmute(__zdiv) };
      __zdiv as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let __ovrfl: u16 = unsafe { ::core::mem::transmute(__ovrfl) };
      __ovrfl as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let __undfl: u16 = unsafe { ::core::mem::transmute(__undfl) };
      __undfl as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let __precis: u16 = unsafe { ::core::mem::transmute(__precis) };
      __precis as u64
    });
    __bindgen_bitfield_unit.set(6usize, 1u8, {
      let __stkflt: u16 = unsafe { ::core::mem::transmute(__stkflt) };
      __stkflt as u64
    });
    __bindgen_bitfield_unit.set(7usize, 1u8, {
      let __errsumm: u16 = unsafe { ::core::mem::transmute(__errsumm) };
      __errsumm as u64
    });
    __bindgen_bitfield_unit.set(8usize, 1u8, {
      let __c0: u16 = unsafe { ::core::mem::transmute(__c0) };
      __c0 as u64
    });
    __bindgen_bitfield_unit.set(9usize, 1u8, {
      let __c1: u16 = unsafe { ::core::mem::transmute(__c1) };
      __c1 as u64
    });
    __bindgen_bitfield_unit.set(10usize, 1u8, {
      let __c2: u16 = unsafe { ::core::mem::transmute(__c2) };
      __c2 as u64
    });
    __bindgen_bitfield_unit.set(11usize, 3u8, {
      let __tos: u16 = unsafe { ::core::mem::transmute(__tos) };
      __tos as u64
    });
    __bindgen_bitfield_unit.set(14usize, 1u8, {
      let __c3: u16 = unsafe { ::core::mem::transmute(__c3) };
      __c3 as u64
    });
    __bindgen_bitfield_unit.set(15usize, 1u8, {
      let __busy: u16 = unsafe { ::core::mem::transmute(__busy) };
      __busy as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_mmst_reg {
  pub __mmst_reg: [libc::c_char; 10usize],
  pub __mmst_rsrv: [libc::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mmst_reg>(),
    16usize,
    concat!("Size of: ", stringify!(__darwin_mmst_reg))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mmst_reg>(),
    1usize,
    concat!("Alignment of ", stringify!(__darwin_mmst_reg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mmst_reg),
      "::",
      stringify!(__mmst_reg)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mmst_reg),
      "::",
      stringify!(__mmst_rsrv)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_xmm_reg {
  pub __xmm_reg: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_xmm_reg>(),
    16usize,
    concat!("Size of: ", stringify!(__darwin_xmm_reg))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_xmm_reg>(),
    1usize,
    concat!("Alignment of ", stringify!(__darwin_xmm_reg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_xmm_reg),
      "::",
      stringify!(__xmm_reg)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_ymm_reg {
  pub __ymm_reg: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_ymm_reg>(),
    32usize,
    concat!("Size of: ", stringify!(__darwin_ymm_reg))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_ymm_reg>(),
    1usize,
    concat!("Alignment of ", stringify!(__darwin_ymm_reg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ymm_reg),
      "::",
      stringify!(__ymm_reg)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
  pub __zmm_reg: [libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_zmm_reg>(),
    64usize,
    concat!("Size of: ", stringify!(__darwin_zmm_reg))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_zmm_reg>(),
    1usize,
    concat!("Alignment of ", stringify!(__darwin_zmm_reg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_zmm_reg),
      "::",
      stringify!(__zmm_reg)
    )
  );
}
impl Default for __darwin_zmm_reg {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_zmm_reg {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "__darwin_zmm_reg {{ __zmm_reg: [...] }}")
  }
}
impl ::core::cmp::PartialEq for __darwin_zmm_reg {
  fn eq(&self, other: &__darwin_zmm_reg) -> bool {
    &self.__zmm_reg[..] == &other.__zmm_reg[..]
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_opmask_reg {
  pub __opmask_reg: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_opmask_reg>(),
    8usize,
    concat!("Size of: ", stringify!(__darwin_opmask_reg))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_opmask_reg>(),
    1usize,
    concat!("Alignment of ", stringify!(__darwin_opmask_reg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_opmask_reg),
      "::",
      stringify!(__opmask_reg)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
  pub __fpu_reserved: [libc::c_int; 2usize],
  pub __fpu_fcw: __darwin_fp_control,
  pub __fpu_fsw: __darwin_fp_status,
  pub __fpu_ftw: __uint8_t,
  pub __fpu_rsrv1: __uint8_t,
  pub __fpu_fop: __uint16_t,
  pub __fpu_ip: __uint32_t,
  pub __fpu_cs: __uint16_t,
  pub __fpu_rsrv2: __uint16_t,
  pub __fpu_dp: __uint32_t,
  pub __fpu_ds: __uint16_t,
  pub __fpu_rsrv3: __uint16_t,
  pub __fpu_mxcsr: __uint32_t,
  pub __fpu_mxcsrmask: __uint32_t,
  pub __fpu_stmm0: __darwin_mmst_reg,
  pub __fpu_stmm1: __darwin_mmst_reg,
  pub __fpu_stmm2: __darwin_mmst_reg,
  pub __fpu_stmm3: __darwin_mmst_reg,
  pub __fpu_stmm4: __darwin_mmst_reg,
  pub __fpu_stmm5: __darwin_mmst_reg,
  pub __fpu_stmm6: __darwin_mmst_reg,
  pub __fpu_stmm7: __darwin_mmst_reg,
  pub __fpu_xmm0: __darwin_xmm_reg,
  pub __fpu_xmm1: __darwin_xmm_reg,
  pub __fpu_xmm2: __darwin_xmm_reg,
  pub __fpu_xmm3: __darwin_xmm_reg,
  pub __fpu_xmm4: __darwin_xmm_reg,
  pub __fpu_xmm5: __darwin_xmm_reg,
  pub __fpu_xmm6: __darwin_xmm_reg,
  pub __fpu_xmm7: __darwin_xmm_reg,
  pub __fpu_rsrv4: [libc::c_char; 224usize],
  pub __fpu_reserved1: libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_i386_float_state>(),
    524usize,
    concat!("Size of: ", stringify!(__darwin_i386_float_state))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_i386_float_state>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_i386_float_state))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_fcw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_fsw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_ftw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_rsrv1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_fop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_ip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_cs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_rsrv2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_dp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_ds)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_rsrv3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_mxcsr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_mxcsrmask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_stmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
    },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
    },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
    },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
    },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_rsrv4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _ as usize
    },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_float_state),
      "::",
      stringify!(__fpu_reserved1)
    )
  );
}
impl Default for __darwin_i386_float_state {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_i386_float_state {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__darwin_i386_float_state {{ __fpu_reserved: {:?}, __fpu_fcw: {:?}, __fpu_fsw: {:?}, __fpu_ftw: {:?}, __fpu_rsrv1: {:?}, __fpu_fop: {:?}, __fpu_ip: {:?}, __fpu_cs: {:?}, __fpu_rsrv2: {:?}, __fpu_dp: {:?}, __fpu_ds: {:?}, __fpu_rsrv3: {:?}, __fpu_mxcsr: {:?}, __fpu_mxcsrmask: {:?}, __fpu_stmm0: {:?}, __fpu_stmm1: {:?}, __fpu_stmm2: {:?}, __fpu_stmm3: {:?}, __fpu_stmm4: {:?}, __fpu_stmm5: {:?}, __fpu_stmm6: {:?}, __fpu_stmm7: {:?}, __fpu_xmm0: {:?}, __fpu_xmm1: {:?}, __fpu_xmm2: {:?}, __fpu_xmm3: {:?}, __fpu_xmm4: {:?}, __fpu_xmm5: {:?}, __fpu_xmm6: {:?}, __fpu_xmm7: {:?}, __fpu_rsrv4: [...], __fpu_reserved1: {:?} }}" , self . __fpu_reserved , self . __fpu_fcw , self . __fpu_fsw , self . __fpu_ftw , self . __fpu_rsrv1 , self . __fpu_fop , self . __fpu_ip , self . __fpu_cs , self . __fpu_rsrv2 , self . __fpu_dp , self . __fpu_ds , self . __fpu_rsrv3 , self . __fpu_mxcsr , self . __fpu_mxcsrmask , self . __fpu_stmm0 , self . __fpu_stmm1 , self . __fpu_stmm2 , self . __fpu_stmm3 , self . __fpu_stmm4 , self . __fpu_stmm5 , self . __fpu_stmm6 , self . __fpu_stmm7 , self . __fpu_xmm0 , self . __fpu_xmm1 , self . __fpu_xmm2 , self . __fpu_xmm3 , self . __fpu_xmm4 , self . __fpu_xmm5 , self . __fpu_xmm6 , self . __fpu_xmm7 , self . __fpu_reserved1 )
  }
}
impl ::core::cmp::PartialEq for __darwin_i386_float_state {
  fn eq(&self, other: &__darwin_i386_float_state) -> bool {
    self.__fpu_reserved == other.__fpu_reserved
      && self.__fpu_fcw == other.__fpu_fcw
      && self.__fpu_fsw == other.__fpu_fsw
      && self.__fpu_ftw == other.__fpu_ftw
      && self.__fpu_rsrv1 == other.__fpu_rsrv1
      && self.__fpu_fop == other.__fpu_fop
      && self.__fpu_ip == other.__fpu_ip
      && self.__fpu_cs == other.__fpu_cs
      && self.__fpu_rsrv2 == other.__fpu_rsrv2
      && self.__fpu_dp == other.__fpu_dp
      && self.__fpu_ds == other.__fpu_ds
      && self.__fpu_rsrv3 == other.__fpu_rsrv3
      && self.__fpu_mxcsr == other.__fpu_mxcsr
      && self.__fpu_mxcsrmask == other.__fpu_mxcsrmask
      && self.__fpu_stmm0 == other.__fpu_stmm0
      && self.__fpu_stmm1 == other.__fpu_stmm1
      && self.__fpu_stmm2 == other.__fpu_stmm2
      && self.__fpu_stmm3 == other.__fpu_stmm3
      && self.__fpu_stmm4 == other.__fpu_stmm4
      && self.__fpu_stmm5 == other.__fpu_stmm5
      && self.__fpu_stmm6 == other.__fpu_stmm6
      && self.__fpu_stmm7 == other.__fpu_stmm7
      && self.__fpu_xmm0 == other.__fpu_xmm0
      && self.__fpu_xmm1 == other.__fpu_xmm1
      && self.__fpu_xmm2 == other.__fpu_xmm2
      && self.__fpu_xmm3 == other.__fpu_xmm3
      && self.__fpu_xmm4 == other.__fpu_xmm4
      && self.__fpu_xmm5 == other.__fpu_xmm5
      && self.__fpu_xmm6 == other.__fpu_xmm6
      && self.__fpu_xmm7 == other.__fpu_xmm7
      && &self.__fpu_rsrv4[..] == &other.__fpu_rsrv4[..]
      && self.__fpu_reserved1 == other.__fpu_reserved1
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
  pub __fpu_reserved: [libc::c_int; 2usize],
  pub __fpu_fcw: __darwin_fp_control,
  pub __fpu_fsw: __darwin_fp_status,
  pub __fpu_ftw: __uint8_t,
  pub __fpu_rsrv1: __uint8_t,
  pub __fpu_fop: __uint16_t,
  pub __fpu_ip: __uint32_t,
  pub __fpu_cs: __uint16_t,
  pub __fpu_rsrv2: __uint16_t,
  pub __fpu_dp: __uint32_t,
  pub __fpu_ds: __uint16_t,
  pub __fpu_rsrv3: __uint16_t,
  pub __fpu_mxcsr: __uint32_t,
  pub __fpu_mxcsrmask: __uint32_t,
  pub __fpu_stmm0: __darwin_mmst_reg,
  pub __fpu_stmm1: __darwin_mmst_reg,
  pub __fpu_stmm2: __darwin_mmst_reg,
  pub __fpu_stmm3: __darwin_mmst_reg,
  pub __fpu_stmm4: __darwin_mmst_reg,
  pub __fpu_stmm5: __darwin_mmst_reg,
  pub __fpu_stmm6: __darwin_mmst_reg,
  pub __fpu_stmm7: __darwin_mmst_reg,
  pub __fpu_xmm0: __darwin_xmm_reg,
  pub __fpu_xmm1: __darwin_xmm_reg,
  pub __fpu_xmm2: __darwin_xmm_reg,
  pub __fpu_xmm3: __darwin_xmm_reg,
  pub __fpu_xmm4: __darwin_xmm_reg,
  pub __fpu_xmm5: __darwin_xmm_reg,
  pub __fpu_xmm6: __darwin_xmm_reg,
  pub __fpu_xmm7: __darwin_xmm_reg,
  pub __fpu_rsrv4: [libc::c_char; 224usize],
  pub __fpu_reserved1: libc::c_int,
  pub __avx_reserved1: [libc::c_char; 64usize],
  pub __fpu_ymmh0: __darwin_xmm_reg,
  pub __fpu_ymmh1: __darwin_xmm_reg,
  pub __fpu_ymmh2: __darwin_xmm_reg,
  pub __fpu_ymmh3: __darwin_xmm_reg,
  pub __fpu_ymmh4: __darwin_xmm_reg,
  pub __fpu_ymmh5: __darwin_xmm_reg,
  pub __fpu_ymmh6: __darwin_xmm_reg,
  pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_i386_avx_state>(),
    716usize,
    concat!("Size of: ", stringify!(__darwin_i386_avx_state))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_i386_avx_state>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_fcw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_fsw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ftw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_rsrv1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_fop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_cs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_rsrv2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_dp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ds)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_rsrv3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_mxcsr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_mxcsrmask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_stmm7)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm4)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm5)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm6)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
    },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_rsrv4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
    },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
    },
    524usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__avx_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
    },
    588usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
    },
    604usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
    },
    620usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
    },
    636usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
    },
    652usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
    },
    668usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
    },
    684usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
    },
    700usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx_state),
      "::",
      stringify!(__fpu_ymmh7)
    )
  );
}
impl Default for __darwin_i386_avx_state {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_i386_avx_state {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__darwin_i386_avx_state {{ __fpu_reserved: {:?}, __fpu_fcw: {:?}, __fpu_fsw: {:?}, __fpu_ftw: {:?}, __fpu_rsrv1: {:?}, __fpu_fop: {:?}, __fpu_ip: {:?}, __fpu_cs: {:?}, __fpu_rsrv2: {:?}, __fpu_dp: {:?}, __fpu_ds: {:?}, __fpu_rsrv3: {:?}, __fpu_mxcsr: {:?}, __fpu_mxcsrmask: {:?}, __fpu_stmm0: {:?}, __fpu_stmm1: {:?}, __fpu_stmm2: {:?}, __fpu_stmm3: {:?}, __fpu_stmm4: {:?}, __fpu_stmm5: {:?}, __fpu_stmm6: {:?}, __fpu_stmm7: {:?}, __fpu_xmm0: {:?}, __fpu_xmm1: {:?}, __fpu_xmm2: {:?}, __fpu_xmm3: {:?}, __fpu_xmm4: {:?}, __fpu_xmm5: {:?}, __fpu_xmm6: {:?}, __fpu_xmm7: {:?}, __fpu_rsrv4: [...], __fpu_reserved1: {:?}, __avx_reserved1: [...], __fpu_ymmh0: {:?}, __fpu_ymmh1: {:?}, __fpu_ymmh2: {:?}, __fpu_ymmh3: {:?}, __fpu_ymmh4: {:?}, __fpu_ymmh5: {:?}, __fpu_ymmh6: {:?}, __fpu_ymmh7: {:?} }}" , self . __fpu_reserved , self . __fpu_fcw , self . __fpu_fsw , self . __fpu_ftw , self . __fpu_rsrv1 , self . __fpu_fop , self . __fpu_ip , self . __fpu_cs , self . __fpu_rsrv2 , self . __fpu_dp , self . __fpu_ds , self . __fpu_rsrv3 , self . __fpu_mxcsr , self . __fpu_mxcsrmask , self . __fpu_stmm0 , self . __fpu_stmm1 , self . __fpu_stmm2 , self . __fpu_stmm3 , self . __fpu_stmm4 , self . __fpu_stmm5 , self . __fpu_stmm6 , self . __fpu_stmm7 , self . __fpu_xmm0 , self . __fpu_xmm1 , self . __fpu_xmm2 , self . __fpu_xmm3 , self . __fpu_xmm4 , self . __fpu_xmm5 , self . __fpu_xmm6 , self . __fpu_xmm7 , self . __fpu_reserved1 , self . __fpu_ymmh0 , self . __fpu_ymmh1 , self . __fpu_ymmh2 , self . __fpu_ymmh3 , self . __fpu_ymmh4 , self . __fpu_ymmh5 , self . __fpu_ymmh6 , self . __fpu_ymmh7 )
  }
}
impl ::core::cmp::PartialEq for __darwin_i386_avx_state {
  fn eq(&self, other: &__darwin_i386_avx_state) -> bool {
    self.__fpu_reserved == other.__fpu_reserved
      && self.__fpu_fcw == other.__fpu_fcw
      && self.__fpu_fsw == other.__fpu_fsw
      && self.__fpu_ftw == other.__fpu_ftw
      && self.__fpu_rsrv1 == other.__fpu_rsrv1
      && self.__fpu_fop == other.__fpu_fop
      && self.__fpu_ip == other.__fpu_ip
      && self.__fpu_cs == other.__fpu_cs
      && self.__fpu_rsrv2 == other.__fpu_rsrv2
      && self.__fpu_dp == other.__fpu_dp
      && self.__fpu_ds == other.__fpu_ds
      && self.__fpu_rsrv3 == other.__fpu_rsrv3
      && self.__fpu_mxcsr == other.__fpu_mxcsr
      && self.__fpu_mxcsrmask == other.__fpu_mxcsrmask
      && self.__fpu_stmm0 == other.__fpu_stmm0
      && self.__fpu_stmm1 == other.__fpu_stmm1
      && self.__fpu_stmm2 == other.__fpu_stmm2
      && self.__fpu_stmm3 == other.__fpu_stmm3
      && self.__fpu_stmm4 == other.__fpu_stmm4
      && self.__fpu_stmm5 == other.__fpu_stmm5
      && self.__fpu_stmm6 == other.__fpu_stmm6
      && self.__fpu_stmm7 == other.__fpu_stmm7
      && self.__fpu_xmm0 == other.__fpu_xmm0
      && self.__fpu_xmm1 == other.__fpu_xmm1
      && self.__fpu_xmm2 == other.__fpu_xmm2
      && self.__fpu_xmm3 == other.__fpu_xmm3
      && self.__fpu_xmm4 == other.__fpu_xmm4
      && self.__fpu_xmm5 == other.__fpu_xmm5
      && self.__fpu_xmm6 == other.__fpu_xmm6
      && self.__fpu_xmm7 == other.__fpu_xmm7
      && &self.__fpu_rsrv4[..] == &other.__fpu_rsrv4[..]
      && self.__fpu_reserved1 == other.__fpu_reserved1
      && &self.__avx_reserved1[..] == &other.__avx_reserved1[..]
      && self.__fpu_ymmh0 == other.__fpu_ymmh0
      && self.__fpu_ymmh1 == other.__fpu_ymmh1
      && self.__fpu_ymmh2 == other.__fpu_ymmh2
      && self.__fpu_ymmh3 == other.__fpu_ymmh3
      && self.__fpu_ymmh4 == other.__fpu_ymmh4
      && self.__fpu_ymmh5 == other.__fpu_ymmh5
      && self.__fpu_ymmh6 == other.__fpu_ymmh6
      && self.__fpu_ymmh7 == other.__fpu_ymmh7
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
  pub __fpu_reserved: [libc::c_int; 2usize],
  pub __fpu_fcw: __darwin_fp_control,
  pub __fpu_fsw: __darwin_fp_status,
  pub __fpu_ftw: __uint8_t,
  pub __fpu_rsrv1: __uint8_t,
  pub __fpu_fop: __uint16_t,
  pub __fpu_ip: __uint32_t,
  pub __fpu_cs: __uint16_t,
  pub __fpu_rsrv2: __uint16_t,
  pub __fpu_dp: __uint32_t,
  pub __fpu_ds: __uint16_t,
  pub __fpu_rsrv3: __uint16_t,
  pub __fpu_mxcsr: __uint32_t,
  pub __fpu_mxcsrmask: __uint32_t,
  pub __fpu_stmm0: __darwin_mmst_reg,
  pub __fpu_stmm1: __darwin_mmst_reg,
  pub __fpu_stmm2: __darwin_mmst_reg,
  pub __fpu_stmm3: __darwin_mmst_reg,
  pub __fpu_stmm4: __darwin_mmst_reg,
  pub __fpu_stmm5: __darwin_mmst_reg,
  pub __fpu_stmm6: __darwin_mmst_reg,
  pub __fpu_stmm7: __darwin_mmst_reg,
  pub __fpu_xmm0: __darwin_xmm_reg,
  pub __fpu_xmm1: __darwin_xmm_reg,
  pub __fpu_xmm2: __darwin_xmm_reg,
  pub __fpu_xmm3: __darwin_xmm_reg,
  pub __fpu_xmm4: __darwin_xmm_reg,
  pub __fpu_xmm5: __darwin_xmm_reg,
  pub __fpu_xmm6: __darwin_xmm_reg,
  pub __fpu_xmm7: __darwin_xmm_reg,
  pub __fpu_rsrv4: [libc::c_char; 224usize],
  pub __fpu_reserved1: libc::c_int,
  pub __avx_reserved1: [libc::c_char; 64usize],
  pub __fpu_ymmh0: __darwin_xmm_reg,
  pub __fpu_ymmh1: __darwin_xmm_reg,
  pub __fpu_ymmh2: __darwin_xmm_reg,
  pub __fpu_ymmh3: __darwin_xmm_reg,
  pub __fpu_ymmh4: __darwin_xmm_reg,
  pub __fpu_ymmh5: __darwin_xmm_reg,
  pub __fpu_ymmh6: __darwin_xmm_reg,
  pub __fpu_ymmh7: __darwin_xmm_reg,
  pub __fpu_k0: __darwin_opmask_reg,
  pub __fpu_k1: __darwin_opmask_reg,
  pub __fpu_k2: __darwin_opmask_reg,
  pub __fpu_k3: __darwin_opmask_reg,
  pub __fpu_k4: __darwin_opmask_reg,
  pub __fpu_k5: __darwin_opmask_reg,
  pub __fpu_k6: __darwin_opmask_reg,
  pub __fpu_k7: __darwin_opmask_reg,
  pub __fpu_zmmh0: __darwin_ymm_reg,
  pub __fpu_zmmh1: __darwin_ymm_reg,
  pub __fpu_zmmh2: __darwin_ymm_reg,
  pub __fpu_zmmh3: __darwin_ymm_reg,
  pub __fpu_zmmh4: __darwin_ymm_reg,
  pub __fpu_zmmh5: __darwin_ymm_reg,
  pub __fpu_zmmh6: __darwin_ymm_reg,
  pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_i386_avx512_state>(),
    1036usize,
    concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_i386_avx512_state>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_fcw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_fsw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ftw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_rsrv1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_fop)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ip)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_cs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_rsrv2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_dp)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ds)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_rsrv3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_mxcsr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_mxcsrmask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_stmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
    },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
    },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
    },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
    },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_rsrv4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _ as usize
    },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _ as usize
    },
    524usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__avx_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
    },
    588usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
    },
    604usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
    },
    620usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
    },
    636usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
    },
    652usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
    },
    668usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
    },
    684usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
    },
    700usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_ymmh7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
    },
    716usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
    },
    724usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
    },
    732usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
    },
    740usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
    },
    748usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
    },
    756usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
    },
    764usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
    },
    772usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_k7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
    },
    780usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
    },
    812usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
    },
    844usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
    },
    876usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
    },
    908usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
    },
    940usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
    },
    972usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
    },
    1004usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_avx512_state),
      "::",
      stringify!(__fpu_zmmh7)
    )
  );
}
impl Default for __darwin_i386_avx512_state {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_i386_avx512_state {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__darwin_i386_avx512_state {{ __fpu_reserved: {:?}, __fpu_fcw: {:?}, __fpu_fsw: {:?}, __fpu_ftw: {:?}, __fpu_rsrv1: {:?}, __fpu_fop: {:?}, __fpu_ip: {:?}, __fpu_cs: {:?}, __fpu_rsrv2: {:?}, __fpu_dp: {:?}, __fpu_ds: {:?}, __fpu_rsrv3: {:?}, __fpu_mxcsr: {:?}, __fpu_mxcsrmask: {:?}, __fpu_stmm0: {:?}, __fpu_stmm1: {:?}, __fpu_stmm2: {:?}, __fpu_stmm3: {:?}, __fpu_stmm4: {:?}, __fpu_stmm5: {:?}, __fpu_stmm6: {:?}, __fpu_stmm7: {:?}, __fpu_xmm0: {:?}, __fpu_xmm1: {:?}, __fpu_xmm2: {:?}, __fpu_xmm3: {:?}, __fpu_xmm4: {:?}, __fpu_xmm5: {:?}, __fpu_xmm6: {:?}, __fpu_xmm7: {:?}, __fpu_rsrv4: [...], __fpu_reserved1: {:?}, __avx_reserved1: [...], __fpu_ymmh0: {:?}, __fpu_ymmh1: {:?}, __fpu_ymmh2: {:?}, __fpu_ymmh3: {:?}, __fpu_ymmh4: {:?}, __fpu_ymmh5: {:?}, __fpu_ymmh6: {:?}, __fpu_ymmh7: {:?}, __fpu_k0: {:?}, __fpu_k1: {:?}, __fpu_k2: {:?}, __fpu_k3: {:?}, __fpu_k4: {:?}, __fpu_k5: {:?}, __fpu_k6: {:?}, __fpu_k7: {:?}, __fpu_zmmh0: {:?}, __fpu_zmmh1: {:?}, __fpu_zmmh2: {:?}, __fpu_zmmh3: {:?}, __fpu_zmmh4: {:?}, __fpu_zmmh5: {:?}, __fpu_zmmh6: {:?}, __fpu_zmmh7: {:?} }}" , self . __fpu_reserved , self . __fpu_fcw , self . __fpu_fsw , self . __fpu_ftw , self . __fpu_rsrv1 , self . __fpu_fop , self . __fpu_ip , self . __fpu_cs , self . __fpu_rsrv2 , self . __fpu_dp , self . __fpu_ds , self . __fpu_rsrv3 , self . __fpu_mxcsr , self . __fpu_mxcsrmask , self . __fpu_stmm0 , self . __fpu_stmm1 , self . __fpu_stmm2 , self . __fpu_stmm3 , self . __fpu_stmm4 , self . __fpu_stmm5 , self . __fpu_stmm6 , self . __fpu_stmm7 , self . __fpu_xmm0 , self . __fpu_xmm1 , self . __fpu_xmm2 , self . __fpu_xmm3 , self . __fpu_xmm4 , self . __fpu_xmm5 , self . __fpu_xmm6 , self . __fpu_xmm7 , self . __fpu_reserved1 , self . __fpu_ymmh0 , self . __fpu_ymmh1 , self . __fpu_ymmh2 , self . __fpu_ymmh3 , self . __fpu_ymmh4 , self . __fpu_ymmh5 , self . __fpu_ymmh6 , self . __fpu_ymmh7 , self . __fpu_k0 , self . __fpu_k1 , self . __fpu_k2 , self . __fpu_k3 , self . __fpu_k4 , self . __fpu_k5 , self . __fpu_k6 , self . __fpu_k7 , self . __fpu_zmmh0 , self . __fpu_zmmh1 , self . __fpu_zmmh2 , self . __fpu_zmmh3 , self . __fpu_zmmh4 , self . __fpu_zmmh5 , self . __fpu_zmmh6 , self . __fpu_zmmh7 )
  }
}
impl ::core::cmp::PartialEq for __darwin_i386_avx512_state {
  fn eq(&self, other: &__darwin_i386_avx512_state) -> bool {
    self.__fpu_reserved == other.__fpu_reserved
      && self.__fpu_fcw == other.__fpu_fcw
      && self.__fpu_fsw == other.__fpu_fsw
      && self.__fpu_ftw == other.__fpu_ftw
      && self.__fpu_rsrv1 == other.__fpu_rsrv1
      && self.__fpu_fop == other.__fpu_fop
      && self.__fpu_ip == other.__fpu_ip
      && self.__fpu_cs == other.__fpu_cs
      && self.__fpu_rsrv2 == other.__fpu_rsrv2
      && self.__fpu_dp == other.__fpu_dp
      && self.__fpu_ds == other.__fpu_ds
      && self.__fpu_rsrv3 == other.__fpu_rsrv3
      && self.__fpu_mxcsr == other.__fpu_mxcsr
      && self.__fpu_mxcsrmask == other.__fpu_mxcsrmask
      && self.__fpu_stmm0 == other.__fpu_stmm0
      && self.__fpu_stmm1 == other.__fpu_stmm1
      && self.__fpu_stmm2 == other.__fpu_stmm2
      && self.__fpu_stmm3 == other.__fpu_stmm3
      && self.__fpu_stmm4 == other.__fpu_stmm4
      && self.__fpu_stmm5 == other.__fpu_stmm5
      && self.__fpu_stmm6 == other.__fpu_stmm6
      && self.__fpu_stmm7 == other.__fpu_stmm7
      && self.__fpu_xmm0 == other.__fpu_xmm0
      && self.__fpu_xmm1 == other.__fpu_xmm1
      && self.__fpu_xmm2 == other.__fpu_xmm2
      && self.__fpu_xmm3 == other.__fpu_xmm3
      && self.__fpu_xmm4 == other.__fpu_xmm4
      && self.__fpu_xmm5 == other.__fpu_xmm5
      && self.__fpu_xmm6 == other.__fpu_xmm6
      && self.__fpu_xmm7 == other.__fpu_xmm7
      && &self.__fpu_rsrv4[..] == &other.__fpu_rsrv4[..]
      && self.__fpu_reserved1 == other.__fpu_reserved1
      && &self.__avx_reserved1[..] == &other.__avx_reserved1[..]
      && self.__fpu_ymmh0 == other.__fpu_ymmh0
      && self.__fpu_ymmh1 == other.__fpu_ymmh1
      && self.__fpu_ymmh2 == other.__fpu_ymmh2
      && self.__fpu_ymmh3 == other.__fpu_ymmh3
      && self.__fpu_ymmh4 == other.__fpu_ymmh4
      && self.__fpu_ymmh5 == other.__fpu_ymmh5
      && self.__fpu_ymmh6 == other.__fpu_ymmh6
      && self.__fpu_ymmh7 == other.__fpu_ymmh7
      && self.__fpu_k0 == other.__fpu_k0
      && self.__fpu_k1 == other.__fpu_k1
      && self.__fpu_k2 == other.__fpu_k2
      && self.__fpu_k3 == other.__fpu_k3
      && self.__fpu_k4 == other.__fpu_k4
      && self.__fpu_k5 == other.__fpu_k5
      && self.__fpu_k6 == other.__fpu_k6
      && self.__fpu_k7 == other.__fpu_k7
      && self.__fpu_zmmh0 == other.__fpu_zmmh0
      && self.__fpu_zmmh1 == other.__fpu_zmmh1
      && self.__fpu_zmmh2 == other.__fpu_zmmh2
      && self.__fpu_zmmh3 == other.__fpu_zmmh3
      && self.__fpu_zmmh4 == other.__fpu_zmmh4
      && self.__fpu_zmmh5 == other.__fpu_zmmh5
      && self.__fpu_zmmh6 == other.__fpu_zmmh6
      && self.__fpu_zmmh7 == other.__fpu_zmmh7
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_i386_exception_state {
  pub __trapno: __uint16_t,
  pub __cpu: __uint16_t,
  pub __err: __uint32_t,
  pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_i386_exception_state>(),
    12usize,
    concat!("Size of: ", stringify!(__darwin_i386_exception_state))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_i386_exception_state>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_exception_state),
      "::",
      stringify!(__trapno)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_exception_state),
      "::",
      stringify!(__cpu)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_exception_state),
      "::",
      stringify!(__err)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_i386_exception_state),
      "::",
      stringify!(__faultvaddr)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_x86_debug_state32 {
  pub __dr0: libc::c_uint,
  pub __dr1: libc::c_uint,
  pub __dr2: libc::c_uint,
  pub __dr3: libc::c_uint,
  pub __dr4: libc::c_uint,
  pub __dr5: libc::c_uint,
  pub __dr6: libc::c_uint,
  pub __dr7: libc::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_debug_state32>(),
    32usize,
    concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_debug_state32>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr4)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr5)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr6)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state32),
      "::",
      stringify!(__dr7)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_x86_thread_state64 {
  pub __rax: __uint64_t,
  pub __rbx: __uint64_t,
  pub __rcx: __uint64_t,
  pub __rdx: __uint64_t,
  pub __rdi: __uint64_t,
  pub __rsi: __uint64_t,
  pub __rbp: __uint64_t,
  pub __rsp: __uint64_t,
  pub __r8: __uint64_t,
  pub __r9: __uint64_t,
  pub __r10: __uint64_t,
  pub __r11: __uint64_t,
  pub __r12: __uint64_t,
  pub __r13: __uint64_t,
  pub __r14: __uint64_t,
  pub __r15: __uint64_t,
  pub __rip: __uint64_t,
  pub __rflags: __uint64_t,
  pub __cs: __uint64_t,
  pub __fs: __uint64_t,
  pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_thread_state64>(),
    168usize,
    concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_thread_state64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rbx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rcx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rdx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rdi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rsi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rbp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rsp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r8)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r9)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r10)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r11)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r12)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r13)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r14)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__r15)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rip)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__rflags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__cs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__fs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_thread_state64),
      "::",
      stringify!(__gs)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
  pub __fpu_reserved: [libc::c_int; 2usize],
  pub __fpu_fcw: __darwin_fp_control,
  pub __fpu_fsw: __darwin_fp_status,
  pub __fpu_ftw: __uint8_t,
  pub __fpu_rsrv1: __uint8_t,
  pub __fpu_fop: __uint16_t,
  pub __fpu_ip: __uint32_t,
  pub __fpu_cs: __uint16_t,
  pub __fpu_rsrv2: __uint16_t,
  pub __fpu_dp: __uint32_t,
  pub __fpu_ds: __uint16_t,
  pub __fpu_rsrv3: __uint16_t,
  pub __fpu_mxcsr: __uint32_t,
  pub __fpu_mxcsrmask: __uint32_t,
  pub __fpu_stmm0: __darwin_mmst_reg,
  pub __fpu_stmm1: __darwin_mmst_reg,
  pub __fpu_stmm2: __darwin_mmst_reg,
  pub __fpu_stmm3: __darwin_mmst_reg,
  pub __fpu_stmm4: __darwin_mmst_reg,
  pub __fpu_stmm5: __darwin_mmst_reg,
  pub __fpu_stmm6: __darwin_mmst_reg,
  pub __fpu_stmm7: __darwin_mmst_reg,
  pub __fpu_xmm0: __darwin_xmm_reg,
  pub __fpu_xmm1: __darwin_xmm_reg,
  pub __fpu_xmm2: __darwin_xmm_reg,
  pub __fpu_xmm3: __darwin_xmm_reg,
  pub __fpu_xmm4: __darwin_xmm_reg,
  pub __fpu_xmm5: __darwin_xmm_reg,
  pub __fpu_xmm6: __darwin_xmm_reg,
  pub __fpu_xmm7: __darwin_xmm_reg,
  pub __fpu_xmm8: __darwin_xmm_reg,
  pub __fpu_xmm9: __darwin_xmm_reg,
  pub __fpu_xmm10: __darwin_xmm_reg,
  pub __fpu_xmm11: __darwin_xmm_reg,
  pub __fpu_xmm12: __darwin_xmm_reg,
  pub __fpu_xmm13: __darwin_xmm_reg,
  pub __fpu_xmm14: __darwin_xmm_reg,
  pub __fpu_xmm15: __darwin_xmm_reg,
  pub __fpu_rsrv4: [libc::c_char; 96usize],
  pub __fpu_reserved1: libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_float_state64>(),
    524usize,
    concat!("Size of: ", stringify!(__darwin_x86_float_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_float_state64>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_fcw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_fsw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_ftw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_rsrv1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_fop)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_ip)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_cs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_rsrv2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_dp)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_ds)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_rsrv3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_mxcsr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_mxcsrmask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_stmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
    },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
    },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
    },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
    },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
    },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
    },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
    },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
    },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
    },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
    },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
    },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_xmm15)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
    },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_rsrv4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _ as usize
    },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_float_state64),
      "::",
      stringify!(__fpu_reserved1)
    )
  );
}
impl Default for __darwin_x86_float_state64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_x86_float_state64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__darwin_x86_float_state64 {{ __fpu_reserved: {:?}, __fpu_fcw: {:?}, __fpu_fsw: {:?}, __fpu_ftw: {:?}, __fpu_rsrv1: {:?}, __fpu_fop: {:?}, __fpu_ip: {:?}, __fpu_cs: {:?}, __fpu_rsrv2: {:?}, __fpu_dp: {:?}, __fpu_ds: {:?}, __fpu_rsrv3: {:?}, __fpu_mxcsr: {:?}, __fpu_mxcsrmask: {:?}, __fpu_stmm0: {:?}, __fpu_stmm1: {:?}, __fpu_stmm2: {:?}, __fpu_stmm3: {:?}, __fpu_stmm4: {:?}, __fpu_stmm5: {:?}, __fpu_stmm6: {:?}, __fpu_stmm7: {:?}, __fpu_xmm0: {:?}, __fpu_xmm1: {:?}, __fpu_xmm2: {:?}, __fpu_xmm3: {:?}, __fpu_xmm4: {:?}, __fpu_xmm5: {:?}, __fpu_xmm6: {:?}, __fpu_xmm7: {:?}, __fpu_xmm8: {:?}, __fpu_xmm9: {:?}, __fpu_xmm10: {:?}, __fpu_xmm11: {:?}, __fpu_xmm12: {:?}, __fpu_xmm13: {:?}, __fpu_xmm14: {:?}, __fpu_xmm15: {:?}, __fpu_rsrv4: [...], __fpu_reserved1: {:?} }}" , self . __fpu_reserved , self . __fpu_fcw , self . __fpu_fsw , self . __fpu_ftw , self . __fpu_rsrv1 , self . __fpu_fop , self . __fpu_ip , self . __fpu_cs , self . __fpu_rsrv2 , self . __fpu_dp , self . __fpu_ds , self . __fpu_rsrv3 , self . __fpu_mxcsr , self . __fpu_mxcsrmask , self . __fpu_stmm0 , self . __fpu_stmm1 , self . __fpu_stmm2 , self . __fpu_stmm3 , self . __fpu_stmm4 , self . __fpu_stmm5 , self . __fpu_stmm6 , self . __fpu_stmm7 , self . __fpu_xmm0 , self . __fpu_xmm1 , self . __fpu_xmm2 , self . __fpu_xmm3 , self . __fpu_xmm4 , self . __fpu_xmm5 , self . __fpu_xmm6 , self . __fpu_xmm7 , self . __fpu_xmm8 , self . __fpu_xmm9 , self . __fpu_xmm10 , self . __fpu_xmm11 , self . __fpu_xmm12 , self . __fpu_xmm13 , self . __fpu_xmm14 , self . __fpu_xmm15 , self . __fpu_reserved1 )
  }
}
impl ::core::cmp::PartialEq for __darwin_x86_float_state64 {
  fn eq(&self, other: &__darwin_x86_float_state64) -> bool {
    self.__fpu_reserved == other.__fpu_reserved
      && self.__fpu_fcw == other.__fpu_fcw
      && self.__fpu_fsw == other.__fpu_fsw
      && self.__fpu_ftw == other.__fpu_ftw
      && self.__fpu_rsrv1 == other.__fpu_rsrv1
      && self.__fpu_fop == other.__fpu_fop
      && self.__fpu_ip == other.__fpu_ip
      && self.__fpu_cs == other.__fpu_cs
      && self.__fpu_rsrv2 == other.__fpu_rsrv2
      && self.__fpu_dp == other.__fpu_dp
      && self.__fpu_ds == other.__fpu_ds
      && self.__fpu_rsrv3 == other.__fpu_rsrv3
      && self.__fpu_mxcsr == other.__fpu_mxcsr
      && self.__fpu_mxcsrmask == other.__fpu_mxcsrmask
      && self.__fpu_stmm0 == other.__fpu_stmm0
      && self.__fpu_stmm1 == other.__fpu_stmm1
      && self.__fpu_stmm2 == other.__fpu_stmm2
      && self.__fpu_stmm3 == other.__fpu_stmm3
      && self.__fpu_stmm4 == other.__fpu_stmm4
      && self.__fpu_stmm5 == other.__fpu_stmm5
      && self.__fpu_stmm6 == other.__fpu_stmm6
      && self.__fpu_stmm7 == other.__fpu_stmm7
      && self.__fpu_xmm0 == other.__fpu_xmm0
      && self.__fpu_xmm1 == other.__fpu_xmm1
      && self.__fpu_xmm2 == other.__fpu_xmm2
      && self.__fpu_xmm3 == other.__fpu_xmm3
      && self.__fpu_xmm4 == other.__fpu_xmm4
      && self.__fpu_xmm5 == other.__fpu_xmm5
      && self.__fpu_xmm6 == other.__fpu_xmm6
      && self.__fpu_xmm7 == other.__fpu_xmm7
      && self.__fpu_xmm8 == other.__fpu_xmm8
      && self.__fpu_xmm9 == other.__fpu_xmm9
      && self.__fpu_xmm10 == other.__fpu_xmm10
      && self.__fpu_xmm11 == other.__fpu_xmm11
      && self.__fpu_xmm12 == other.__fpu_xmm12
      && self.__fpu_xmm13 == other.__fpu_xmm13
      && self.__fpu_xmm14 == other.__fpu_xmm14
      && self.__fpu_xmm15 == other.__fpu_xmm15
      && &self.__fpu_rsrv4[..] == &other.__fpu_rsrv4[..]
      && self.__fpu_reserved1 == other.__fpu_reserved1
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
  pub __fpu_reserved: [libc::c_int; 2usize],
  pub __fpu_fcw: __darwin_fp_control,
  pub __fpu_fsw: __darwin_fp_status,
  pub __fpu_ftw: __uint8_t,
  pub __fpu_rsrv1: __uint8_t,
  pub __fpu_fop: __uint16_t,
  pub __fpu_ip: __uint32_t,
  pub __fpu_cs: __uint16_t,
  pub __fpu_rsrv2: __uint16_t,
  pub __fpu_dp: __uint32_t,
  pub __fpu_ds: __uint16_t,
  pub __fpu_rsrv3: __uint16_t,
  pub __fpu_mxcsr: __uint32_t,
  pub __fpu_mxcsrmask: __uint32_t,
  pub __fpu_stmm0: __darwin_mmst_reg,
  pub __fpu_stmm1: __darwin_mmst_reg,
  pub __fpu_stmm2: __darwin_mmst_reg,
  pub __fpu_stmm3: __darwin_mmst_reg,
  pub __fpu_stmm4: __darwin_mmst_reg,
  pub __fpu_stmm5: __darwin_mmst_reg,
  pub __fpu_stmm6: __darwin_mmst_reg,
  pub __fpu_stmm7: __darwin_mmst_reg,
  pub __fpu_xmm0: __darwin_xmm_reg,
  pub __fpu_xmm1: __darwin_xmm_reg,
  pub __fpu_xmm2: __darwin_xmm_reg,
  pub __fpu_xmm3: __darwin_xmm_reg,
  pub __fpu_xmm4: __darwin_xmm_reg,
  pub __fpu_xmm5: __darwin_xmm_reg,
  pub __fpu_xmm6: __darwin_xmm_reg,
  pub __fpu_xmm7: __darwin_xmm_reg,
  pub __fpu_xmm8: __darwin_xmm_reg,
  pub __fpu_xmm9: __darwin_xmm_reg,
  pub __fpu_xmm10: __darwin_xmm_reg,
  pub __fpu_xmm11: __darwin_xmm_reg,
  pub __fpu_xmm12: __darwin_xmm_reg,
  pub __fpu_xmm13: __darwin_xmm_reg,
  pub __fpu_xmm14: __darwin_xmm_reg,
  pub __fpu_xmm15: __darwin_xmm_reg,
  pub __fpu_rsrv4: [libc::c_char; 96usize],
  pub __fpu_reserved1: libc::c_int,
  pub __avx_reserved1: [libc::c_char; 64usize],
  pub __fpu_ymmh0: __darwin_xmm_reg,
  pub __fpu_ymmh1: __darwin_xmm_reg,
  pub __fpu_ymmh2: __darwin_xmm_reg,
  pub __fpu_ymmh3: __darwin_xmm_reg,
  pub __fpu_ymmh4: __darwin_xmm_reg,
  pub __fpu_ymmh5: __darwin_xmm_reg,
  pub __fpu_ymmh6: __darwin_xmm_reg,
  pub __fpu_ymmh7: __darwin_xmm_reg,
  pub __fpu_ymmh8: __darwin_xmm_reg,
  pub __fpu_ymmh9: __darwin_xmm_reg,
  pub __fpu_ymmh10: __darwin_xmm_reg,
  pub __fpu_ymmh11: __darwin_xmm_reg,
  pub __fpu_ymmh12: __darwin_xmm_reg,
  pub __fpu_ymmh13: __darwin_xmm_reg,
  pub __fpu_ymmh14: __darwin_xmm_reg,
  pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_avx_state64>(),
    844usize,
    concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_avx_state64>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_fcw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_fsw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ftw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_rsrv1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_fop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_cs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_rsrv2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_dp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ds)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_rsrv3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_mxcsr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_mxcsrmask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_stmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
    },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
    },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
    },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
    },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
    },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
    },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
    },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
    },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
    },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
    },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
    },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_xmm15)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
    },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_rsrv4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _ as usize
    },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _ as usize
    },
    524usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__avx_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
    },
    588usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
    },
    604usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
    },
    620usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
    },
    636usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
    },
    652usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
    },
    668usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
    },
    684usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
    },
    700usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
    },
    716usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
    },
    732usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
    },
    748usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
    },
    764usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
    },
    780usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
    },
    796usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
    },
    812usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
    },
    828usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx_state64),
      "::",
      stringify!(__fpu_ymmh15)
    )
  );
}
impl Default for __darwin_x86_avx_state64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_x86_avx_state64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__darwin_x86_avx_state64 {{ __fpu_reserved: {:?}, __fpu_fcw: {:?}, __fpu_fsw: {:?}, __fpu_ftw: {:?}, __fpu_rsrv1: {:?}, __fpu_fop: {:?}, __fpu_ip: {:?}, __fpu_cs: {:?}, __fpu_rsrv2: {:?}, __fpu_dp: {:?}, __fpu_ds: {:?}, __fpu_rsrv3: {:?}, __fpu_mxcsr: {:?}, __fpu_mxcsrmask: {:?}, __fpu_stmm0: {:?}, __fpu_stmm1: {:?}, __fpu_stmm2: {:?}, __fpu_stmm3: {:?}, __fpu_stmm4: {:?}, __fpu_stmm5: {:?}, __fpu_stmm6: {:?}, __fpu_stmm7: {:?}, __fpu_xmm0: {:?}, __fpu_xmm1: {:?}, __fpu_xmm2: {:?}, __fpu_xmm3: {:?}, __fpu_xmm4: {:?}, __fpu_xmm5: {:?}, __fpu_xmm6: {:?}, __fpu_xmm7: {:?}, __fpu_xmm8: {:?}, __fpu_xmm9: {:?}, __fpu_xmm10: {:?}, __fpu_xmm11: {:?}, __fpu_xmm12: {:?}, __fpu_xmm13: {:?}, __fpu_xmm14: {:?}, __fpu_xmm15: {:?}, __fpu_rsrv4: [...], __fpu_reserved1: {:?}, __avx_reserved1: [...], __fpu_ymmh0: {:?}, __fpu_ymmh1: {:?}, __fpu_ymmh2: {:?}, __fpu_ymmh3: {:?}, __fpu_ymmh4: {:?}, __fpu_ymmh5: {:?}, __fpu_ymmh6: {:?}, __fpu_ymmh7: {:?}, __fpu_ymmh8: {:?}, __fpu_ymmh9: {:?}, __fpu_ymmh10: {:?}, __fpu_ymmh11: {:?}, __fpu_ymmh12: {:?}, __fpu_ymmh13: {:?}, __fpu_ymmh14: {:?}, __fpu_ymmh15: {:?} }}" , self . __fpu_reserved , self . __fpu_fcw , self . __fpu_fsw , self . __fpu_ftw , self . __fpu_rsrv1 , self . __fpu_fop , self . __fpu_ip , self . __fpu_cs , self . __fpu_rsrv2 , self . __fpu_dp , self . __fpu_ds , self . __fpu_rsrv3 , self . __fpu_mxcsr , self . __fpu_mxcsrmask , self . __fpu_stmm0 , self . __fpu_stmm1 , self . __fpu_stmm2 , self . __fpu_stmm3 , self . __fpu_stmm4 , self . __fpu_stmm5 , self . __fpu_stmm6 , self . __fpu_stmm7 , self . __fpu_xmm0 , self . __fpu_xmm1 , self . __fpu_xmm2 , self . __fpu_xmm3 , self . __fpu_xmm4 , self . __fpu_xmm5 , self . __fpu_xmm6 , self . __fpu_xmm7 , self . __fpu_xmm8 , self . __fpu_xmm9 , self . __fpu_xmm10 , self . __fpu_xmm11 , self . __fpu_xmm12 , self . __fpu_xmm13 , self . __fpu_xmm14 , self . __fpu_xmm15 , self . __fpu_reserved1 , self . __fpu_ymmh0 , self . __fpu_ymmh1 , self . __fpu_ymmh2 , self . __fpu_ymmh3 , self . __fpu_ymmh4 , self . __fpu_ymmh5 , self . __fpu_ymmh6 , self . __fpu_ymmh7 , self . __fpu_ymmh8 , self . __fpu_ymmh9 , self . __fpu_ymmh10 , self . __fpu_ymmh11 , self . __fpu_ymmh12 , self . __fpu_ymmh13 , self . __fpu_ymmh14 , self . __fpu_ymmh15 )
  }
}
impl ::core::cmp::PartialEq for __darwin_x86_avx_state64 {
  fn eq(&self, other: &__darwin_x86_avx_state64) -> bool {
    self.__fpu_reserved == other.__fpu_reserved
      && self.__fpu_fcw == other.__fpu_fcw
      && self.__fpu_fsw == other.__fpu_fsw
      && self.__fpu_ftw == other.__fpu_ftw
      && self.__fpu_rsrv1 == other.__fpu_rsrv1
      && self.__fpu_fop == other.__fpu_fop
      && self.__fpu_ip == other.__fpu_ip
      && self.__fpu_cs == other.__fpu_cs
      && self.__fpu_rsrv2 == other.__fpu_rsrv2
      && self.__fpu_dp == other.__fpu_dp
      && self.__fpu_ds == other.__fpu_ds
      && self.__fpu_rsrv3 == other.__fpu_rsrv3
      && self.__fpu_mxcsr == other.__fpu_mxcsr
      && self.__fpu_mxcsrmask == other.__fpu_mxcsrmask
      && self.__fpu_stmm0 == other.__fpu_stmm0
      && self.__fpu_stmm1 == other.__fpu_stmm1
      && self.__fpu_stmm2 == other.__fpu_stmm2
      && self.__fpu_stmm3 == other.__fpu_stmm3
      && self.__fpu_stmm4 == other.__fpu_stmm4
      && self.__fpu_stmm5 == other.__fpu_stmm5
      && self.__fpu_stmm6 == other.__fpu_stmm6
      && self.__fpu_stmm7 == other.__fpu_stmm7
      && self.__fpu_xmm0 == other.__fpu_xmm0
      && self.__fpu_xmm1 == other.__fpu_xmm1
      && self.__fpu_xmm2 == other.__fpu_xmm2
      && self.__fpu_xmm3 == other.__fpu_xmm3
      && self.__fpu_xmm4 == other.__fpu_xmm4
      && self.__fpu_xmm5 == other.__fpu_xmm5
      && self.__fpu_xmm6 == other.__fpu_xmm6
      && self.__fpu_xmm7 == other.__fpu_xmm7
      && self.__fpu_xmm8 == other.__fpu_xmm8
      && self.__fpu_xmm9 == other.__fpu_xmm9
      && self.__fpu_xmm10 == other.__fpu_xmm10
      && self.__fpu_xmm11 == other.__fpu_xmm11
      && self.__fpu_xmm12 == other.__fpu_xmm12
      && self.__fpu_xmm13 == other.__fpu_xmm13
      && self.__fpu_xmm14 == other.__fpu_xmm14
      && self.__fpu_xmm15 == other.__fpu_xmm15
      && &self.__fpu_rsrv4[..] == &other.__fpu_rsrv4[..]
      && self.__fpu_reserved1 == other.__fpu_reserved1
      && &self.__avx_reserved1[..] == &other.__avx_reserved1[..]
      && self.__fpu_ymmh0 == other.__fpu_ymmh0
      && self.__fpu_ymmh1 == other.__fpu_ymmh1
      && self.__fpu_ymmh2 == other.__fpu_ymmh2
      && self.__fpu_ymmh3 == other.__fpu_ymmh3
      && self.__fpu_ymmh4 == other.__fpu_ymmh4
      && self.__fpu_ymmh5 == other.__fpu_ymmh5
      && self.__fpu_ymmh6 == other.__fpu_ymmh6
      && self.__fpu_ymmh7 == other.__fpu_ymmh7
      && self.__fpu_ymmh8 == other.__fpu_ymmh8
      && self.__fpu_ymmh9 == other.__fpu_ymmh9
      && self.__fpu_ymmh10 == other.__fpu_ymmh10
      && self.__fpu_ymmh11 == other.__fpu_ymmh11
      && self.__fpu_ymmh12 == other.__fpu_ymmh12
      && self.__fpu_ymmh13 == other.__fpu_ymmh13
      && self.__fpu_ymmh14 == other.__fpu_ymmh14
      && self.__fpu_ymmh15 == other.__fpu_ymmh15
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
  pub __fpu_reserved: [libc::c_int; 2usize],
  pub __fpu_fcw: __darwin_fp_control,
  pub __fpu_fsw: __darwin_fp_status,
  pub __fpu_ftw: __uint8_t,
  pub __fpu_rsrv1: __uint8_t,
  pub __fpu_fop: __uint16_t,
  pub __fpu_ip: __uint32_t,
  pub __fpu_cs: __uint16_t,
  pub __fpu_rsrv2: __uint16_t,
  pub __fpu_dp: __uint32_t,
  pub __fpu_ds: __uint16_t,
  pub __fpu_rsrv3: __uint16_t,
  pub __fpu_mxcsr: __uint32_t,
  pub __fpu_mxcsrmask: __uint32_t,
  pub __fpu_stmm0: __darwin_mmst_reg,
  pub __fpu_stmm1: __darwin_mmst_reg,
  pub __fpu_stmm2: __darwin_mmst_reg,
  pub __fpu_stmm3: __darwin_mmst_reg,
  pub __fpu_stmm4: __darwin_mmst_reg,
  pub __fpu_stmm5: __darwin_mmst_reg,
  pub __fpu_stmm6: __darwin_mmst_reg,
  pub __fpu_stmm7: __darwin_mmst_reg,
  pub __fpu_xmm0: __darwin_xmm_reg,
  pub __fpu_xmm1: __darwin_xmm_reg,
  pub __fpu_xmm2: __darwin_xmm_reg,
  pub __fpu_xmm3: __darwin_xmm_reg,
  pub __fpu_xmm4: __darwin_xmm_reg,
  pub __fpu_xmm5: __darwin_xmm_reg,
  pub __fpu_xmm6: __darwin_xmm_reg,
  pub __fpu_xmm7: __darwin_xmm_reg,
  pub __fpu_xmm8: __darwin_xmm_reg,
  pub __fpu_xmm9: __darwin_xmm_reg,
  pub __fpu_xmm10: __darwin_xmm_reg,
  pub __fpu_xmm11: __darwin_xmm_reg,
  pub __fpu_xmm12: __darwin_xmm_reg,
  pub __fpu_xmm13: __darwin_xmm_reg,
  pub __fpu_xmm14: __darwin_xmm_reg,
  pub __fpu_xmm15: __darwin_xmm_reg,
  pub __fpu_rsrv4: [libc::c_char; 96usize],
  pub __fpu_reserved1: libc::c_int,
  pub __avx_reserved1: [libc::c_char; 64usize],
  pub __fpu_ymmh0: __darwin_xmm_reg,
  pub __fpu_ymmh1: __darwin_xmm_reg,
  pub __fpu_ymmh2: __darwin_xmm_reg,
  pub __fpu_ymmh3: __darwin_xmm_reg,
  pub __fpu_ymmh4: __darwin_xmm_reg,
  pub __fpu_ymmh5: __darwin_xmm_reg,
  pub __fpu_ymmh6: __darwin_xmm_reg,
  pub __fpu_ymmh7: __darwin_xmm_reg,
  pub __fpu_ymmh8: __darwin_xmm_reg,
  pub __fpu_ymmh9: __darwin_xmm_reg,
  pub __fpu_ymmh10: __darwin_xmm_reg,
  pub __fpu_ymmh11: __darwin_xmm_reg,
  pub __fpu_ymmh12: __darwin_xmm_reg,
  pub __fpu_ymmh13: __darwin_xmm_reg,
  pub __fpu_ymmh14: __darwin_xmm_reg,
  pub __fpu_ymmh15: __darwin_xmm_reg,
  pub __fpu_k0: __darwin_opmask_reg,
  pub __fpu_k1: __darwin_opmask_reg,
  pub __fpu_k2: __darwin_opmask_reg,
  pub __fpu_k3: __darwin_opmask_reg,
  pub __fpu_k4: __darwin_opmask_reg,
  pub __fpu_k5: __darwin_opmask_reg,
  pub __fpu_k6: __darwin_opmask_reg,
  pub __fpu_k7: __darwin_opmask_reg,
  pub __fpu_zmmh0: __darwin_ymm_reg,
  pub __fpu_zmmh1: __darwin_ymm_reg,
  pub __fpu_zmmh2: __darwin_ymm_reg,
  pub __fpu_zmmh3: __darwin_ymm_reg,
  pub __fpu_zmmh4: __darwin_ymm_reg,
  pub __fpu_zmmh5: __darwin_ymm_reg,
  pub __fpu_zmmh6: __darwin_ymm_reg,
  pub __fpu_zmmh7: __darwin_ymm_reg,
  pub __fpu_zmmh8: __darwin_ymm_reg,
  pub __fpu_zmmh9: __darwin_ymm_reg,
  pub __fpu_zmmh10: __darwin_ymm_reg,
  pub __fpu_zmmh11: __darwin_ymm_reg,
  pub __fpu_zmmh12: __darwin_ymm_reg,
  pub __fpu_zmmh13: __darwin_ymm_reg,
  pub __fpu_zmmh14: __darwin_ymm_reg,
  pub __fpu_zmmh15: __darwin_ymm_reg,
  pub __fpu_zmm16: __darwin_zmm_reg,
  pub __fpu_zmm17: __darwin_zmm_reg,
  pub __fpu_zmm18: __darwin_zmm_reg,
  pub __fpu_zmm19: __darwin_zmm_reg,
  pub __fpu_zmm20: __darwin_zmm_reg,
  pub __fpu_zmm21: __darwin_zmm_reg,
  pub __fpu_zmm22: __darwin_zmm_reg,
  pub __fpu_zmm23: __darwin_zmm_reg,
  pub __fpu_zmm24: __darwin_zmm_reg,
  pub __fpu_zmm25: __darwin_zmm_reg,
  pub __fpu_zmm26: __darwin_zmm_reg,
  pub __fpu_zmm27: __darwin_zmm_reg,
  pub __fpu_zmm28: __darwin_zmm_reg,
  pub __fpu_zmm29: __darwin_zmm_reg,
  pub __fpu_zmm30: __darwin_zmm_reg,
  pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_avx512_state64>(),
    2444usize,
    concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_avx512_state64>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_fcw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_fsw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ftw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_rsrv1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_fop)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ip)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_cs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_rsrv2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_dp)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ds)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_rsrv3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_mxcsr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_mxcsrmask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_stmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
    },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
    },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
    },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
    },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
    },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
    },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
    },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
    },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
    },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
    },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
    },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_xmm15)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
    },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_rsrv4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _ as usize
    },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _ as usize
    },
    524usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__avx_reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
    },
    588usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
    },
    604usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
    },
    620usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
    },
    636usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
    },
    652usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
    },
    668usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
    },
    684usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
    },
    700usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
    },
    716usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
    },
    732usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _ as usize
    },
    748usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _ as usize
    },
    764usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _ as usize
    },
    780usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _ as usize
    },
    796usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _ as usize
    },
    812usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _ as usize
    },
    828usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_ymmh15)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
    },
    844usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
    },
    852usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
    },
    860usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
    },
    868usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
    },
    876usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
    },
    884usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
    },
    892usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
    },
    900usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_k7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
    },
    908usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
    },
    940usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
    },
    972usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
    },
    1004usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
    },
    1036usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
    },
    1068usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
    },
    1100usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
    },
    1132usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
    },
    1164usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
    },
    1196usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _ as usize
    },
    1228usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _ as usize
    },
    1260usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _ as usize
    },
    1292usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _ as usize
    },
    1324usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _ as usize
    },
    1356usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _ as usize
    },
    1388usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmmh15)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
    },
    1420usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm16)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
    },
    1484usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm17)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
    },
    1548usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm18)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
    },
    1612usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm19)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
    },
    1676usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm20)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
    },
    1740usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm21)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
    },
    1804usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm22)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
    },
    1868usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm23)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
    },
    1932usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm24)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
    },
    1996usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm25)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
    },
    2060usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm26)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
    },
    2124usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm27)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
    },
    2188usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm28)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
    },
    2252usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm29)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
    },
    2316usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm30)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
    },
    2380usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_avx512_state64),
      "::",
      stringify!(__fpu_zmm31)
    )
  );
}
impl Default for __darwin_x86_avx512_state64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_x86_avx512_state64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__darwin_x86_avx512_state64 {{ __fpu_reserved: {:?}, __fpu_fcw: {:?}, __fpu_fsw: {:?}, __fpu_ftw: {:?}, __fpu_rsrv1: {:?}, __fpu_fop: {:?}, __fpu_ip: {:?}, __fpu_cs: {:?}, __fpu_rsrv2: {:?}, __fpu_dp: {:?}, __fpu_ds: {:?}, __fpu_rsrv3: {:?}, __fpu_mxcsr: {:?}, __fpu_mxcsrmask: {:?}, __fpu_stmm0: {:?}, __fpu_stmm1: {:?}, __fpu_stmm2: {:?}, __fpu_stmm3: {:?}, __fpu_stmm4: {:?}, __fpu_stmm5: {:?}, __fpu_stmm6: {:?}, __fpu_stmm7: {:?}, __fpu_xmm0: {:?}, __fpu_xmm1: {:?}, __fpu_xmm2: {:?}, __fpu_xmm3: {:?}, __fpu_xmm4: {:?}, __fpu_xmm5: {:?}, __fpu_xmm6: {:?}, __fpu_xmm7: {:?}, __fpu_xmm8: {:?}, __fpu_xmm9: {:?}, __fpu_xmm10: {:?}, __fpu_xmm11: {:?}, __fpu_xmm12: {:?}, __fpu_xmm13: {:?}, __fpu_xmm14: {:?}, __fpu_xmm15: {:?}, __fpu_rsrv4: [...], __fpu_reserved1: {:?}, __avx_reserved1: [...], __fpu_ymmh0: {:?}, __fpu_ymmh1: {:?}, __fpu_ymmh2: {:?}, __fpu_ymmh3: {:?}, __fpu_ymmh4: {:?}, __fpu_ymmh5: {:?}, __fpu_ymmh6: {:?}, __fpu_ymmh7: {:?}, __fpu_ymmh8: {:?}, __fpu_ymmh9: {:?}, __fpu_ymmh10: {:?}, __fpu_ymmh11: {:?}, __fpu_ymmh12: {:?}, __fpu_ymmh13: {:?}, __fpu_ymmh14: {:?}, __fpu_ymmh15: {:?}, __fpu_k0: {:?}, __fpu_k1: {:?}, __fpu_k2: {:?}, __fpu_k3: {:?}, __fpu_k4: {:?}, __fpu_k5: {:?}, __fpu_k6: {:?}, __fpu_k7: {:?}, __fpu_zmmh0: {:?}, __fpu_zmmh1: {:?}, __fpu_zmmh2: {:?}, __fpu_zmmh3: {:?}, __fpu_zmmh4: {:?}, __fpu_zmmh5: {:?}, __fpu_zmmh6: {:?}, __fpu_zmmh7: {:?}, __fpu_zmmh8: {:?}, __fpu_zmmh9: {:?}, __fpu_zmmh10: {:?}, __fpu_zmmh11: {:?}, __fpu_zmmh12: {:?}, __fpu_zmmh13: {:?}, __fpu_zmmh14: {:?}, __fpu_zmmh15: {:?}, __fpu_zmm16: {:?}, __fpu_zmm17: {:?}, __fpu_zmm18: {:?}, __fpu_zmm19: {:?}, __fpu_zmm20: {:?}, __fpu_zmm21: {:?}, __fpu_zmm22: {:?}, __fpu_zmm23: {:?}, __fpu_zmm24: {:?}, __fpu_zmm25: {:?}, __fpu_zmm26: {:?}, __fpu_zmm27: {:?}, __fpu_zmm28: {:?}, __fpu_zmm29: {:?}, __fpu_zmm30: {:?}, __fpu_zmm31: {:?} }}" , self . __fpu_reserved , self . __fpu_fcw , self . __fpu_fsw , self . __fpu_ftw , self . __fpu_rsrv1 , self . __fpu_fop , self . __fpu_ip , self . __fpu_cs , self . __fpu_rsrv2 , self . __fpu_dp , self . __fpu_ds , self . __fpu_rsrv3 , self . __fpu_mxcsr , self . __fpu_mxcsrmask , self . __fpu_stmm0 , self . __fpu_stmm1 , self . __fpu_stmm2 , self . __fpu_stmm3 , self . __fpu_stmm4 , self . __fpu_stmm5 , self . __fpu_stmm6 , self . __fpu_stmm7 , self . __fpu_xmm0 , self . __fpu_xmm1 , self . __fpu_xmm2 , self . __fpu_xmm3 , self . __fpu_xmm4 , self . __fpu_xmm5 , self . __fpu_xmm6 , self . __fpu_xmm7 , self . __fpu_xmm8 , self . __fpu_xmm9 , self . __fpu_xmm10 , self . __fpu_xmm11 , self . __fpu_xmm12 , self . __fpu_xmm13 , self . __fpu_xmm14 , self . __fpu_xmm15 , self . __fpu_reserved1 , self . __fpu_ymmh0 , self . __fpu_ymmh1 , self . __fpu_ymmh2 , self . __fpu_ymmh3 , self . __fpu_ymmh4 , self . __fpu_ymmh5 , self . __fpu_ymmh6 , self . __fpu_ymmh7 , self . __fpu_ymmh8 , self . __fpu_ymmh9 , self . __fpu_ymmh10 , self . __fpu_ymmh11 , self . __fpu_ymmh12 , self . __fpu_ymmh13 , self . __fpu_ymmh14 , self . __fpu_ymmh15 , self . __fpu_k0 , self . __fpu_k1 , self . __fpu_k2 , self . __fpu_k3 , self . __fpu_k4 , self . __fpu_k5 , self . __fpu_k6 , self . __fpu_k7 , self . __fpu_zmmh0 , self . __fpu_zmmh1 , self . __fpu_zmmh2 , self . __fpu_zmmh3 , self . __fpu_zmmh4 , self . __fpu_zmmh5 , self . __fpu_zmmh6 , self . __fpu_zmmh7 , self . __fpu_zmmh8 , self . __fpu_zmmh9 , self . __fpu_zmmh10 , self . __fpu_zmmh11 , self . __fpu_zmmh12 , self . __fpu_zmmh13 , self . __fpu_zmmh14 , self . __fpu_zmmh15 , self . __fpu_zmm16 , self . __fpu_zmm17 , self . __fpu_zmm18 , self . __fpu_zmm19 , self . __fpu_zmm20 , self . __fpu_zmm21 , self . __fpu_zmm22 , self . __fpu_zmm23 , self . __fpu_zmm24 , self . __fpu_zmm25 , self . __fpu_zmm26 , self . __fpu_zmm27 , self . __fpu_zmm28 , self . __fpu_zmm29 , self . __fpu_zmm30 , self . __fpu_zmm31 )
  }
}
impl ::core::cmp::PartialEq for __darwin_x86_avx512_state64 {
  fn eq(&self, other: &__darwin_x86_avx512_state64) -> bool {
    self.__fpu_reserved == other.__fpu_reserved
      && self.__fpu_fcw == other.__fpu_fcw
      && self.__fpu_fsw == other.__fpu_fsw
      && self.__fpu_ftw == other.__fpu_ftw
      && self.__fpu_rsrv1 == other.__fpu_rsrv1
      && self.__fpu_fop == other.__fpu_fop
      && self.__fpu_ip == other.__fpu_ip
      && self.__fpu_cs == other.__fpu_cs
      && self.__fpu_rsrv2 == other.__fpu_rsrv2
      && self.__fpu_dp == other.__fpu_dp
      && self.__fpu_ds == other.__fpu_ds
      && self.__fpu_rsrv3 == other.__fpu_rsrv3
      && self.__fpu_mxcsr == other.__fpu_mxcsr
      && self.__fpu_mxcsrmask == other.__fpu_mxcsrmask
      && self.__fpu_stmm0 == other.__fpu_stmm0
      && self.__fpu_stmm1 == other.__fpu_stmm1
      && self.__fpu_stmm2 == other.__fpu_stmm2
      && self.__fpu_stmm3 == other.__fpu_stmm3
      && self.__fpu_stmm4 == other.__fpu_stmm4
      && self.__fpu_stmm5 == other.__fpu_stmm5
      && self.__fpu_stmm6 == other.__fpu_stmm6
      && self.__fpu_stmm7 == other.__fpu_stmm7
      && self.__fpu_xmm0 == other.__fpu_xmm0
      && self.__fpu_xmm1 == other.__fpu_xmm1
      && self.__fpu_xmm2 == other.__fpu_xmm2
      && self.__fpu_xmm3 == other.__fpu_xmm3
      && self.__fpu_xmm4 == other.__fpu_xmm4
      && self.__fpu_xmm5 == other.__fpu_xmm5
      && self.__fpu_xmm6 == other.__fpu_xmm6
      && self.__fpu_xmm7 == other.__fpu_xmm7
      && self.__fpu_xmm8 == other.__fpu_xmm8
      && self.__fpu_xmm9 == other.__fpu_xmm9
      && self.__fpu_xmm10 == other.__fpu_xmm10
      && self.__fpu_xmm11 == other.__fpu_xmm11
      && self.__fpu_xmm12 == other.__fpu_xmm12
      && self.__fpu_xmm13 == other.__fpu_xmm13
      && self.__fpu_xmm14 == other.__fpu_xmm14
      && self.__fpu_xmm15 == other.__fpu_xmm15
      && &self.__fpu_rsrv4[..] == &other.__fpu_rsrv4[..]
      && self.__fpu_reserved1 == other.__fpu_reserved1
      && &self.__avx_reserved1[..] == &other.__avx_reserved1[..]
      && self.__fpu_ymmh0 == other.__fpu_ymmh0
      && self.__fpu_ymmh1 == other.__fpu_ymmh1
      && self.__fpu_ymmh2 == other.__fpu_ymmh2
      && self.__fpu_ymmh3 == other.__fpu_ymmh3
      && self.__fpu_ymmh4 == other.__fpu_ymmh4
      && self.__fpu_ymmh5 == other.__fpu_ymmh5
      && self.__fpu_ymmh6 == other.__fpu_ymmh6
      && self.__fpu_ymmh7 == other.__fpu_ymmh7
      && self.__fpu_ymmh8 == other.__fpu_ymmh8
      && self.__fpu_ymmh9 == other.__fpu_ymmh9
      && self.__fpu_ymmh10 == other.__fpu_ymmh10
      && self.__fpu_ymmh11 == other.__fpu_ymmh11
      && self.__fpu_ymmh12 == other.__fpu_ymmh12
      && self.__fpu_ymmh13 == other.__fpu_ymmh13
      && self.__fpu_ymmh14 == other.__fpu_ymmh14
      && self.__fpu_ymmh15 == other.__fpu_ymmh15
      && self.__fpu_k0 == other.__fpu_k0
      && self.__fpu_k1 == other.__fpu_k1
      && self.__fpu_k2 == other.__fpu_k2
      && self.__fpu_k3 == other.__fpu_k3
      && self.__fpu_k4 == other.__fpu_k4
      && self.__fpu_k5 == other.__fpu_k5
      && self.__fpu_k6 == other.__fpu_k6
      && self.__fpu_k7 == other.__fpu_k7
      && self.__fpu_zmmh0 == other.__fpu_zmmh0
      && self.__fpu_zmmh1 == other.__fpu_zmmh1
      && self.__fpu_zmmh2 == other.__fpu_zmmh2
      && self.__fpu_zmmh3 == other.__fpu_zmmh3
      && self.__fpu_zmmh4 == other.__fpu_zmmh4
      && self.__fpu_zmmh5 == other.__fpu_zmmh5
      && self.__fpu_zmmh6 == other.__fpu_zmmh6
      && self.__fpu_zmmh7 == other.__fpu_zmmh7
      && self.__fpu_zmmh8 == other.__fpu_zmmh8
      && self.__fpu_zmmh9 == other.__fpu_zmmh9
      && self.__fpu_zmmh10 == other.__fpu_zmmh10
      && self.__fpu_zmmh11 == other.__fpu_zmmh11
      && self.__fpu_zmmh12 == other.__fpu_zmmh12
      && self.__fpu_zmmh13 == other.__fpu_zmmh13
      && self.__fpu_zmmh14 == other.__fpu_zmmh14
      && self.__fpu_zmmh15 == other.__fpu_zmmh15
      && self.__fpu_zmm16 == other.__fpu_zmm16
      && self.__fpu_zmm17 == other.__fpu_zmm17
      && self.__fpu_zmm18 == other.__fpu_zmm18
      && self.__fpu_zmm19 == other.__fpu_zmm19
      && self.__fpu_zmm20 == other.__fpu_zmm20
      && self.__fpu_zmm21 == other.__fpu_zmm21
      && self.__fpu_zmm22 == other.__fpu_zmm22
      && self.__fpu_zmm23 == other.__fpu_zmm23
      && self.__fpu_zmm24 == other.__fpu_zmm24
      && self.__fpu_zmm25 == other.__fpu_zmm25
      && self.__fpu_zmm26 == other.__fpu_zmm26
      && self.__fpu_zmm27 == other.__fpu_zmm27
      && self.__fpu_zmm28 == other.__fpu_zmm28
      && self.__fpu_zmm29 == other.__fpu_zmm29
      && self.__fpu_zmm30 == other.__fpu_zmm30
      && self.__fpu_zmm31 == other.__fpu_zmm31
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_x86_exception_state64 {
  pub __trapno: __uint16_t,
  pub __cpu: __uint16_t,
  pub __err: __uint32_t,
  pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_exception_state64>(),
    16usize,
    concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_exception_state64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_exception_state64),
      "::",
      stringify!(__trapno)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_exception_state64),
      "::",
      stringify!(__cpu)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_exception_state64),
      "::",
      stringify!(__err)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_exception_state64),
      "::",
      stringify!(__faultvaddr)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_x86_debug_state64 {
  pub __dr0: __uint64_t,
  pub __dr1: __uint64_t,
  pub __dr2: __uint64_t,
  pub __dr3: __uint64_t,
  pub __dr4: __uint64_t,
  pub __dr5: __uint64_t,
  pub __dr6: __uint64_t,
  pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_debug_state64>(),
    64usize,
    concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_debug_state64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr4)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr5)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr6)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_debug_state64),
      "::",
      stringify!(__dr7)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __darwin_x86_cpmu_state64 {
  pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_x86_cpmu_state64>(),
    128usize,
    concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_x86_cpmu_state64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_x86_cpmu_state64),
      "::",
      stringify!(__ctrs)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
  pub __es: __darwin_i386_exception_state,
  pub __ss: __darwin_i386_thread_state,
  pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mcontext32>(),
    600usize,
    concat!("Size of: ", stringify!(__darwin_mcontext32))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mcontext32>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_mcontext32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext32),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext32),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext32),
      "::",
      stringify!(__fs)
    )
  );
}
impl Default for __darwin_mcontext32 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_mcontext32 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__darwin_mcontext32 {{ __es: {:?}, __ss: {:?}, __fs: {:?} }}",
      self.__es, self.__ss, self.__fs
    )
  }
}
impl ::core::cmp::PartialEq for __darwin_mcontext32 {
  fn eq(&self, other: &__darwin_mcontext32) -> bool {
    self.__es == other.__es && self.__ss == other.__ss && self.__fs == other.__fs
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
  pub __es: __darwin_i386_exception_state,
  pub __ss: __darwin_i386_thread_state,
  pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mcontext_avx32>(),
    792usize,
    concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mcontext_avx32>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx32),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx32),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx32),
      "::",
      stringify!(__fs)
    )
  );
}
impl Default for __darwin_mcontext_avx32 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_mcontext_avx32 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__darwin_mcontext_avx32 {{ __es: {:?}, __ss: {:?}, __fs: {:?} }}",
      self.__es, self.__ss, self.__fs
    )
  }
}
impl ::core::cmp::PartialEq for __darwin_mcontext_avx32 {
  fn eq(&self, other: &__darwin_mcontext_avx32) -> bool {
    self.__es == other.__es && self.__ss == other.__ss && self.__fs == other.__fs
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
  pub __es: __darwin_i386_exception_state,
  pub __ss: __darwin_i386_thread_state,
  pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mcontext_avx512_32>(),
    1112usize,
    concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mcontext_avx512_32>(),
    4usize,
    concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx512_32),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx512_32),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx512_32),
      "::",
      stringify!(__fs)
    )
  );
}
impl Default for __darwin_mcontext_avx512_32 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_mcontext_avx512_32 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__darwin_mcontext_avx512_32 {{ __es: {:?}, __ss: {:?}, __fs: {:?} }}",
      self.__es, self.__ss, self.__fs
    )
  }
}
impl ::core::cmp::PartialEq for __darwin_mcontext_avx512_32 {
  fn eq(&self, other: &__darwin_mcontext_avx512_32) -> bool {
    self.__es == other.__es && self.__ss == other.__ss && self.__fs == other.__fs
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
  pub __es: __darwin_x86_exception_state64,
  pub __ss: __darwin_x86_thread_state64,
  pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mcontext64>(),
    712usize,
    concat!("Size of: ", stringify!(__darwin_mcontext64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mcontext64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_mcontext64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext64),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext64),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext64),
      "::",
      stringify!(__fs)
    )
  );
}
impl Default for __darwin_mcontext64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_mcontext64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__darwin_mcontext64 {{ __es: {:?}, __ss: {:?}, __fs: {:?} }}",
      self.__es, self.__ss, self.__fs
    )
  }
}
impl ::core::cmp::PartialEq for __darwin_mcontext64 {
  fn eq(&self, other: &__darwin_mcontext64) -> bool {
    self.__es == other.__es && self.__ss == other.__ss && self.__fs == other.__fs
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
  pub __es: __darwin_x86_exception_state64,
  pub __ss: __darwin_x86_thread_state64,
  pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mcontext_avx64>(),
    1032usize,
    concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mcontext_avx64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx64),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx64),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx64),
      "::",
      stringify!(__fs)
    )
  );
}
impl Default for __darwin_mcontext_avx64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_mcontext_avx64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__darwin_mcontext_avx64 {{ __es: {:?}, __ss: {:?}, __fs: {:?} }}",
      self.__es, self.__ss, self.__fs
    )
  }
}
impl ::core::cmp::PartialEq for __darwin_mcontext_avx64 {
  fn eq(&self, other: &__darwin_mcontext_avx64) -> bool {
    self.__es == other.__es && self.__ss == other.__ss && self.__fs == other.__fs
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
  pub __es: __darwin_x86_exception_state64,
  pub __ss: __darwin_x86_thread_state64,
  pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_mcontext_avx512_64>(),
    2632usize,
    concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_mcontext_avx512_64>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx512_64),
      "::",
      stringify!(__es)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx512_64),
      "::",
      stringify!(__ss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_mcontext_avx512_64),
      "::",
      stringify!(__fs)
    )
  );
}
impl Default for __darwin_mcontext_avx512_64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __darwin_mcontext_avx512_64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__darwin_mcontext_avx512_64 {{ __es: {:?}, __ss: {:?}, __fs: {:?} }}",
      self.__es, self.__ss, self.__fs
    )
  }
}
impl ::core::cmp::PartialEq for __darwin_mcontext_avx512_64 {
  fn eq(&self, other: &__darwin_mcontext_avx512_64) -> bool {
    self.__es == other.__es && self.__ss == other.__ss && self.__fs == other.__fs
  }
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __darwin_sigaltstack {
  pub ss_sp: *mut libc::c_void,
  pub ss_size: __darwin_size_t,
  pub ss_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_sigaltstack>(),
    24usize,
    concat!("Size of: ", stringify!(__darwin_sigaltstack))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_sigaltstack>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_sigaltstack))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_sigaltstack),
      "::",
      stringify!(ss_sp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_sigaltstack),
      "::",
      stringify!(ss_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_sigaltstack),
      "::",
      stringify!(ss_flags)
    )
  );
}
impl Default for __darwin_sigaltstack {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __darwin_ucontext {
  pub uc_onstack: libc::c_int,
  pub uc_sigmask: __darwin_sigset_t,
  pub uc_stack: __darwin_sigaltstack,
  pub uc_link: *mut __darwin_ucontext,
  pub uc_mcsize: __darwin_size_t,
  pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
  assert_eq!(
    ::core::mem::size_of::<__darwin_ucontext>(),
    56usize,
    concat!("Size of: ", stringify!(__darwin_ucontext))
  );
  assert_eq!(
    ::core::mem::align_of::<__darwin_ucontext>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_ucontext))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ucontext),
      "::",
      stringify!(uc_onstack)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ucontext),
      "::",
      stringify!(uc_sigmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ucontext),
      "::",
      stringify!(uc_stack)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ucontext),
      "::",
      stringify!(uc_link)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ucontext),
      "::",
      stringify!(uc_mcsize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_ucontext),
      "::",
      stringify!(uc_mcontext)
    )
  );
}
impl Default for __darwin_ucontext {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
  pub sival_int: libc::c_int,
  pub sival_ptr: *mut libc::c_void,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
  assert_eq!(
    ::core::mem::size_of::<sigval>(),
    8usize,
    concat!("Size of: ", stringify!(sigval))
  );
  assert_eq!(
    ::core::mem::align_of::<sigval>(),
    8usize,
    concat!("Alignment of ", stringify!(sigval))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sigval),
      "::",
      stringify!(sival_int)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sigval),
      "::",
      stringify!(sival_ptr)
    )
  );
}
impl Default for sigval {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for sigval {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "sigval {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
  pub sigev_notify: libc::c_int,
  pub sigev_signo: libc::c_int,
  pub sigev_value: sigval,
  pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
  pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
  assert_eq!(
    ::core::mem::size_of::<sigevent>(),
    32usize,
    concat!("Size of: ", stringify!(sigevent))
  );
  assert_eq!(
    ::core::mem::align_of::<sigevent>(),
    8usize,
    concat!("Alignment of ", stringify!(sigevent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sigevent),
      "::",
      stringify!(sigev_notify)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(sigevent),
      "::",
      stringify!(sigev_signo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sigevent),
      "::",
      stringify!(sigev_value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(sigevent),
      "::",
      stringify!(sigev_notify_function)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(sigevent),
      "::",
      stringify!(sigev_notify_attributes)
    )
  );
}
impl Default for sigevent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for sigevent {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "sigevent {{ sigev_notify: {:?}, sigev_signo: {:?}, sigev_value: {:?}, sigev_notify_function: {:?}, sigev_notify_attributes: {:?} }}" , self . sigev_notify , self . sigev_signo , self . sigev_value , self . sigev_notify_function , self . sigev_notify_attributes )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
  pub si_signo: libc::c_int,
  pub si_errno: libc::c_int,
  pub si_code: libc::c_int,
  pub si_pid: pid_t,
  pub si_uid: uid_t,
  pub si_status: libc::c_int,
  pub si_addr: *mut libc::c_void,
  pub si_value: sigval,
  pub si_band: libc::c_long,
  pub __pad: [libc::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
  assert_eq!(
    ::core::mem::size_of::<__siginfo>(),
    104usize,
    concat!("Size of: ", stringify!(__siginfo))
  );
  assert_eq!(
    ::core::mem::align_of::<__siginfo>(),
    8usize,
    concat!("Alignment of ", stringify!(__siginfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_signo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_errno)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_code as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_pid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_uid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_status as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_status)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_addr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_value as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).si_band as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(si_band)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__siginfo>())).__pad as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__siginfo),
      "::",
      stringify!(__pad)
    )
  );
}
impl Default for __siginfo {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __siginfo {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "__siginfo {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, si_band: {:?}, __pad: {:?} }}" , self . si_signo , self . si_errno , self . si_code , self . si_pid , self . si_uid , self . si_status , self . si_addr , self . si_value , self . si_band , self . __pad )
  }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
  pub __sa_handler: ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
  pub __sa_sigaction: ::core::option::Option<
    unsafe extern "C" fn(arg1: libc::c_int, arg2: *mut __siginfo, arg3: *mut libc::c_void),
  >,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
  assert_eq!(
    ::core::mem::size_of::<__sigaction_u>(),
    8usize,
    concat!("Size of: ", stringify!(__sigaction_u))
  );
  assert_eq!(
    ::core::mem::align_of::<__sigaction_u>(),
    8usize,
    concat!("Alignment of ", stringify!(__sigaction_u))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigaction_u),
      "::",
      stringify!(__sa_handler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigaction_u),
      "::",
      stringify!(__sa_sigaction)
    )
  );
}
impl Default for __sigaction_u {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __sigaction_u {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "__sigaction_u {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
  pub __sigaction_u: __sigaction_u,
  pub sa_tramp: ::core::option::Option<
    unsafe extern "C" fn(
      arg1: *mut libc::c_void,
      arg2: libc::c_int,
      arg3: libc::c_int,
      arg4: *mut siginfo_t,
      arg5: *mut libc::c_void,
    ),
  >,
  pub sa_mask: sigset_t,
  pub sa_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
  assert_eq!(
    ::core::mem::size_of::<__sigaction>(),
    24usize,
    concat!("Size of: ", stringify!(__sigaction))
  );
  assert_eq!(
    ::core::mem::align_of::<__sigaction>(),
    8usize,
    concat!("Alignment of ", stringify!(__sigaction))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigaction),
      "::",
      stringify!(__sigaction_u)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigaction),
      "::",
      stringify!(sa_tramp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigaction),
      "::",
      stringify!(sa_mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigaction),
      "::",
      stringify!(sa_flags)
    )
  );
}
impl Default for __sigaction {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for __sigaction {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "__sigaction {{ __sigaction_u: {:?}, sa_tramp: {:?}, sa_mask: {:?}, sa_flags: {:?} }}",
      self.__sigaction_u, self.sa_tramp, self.sa_mask, self.sa_flags
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
  pub __sigaction_u: __sigaction_u,
  pub sa_mask: sigset_t,
  pub sa_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
  assert_eq!(
    ::core::mem::size_of::<sigaction>(),
    16usize,
    concat!("Size of: ", stringify!(sigaction))
  );
  assert_eq!(
    ::core::mem::align_of::<sigaction>(),
    8usize,
    concat!("Alignment of ", stringify!(sigaction))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sigaction),
      "::",
      stringify!(__sigaction_u)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sigaction),
      "::",
      stringify!(sa_mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(sigaction),
      "::",
      stringify!(sa_flags)
    )
  );
}
impl Default for sigaction {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for sigaction {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "sigaction {{ __sigaction_u: {:?}, sa_mask: {:?}, sa_flags: {:?} }}",
      self.__sigaction_u, self.sa_mask, self.sa_flags
    )
  }
}
pub type sig_t = ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sigvec {
  pub sv_handler: ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
  pub sv_mask: libc::c_int,
  pub sv_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
  assert_eq!(
    ::core::mem::size_of::<sigvec>(),
    16usize,
    concat!("Size of: ", stringify!(sigvec))
  );
  assert_eq!(
    ::core::mem::align_of::<sigvec>(),
    8usize,
    concat!("Alignment of ", stringify!(sigvec))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sigvec),
      "::",
      stringify!(sv_handler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sigvec),
      "::",
      stringify!(sv_mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(sigvec),
      "::",
      stringify!(sv_flags)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sigstack {
  pub ss_sp: *mut libc::c_char,
  pub ss_onstack: libc::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
  assert_eq!(
    ::core::mem::size_of::<sigstack>(),
    16usize,
    concat!("Size of: ", stringify!(sigstack))
  );
  assert_eq!(
    ::core::mem::align_of::<sigstack>(),
    8usize,
    concat!("Alignment of ", stringify!(sigstack))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sigstack),
      "::",
      stringify!(ss_sp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sigstack),
      "::",
      stringify!(ss_onstack)
    )
  );
}
impl Default for sigstack {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[link_name = "\u{1}_signal"]
  pub fn signal(
    arg1: libc::c_int,
    arg2: ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
  ) -> ::core::option::Option<
    unsafe extern "C" fn(
      arg1: libc::c_int,
      arg2: ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
    ),
  >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct timeval {
  pub tv_sec: __darwin_time_t,
  pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
  assert_eq!(
    ::core::mem::size_of::<timeval>(),
    16usize,
    concat!("Size of: ", stringify!(timeval))
  );
  assert_eq!(
    ::core::mem::align_of::<timeval>(),
    8usize,
    concat!("Alignment of ", stringify!(timeval))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(timeval),
      "::",
      stringify!(tv_sec)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(timeval),
      "::",
      stringify!(tv_usec)
    )
  );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rusage {
  pub ru_utime: timeval,
  pub ru_stime: timeval,
  pub ru_maxrss: libc::c_long,
  pub ru_ixrss: libc::c_long,
  pub ru_idrss: libc::c_long,
  pub ru_isrss: libc::c_long,
  pub ru_minflt: libc::c_long,
  pub ru_majflt: libc::c_long,
  pub ru_nswap: libc::c_long,
  pub ru_inblock: libc::c_long,
  pub ru_oublock: libc::c_long,
  pub ru_msgsnd: libc::c_long,
  pub ru_msgrcv: libc::c_long,
  pub ru_nsignals: libc::c_long,
  pub ru_nvcsw: libc::c_long,
  pub ru_nivcsw: libc::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
  assert_eq!(
    ::core::mem::size_of::<rusage>(),
    144usize,
    concat!("Size of: ", stringify!(rusage))
  );
  assert_eq!(
    ::core::mem::align_of::<rusage>(),
    8usize,
    concat!("Alignment of ", stringify!(rusage))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_utime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_utime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_stime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_stime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_maxrss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_ixrss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_idrss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_isrss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_minflt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_majflt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_nswap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_inblock)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_oublock)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_msgsnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_msgrcv)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_nsignals)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_nvcsw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage),
      "::",
      stringify!(ru_nivcsw)
    )
  );
}
pub type rusage_info_t = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rusage_info_v0 {
  pub ri_uuid: [u8; 16usize],
  pub ri_user_time: u64,
  pub ri_system_time: u64,
  pub ri_pkg_idle_wkups: u64,
  pub ri_interrupt_wkups: u64,
  pub ri_pageins: u64,
  pub ri_wired_size: u64,
  pub ri_resident_size: u64,
  pub ri_phys_footprint: u64,
  pub ri_proc_start_abstime: u64,
  pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
  assert_eq!(
    ::core::mem::size_of::<rusage_info_v0>(),
    96usize,
    concat!("Size of: ", stringify!(rusage_info_v0))
  );
  assert_eq!(
    ::core::mem::align_of::<rusage_info_v0>(),
    8usize,
    concat!("Alignment of ", stringify!(rusage_info_v0))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_uuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_user_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_system_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_pageins)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_wired_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_resident_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_phys_footprint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_proc_start_abstime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v0),
      "::",
      stringify!(ri_proc_exit_abstime)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rusage_info_v1 {
  pub ri_uuid: [u8; 16usize],
  pub ri_user_time: u64,
  pub ri_system_time: u64,
  pub ri_pkg_idle_wkups: u64,
  pub ri_interrupt_wkups: u64,
  pub ri_pageins: u64,
  pub ri_wired_size: u64,
  pub ri_resident_size: u64,
  pub ri_phys_footprint: u64,
  pub ri_proc_start_abstime: u64,
  pub ri_proc_exit_abstime: u64,
  pub ri_child_user_time: u64,
  pub ri_child_system_time: u64,
  pub ri_child_pkg_idle_wkups: u64,
  pub ri_child_interrupt_wkups: u64,
  pub ri_child_pageins: u64,
  pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
  assert_eq!(
    ::core::mem::size_of::<rusage_info_v1>(),
    144usize,
    concat!("Size of: ", stringify!(rusage_info_v1))
  );
  assert_eq!(
    ::core::mem::align_of::<rusage_info_v1>(),
    8usize,
    concat!("Alignment of ", stringify!(rusage_info_v1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_uuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_user_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_system_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_pageins)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_wired_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_resident_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_phys_footprint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_proc_start_abstime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_proc_exit_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_child_user_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_child_system_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_child_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_child_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_child_pageins)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v1),
      "::",
      stringify!(ri_child_elapsed_abstime)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rusage_info_v2 {
  pub ri_uuid: [u8; 16usize],
  pub ri_user_time: u64,
  pub ri_system_time: u64,
  pub ri_pkg_idle_wkups: u64,
  pub ri_interrupt_wkups: u64,
  pub ri_pageins: u64,
  pub ri_wired_size: u64,
  pub ri_resident_size: u64,
  pub ri_phys_footprint: u64,
  pub ri_proc_start_abstime: u64,
  pub ri_proc_exit_abstime: u64,
  pub ri_child_user_time: u64,
  pub ri_child_system_time: u64,
  pub ri_child_pkg_idle_wkups: u64,
  pub ri_child_interrupt_wkups: u64,
  pub ri_child_pageins: u64,
  pub ri_child_elapsed_abstime: u64,
  pub ri_diskio_bytesread: u64,
  pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
  assert_eq!(
    ::core::mem::size_of::<rusage_info_v2>(),
    160usize,
    concat!("Size of: ", stringify!(rusage_info_v2))
  );
  assert_eq!(
    ::core::mem::align_of::<rusage_info_v2>(),
    8usize,
    concat!("Alignment of ", stringify!(rusage_info_v2))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_uuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_user_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_system_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_pageins)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_wired_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_resident_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_phys_footprint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_proc_start_abstime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_proc_exit_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_child_user_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_child_system_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_child_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_child_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_child_pageins)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_child_elapsed_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_diskio_bytesread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v2),
      "::",
      stringify!(ri_diskio_byteswritten)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rusage_info_v3 {
  pub ri_uuid: [u8; 16usize],
  pub ri_user_time: u64,
  pub ri_system_time: u64,
  pub ri_pkg_idle_wkups: u64,
  pub ri_interrupt_wkups: u64,
  pub ri_pageins: u64,
  pub ri_wired_size: u64,
  pub ri_resident_size: u64,
  pub ri_phys_footprint: u64,
  pub ri_proc_start_abstime: u64,
  pub ri_proc_exit_abstime: u64,
  pub ri_child_user_time: u64,
  pub ri_child_system_time: u64,
  pub ri_child_pkg_idle_wkups: u64,
  pub ri_child_interrupt_wkups: u64,
  pub ri_child_pageins: u64,
  pub ri_child_elapsed_abstime: u64,
  pub ri_diskio_bytesread: u64,
  pub ri_diskio_byteswritten: u64,
  pub ri_cpu_time_qos_default: u64,
  pub ri_cpu_time_qos_maintenance: u64,
  pub ri_cpu_time_qos_background: u64,
  pub ri_cpu_time_qos_utility: u64,
  pub ri_cpu_time_qos_legacy: u64,
  pub ri_cpu_time_qos_user_initiated: u64,
  pub ri_cpu_time_qos_user_interactive: u64,
  pub ri_billed_system_time: u64,
  pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
  assert_eq!(
    ::core::mem::size_of::<rusage_info_v3>(),
    232usize,
    concat!("Size of: ", stringify!(rusage_info_v3))
  );
  assert_eq!(
    ::core::mem::align_of::<rusage_info_v3>(),
    8usize,
    concat!("Alignment of ", stringify!(rusage_info_v3))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_uuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_user_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_system_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_pageins)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_wired_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_resident_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_phys_footprint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_proc_start_abstime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_proc_exit_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_child_user_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_child_system_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_child_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_child_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_child_pageins)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_child_elapsed_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_diskio_bytesread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_diskio_byteswritten)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
    },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_default)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_maintenance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_background)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_utility)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
    },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_legacy)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
        as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_user_initiated)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
        as usize
    },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_cpu_time_qos_user_interactive)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_billed_system_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
    },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v3),
      "::",
      stringify!(ri_serviced_system_time)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rusage_info_v4 {
  pub ri_uuid: [u8; 16usize],
  pub ri_user_time: u64,
  pub ri_system_time: u64,
  pub ri_pkg_idle_wkups: u64,
  pub ri_interrupt_wkups: u64,
  pub ri_pageins: u64,
  pub ri_wired_size: u64,
  pub ri_resident_size: u64,
  pub ri_phys_footprint: u64,
  pub ri_proc_start_abstime: u64,
  pub ri_proc_exit_abstime: u64,
  pub ri_child_user_time: u64,
  pub ri_child_system_time: u64,
  pub ri_child_pkg_idle_wkups: u64,
  pub ri_child_interrupt_wkups: u64,
  pub ri_child_pageins: u64,
  pub ri_child_elapsed_abstime: u64,
  pub ri_diskio_bytesread: u64,
  pub ri_diskio_byteswritten: u64,
  pub ri_cpu_time_qos_default: u64,
  pub ri_cpu_time_qos_maintenance: u64,
  pub ri_cpu_time_qos_background: u64,
  pub ri_cpu_time_qos_utility: u64,
  pub ri_cpu_time_qos_legacy: u64,
  pub ri_cpu_time_qos_user_initiated: u64,
  pub ri_cpu_time_qos_user_interactive: u64,
  pub ri_billed_system_time: u64,
  pub ri_serviced_system_time: u64,
  pub ri_logical_writes: u64,
  pub ri_lifetime_max_phys_footprint: u64,
  pub ri_instructions: u64,
  pub ri_cycles: u64,
  pub ri_billed_energy: u64,
  pub ri_serviced_energy: u64,
  pub ri_unused: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
  assert_eq!(
    ::core::mem::size_of::<rusage_info_v4>(),
    296usize,
    concat!("Size of: ", stringify!(rusage_info_v4))
  );
  assert_eq!(
    ::core::mem::align_of::<rusage_info_v4>(),
    8usize,
    concat!("Alignment of ", stringify!(rusage_info_v4))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_uuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_user_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_system_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_pageins)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_wired_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_resident_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_phys_footprint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_proc_start_abstime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_proc_exit_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_child_user_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_child_system_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_child_pkg_idle_wkups)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_child_interrupt_wkups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_child_pageins)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_child_elapsed_abstime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_diskio_bytesread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_diskio_byteswritten)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
    },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_default)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_maintenance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_background)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_utility)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
    },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_legacy)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
        as usize
    },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_user_initiated)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
        as usize
    },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cpu_time_qos_user_interactive)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_billed_system_time)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
    },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_serviced_system_time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_logical_writes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
        as usize
    },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_lifetime_max_phys_footprint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_instructions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_cycles)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_billed_energy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_serviced_energy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rusage_info_v4>())).ri_unused as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(rusage_info_v4),
      "::",
      stringify!(ri_unused)
    )
  );
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rlimit {
  pub rlim_cur: rlim_t,
  pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
  assert_eq!(
    ::core::mem::size_of::<rlimit>(),
    16usize,
    concat!("Size of: ", stringify!(rlimit))
  );
  assert_eq!(
    ::core::mem::align_of::<rlimit>(),
    8usize,
    concat!("Alignment of ", stringify!(rlimit))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(rlimit),
      "::",
      stringify!(rlim_cur)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(rlimit),
      "::",
      stringify!(rlim_max)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct proc_rlimit_control_wakeupmon {
  pub wm_flags: u32,
  pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
  assert_eq!(
    ::core::mem::size_of::<proc_rlimit_control_wakeupmon>(),
    8usize,
    concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
  );
  assert_eq!(
    ::core::mem::align_of::<proc_rlimit_control_wakeupmon>(),
    4usize,
    concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(proc_rlimit_control_wakeupmon),
      "::",
      stringify!(wm_flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(proc_rlimit_control_wakeupmon),
      "::",
      stringify!(wm_rate)
    )
  );
}
extern "C" {
  #[link_name = "\u{1}_getpriority"]
  pub fn getpriority(arg1: libc::c_int, arg2: id_t) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getiopolicy_np"]
  pub fn getiopolicy_np(arg1: libc::c_int, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getrlimit"]
  pub fn getrlimit(arg1: libc::c_int, arg2: *mut rlimit) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getrusage"]
  pub fn getrusage(arg1: libc::c_int, arg2: *mut rusage) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setpriority"]
  pub fn setpriority(arg1: libc::c_int, arg2: id_t, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setiopolicy_np"]
  pub fn setiopolicy_np(arg1: libc::c_int, arg2: libc::c_int, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setrlimit"]
  pub fn setrlimit(arg1: libc::c_int, arg2: *const rlimit) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
  pub w_status: libc::c_int,
  pub w_T: wait__bindgen_ty_1,
  pub w_S: wait__bindgen_ty_2,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct wait__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<wait__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(wait__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<wait__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
  );
}
impl wait__bindgen_ty_1 {
  #[inline]
  pub fn w_Termsig(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
  }
  #[inline]
  pub fn set_w_Termsig(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn w_Coredump(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_w_Coredump(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(7usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn w_Retcode(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_w_Retcode(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn w_Filler(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_w_Filler(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    w_Termsig: libc::c_uint,
    w_Coredump: libc::c_uint,
    w_Retcode: libc::c_uint,
    w_Filler: libc::c_uint,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 7u8, {
      let w_Termsig: u32 = unsafe { ::core::mem::transmute(w_Termsig) };
      w_Termsig as u64
    });
    __bindgen_bitfield_unit.set(7usize, 1u8, {
      let w_Coredump: u32 = unsafe { ::core::mem::transmute(w_Coredump) };
      w_Coredump as u64
    });
    __bindgen_bitfield_unit.set(8usize, 8u8, {
      let w_Retcode: u32 = unsafe { ::core::mem::transmute(w_Retcode) };
      w_Retcode as u64
    });
    __bindgen_bitfield_unit.set(16usize, 16u8, {
      let w_Filler: u32 = unsafe { ::core::mem::transmute(w_Filler) };
      w_Filler as u64
    });
    __bindgen_bitfield_unit
  }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct wait__bindgen_ty_2 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<wait__bindgen_ty_2>(),
    4usize,
    concat!("Size of: ", stringify!(wait__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<wait__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
  );
}
impl wait__bindgen_ty_2 {
  #[inline]
  pub fn w_Stopval(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_w_Stopval(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn w_Stopsig(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_w_Stopsig(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn w_Filler(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_w_Filler(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    w_Stopval: libc::c_uint,
    w_Stopsig: libc::c_uint,
    w_Filler: libc::c_uint,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let w_Stopval: u32 = unsafe { ::core::mem::transmute(w_Stopval) };
      w_Stopval as u64
    });
    __bindgen_bitfield_unit.set(8usize, 8u8, {
      let w_Stopsig: u32 = unsafe { ::core::mem::transmute(w_Stopsig) };
      w_Stopsig as u64
    });
    __bindgen_bitfield_unit.set(16usize, 16u8, {
      let w_Filler: u32 = unsafe { ::core::mem::transmute(w_Filler) };
      w_Filler as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_wait() {
  assert_eq!(
    ::core::mem::size_of::<wait>(),
    4usize,
    concat!("Size of: ", stringify!(wait))
  );
  assert_eq!(
    ::core::mem::align_of::<wait>(),
    4usize,
    concat!("Alignment of ", stringify!(wait))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<wait>())).w_status as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wait),
      "::",
      stringify!(w_status)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<wait>())).w_T as *const _ as usize },
    0usize,
    concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<wait>())).w_S as *const _ as usize },
    0usize,
    concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
  );
}
impl Default for wait {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for wait {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "wait {{ union }}")
  }
}
extern "C" {
  #[link_name = "\u{1}_wait"]
  pub fn wait(arg1: *mut libc::c_int) -> pid_t;
}
extern "C" {
  #[link_name = "\u{1}_waitpid"]
  pub fn waitpid(arg1: pid_t, arg2: *mut libc::c_int, arg3: libc::c_int) -> pid_t;
}
extern "C" {
  #[link_name = "\u{1}_waitid"]
  pub fn waitid(
    arg1: idtype_t::Type,
    arg2: id_t,
    arg3: *mut siginfo_t,
    arg4: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_wait3"]
  pub fn wait3(arg1: *mut libc::c_int, arg2: libc::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
  #[link_name = "\u{1}_wait4"]
  pub fn wait4(arg1: pid_t, arg2: *mut libc::c_int, arg3: libc::c_int, arg4: *mut rusage) -> pid_t;
}
extern "C" {
  #[link_name = "\u{1}_alloca"]
  pub fn alloca(arg1: libc::c_ulong) -> *mut libc::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct div_t {
  pub quot: libc::c_int,
  pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
  assert_eq!(
    ::core::mem::size_of::<div_t>(),
    8usize,
    concat!("Size of: ", stringify!(div_t))
  );
  assert_eq!(
    ::core::mem::align_of::<div_t>(),
    4usize,
    concat!("Alignment of ", stringify!(div_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(div_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(div_t),
      "::",
      stringify!(rem)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ldiv_t {
  pub quot: libc::c_long,
  pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
  assert_eq!(
    ::core::mem::size_of::<ldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(ldiv_t))
  );
  assert_eq!(
    ::core::mem::align_of::<ldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(ldiv_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lldiv_t {
  pub quot: libc::c_longlong,
  pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
  assert_eq!(
    ::core::mem::size_of::<lldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(lldiv_t))
  );
  assert_eq!(
    ::core::mem::align_of::<lldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(lldiv_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(lldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(lldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
extern "C" {
  #[link_name = "\u{1}___mb_cur_max"]
  pub static mut __mb_cur_max: libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_abort"]
  pub fn abort();
}
extern "C" {
  #[link_name = "\u{1}_abs"]
  pub fn abs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_atexit"]
  pub fn atexit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_atof"]
  pub fn atof(arg1: *const libc::c_char) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_atoi"]
  pub fn atoi(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_atol"]
  pub fn atol(arg1: *const libc::c_char) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_atoll"]
  pub fn atoll(arg1: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_bsearch"]
  pub fn bsearch(
    __key: *const libc::c_void,
    __base: *const libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_calloc"]
  pub fn calloc(__count: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_div"]
  pub fn div(arg1: libc::c_int, arg2: libc::c_int) -> div_t;
}
extern "C" {
  #[link_name = "\u{1}_exit"]
  pub fn exit(arg1: libc::c_int);
}
extern "C" {
  #[link_name = "\u{1}_free"]
  pub fn free(arg1: *mut libc::c_void);
}
extern "C" {
  #[link_name = "\u{1}_getenv"]
  pub fn getenv(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_labs"]
  pub fn labs(arg1: libc::c_long) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_ldiv"]
  pub fn ldiv(arg1: libc::c_long, arg2: libc::c_long) -> ldiv_t;
}
extern "C" {
  #[link_name = "\u{1}_llabs"]
  pub fn llabs(arg1: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_lldiv"]
  pub fn lldiv(arg1: libc::c_longlong, arg2: libc::c_longlong) -> lldiv_t;
}
extern "C" {
  #[link_name = "\u{1}_malloc"]
  pub fn malloc(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_mblen"]
  pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_mbstowcs"]
  pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const libc::c_char, arg3: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_mbtowc"]
  pub fn mbtowc(arg1: *mut wchar_t, arg2: *const libc::c_char, arg3: usize) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_posix_memalign"]
  pub fn posix_memalign(
    __memptr: *mut *mut libc::c_void,
    __alignment: usize,
    __size: usize,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_qsort"]
  pub fn qsort(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  );
}
extern "C" {
  #[link_name = "\u{1}_rand"]
  pub fn rand() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_realloc"]
  pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_srand"]
  pub fn srand(arg1: libc::c_uint);
}
extern "C" {
  #[link_name = "\u{1}_strtod"]
  pub fn strtod(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_strtof"]
  pub fn strtof(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_strtol"]
  pub fn strtol(
    __str: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_strtold"]
  pub fn strtold(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_strtoll"]
  pub fn strtoll(
    __str: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_strtoul"]
  pub fn strtoul(
    __str: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strtoull"]
  pub fn strtoull(
    __str: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> libc::c_ulonglong;
}
extern "C" {
  #[link_name = "\u{1}_system"]
  pub fn system(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_wcstombs"]
  pub fn wcstombs(arg1: *mut libc::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_wctomb"]
  pub fn wctomb(arg1: *mut libc::c_char, arg2: wchar_t) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}__Exit"]
  pub fn _Exit(arg1: libc::c_int);
}
extern "C" {
  #[link_name = "\u{1}_a64l"]
  pub fn a64l(arg1: *const libc::c_char) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_drand48"]
  pub fn drand48() -> f64;
}
extern "C" {
  #[link_name = "\u{1}_ecvt"]
  pub fn ecvt(
    arg1: f64,
    arg2: libc::c_int,
    arg3: *mut libc::c_int,
    arg4: *mut libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_erand48"]
  pub fn erand48(arg1: *mut libc::c_ushort) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fcvt"]
  pub fn fcvt(
    arg1: f64,
    arg2: libc::c_int,
    arg3: *mut libc::c_int,
    arg4: *mut libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_gcvt"]
  pub fn gcvt(arg1: f64, arg2: libc::c_int, arg3: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_getsubopt"]
  pub fn getsubopt(
    arg1: *mut *mut libc::c_char,
    arg2: *const *mut libc::c_char,
    arg3: *mut *mut libc::c_char,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_grantpt"]
  pub fn grantpt(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_initstate"]
  pub fn initstate(arg1: libc::c_uint, arg2: *mut libc::c_char, arg3: usize) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_jrand48"]
  pub fn jrand48(arg1: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_l64a"]
  pub fn l64a(arg1: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_lcong48"]
  pub fn lcong48(arg1: *mut libc::c_ushort);
}
extern "C" {
  #[link_name = "\u{1}_lrand48"]
  pub fn lrand48() -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_mktemp"]
  pub fn mktemp(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_mkstemp"]
  pub fn mkstemp(arg1: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_mrand48"]
  pub fn mrand48() -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_nrand48"]
  pub fn nrand48(arg1: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_posix_openpt"]
  pub fn posix_openpt(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ptsname"]
  pub fn ptsname(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_ptsname_r"]
  pub fn ptsname_r(fildes: libc::c_int, buffer: *mut libc::c_char, buflen: usize) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_putenv"]
  pub fn putenv(arg1: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_random"]
  pub fn random() -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_rand_r"]
  pub fn rand_r(arg1: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
  pub fn realpath(arg1: *const libc::c_char, arg2: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_seed48"]
  pub fn seed48(arg1: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
  #[link_name = "\u{1}_setenv"]
  pub fn setenv(
    __name: *const libc::c_char,
    __value: *const libc::c_char,
    __overwrite: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setkey"]
  pub fn setkey(arg1: *const libc::c_char);
}
extern "C" {
  #[link_name = "\u{1}_setstate"]
  pub fn setstate(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_srand48"]
  pub fn srand48(arg1: libc::c_long);
}
extern "C" {
  #[link_name = "\u{1}_srandom"]
  pub fn srandom(arg1: libc::c_uint);
}
extern "C" {
  #[link_name = "\u{1}_unlockpt"]
  pub fn unlockpt(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_unsetenv"]
  pub fn unsetenv(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_arc4random"]
  pub fn arc4random() -> u32;
}
extern "C" {
  #[link_name = "\u{1}_arc4random_addrandom"]
  pub fn arc4random_addrandom(arg1: *mut libc::c_uchar, arg2: libc::c_int);
}
extern "C" {
  #[link_name = "\u{1}_arc4random_buf"]
  pub fn arc4random_buf(__buf: *mut libc::c_void, __nbytes: usize);
}
extern "C" {
  #[link_name = "\u{1}_arc4random_stir"]
  pub fn arc4random_stir();
}
extern "C" {
  #[link_name = "\u{1}_arc4random_uniform"]
  pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
  #[link_name = "\u{1}_atexit_b"]
  pub fn atexit_b(arg1: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_bsearch_b"]
  pub fn bsearch_b(
    __key: *const libc::c_void,
    __base: *const libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: *mut libc::c_void,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_cgetcap"]
  pub fn cgetcap(
    arg1: *mut libc::c_char,
    arg2: *const libc::c_char,
    arg3: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_cgetclose"]
  pub fn cgetclose() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetent"]
  pub fn cgetent(
    arg1: *mut *mut libc::c_char,
    arg2: *mut *mut libc::c_char,
    arg3: *const libc::c_char,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetfirst"]
  pub fn cgetfirst(arg1: *mut *mut libc::c_char, arg2: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetmatch"]
  pub fn cgetmatch(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetnext"]
  pub fn cgetnext(arg1: *mut *mut libc::c_char, arg2: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetnum"]
  pub fn cgetnum(
    arg1: *mut libc::c_char,
    arg2: *const libc::c_char,
    arg3: *mut libc::c_long,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetset"]
  pub fn cgetset(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetstr"]
  pub fn cgetstr(
    arg1: *mut libc::c_char,
    arg2: *const libc::c_char,
    arg3: *mut *mut libc::c_char,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_cgetustr"]
  pub fn cgetustr(
    arg1: *mut libc::c_char,
    arg2: *const libc::c_char,
    arg3: *mut *mut libc::c_char,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_daemon"]
  pub fn daemon(arg1: libc::c_int, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_devname"]
  pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_devname_r"]
  pub fn devname_r(
    arg1: dev_t,
    arg2: mode_t,
    buf: *mut libc::c_char,
    len: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_getbsize"]
  pub fn getbsize(arg1: *mut libc::c_int, arg2: *mut libc::c_long) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_getloadavg"]
  pub fn getloadavg(arg1: *mut f64, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_getprogname"]
  pub fn getprogname() -> *const libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_heapsort"]
  pub fn heapsort(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_heapsort_b"]
  pub fn heapsort_b(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: *mut libc::c_void,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_mergesort"]
  pub fn mergesort(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_mergesort_b"]
  pub fn mergesort_b(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: *mut libc::c_void,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_psort"]
  pub fn psort(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  );
}
extern "C" {
  #[link_name = "\u{1}_psort_b"]
  pub fn psort_b(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: *mut libc::c_void,
  );
}
extern "C" {
  #[link_name = "\u{1}_psort_r"]
  pub fn psort_r(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    arg1: *mut libc::c_void,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(
        arg1: *mut libc::c_void,
        arg2: *const libc::c_void,
        arg3: *const libc::c_void,
      ) -> libc::c_int,
    >,
  );
}
extern "C" {
  #[link_name = "\u{1}_qsort_b"]
  pub fn qsort_b(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    __compar: *mut libc::c_void,
  );
}
extern "C" {
  #[link_name = "\u{1}_qsort_r"]
  pub fn qsort_r(
    __base: *mut libc::c_void,
    __nel: usize,
    __width: usize,
    arg1: *mut libc::c_void,
    __compar: ::core::option::Option<
      unsafe extern "C" fn(
        arg1: *mut libc::c_void,
        arg2: *const libc::c_void,
        arg3: *const libc::c_void,
      ) -> libc::c_int,
    >,
  );
}
extern "C" {
  #[link_name = "\u{1}_radixsort"]
  pub fn radixsort(
    __base: *mut *const libc::c_uchar,
    __nel: libc::c_int,
    __table: *const libc::c_uchar,
    __endbyte: libc::c_uint,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_setprogname"]
  pub fn setprogname(arg1: *const libc::c_char);
}
extern "C" {
  #[link_name = "\u{1}_sradixsort"]
  pub fn sradixsort(
    __base: *mut *const libc::c_uchar,
    __nel: libc::c_int,
    __table: *const libc::c_uchar,
    __endbyte: libc::c_uint,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_sranddev"]
  pub fn sranddev();
}
extern "C" {
  #[link_name = "\u{1}_srandomdev"]
  pub fn srandomdev();
}
extern "C" {
  #[link_name = "\u{1}_reallocf"]
  pub fn reallocf(__ptr: *mut libc::c_void, __size: usize) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_strtoq"]
  pub fn strtoq(
    __str: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_strtouq"]
  pub fn strtouq(
    __str: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> libc::c_ulonglong;
}
extern "C" {
  #[link_name = "\u{1}_suboptarg"]
  pub static mut suboptarg: *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_valloc"]
  pub fn valloc(arg1: usize) -> *mut libc::c_void;
}
pub type max_align_t = u128;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
  #[link_name = "\u{1}_memchr"]
  pub fn memchr(
    __s: *const libc::c_void,
    __c: libc::c_int,
    __n: libc::c_ulong,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_memcmp"]
  pub fn memcmp(
    __s1: *const libc::c_void,
    __s2: *const libc::c_void,
    __n: libc::c_ulong,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_memcpy"]
  pub fn memcpy(
    __dst: *mut libc::c_void,
    __src: *const libc::c_void,
    __n: libc::c_ulong,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_memmove"]
  pub fn memmove(
    __dst: *mut libc::c_void,
    __src: *const libc::c_void,
    __len: libc::c_ulong,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_memset"]
  pub fn memset(
    __b: *mut libc::c_void,
    __c: libc::c_int,
    __len: libc::c_ulong,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_strcat"]
  pub fn strcat(__s1: *mut libc::c_char, __s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strchr"]
  pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strcmp"]
  pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_strcoll"]
  pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_strcpy"]
  pub fn strcpy(__dst: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strcspn"]
  pub fn strcspn(__s: *const libc::c_char, __charset: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strerror"]
  pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strlen"]
  pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strncat"]
  pub fn strncat(
    __s1: *mut libc::c_char,
    __s2: *const libc::c_char,
    __n: libc::c_ulong,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strncmp"]
  pub fn strncmp(
    __s1: *const libc::c_char,
    __s2: *const libc::c_char,
    __n: libc::c_ulong,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_strncpy"]
  pub fn strncpy(
    __dst: *mut libc::c_char,
    __src: *const libc::c_char,
    __n: libc::c_ulong,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strpbrk"]
  pub fn strpbrk(__s: *const libc::c_char, __charset: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strrchr"]
  pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strspn"]
  pub fn strspn(__s: *const libc::c_char, __charset: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strstr"]
  pub fn strstr(__big: *const libc::c_char, __little: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strtok"]
  pub fn strtok(__str: *mut libc::c_char, __sep: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strxfrm"]
  pub fn strxfrm(
    __s1: *mut libc::c_char,
    __s2: *const libc::c_char,
    __n: libc::c_ulong,
  ) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strtok_r"]
  pub fn strtok_r(
    __str: *mut libc::c_char,
    __sep: *const libc::c_char,
    __lasts: *mut *mut libc::c_char,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strerror_r"]
  pub fn strerror_r(
    __errnum: libc::c_int,
    __strerrbuf: *mut libc::c_char,
    __buflen: usize,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_strdup"]
  pub fn strdup(__s1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_memccpy"]
  pub fn memccpy(
    __dst: *mut libc::c_void,
    __src: *const libc::c_void,
    __c: libc::c_int,
    __n: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_stpcpy"]
  pub fn stpcpy(__dst: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_stpncpy"]
  pub fn stpncpy(
    __dst: *mut libc::c_char,
    __src: *const libc::c_char,
    __n: libc::c_ulong,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strndup"]
  pub fn strndup(__s1: *const libc::c_char, __n: libc::c_ulong) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strnlen"]
  pub fn strnlen(__s1: *const libc::c_char, __n: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_strsignal"]
  pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_memset_s"]
  pub fn memset_s(
    __s: *mut libc::c_void,
    __smax: rsize_t,
    __c: libc::c_int,
    __n: rsize_t,
  ) -> errno_t;
}
extern "C" {
  #[link_name = "\u{1}_memmem"]
  pub fn memmem(
    __big: *const libc::c_void,
    __big_len: usize,
    __little: *const libc::c_void,
    __little_len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_memset_pattern4"]
  pub fn memset_pattern4(__b: *mut libc::c_void, __pattern4: *const libc::c_void, __len: usize);
}
extern "C" {
  #[link_name = "\u{1}_memset_pattern8"]
  pub fn memset_pattern8(__b: *mut libc::c_void, __pattern8: *const libc::c_void, __len: usize);
}
extern "C" {
  #[link_name = "\u{1}_memset_pattern16"]
  pub fn memset_pattern16(__b: *mut libc::c_void, __pattern16: *const libc::c_void, __len: usize);
}
extern "C" {
  #[link_name = "\u{1}_strcasestr"]
  pub fn strcasestr(__big: *const libc::c_char, __little: *const libc::c_char)
    -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strnstr"]
  pub fn strnstr(
    __big: *const libc::c_char,
    __little: *const libc::c_char,
    __len: usize,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_strlcat"]
  pub fn strlcat(
    __dst: *mut libc::c_char,
    __source: *const libc::c_char,
    __size: libc::c_ulong,
  ) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strlcpy"]
  pub fn strlcpy(
    __dst: *mut libc::c_char,
    __source: *const libc::c_char,
    __size: libc::c_ulong,
  ) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_strmode"]
  pub fn strmode(__mode: libc::c_int, __bp: *mut libc::c_char);
}
extern "C" {
  #[link_name = "\u{1}_strsep"]
  pub fn strsep(
    __stringp: *mut *mut libc::c_char,
    __delim: *const libc::c_char,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_swab"]
  pub fn swab(arg1: *const libc::c_void, arg2: *mut libc::c_void, arg3: isize);
}
extern "C" {
  #[link_name = "\u{1}_timingsafe_bcmp"]
  pub fn timingsafe_bcmp(
    __b1: *const libc::c_void,
    __b2: *const libc::c_void,
    __len: usize,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_bcmp"]
  pub fn bcmp(arg1: *const libc::c_void, arg2: *const libc::c_void, arg3: usize) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_bcopy"]
  pub fn bcopy(arg1: *const libc::c_void, arg2: *mut libc::c_void, arg3: usize);
}
extern "C" {
  #[link_name = "\u{1}_bzero"]
  pub fn bzero(arg1: *mut libc::c_void, arg2: libc::c_ulong);
}
extern "C" {
  #[link_name = "\u{1}_index"]
  pub fn index(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_rindex"]
  pub fn rindex(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_ffs"]
  pub fn ffs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_strcasecmp"]
  pub fn strcasecmp(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_strncasecmp"]
  pub fn strncasecmp(
    arg1: *const libc::c_char,
    arg2: *const libc::c_char,
    arg3: libc::c_ulong,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ffsl"]
  pub fn ffsl(arg1: libc::c_long) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ffsll"]
  pub fn ffsll(arg1: libc::c_longlong) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_fls"]
  pub fn fls(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_flsl"]
  pub fn flsl(arg1: libc::c_long) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_flsll"]
  pub fn flsll(arg1: libc::c_longlong) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_imaxabs"]
  pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct imaxdiv_t {
  pub quot: intmax_t,
  pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
  assert_eq!(
    ::core::mem::size_of::<imaxdiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(imaxdiv_t))
  );
  assert_eq!(
    ::core::mem::align_of::<imaxdiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(imaxdiv_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(imaxdiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(imaxdiv_t),
      "::",
      stringify!(rem)
    )
  );
}
extern "C" {
  #[link_name = "\u{1}_imaxdiv"]
  pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
  #[link_name = "\u{1}_strtoimax"]
  pub fn strtoimax(
    __nptr: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> intmax_t;
}
extern "C" {
  #[link_name = "\u{1}_strtoumax"]
  pub fn strtoumax(
    __nptr: *const libc::c_char,
    __endptr: *mut *mut libc::c_char,
    __base: libc::c_int,
  ) -> uintmax_t;
}
extern "C" {
  #[link_name = "\u{1}_wcstoimax"]
  pub fn wcstoimax(
    __nptr: *const wchar_t,
    __endptr: *mut *mut wchar_t,
    __base: libc::c_int,
  ) -> intmax_t;
}
extern "C" {
  #[link_name = "\u{1}_wcstoumax"]
  pub fn wcstoumax(
    __nptr: *const wchar_t,
    __endptr: *mut *mut wchar_t,
    __base: libc::c_int,
  ) -> uintmax_t;
}
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RuneEntry {
  pub __min: __darwin_rune_t,
  pub __max: __darwin_rune_t,
  pub __map: __darwin_rune_t,
  pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
  assert_eq!(
    ::core::mem::size_of::<_RuneEntry>(),
    24usize,
    concat!("Size of: ", stringify!(_RuneEntry))
  );
  assert_eq!(
    ::core::mem::align_of::<_RuneEntry>(),
    8usize,
    concat!("Alignment of ", stringify!(_RuneEntry))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneEntry>())).__min as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneEntry),
      "::",
      stringify!(__min)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneEntry>())).__max as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneEntry),
      "::",
      stringify!(__max)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneEntry>())).__map as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneEntry),
      "::",
      stringify!(__map)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneEntry>())).__types as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneEntry),
      "::",
      stringify!(__types)
    )
  );
}
impl Default for _RuneEntry {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RuneRange {
  pub __nranges: libc::c_int,
  pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
  assert_eq!(
    ::core::mem::size_of::<_RuneRange>(),
    16usize,
    concat!("Size of: ", stringify!(_RuneRange))
  );
  assert_eq!(
    ::core::mem::align_of::<_RuneRange>(),
    8usize,
    concat!("Alignment of ", stringify!(_RuneRange))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneRange>())).__nranges as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneRange),
      "::",
      stringify!(__nranges)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneRange>())).__ranges as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneRange),
      "::",
      stringify!(__ranges)
    )
  );
}
impl Default for _RuneRange {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RuneCharClass {
  pub __name: [libc::c_char; 14usize],
  pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
  assert_eq!(
    ::core::mem::size_of::<_RuneCharClass>(),
    20usize,
    concat!("Size of: ", stringify!(_RuneCharClass))
  );
  assert_eq!(
    ::core::mem::align_of::<_RuneCharClass>(),
    4usize,
    concat!("Alignment of ", stringify!(_RuneCharClass))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneCharClass>())).__name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneCharClass),
      "::",
      stringify!(__name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneCharClass>())).__mask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneCharClass),
      "::",
      stringify!(__mask)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RuneLocale {
  pub __magic: [libc::c_char; 8usize],
  pub __encoding: [libc::c_char; 32usize],
  pub __sgetrune: ::core::option::Option<
    unsafe extern "C" fn(
      arg1: *const libc::c_char,
      arg2: __darwin_size_t,
      arg3: *mut *const libc::c_char,
    ) -> __darwin_rune_t,
  >,
  pub __sputrune: ::core::option::Option<
    unsafe extern "C" fn(
      arg1: __darwin_rune_t,
      arg2: *mut libc::c_char,
      arg3: __darwin_size_t,
      arg4: *mut *mut libc::c_char,
    ) -> libc::c_int,
  >,
  pub __invalid_rune: __darwin_rune_t,
  pub __runetype: [__uint32_t; 256usize],
  pub __maplower: [__darwin_rune_t; 256usize],
  pub __mapupper: [__darwin_rune_t; 256usize],
  pub __runetype_ext: _RuneRange,
  pub __maplower_ext: _RuneRange,
  pub __mapupper_ext: _RuneRange,
  pub __variable: *mut libc::c_void,
  pub __variable_len: libc::c_int,
  pub __ncharclasses: libc::c_int,
  pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
  assert_eq!(
    ::core::mem::size_of::<_RuneLocale>(),
    3208usize,
    concat!("Size of: ", stringify!(_RuneLocale))
  );
  assert_eq!(
    ::core::mem::align_of::<_RuneLocale>(),
    8usize,
    concat!("Alignment of ", stringify!(_RuneLocale))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__magic as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__magic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__encoding as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__encoding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__sgetrune as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__sgetrune)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__sputrune as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__sputrune)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__invalid_rune as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__invalid_rune)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__runetype as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__runetype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__maplower as *const _ as usize },
    1084usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__maplower)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__mapupper as *const _ as usize },
    2108usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__mapupper)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__runetype_ext as *const _ as usize },
    3136usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__runetype_ext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__maplower_ext as *const _ as usize },
    3152usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__maplower_ext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__mapupper_ext as *const _ as usize },
    3168usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__mapupper_ext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__variable as *const _ as usize },
    3184usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__variable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__variable_len as *const _ as usize },
    3192usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__variable_len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__ncharclasses as *const _ as usize },
    3196usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__ncharclasses)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RuneLocale>())).__charclasses as *const _ as usize },
    3200usize,
    concat!(
      "Offset of field: ",
      stringify!(_RuneLocale),
      "::",
      stringify!(__charclasses)
    )
  );
}
impl Default for _RuneLocale {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _RuneLocale {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_RuneLocale {{ __magic: {:?}, __encoding: [...], __sgetrune: {:?}, __sputrune: {:?}, __invalid_rune: {:?}, __runetype: [...], __maplower: [...], __mapupper: [...], __runetype_ext: {:?}, __maplower_ext: {:?}, __mapupper_ext: {:?}, __variable: {:?}, __variable_len: {:?}, __ncharclasses: {:?}, __charclasses: {:?} }}" , self . __magic , self . __sgetrune , self . __sputrune , self . __invalid_rune , self . __runetype_ext , self . __maplower_ext , self . __mapupper_ext , self . __variable , self . __variable_len , self . __ncharclasses , self . __charclasses )
  }
}
impl ::core::cmp::PartialEq for _RuneLocale {
  fn eq(&self, other: &_RuneLocale) -> bool {
    self.__magic == other.__magic
      && self.__encoding == other.__encoding
      && self.__sgetrune == other.__sgetrune
      && self.__sputrune == other.__sputrune
      && self.__invalid_rune == other.__invalid_rune
      && &self.__runetype[..] == &other.__runetype[..]
      && &self.__maplower[..] == &other.__maplower[..]
      && &self.__mapupper[..] == &other.__mapupper[..]
      && self.__runetype_ext == other.__runetype_ext
      && self.__maplower_ext == other.__maplower_ext
      && self.__mapupper_ext == other.__mapupper_ext
      && self.__variable == other.__variable
      && self.__variable_len == other.__variable_len
      && self.__ncharclasses == other.__ncharclasses
      && self.__charclasses == other.__charclasses
  }
}
extern "C" {
  #[link_name = "\u{1}__DefaultRuneLocale"]
  pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
  #[link_name = "\u{1}__CurrentRuneLocale"]
  pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
  #[link_name = "\u{1}____runetype"]
  pub fn ___runetype(arg1: __darwin_ct_rune_t) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}____tolower"]
  pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
  #[link_name = "\u{1}____toupper"]
  pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
  #[link_name = "\u{1}___maskrune"]
  pub fn __maskrune(arg1: __darwin_ct_rune_t, arg2: libc::c_ulong) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}___toupper"]
  pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
  #[link_name = "\u{1}___tolower"]
  pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
  #[link_name = "\u{1}___math_errhandling"]
  pub fn __math_errhandling() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}___fpclassifyf"]
  pub fn __fpclassifyf(arg1: f32) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}___fpclassifyd"]
  pub fn __fpclassifyd(arg1: f64) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}___fpclassify"]
  pub fn __fpclassify(arg1: u128) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_acosf"]
  pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_acos"]
  pub fn acos(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_acosl"]
  pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_asinf"]
  pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_asin"]
  pub fn asin(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_asinl"]
  pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_atanf"]
  pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_atan"]
  pub fn atan(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_atanl"]
  pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_atan2f"]
  pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_atan2"]
  pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_atan2l"]
  pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_cosf"]
  pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_cos"]
  pub fn cos(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_cosl"]
  pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_sinf"]
  pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_sin"]
  pub fn sin(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_sinl"]
  pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_tanf"]
  pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_tan"]
  pub fn tan(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_tanl"]
  pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_acoshf"]
  pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_acosh"]
  pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_acoshl"]
  pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_asinhf"]
  pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_asinh"]
  pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_asinhl"]
  pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_atanhf"]
  pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_atanh"]
  pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_atanhl"]
  pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_coshf"]
  pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_cosh"]
  pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_coshl"]
  pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_sinhf"]
  pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_sinh"]
  pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_sinhl"]
  pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_tanhf"]
  pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_tanh"]
  pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_tanhl"]
  pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_expf"]
  pub fn expf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_exp"]
  pub fn exp(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_expl"]
  pub fn expl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_exp2f"]
  pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_exp2"]
  pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_exp2l"]
  pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_expm1f"]
  pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_expm1"]
  pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_expm1l"]
  pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_logf"]
  pub fn logf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_log"]
  pub fn log(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_logl"]
  pub fn logl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_log10f"]
  pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_log10"]
  pub fn log10(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_log10l"]
  pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_log2f"]
  pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_log2"]
  pub fn log2(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_log2l"]
  pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_log1pf"]
  pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_log1p"]
  pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_log1pl"]
  pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_logbf"]
  pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_logb"]
  pub fn logb(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_logbl"]
  pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_modff"]
  pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_modf"]
  pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_modfl"]
  pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_ldexpf"]
  pub fn ldexpf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_ldexp"]
  pub fn ldexp(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_ldexpl"]
  pub fn ldexpl(arg1: u128, arg2: libc::c_int) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_frexpf"]
  pub fn frexpf(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_frexp"]
  pub fn frexp(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_frexpl"]
  pub fn frexpl(arg1: u128, arg2: *mut libc::c_int) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_ilogbf"]
  pub fn ilogbf(arg1: f32) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ilogb"]
  pub fn ilogb(arg1: f64) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_ilogbl"]
  pub fn ilogbl(arg1: u128) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_scalbnf"]
  pub fn scalbnf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_scalbn"]
  pub fn scalbn(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_scalbnl"]
  pub fn scalbnl(arg1: u128, arg2: libc::c_int) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_scalblnf"]
  pub fn scalblnf(arg1: f32, arg2: libc::c_long) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_scalbln"]
  pub fn scalbln(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_scalblnl"]
  pub fn scalblnl(arg1: u128, arg2: libc::c_long) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_fabsf"]
  pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_fabs"]
  pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fabsl"]
  pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_cbrtf"]
  pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_cbrt"]
  pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_cbrtl"]
  pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_hypotf"]
  pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_hypot"]
  pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_hypotl"]
  pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_powf"]
  pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_pow"]
  pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_powl"]
  pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_sqrtf"]
  pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_sqrt"]
  pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_sqrtl"]
  pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_erff"]
  pub fn erff(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_erf"]
  pub fn erf(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_erfl"]
  pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_erfcf"]
  pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_erfc"]
  pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_erfcl"]
  pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_lgammaf"]
  pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_lgamma"]
  pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_lgammal"]
  pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_tgammaf"]
  pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_tgamma"]
  pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_tgammal"]
  pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_ceilf"]
  pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_ceil"]
  pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_ceill"]
  pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_floorf"]
  pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_floor"]
  pub fn floor(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_floorl"]
  pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_nearbyintf"]
  pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_nearbyint"]
  pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_nearbyintl"]
  pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_rintf"]
  pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_rint"]
  pub fn rint(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_rintl"]
  pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_lrintf"]
  pub fn lrintf(arg1: f32) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_lrint"]
  pub fn lrint(arg1: f64) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_lrintl"]
  pub fn lrintl(arg1: u128) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_roundf"]
  pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_round"]
  pub fn round(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_roundl"]
  pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_lroundf"]
  pub fn lroundf(arg1: f32) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_lround"]
  pub fn lround(arg1: f64) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_lroundl"]
  pub fn lroundl(arg1: u128) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_llrintf"]
  pub fn llrintf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_llrint"]
  pub fn llrint(arg1: f64) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_llrintl"]
  pub fn llrintl(arg1: u128) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_llroundf"]
  pub fn llroundf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_llround"]
  pub fn llround(arg1: f64) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_llroundl"]
  pub fn llroundl(arg1: u128) -> libc::c_longlong;
}
extern "C" {
  #[link_name = "\u{1}_truncf"]
  pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_trunc"]
  pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_truncl"]
  pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_fmodf"]
  pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_fmod"]
  pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fmodl"]
  pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_remainderf"]
  pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_remainder"]
  pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_remainderl"]
  pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_remquof"]
  pub fn remquof(arg1: f32, arg2: f32, arg3: *mut libc::c_int) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_remquo"]
  pub fn remquo(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_remquol"]
  pub fn remquol(arg1: u128, arg2: u128, arg3: *mut libc::c_int) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_copysignf"]
  pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_copysign"]
  pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_copysignl"]
  pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_nanf"]
  pub fn nanf(arg1: *const libc::c_char) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_nan"]
  pub fn nan(arg1: *const libc::c_char) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_nanl"]
  pub fn nanl(arg1: *const libc::c_char) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_nextafterf"]
  pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_nextafter"]
  pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_nextafterl"]
  pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_nexttoward"]
  pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_nexttowardf"]
  pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_nexttowardl"]
  pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_fdimf"]
  pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_fdim"]
  pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fdiml"]
  pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_fmaxf"]
  pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_fmax"]
  pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fmaxl"]
  pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_fminf"]
  pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_fmin"]
  pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fminl"]
  pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}_fmaf"]
  pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_fma"]
  pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_fmal"]
  pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
  #[link_name = "\u{1}___inff"]
  pub fn __inff() -> f32;
}
extern "C" {
  #[link_name = "\u{1}___inf"]
  pub fn __inf() -> f64;
}
extern "C" {
  #[link_name = "\u{1}___infl"]
  pub fn __infl() -> u128;
}
extern "C" {
  #[link_name = "\u{1}___nan"]
  pub fn __nan() -> f32;
}
extern "C" {
  #[link_name = "\u{1}___exp10f"]
  pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}___exp10"]
  pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}___cospif"]
  pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}___cospi"]
  pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}___sinpif"]
  pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}___sinpi"]
  pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}___tanpif"]
  pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}___tanpi"]
  pub fn __tanpi(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_j0"]
  pub fn j0(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_j1"]
  pub fn j1(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_jn"]
  pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_y0"]
  pub fn y0(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_y1"]
  pub fn y1(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_yn"]
  pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_scalb"]
  pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_signgam"]
  pub static mut signgam: libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_rinttol"]
  pub fn rinttol(arg1: f64) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_roundtol"]
  pub fn roundtol(arg1: f64) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_drem"]
  pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_finite"]
  pub fn finite(arg1: f64) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_gamma"]
  pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_significand"]
  pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct exception {
  pub type_: libc::c_int,
  pub name: *mut libc::c_char,
  pub arg1: f64,
  pub arg2: f64,
  pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
  assert_eq!(
    ::core::mem::size_of::<exception>(),
    40usize,
    concat!("Size of: ", stringify!(exception))
  );
  assert_eq!(
    ::core::mem::align_of::<exception>(),
    8usize,
    concat!("Alignment of ", stringify!(exception))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<exception>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(exception),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<exception>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(exception),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<exception>())).arg1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(exception),
      "::",
      stringify!(arg1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<exception>())).arg2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(exception),
      "::",
      stringify!(arg2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<exception>())).retval as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(exception),
      "::",
      stringify!(retval)
    )
  );
}
impl Default for exception {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[link_name = "\u{1}_matherr"]
  pub fn matherr(arg1: *mut exception) -> libc::c_int;
}
pub mod SDL_bool {
  pub type Type = u32;
  pub const SDL_FALSE: Type = 0;
  pub const SDL_TRUE: Type = 1;
}
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [libc::c_int; 1usize];
pub mod SDL_DUMMY_ENUM {
  pub type Type = u32;
  pub const DUMMY_ENUM_VALUE: Type = 0;
}
pub type SDL_compile_time_assert_enum = [libc::c_int; 1usize];
extern "C" {
  #[link_name = "\u{1}_SDL_malloc"]
  pub fn SDL_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_calloc"]
  pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_realloc"]
  pub fn SDL_realloc(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_free"]
  pub fn SDL_free(mem: *mut libc::c_void);
}
pub type SDL_malloc_func =
  ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut libc::c_void>;
pub type SDL_calloc_func =
  ::core::option::Option<unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut libc::c_void>;
pub type SDL_realloc_func = ::core::option::Option<
  unsafe extern "C" fn(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void,
>;
pub type SDL_free_func = ::core::option::Option<unsafe extern "C" fn(mem: *mut libc::c_void)>;
extern "C" {
  #[doc = "  \\brief Get the current set of SDL memory functions"]
  #[link_name = "\u{1}_SDL_GetMemoryFunctions"]
  pub fn SDL_GetMemoryFunctions(
    malloc_func: *mut SDL_malloc_func,
    calloc_func: *mut SDL_calloc_func,
    realloc_func: *mut SDL_realloc_func,
    free_func: *mut SDL_free_func,
  );
}
extern "C" {
  #[doc = "  \\brief Replace SDL's memory allocation functions with a custom set"]
  #[doc = ""]
  #[doc = "  \\note If you are replacing SDL's memory functions, you should call"]
  #[doc = "        SDL_GetNumAllocations() and be very careful if it returns non-zero."]
  #[doc = "        That means that your free function will be called with memory"]
  #[doc = "        allocated by the previous memory allocation functions."]
  #[link_name = "\u{1}_SDL_SetMemoryFunctions"]
  pub fn SDL_SetMemoryFunctions(
    malloc_func: SDL_malloc_func,
    calloc_func: SDL_calloc_func,
    realloc_func: SDL_realloc_func,
    free_func: SDL_free_func,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the number of outstanding (unfreed) allocations"]
  #[link_name = "\u{1}_SDL_GetNumAllocations"]
  pub fn SDL_GetNumAllocations() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_getenv"]
  pub fn SDL_getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_setenv"]
  pub fn SDL_setenv(
    name: *const libc::c_char,
    value: *const libc::c_char,
    overwrite: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_qsort"]
  pub fn SDL_qsort(
    base: *mut libc::c_void,
    nmemb: usize,
    size: usize,
    compare: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  );
}
extern "C" {
  #[link_name = "\u{1}_SDL_abs"]
  pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_isdigit"]
  pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_isspace"]
  pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_toupper"]
  pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_tolower"]
  pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_memset"]
  pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: usize) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_memcpy"]
  pub fn SDL_memcpy(
    dst: *mut libc::c_void,
    src: *const libc::c_void,
    len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_memmove"]
  pub fn SDL_memmove(
    dst: *mut libc::c_void,
    src: *const libc::c_void,
    len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_memcmp"]
  pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: usize) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_wcsdup"]
  pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  #[link_name = "\u{1}_SDL_wcslen"]
  pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_wcslcpy"]
  pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_wcslcat"]
  pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_wcscmp"]
  pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strlen"]
  pub fn SDL_strlen(str: *const libc::c_char) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strlcpy"]
  pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_utf8strlcpy"]
  pub fn SDL_utf8strlcpy(
    dst: *mut libc::c_char,
    src: *const libc::c_char,
    dst_bytes: usize,
  ) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strlcat"]
  pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strdup"]
  pub fn SDL_strdup(str: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strrev"]
  pub fn SDL_strrev(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strupr"]
  pub fn SDL_strupr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strlwr"]
  pub fn SDL_strlwr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strchr"]
  pub fn SDL_strchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strrchr"]
  pub fn SDL_strrchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strstr"]
  pub fn SDL_strstr(
    haystack: *const libc::c_char,
    needle: *const libc::c_char,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_utf8strlen"]
  pub fn SDL_utf8strlen(str: *const libc::c_char) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_itoa"]
  pub fn SDL_itoa(
    value: libc::c_int,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_uitoa"]
  pub fn SDL_uitoa(
    value: libc::c_uint,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ltoa"]
  pub fn SDL_ltoa(
    value: libc::c_long,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ultoa"]
  pub fn SDL_ultoa(
    value: libc::c_ulong,
    str: *mut libc::c_char,
    radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_lltoa"]
  pub fn SDL_lltoa(value: Sint64, str: *mut libc::c_char, radix: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ulltoa"]
  pub fn SDL_ulltoa(value: Uint64, str: *mut libc::c_char, radix: libc::c_int)
    -> *mut libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_atoi"]
  pub fn SDL_atoi(str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_atof"]
  pub fn SDL_atof(str: *const libc::c_char) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strtol"]
  pub fn SDL_strtol(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> libc::c_long;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strtoul"]
  pub fn SDL_strtoul(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> libc::c_ulong;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strtoll"]
  pub fn SDL_strtoll(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> Sint64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strtoull"]
  pub fn SDL_strtoull(
    str: *const libc::c_char,
    endp: *mut *mut libc::c_char,
    base: libc::c_int,
  ) -> Uint64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strtod"]
  pub fn SDL_strtod(str: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strcmp"]
  pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strncmp"]
  pub fn SDL_strncmp(
    str1: *const libc::c_char,
    str2: *const libc::c_char,
    maxlen: usize,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strcasecmp"]
  pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_strncasecmp"]
  pub fn SDL_strncasecmp(
    str1: *const libc::c_char,
    str2: *const libc::c_char,
    len: usize,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_sscanf"]
  pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_vsscanf"]
  pub fn SDL_vsscanf(
    text: *const libc::c_char,
    fmt: *const libc::c_char,
    ap: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_snprintf"]
  pub fn SDL_snprintf(
    text: *mut libc::c_char,
    maxlen: usize,
    fmt: *const libc::c_char,
    ...
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_vsnprintf"]
  pub fn SDL_vsnprintf(
    text: *mut libc::c_char,
    maxlen: usize,
    fmt: *const libc::c_char,
    ap: *mut __va_list_tag,
  ) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_acos"]
  pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_acosf"]
  pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_asin"]
  pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_asinf"]
  pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_atan"]
  pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_atanf"]
  pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_atan2"]
  pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_atan2f"]
  pub fn SDL_atan2f(x: f32, y: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ceil"]
  pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ceilf"]
  pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_copysign"]
  pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_copysignf"]
  pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_cos"]
  pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_cosf"]
  pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_exp"]
  pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_expf"]
  pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_fabs"]
  pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_fabsf"]
  pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_floor"]
  pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_floorf"]
  pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_fmod"]
  pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_fmodf"]
  pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_log"]
  pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_logf"]
  pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_log10"]
  pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_log10f"]
  pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_pow"]
  pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_powf"]
  pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_scalbn"]
  pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_scalbnf"]
  pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_sin"]
  pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_sinf"]
  pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_sqrt"]
  pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_sqrtf"]
  pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_tan"]
  pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_tanf"]
  pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_iconv_t {
  _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
  #[link_name = "\u{1}_SDL_iconv_open"]
  pub fn SDL_iconv_open(tocode: *const libc::c_char, fromcode: *const libc::c_char) -> SDL_iconv_t;
}
extern "C" {
  #[link_name = "\u{1}_SDL_iconv_close"]
  pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_iconv"]
  pub fn SDL_iconv(
    cd: SDL_iconv_t,
    inbuf: *mut *const libc::c_char,
    inbytesleft: *mut usize,
    outbuf: *mut *mut libc::c_char,
    outbytesleft: *mut usize,
  ) -> usize;
}
extern "C" {
  #[doc = "  This function converts a string between encodings in one pass, returning a"]
  #[doc = "  string that must be freed with SDL_free() or NULL on error."]
  #[link_name = "\u{1}_SDL_iconv_string"]
  pub fn SDL_iconv_string(
    tocode: *const libc::c_char,
    fromcode: *const libc::c_char,
    inbuf: *const libc::c_char,
    inbytesleft: usize,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  The prototype for the application's main() function"]
  #[link_name = "\u{1}_SDL_main"]
  pub fn SDL_main(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is called by the real SDL main function to let the rest of the"]
  #[doc = "  library know that initialization was done properly."]
  #[doc = ""]
  #[doc = "  Calling this yourself without knowing what you're doing can cause"]
  #[doc = "  crashes and hard to diagnose problems with your application."]
  #[link_name = "\u{1}_SDL_SetMainReady"]
  pub fn SDL_SetMainReady();
}
pub mod SDL_AssertState {
  pub type Type = u32;
  #[doc = "< Retry the assert immediately."]
  pub const SDL_ASSERTION_RETRY: Type = 0;
  #[doc = "< Make the debugger trigger a breakpoint."]
  pub const SDL_ASSERTION_BREAK: Type = 1;
  #[doc = "< Terminate the program."]
  pub const SDL_ASSERTION_ABORT: Type = 2;
  #[doc = "< Ignore the assert."]
  pub const SDL_ASSERTION_IGNORE: Type = 3;
  #[doc = "< Ignore the assert from now on."]
  pub const SDL_ASSERTION_ALWAYS_IGNORE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AssertData {
  pub always_ignore: libc::c_int,
  pub trigger_count: libc::c_uint,
  pub condition: *const libc::c_char,
  pub filename: *const libc::c_char,
  pub linenum: libc::c_int,
  pub function: *const libc::c_char,
  pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AssertData>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_AssertData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AssertData>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_AssertData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).always_ignore as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(always_ignore)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).trigger_count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(trigger_count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).condition as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(condition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).filename as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(filename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).linenum as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(linenum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).function as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(function)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).next as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(next)
    )
  );
}
impl Default for SDL_AssertData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReportAssertion"]
  pub fn SDL_ReportAssertion(
    arg1: *mut SDL_AssertData,
    arg2: *const libc::c_char,
    arg3: *const libc::c_char,
    arg4: libc::c_int,
  ) -> SDL_AssertState::Type;
}
pub type SDL_AssertionHandler = ::core::option::Option<
  unsafe extern "C" fn(
    data: *const SDL_AssertData,
    userdata: *mut libc::c_void,
  ) -> SDL_AssertState::Type,
>;
extern "C" {
  #[doc = "  \\brief Set an application-defined assertion handler."]
  #[doc = ""]
  #[doc = "  This allows an app to show its own assertion UI and/or force the"]
  #[doc = "  response to an assertion failure. If the app doesn't provide this, SDL"]
  #[doc = "  will try to do the right thing, popping up a system-specific GUI dialog,"]
  #[doc = "  and probably minimizing any fullscreen windows."]
  #[doc = ""]
  #[doc = "  This callback may fire from any thread, but it runs wrapped in a mutex, so"]
  #[doc = "  it will only fire from one thread at a time."]
  #[doc = ""]
  #[doc = "  Setting the callback to NULL restores SDL's original internal handler."]
  #[doc = ""]
  #[doc = "  This callback is NOT reset to SDL's internal handler upon SDL_Quit()!"]
  #[doc = ""]
  #[doc = "  Return SDL_AssertState value of how to handle the assertion failure."]
  #[doc = ""]
  #[doc = "  \\param handler Callback function, called when an assertion fails."]
  #[doc = "  \\param userdata A pointer passed to the callback as-is."]
  #[link_name = "\u{1}_SDL_SetAssertionHandler"]
  pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  \\brief Get the default assertion handler."]
  #[doc = ""]
  #[doc = "  This returns the function pointer that is called by default when an"]
  #[doc = "   assertion is triggered. This is an internal function provided by SDL,"]
  #[doc = "   that is used for assertions when SDL_SetAssertionHandler() hasn't been"]
  #[doc = "   used to provide a different function."]
  #[doc = ""]
  #[doc = "  \\return The default SDL_AssertionHandler that is called when an assert triggers."]
  #[link_name = "\u{1}_SDL_GetDefaultAssertionHandler"]
  pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
  #[doc = "  \\brief Get the current assertion handler."]
  #[doc = ""]
  #[doc = "  This returns the function pointer that is called when an assertion is"]
  #[doc = "   triggered. This is either the value last passed to"]
  #[doc = "   SDL_SetAssertionHandler(), or if no application-specified function is"]
  #[doc = "   set, is equivalent to calling SDL_GetDefaultAssertionHandler()."]
  #[doc = ""]
  #[doc = "   \\param puserdata Pointer to a void*, which will store the \"userdata\""]
  #[doc = "                    pointer that was passed to SDL_SetAssertionHandler()."]
  #[doc = "                    This value will always be NULL for the default handler."]
  #[doc = "                    If you don't care about this data, it is safe to pass"]
  #[doc = "                    a NULL pointer to this function to ignore it."]
  #[doc = "  \\return The SDL_AssertionHandler that is called when an assert triggers."]
  #[link_name = "\u{1}_SDL_GetAssertionHandler"]
  pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
extern "C" {
  #[doc = "  \\brief Get a list of all assertion failures."]
  #[doc = ""]
  #[doc = "  Get all assertions triggered since last call to SDL_ResetAssertionReport(),"]
  #[doc = "  or the start of the program."]
  #[doc = ""]
  #[doc = "  The proper way to examine this data looks something like this:"]
  #[doc = ""]
  #[doc = "  <code>"]
  #[doc = "  const SDL_AssertData *item = SDL_GetAssertionReport();"]
  #[doc = "  while (item) {"]
  #[doc = "      printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\","]
  #[doc = "             item->condition, item->function, item->filename,"]
  #[doc = "             item->linenum, item->trigger_count,"]
  #[doc = "             item->always_ignore ? \"yes\" : \"no\");"]
  #[doc = "      item = item->next;"]
  #[doc = "  }"]
  #[doc = "  </code>"]
  #[doc = ""]
  #[doc = "  \\return List of all assertions."]
  #[doc = "  \\sa SDL_ResetAssertionReport"]
  #[link_name = "\u{1}_SDL_GetAssertionReport"]
  pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
  #[doc = "  \\brief Reset the list of all assertion failures."]
  #[doc = ""]
  #[doc = "  Reset list of all assertions triggered."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetAssertionReport"]
  #[link_name = "\u{1}_SDL_ResetAssertionReport"]
  pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = libc::c_int;
extern "C" {
  #[doc = " \\brief Try to lock a spin lock by setting it to a non-zero value."]
  #[doc = ""]
  #[doc = " \\param lock Points to the lock."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held."]
  #[link_name = "\u{1}_SDL_AtomicTryLock"]
  pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Lock a spin lock by setting it to a non-zero value."]
  #[doc = ""]
  #[doc = " \\param lock Points to the lock."]
  #[link_name = "\u{1}_SDL_AtomicLock"]
  pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
  #[doc = " \\brief Unlock a spin lock by setting it to 0. Always returns immediately"]
  #[doc = ""]
  #[doc = " \\param lock Points to the lock."]
  #[link_name = "\u{1}_SDL_AtomicUnlock"]
  pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
  #[doc = " Memory barriers are designed to prevent reads and writes from being"]
  #[doc = " reordered by the compiler and being seen out of order on multi-core CPUs."]
  #[doc = ""]
  #[doc = " A typical pattern would be for thread A to write some data and a flag,"]
  #[doc = " and for thread B to read the flag and get the data. In this case you"]
  #[doc = " would insert a release barrier between writing the data and the flag,"]
  #[doc = " guaranteeing that the data write completes no later than the flag is"]
  #[doc = " written, and you would insert an acquire barrier between reading the"]
  #[doc = " flag and reading the data, to ensure that all the reads associated"]
  #[doc = " with the flag have completed."]
  #[doc = ""]
  #[doc = " In this pattern you should always see a release barrier paired with"]
  #[doc = " an acquire barrier and you should gate the data reads/writes with a"]
  #[doc = " single flag variable."]
  #[doc = ""]
  #[doc = " For more information on these semantics, take a look at the blog post:"]
  #[doc = " http://preshing.com/20120913/acquire-and-release-semantics"]
  #[link_name = "\u{1}_SDL_MemoryBarrierReleaseFunction"]
  pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
  #[link_name = "\u{1}_SDL_MemoryBarrierAcquireFunction"]
  pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " \\brief A type representing an atomic integer value.  It is a struct"]
#[doc = "        so people don't accidentally use numeric operations on it."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_atomic_t {
  pub value: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
  assert_eq!(
    ::core::mem::size_of::<SDL_atomic_t>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_atomic_t))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_atomic_t>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_atomic_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_atomic_t>())).value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_atomic_t),
      "::",
      stringify!(value)
    )
  );
}
extern "C" {
  #[doc = " \\brief Set an atomic variable to a new value if it is currently an old value."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = " \\note If you don't know what this function is for, you shouldn't use it!"]
  #[link_name = "\u{1}_SDL_AtomicCAS"]
  pub fn SDL_AtomicCAS(
    a: *mut SDL_atomic_t,
    oldval: libc::c_int,
    newval: libc::c_int,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Set an atomic variable to a value."]
  #[doc = ""]
  #[doc = " \\return The previous value of the atomic variable."]
  #[link_name = "\u{1}_SDL_AtomicSet"]
  pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get the value of an atomic variable"]
  #[link_name = "\u{1}_SDL_AtomicGet"]
  pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Add to an atomic variable."]
  #[doc = ""]
  #[doc = " \\return The previous value of the atomic variable."]
  #[doc = ""]
  #[doc = " \\note This same style can be used for any number operation"]
  #[link_name = "\u{1}_SDL_AtomicAdd"]
  pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Set a pointer to a new value if it is currently an old value."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the pointer was set, SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = " \\note If you don't know what this function is for, you shouldn't use it!"]
  #[link_name = "\u{1}_SDL_AtomicCASPtr"]
  pub fn SDL_AtomicCASPtr(
    a: *mut *mut libc::c_void,
    oldval: *mut libc::c_void,
    newval: *mut libc::c_void,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Set a pointer to a value atomically."]
  #[doc = ""]
  #[doc = " \\return The previous value of the pointer."]
  #[link_name = "\u{1}_SDL_AtomicSetPtr"]
  pub fn SDL_AtomicSetPtr(a: *mut *mut libc::c_void, v: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
  #[doc = " \\brief Get the value of a pointer atomically."]
  #[link_name = "\u{1}_SDL_AtomicGetPtr"]
  pub fn SDL_AtomicGetPtr(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_SetError"]
  pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_GetError"]
  pub fn SDL_GetError() -> *const libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ClearError"]
  pub fn SDL_ClearError();
}
pub mod SDL_errorcode {
  pub type Type = u32;
  pub const SDL_ENOMEM: Type = 0;
  pub const SDL_EFREAD: Type = 1;
  pub const SDL_EFWRITE: Type = 2;
  pub const SDL_EFSEEK: Type = 3;
  pub const SDL_UNSUPPORTED: Type = 4;
  pub const SDL_LASTERROR: Type = 5;
}
extern "C" {
  #[link_name = "\u{1}_SDL_Error"]
  pub fn SDL_Error(code: SDL_errorcode::Type) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "  Create a mutex, initialized unlocked."]
  #[link_name = "\u{1}_SDL_CreateMutex"]
  pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
  #[link_name = "\u{1}_SDL_LockMutex"]
  pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[doc = "  Try to lock the mutex"]
  #[doc = ""]
  #[doc = "  \\return 0, SDL_MUTEX_TIMEDOUT, or -1 on error"]
  #[link_name = "\u{1}_SDL_TryLockMutex"]
  pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_UnlockMutex"]
  pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[doc = "  Destroy a mutex."]
  #[link_name = "\u{1}_SDL_DestroyMutex"]
  pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
  _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
  #[doc = "  Create a semaphore, initialized with value, returns NULL on failure."]
  #[link_name = "\u{1}_SDL_CreateSemaphore"]
  pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
  #[doc = "  Destroy a semaphore."]
  #[link_name = "\u{1}_SDL_DestroySemaphore"]
  pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
  #[doc = "  This function suspends the calling thread until the semaphore pointed"]
  #[doc = "  to by \\c sem has a positive count. It then atomically decreases the"]
  #[doc = "  semaphore count."]
  #[link_name = "\u{1}_SDL_SemWait"]
  pub fn SDL_SemWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  #[doc = "  Non-blocking variant of SDL_SemWait()."]
  #[doc = ""]
  #[doc = "  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would"]
  #[doc = "          block, and -1 on error."]
  #[link_name = "\u{1}_SDL_SemTryWait"]
  pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  #[doc = "  Variant of SDL_SemWait() with a timeout in milliseconds."]
  #[doc = ""]
  #[doc = "  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not"]
  #[doc = "          succeed in the allotted time, and -1 on error."]
  #[doc = ""]
  #[doc = "  \\warning On some platforms this function is implemented by looping with a"]
  #[doc = "           delay of 1 ms, and so should be avoided if possible."]
  #[link_name = "\u{1}_SDL_SemWaitTimeout"]
  pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  Atomically increases the semaphore's count (not blocking)."]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 on error."]
  #[link_name = "\u{1}_SDL_SemPost"]
  pub fn SDL_SemPost(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  #[doc = "  Returns the current count of the semaphore."]
  #[link_name = "\u{1}_SDL_SemValue"]
  pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "  Create a condition variable."]
  #[doc = ""]
  #[doc = "  Typical use of condition variables:"]
  #[doc = ""]
  #[doc = "  Thread A:"]
  #[doc = "    SDL_LockMutex(lock);"]
  #[doc = "    while ( ! condition ) {"]
  #[doc = "        SDL_CondWait(cond, lock);"]
  #[doc = "    }"]
  #[doc = "    SDL_UnlockMutex(lock);"]
  #[doc = ""]
  #[doc = "  Thread B:"]
  #[doc = "    SDL_LockMutex(lock);"]
  #[doc = "    ..."]
  #[doc = "    condition = true;"]
  #[doc = "    ..."]
  #[doc = "    SDL_CondSignal(cond);"]
  #[doc = "    SDL_UnlockMutex(lock);"]
  #[doc = ""]
  #[doc = "  There is some discussion whether to signal the condition variable"]
  #[doc = "  with the mutex locked or not.  There is some potential performance"]
  #[doc = "  benefit to unlocking first on some platforms, but there are some"]
  #[doc = "  potential race conditions depending on how your code is structured."]
  #[doc = ""]
  #[doc = "  In general it's safer to signal the condition variable while the"]
  #[doc = "  mutex is locked."]
  #[link_name = "\u{1}_SDL_CreateCond"]
  pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
  #[doc = "  Destroy a condition variable."]
  #[link_name = "\u{1}_SDL_DestroyCond"]
  pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
  #[doc = "  Restart one of the threads that are waiting on the condition variable."]
  #[doc = ""]
  #[doc = "  \\return 0 or -1 on error."]
  #[link_name = "\u{1}_SDL_CondSignal"]
  pub fn SDL_CondSignal(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
  #[doc = "  Restart all threads that are waiting on the condition variable."]
  #[doc = ""]
  #[doc = "  \\return 0 or -1 on error."]
  #[link_name = "\u{1}_SDL_CondBroadcast"]
  pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
  #[doc = "  Wait on the condition variable, unlocking the provided mutex."]
  #[doc = ""]
  #[doc = "  \\warning The mutex must be locked before entering this function!"]
  #[doc = ""]
  #[doc = "  The mutex is re-locked once the condition variable is signaled."]
  #[doc = ""]
  #[doc = "  \\return 0 when it is signaled, or -1 on error."]
  #[link_name = "\u{1}_SDL_CondWait"]
  pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[doc = "  Waits for at most \\c ms milliseconds, and returns 0 if the condition"]
  #[doc = "  variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not"]
  #[doc = "  signaled in the allotted time, and -1 on error."]
  #[doc = ""]
  #[doc = "  \\warning On some platforms this function is implemented by looping with a"]
  #[doc = "           delay of 1 ms, and so should be avoided if possible."]
  #[link_name = "\u{1}_SDL_CondWaitTimeout"]
  pub fn SDL_CondWaitTimeout(cond: *mut SDL_cond, mutex: *mut SDL_mutex, ms: Uint32)
    -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
  _unused: [u8; 0],
}
pub type SDL_threadID = libc::c_ulong;
pub type SDL_TLSID = libc::c_uint;
pub mod SDL_ThreadPriority {
  #[doc = "  The SDL thread priority."]
  #[doc = ""]
  #[doc = "  \\note On many systems you require special privileges to set high or time critical priority."]
  pub type Type = u32;
  pub const SDL_THREAD_PRIORITY_LOW: Type = 0;
  pub const SDL_THREAD_PRIORITY_NORMAL: Type = 1;
  pub const SDL_THREAD_PRIORITY_HIGH: Type = 2;
  pub const SDL_THREAD_PRIORITY_TIME_CRITICAL: Type = 3;
}
#[doc = "  The function passed to SDL_CreateThread()."]
#[doc = "  It is passed a void* user context parameter and returns an int."]
pub type SDL_ThreadFunction =
  ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> libc::c_int>;
extern "C" {
  #[doc = "  Create a thread with a default stack size."]
  #[doc = ""]
  #[doc = "  This is equivalent to calling:"]
  #[doc = "  SDL_CreateThreadWithStackSize(fn, name, 0, data);"]
  #[link_name = "\u{1}_SDL_CreateThread"]
  pub fn SDL_CreateThread(
    fn_: SDL_ThreadFunction,
    name: *const libc::c_char,
    data: *mut libc::c_void,
  ) -> *mut SDL_Thread;
}
extern "C" {
  #[doc = "  Create a thread."]
  #[doc = ""]
  #[doc = "   Thread naming is a little complicated: Most systems have very small"]
  #[doc = "    limits for the string length (Haiku has 32 bytes, Linux currently has 16,"]
  #[doc = "    Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll"]
  #[doc = "    have to see what happens with your system's debugger. The name should be"]
  #[doc = "    UTF-8 (but using the naming limits of C identifiers is a better bet)."]
  #[doc = "   There are no requirements for thread naming conventions, so long as the"]
  #[doc = "    string is null-terminated UTF-8, but these guidelines are helpful in"]
  #[doc = "    choosing a name:"]
  #[doc = ""]
  #[doc = "    http://stackoverflow.com/questions/149932/naming-conventions-for-threads"]
  #[doc = ""]
  #[doc = "   If a system imposes requirements, SDL will try to munge the string for"]
  #[doc = "    it (truncate, etc), but the original string contents will be available"]
  #[doc = "    from SDL_GetThreadName()."]
  #[doc = ""]
  #[doc = "   The size (in bytes) of the new stack can be specified. Zero means \"use"]
  #[doc = "    the system default\" which might be wildly different between platforms"]
  #[doc = "    (x86 Linux generally defaults to eight megabytes, an embedded device"]
  #[doc = "    might be a few kilobytes instead)."]
  #[doc = ""]
  #[doc = "   In SDL 2.1, stacksize will be folded into the original SDL_CreateThread"]
  #[doc = "    function."]
  #[link_name = "\u{1}_SDL_CreateThreadWithStackSize"]
  pub fn SDL_CreateThreadWithStackSize(
    fn_: SDL_ThreadFunction,
    name: *const libc::c_char,
    stacksize: usize,
    data: *mut libc::c_void,
  ) -> *mut SDL_Thread;
}
extern "C" {
  #[doc = " Get the thread name, as it was specified in SDL_CreateThread()."]
  #[doc = "  This function returns a pointer to a UTF-8 string that names the"]
  #[doc = "  specified thread, or NULL if it doesn't have a name. This is internal"]
  #[doc = "  memory, not to be free()'d by the caller, and remains valid until the"]
  #[doc = "  specified thread is cleaned up by SDL_WaitThread()."]
  #[link_name = "\u{1}_SDL_GetThreadName"]
  pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the thread identifier for the current thread."]
  #[link_name = "\u{1}_SDL_ThreadID"]
  pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
  #[doc = "  Get the thread identifier for the specified thread."]
  #[doc = ""]
  #[doc = "  Equivalent to SDL_ThreadID() if the specified thread is NULL."]
  #[link_name = "\u{1}_SDL_GetThreadID"]
  pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
  #[doc = "  Set the priority for the current thread"]
  #[link_name = "\u{1}_SDL_SetThreadPriority"]
  pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority::Type) -> libc::c_int;
}
extern "C" {
  #[doc = "  Wait for a thread to finish. Threads that haven't been detached will"]
  #[doc = "  remain (as a \"zombie\") until this function cleans them up. Not doing so"]
  #[doc = "  is a resource leak."]
  #[doc = ""]
  #[doc = "  Once a thread has been cleaned up through this function, the SDL_Thread"]
  #[doc = "  that references it becomes invalid and should not be referenced again."]
  #[doc = "  As such, only one thread may call SDL_WaitThread() on another."]
  #[doc = ""]
  #[doc = "  The return code for the thread function is placed in the area"]
  #[doc = "  pointed to by \\c status, if \\c status is not NULL."]
  #[doc = ""]
  #[doc = "  You may not wait on a thread that has been used in a call to"]
  #[doc = "  SDL_DetachThread(). Use either that function or this one, but not"]
  #[doc = "  both, or behavior is undefined."]
  #[doc = ""]
  #[doc = "  It is safe to pass NULL to this function; it is a no-op."]
  #[link_name = "\u{1}_SDL_WaitThread"]
  pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
extern "C" {
  #[doc = "  A thread may be \"detached\" to signify that it should not remain until"]
  #[doc = "  another thread has called SDL_WaitThread() on it. Detaching a thread"]
  #[doc = "  is useful for long-running threads that nothing needs to synchronize"]
  #[doc = "  with or further manage. When a detached thread is done, it simply"]
  #[doc = "  goes away."]
  #[doc = ""]
  #[doc = "  There is no way to recover the return code of a detached thread. If you"]
  #[doc = "  need this, don't detach the thread and instead use SDL_WaitThread()."]
  #[doc = ""]
  #[doc = "  Once a thread is detached, you should usually assume the SDL_Thread isn't"]
  #[doc = "  safe to reference again, as it will become invalid immediately upon"]
  #[doc = "  the detached thread's exit, instead of remaining until someone has called"]
  #[doc = "  SDL_WaitThread() to finally clean it up. As such, don't detach the same"]
  #[doc = "  thread more than once."]
  #[doc = ""]
  #[doc = "  If a thread has already exited when passed to SDL_DetachThread(), it will"]
  #[doc = "  stop waiting for a call to SDL_WaitThread() and clean up immediately."]
  #[doc = "  It is not safe to detach a thread that might be used with SDL_WaitThread()."]
  #[doc = ""]
  #[doc = "  You may not call SDL_WaitThread() on a thread that has been detached."]
  #[doc = "  Use either that function or this one, but not both, or behavior is"]
  #[doc = "  undefined."]
  #[doc = ""]
  #[doc = "  It is safe to pass NULL to this function; it is a no-op."]
  #[link_name = "\u{1}_SDL_DetachThread"]
  pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
  #[doc = "  \\brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific."]
  #[doc = ""]
  #[doc = "  \\return The newly created thread local storage identifier, or 0 on error"]
  #[doc = ""]
  #[doc = "  \\code"]
  #[doc = "  static SDL_SpinLock tls_lock;"]
  #[doc = "  static SDL_TLSID thread_local_storage;"]
  #[doc = ""]
  #[doc = "  void SetMyThreadData(void *value)"]
  #[doc = "  {"]
  #[doc = "      if (!thread_local_storage) {"]
  #[doc = "          SDL_AtomicLock(&tls_lock);"]
  #[doc = "          if (!thread_local_storage) {"]
  #[doc = "              thread_local_storage = SDL_TLSCreate();"]
  #[doc = "          }"]
  #[doc = "          SDL_AtomicUnlock(&tls_lock);"]
  #[doc = "      }"]
  #[doc = "      SDL_TLSSet(thread_local_storage, value, 0);"]
  #[doc = "  }"]
  #[doc = ""]
  #[doc = "  void *GetMyThreadData(void)"]
  #[doc = "  {"]
  #[doc = "      return SDL_TLSGet(thread_local_storage);"]
  #[doc = "  }"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  \\sa SDL_TLSGet()"]
  #[doc = "  \\sa SDL_TLSSet()"]
  #[link_name = "\u{1}_SDL_TLSCreate"]
  pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
  #[doc = "  \\brief Get the value associated with a thread local storage ID for the current thread."]
  #[doc = ""]
  #[doc = "  \\param id The thread local storage ID"]
  #[doc = ""]
  #[doc = "  \\return The value associated with the ID for the current thread, or NULL if no value has been set."]
  #[doc = ""]
  #[doc = "  \\sa SDL_TLSCreate()"]
  #[doc = "  \\sa SDL_TLSSet()"]
  #[link_name = "\u{1}_SDL_TLSGet"]
  pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Set the value associated with a thread local storage ID for the current thread."]
  #[doc = ""]
  #[doc = "  \\param id The thread local storage ID"]
  #[doc = "  \\param value The value to associate with the ID for the current thread"]
  #[doc = "  \\param destructor A function called when the thread exits, to free the value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_TLSCreate()"]
  #[doc = "  \\sa SDL_TLSGet()"]
  #[link_name = "\u{1}_SDL_TLSSet"]
  pub fn SDL_TLSSet(
    id: SDL_TLSID,
    value: *const libc::c_void,
    destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
  ) -> libc::c_int;
}
#[doc = " This is the read/write operation structure -- very basic."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
  #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
  pub size: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
  #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio's whence values:"]
  #[doc = "  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END"]
  #[doc = ""]
  #[doc = "  \\return the final offset in the data stream, or -1 on error."]
  pub seek: ::core::option::Option<
    unsafe extern "C" fn(context: *mut SDL_RWops, offset: Sint64, whence: libc::c_int) -> Sint64,
  >,
  #[doc = "  Read up to \\c maxnum objects each of size \\c size from the data"]
  #[doc = "  stream to the area pointed at by \\c ptr."]
  #[doc = ""]
  #[doc = "  \\return the number of objects read, or 0 at error or end of file."]
  pub read: ::core::option::Option<
    unsafe extern "C" fn(
      context: *mut SDL_RWops,
      ptr: *mut libc::c_void,
      size: usize,
      maxnum: usize,
    ) -> usize,
  >,
  #[doc = "  Write exactly \\c num objects each of size \\c size from the area"]
  #[doc = "  pointed at by \\c ptr to data stream."]
  #[doc = ""]
  #[doc = "  \\return the number of objects written, or 0 at error or end of file."]
  pub write: ::core::option::Option<
    unsafe extern "C" fn(
      context: *mut SDL_RWops,
      ptr: *const libc::c_void,
      size: usize,
      num: usize,
    ) -> usize,
  >,
  #[doc = "  Close and free an allocated SDL_RWops structure."]
  #[doc = ""]
  #[doc = "  \\return 0 if successful or -1 on write error when flushing data."]
  pub close: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> libc::c_int>,
  pub type_: Uint32,
  pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
  pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
  pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
  pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
  pub autoclose: SDL_bool::Type,
  pub fp: *mut FILE,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).autoclose as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(autoclose)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).fp as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(fp)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
  pub base: *mut Uint8,
  pub here: *mut Uint8,
  pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).base as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).here as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(here)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).stop as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(stop)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
  pub data1: *mut libc::c_void,
  pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data2 as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(data2)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).stdio as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(stdio)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).mem as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(mem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).unknown as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(unknown)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_RWops__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_RWops__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops>(),
    72usize,
    concat!("Size of: ", stringify!(SDL_RWops))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_RWops))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).seek as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(seek)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).read as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(read)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).write as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(write)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).close as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(close)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).type_ as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).hidden as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(hidden)
    )
  );
}
impl Default for SDL_RWops {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_RWops {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "SDL_RWops {{ size: {:?}, seek: {:?}, read: {:?}, write: {:?}, close: {:?}, type: {:?}, hidden: {:?} }}" , self . size , self . seek , self . read , self . write , self . close , self . type_ , self . hidden )
  }
}
extern "C" {
  #[link_name = "\u{1}_SDL_RWFromFile"]
  pub fn SDL_RWFromFile(file: *const libc::c_char, mode: *const libc::c_char) -> *mut SDL_RWops;
}
extern "C" {
  #[link_name = "\u{1}_SDL_RWFromFP"]
  pub fn SDL_RWFromFP(fp: *mut FILE, autoclose: SDL_bool::Type) -> *mut SDL_RWops;
}
extern "C" {
  #[link_name = "\u{1}_SDL_RWFromMem"]
  pub fn SDL_RWFromMem(mem: *mut libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
  #[link_name = "\u{1}_SDL_RWFromConstMem"]
  pub fn SDL_RWFromConstMem(mem: *const libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
  #[link_name = "\u{1}_SDL_AllocRW"]
  pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
  #[link_name = "\u{1}_SDL_FreeRW"]
  pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
  #[doc = "  Load all the data from an SDL data stream."]
  #[doc = ""]
  #[doc = "  The data is allocated with a zero byte at the end (null terminated)"]
  #[doc = ""]
  #[doc = "  If \\c datasize is not NULL, it is filled with the size of the data read."]
  #[doc = ""]
  #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
  #[doc = ""]
  #[doc = "  The data should be freed with SDL_free()."]
  #[doc = ""]
  #[doc = "  \\return the data, or NULL if there was an error."]
  #[link_name = "\u{1}_SDL_LoadFile_RW"]
  pub fn SDL_LoadFile_RW(
    src: *mut SDL_RWops,
    datasize: *mut usize,
    freesrc: libc::c_int,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadU8"]
  pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadLE16"]
  pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadBE16"]
  pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadLE32"]
  pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadBE32"]
  pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadLE64"]
  pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ReadBE64"]
  pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteU8"]
  pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteLE16"]
  pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteBE16"]
  pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteLE32"]
  pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteBE32"]
  pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteLE64"]
  pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
  #[link_name = "\u{1}_SDL_WriteBE64"]
  pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
#[doc = "  \\brief Audio format flags."]
#[doc = ""]
#[doc = "  These are what the 16 bits in SDL_AudioFormat currently mean..."]
#[doc = "  (Unspecified bits are always zero)."]
#[doc = ""]
#[doc = "  \\verbatim"]
#[doc = "++-----------------------sample is signed if set"]
#[doc = "||"]
#[doc = "||       ++-----------sample is bigendian if set"]
#[doc = "||       ||"]
#[doc = "||       ||          ++---sample is float if set"]
#[doc = "||       ||          ||"]
#[doc = "||       ||          || +---sample bit size---+"]
#[doc = "||       ||          || |                     |"]
#[doc = "15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  There are macros in SDL 2.0 and later to query these bits."]
pub type SDL_AudioFormat = Uint16;
#[doc = "  This function is called when the audio device needs more data."]
#[doc = ""]
#[doc = "  \\param userdata An application-specific parameter saved in"]
#[doc = "                  the SDL_AudioSpec structure"]
#[doc = "  \\param stream A pointer to the audio data buffer."]
#[doc = "  \\param len    The length of that buffer in bytes."]
#[doc = ""]
#[doc = "  Once the callback returns, the buffer will no longer be valid."]
#[doc = "  Stereo samples are stored in a LRLRLR ordering."]
#[doc = ""]
#[doc = "  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if"]
#[doc = "  you like. Just open your audio device with a NULL callback."]
pub type SDL_AudioCallback = ::core::option::Option<
  unsafe extern "C" fn(userdata: *mut libc::c_void, stream: *mut Uint8, len: libc::c_int),
>;
#[doc = "  The calculated values in this structure are calculated by SDL_OpenAudio()."]
#[doc = ""]
#[doc = "  For multi-channel audio, the default SDL channel mapping is:"]
#[doc = "  2:  FL FR                       (stereo)"]
#[doc = "  3:  FL FR LFE                   (2.1 surround)"]
#[doc = "  4:  FL FR BL BR                 (quad)"]
#[doc = "  5:  FL FR FC BL BR              (quad + center)"]
#[doc = "  6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)"]
#[doc = "  7:  FL FR FC LFE BC SL SR       (6.1 surround)"]
#[doc = "  8:  FL FR FC LFE BL BR SL SR    (7.1 surround)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AudioSpec {
  #[doc = "< DSP frequency -- samples per second"]
  pub freq: libc::c_int,
  #[doc = "< Audio data format"]
  pub format: SDL_AudioFormat,
  #[doc = "< Number of channels: 1 mono, 2 stereo"]
  pub channels: Uint8,
  #[doc = "< Audio buffer silence value (calculated)"]
  pub silence: Uint8,
  #[doc = "< Audio buffer size in sample FRAMES (total samples divided by channel count)"]
  pub samples: Uint16,
  #[doc = "< Necessary for some compile environments"]
  pub padding: Uint16,
  #[doc = "< Audio buffer size in bytes (calculated)"]
  pub size: Uint32,
  #[doc = "< Callback that feeds the audio device (NULL to use SDL_QueueAudio())."]
  pub callback: SDL_AudioCallback,
  #[doc = "< Userdata passed to callback (ignored for NULL callbacks)."]
  pub userdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioSpec>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_AudioSpec))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioSpec>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_AudioSpec))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).freq as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(freq)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).channels as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).silence as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(silence)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).samples as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).padding as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).size as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).callback as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(callback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).userdata as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(userdata)
    )
  );
}
impl Default for SDL_AudioSpec {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SDL_AudioFilter =
  ::core::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AudioCVT {
  #[doc = "< Set to 1 if conversion possible"]
  pub needed: libc::c_int,
  #[doc = "< Source audio format"]
  pub src_format: SDL_AudioFormat,
  #[doc = "< Target audio format"]
  pub dst_format: SDL_AudioFormat,
  #[doc = "< Rate conversion increment"]
  pub rate_incr: f64,
  #[doc = "< Buffer to hold entire audio data"]
  pub buf: *mut Uint8,
  #[doc = "< Length of original audio buffer"]
  pub len: libc::c_int,
  #[doc = "< Length of converted audio buffer"]
  pub len_cvt: libc::c_int,
  #[doc = "< buffer must be len*len_mult big"]
  pub len_mult: libc::c_int,
  #[doc = "< Given len, final size is len*len_ratio"]
  pub len_ratio: f64,
  #[doc = "< NULL-terminated list of filter functions"]
  pub filters: [SDL_AudioFilter; 10usize],
  #[doc = "< Current audio conversion function"]
  pub filter_index: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioCVT>(),
    128usize,
    concat!("Size of: ", stringify!(SDL_AudioCVT))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioCVT>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_AudioCVT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).needed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(needed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).src_format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(src_format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).dst_format as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(dst_format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).rate_incr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(rate_incr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).buf as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_cvt as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_cvt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_mult as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_mult)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_ratio as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_ratio)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filters as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(filters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filter_index as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(filter_index)
    )
  );
}
impl Default for SDL_AudioCVT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[link_name = "\u{1}_SDL_GetNumAudioDrivers"]
  pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_GetAudioDriver"]
  pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[link_name = "\u{1}_SDL_AudioInit"]
  pub fn SDL_AudioInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_AudioQuit"]
  pub fn SDL_AudioQuit();
}
extern "C" {
  #[doc = "  This function returns the name of the current audio driver, or NULL"]
  #[doc = "  if no driver has been initialized."]
  #[link_name = "\u{1}_SDL_GetCurrentAudioDriver"]
  pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
extern "C" {
  #[doc = "  This function opens the audio device with the desired parameters, and"]
  #[doc = "  returns 0 if successful, placing the actual hardware parameters in the"]
  #[doc = "  structure pointed to by \\c obtained.  If \\c obtained is NULL, the audio"]
  #[doc = "  data passed to the callback function will be guaranteed to be in the"]
  #[doc = "  requested format, and will be automatically converted to the hardware"]
  #[doc = "  audio format if necessary.  This function returns -1 if it failed"]
  #[doc = "  to open the audio device, or couldn't set up the audio thread."]
  #[doc = ""]
  #[doc = "  When filling in the desired audio spec structure,"]
  #[doc = "    - \\c desired->freq should be the desired audio frequency in samples-per-"]
  #[doc = "      second."]
  #[doc = "    - \\c desired->format should be the desired audio format."]
  #[doc = "    - \\c desired->samples is the desired size of the audio buffer, in"]
  #[doc = "      samples.  This number should be a power of two, and may be adjusted by"]
  #[doc = "      the audio driver to a value more suitable for the hardware.  Good values"]
  #[doc = "      seem to range between 512 and 8096 inclusive, depending on the"]
  #[doc = "      application and CPU speed.  Smaller values yield faster response time,"]
  #[doc = "      but can lead to underflow if the application is doing heavy processing"]
  #[doc = "      and cannot fill the audio buffer in time.  A stereo sample consists of"]
  #[doc = "      both right and left channels in LR ordering."]
  #[doc = "      Note that the number of samples is directly related to time by the"]
  #[doc = "      following formula:  \\code ms = (samples*1000)/freq \\endcode"]
  #[doc = "    - \\c desired->size is the size in bytes of the audio buffer, and is"]
  #[doc = "      calculated by SDL_OpenAudio()."]
  #[doc = "    - \\c desired->silence is the value used to set the buffer to silence,"]
  #[doc = "      and is calculated by SDL_OpenAudio()."]
  #[doc = "    - \\c desired->callback should be set to a function that will be called"]
  #[doc = "      when the audio device is ready for more data.  It is passed a pointer"]
  #[doc = "      to the audio buffer, and the length in bytes of the audio buffer."]
  #[doc = "      This function usually runs in a separate thread, and so you should"]
  #[doc = "      protect data structures that it accesses by calling SDL_LockAudio()"]
  #[doc = "      and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL"]
  #[doc = "      pointer here, and call SDL_QueueAudio() with some frequency, to queue"]
  #[doc = "      more audio samples to be played (or for capture devices, call"]
  #[doc = "      SDL_DequeueAudio() with some frequency, to obtain audio samples)."]
  #[doc = "    - \\c desired->userdata is passed as the first parameter to your callback"]
  #[doc = "      function. If you passed a NULL callback, this value is ignored."]
  #[doc = ""]
  #[doc = "  The audio device starts out playing silence when it's opened, and should"]
  #[doc = "  be enabled for playing by calling \\c SDL_PauseAudio(0) when you are ready"]
  #[doc = "  for your audio callback function to be called.  Since the audio driver"]
  #[doc = "  may modify the requested size of the audio buffer, you should allocate"]
  #[doc = "  any local mixing buffers after you open the audio device."]
  #[link_name = "\u{1}_SDL_OpenAudio"]
  pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec, obtained: *mut SDL_AudioSpec) -> libc::c_int;
}
#[doc = "  SDL Audio Device IDs."]
#[doc = ""]
#[doc = "  A successful call to SDL_OpenAudio() is always device id 1, and legacy"]
#[doc = "  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls"]
#[doc = "  always returns devices >= 2 on success. The legacy calls are good both"]
#[doc = "  for backwards compatibility and when you don't care about multiple,"]
#[doc = "  specific, or capture devices."]
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
  #[doc = "  Get the number of available devices exposed by the current driver."]
  #[doc = "  Only valid after a successfully initializing the audio subsystem."]
  #[doc = "  Returns -1 if an explicit list of devices can't be determined; this is"]
  #[doc = "  not an error. For example, if SDL is set up to talk to a remote audio"]
  #[doc = "  server, it can't list every one available on the Internet, but it will"]
  #[doc = "  still allow a specific host to be specified to SDL_OpenAudioDevice()."]
  #[doc = ""]
  #[doc = "  In many common cases, when this function returns a value <= 0, it can still"]
  #[doc = "  successfully open the default device (NULL for first argument of"]
  #[doc = "  SDL_OpenAudioDevice())."]
  #[link_name = "\u{1}_SDL_GetNumAudioDevices"]
  pub fn SDL_GetNumAudioDevices(iscapture: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the human-readable name of a specific audio device."]
  #[doc = "  Must be a value between 0 and (number of audio devices-1)."]
  #[doc = "  Only valid after a successfully initializing the audio subsystem."]
  #[doc = "  The values returned by this function reflect the latest call to"]
  #[doc = "  SDL_GetNumAudioDevices(); recall that function to redetect available"]
  #[doc = "  hardware."]
  #[doc = ""]
  #[doc = "  The string returned by this function is UTF-8 encoded, read-only, and"]
  #[doc = "  managed internally. You are not to free it. If you need to keep the"]
  #[doc = "  string for any length of time, you should make your own copy of it, as it"]
  #[doc = "  will be invalid next time any of several other SDL functions is called."]
  #[link_name = "\u{1}_SDL_GetAudioDeviceName"]
  pub fn SDL_GetAudioDeviceName(index: libc::c_int, iscapture: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Open a specific audio device. Passing in a device name of NULL requests"]
  #[doc = "  the most reasonable default (and is equivalent to calling SDL_OpenAudio())."]
  #[doc = ""]
  #[doc = "  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but"]
  #[doc = "  some drivers allow arbitrary and driver-specific strings, such as a"]
  #[doc = "  hostname/IP address for a remote audio server, or a filename in the"]
  #[doc = "  diskaudio driver."]
  #[doc = ""]
  #[doc = "  \\return 0 on error, a valid device ID that is >= 2 on success."]
  #[doc = ""]
  #[doc = "  SDL_OpenAudio(), unlike this function, always acts on device ID 1."]
  #[link_name = "\u{1}_SDL_OpenAudioDevice"]
  pub fn SDL_OpenAudioDevice(
    device: *const libc::c_char,
    iscapture: libc::c_int,
    desired: *const SDL_AudioSpec,
    obtained: *mut SDL_AudioSpec,
    allowed_changes: libc::c_int,
  ) -> SDL_AudioDeviceID;
}
pub mod SDL_AudioStatus {
  pub type Type = u32;
  pub const SDL_AUDIO_STOPPED: Type = 0;
  pub const SDL_AUDIO_PLAYING: Type = 1;
  pub const SDL_AUDIO_PAUSED: Type = 2;
}
extern "C" {
  #[link_name = "\u{1}_SDL_GetAudioStatus"]
  pub fn SDL_GetAudioStatus() -> SDL_AudioStatus::Type;
}
extern "C" {
  #[link_name = "\u{1}_SDL_GetAudioDeviceStatus"]
  pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus::Type;
}
extern "C" {
  #[link_name = "\u{1}_SDL_PauseAudio"]
  pub fn SDL_PauseAudio(pause_on: libc::c_int);
}
extern "C" {
  #[link_name = "\u{1}_SDL_PauseAudioDevice"]
  pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: libc::c_int);
}
extern "C" {
  #[doc = "  This function loads a WAVE from the data source, automatically freeing"]
  #[doc = "  that source if \\c freesrc is non-zero.  For example, to load a WAVE file,"]
  #[doc = "  you could do:"]
  #[doc = "  \\code"]
  #[doc = "      SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, ...);"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  If this function succeeds, it returns the given SDL_AudioSpec,"]
  #[doc = "  filled with the audio data format of the wave data, and sets"]
  #[doc = "  \\c *audio_buf to a malloc()'d buffer containing the audio data,"]
  #[doc = "  and sets \\c *audio_len to the length of that audio buffer, in bytes."]
  #[doc = "  You need to free the audio buffer with SDL_FreeWAV() when you are"]
  #[doc = "  done with it."]
  #[doc = ""]
  #[doc = "  This function returns NULL and sets the SDL error message if the"]
  #[doc = "  wave file cannot be opened, uses an unknown data format, or is"]
  #[doc = "  corrupt.  Currently raw and MS-ADPCM WAVE files are supported."]
  #[link_name = "\u{1}_SDL_LoadWAV_RW"]
  pub fn SDL_LoadWAV_RW(
    src: *mut SDL_RWops,
    freesrc: libc::c_int,
    spec: *mut SDL_AudioSpec,
    audio_buf: *mut *mut Uint8,
    audio_len: *mut Uint32,
  ) -> *mut SDL_AudioSpec;
}
extern "C" {
  #[doc = "  This function frees data previously allocated with SDL_LoadWAV_RW()"]
  #[link_name = "\u{1}_SDL_FreeWAV"]
  pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
  #[doc = "  This function takes a source format and rate and a destination format"]
  #[doc = "  and rate, and initializes the \\c cvt structure with information needed"]
  #[doc = "  by SDL_ConvertAudio() to convert a buffer of audio data from one format"]
  #[doc = "  to the other. An unsupported format causes an error and -1 will be returned."]
  #[doc = ""]
  #[doc = "  \\return 0 if no conversion is needed, 1 if the audio filter is set up,"]
  #[doc = "  or -1 on error."]
  #[link_name = "\u{1}_SDL_BuildAudioCVT"]
  pub fn SDL_BuildAudioCVT(
    cvt: *mut SDL_AudioCVT,
    src_format: SDL_AudioFormat,
    src_channels: Uint8,
    src_rate: libc::c_int,
    dst_format: SDL_AudioFormat,
    dst_channels: Uint8,
    dst_rate: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Once you have initialized the \\c cvt structure using SDL_BuildAudioCVT(),"]
  #[doc = "  created an audio buffer \\c cvt->buf, and filled it with \\c cvt->len bytes of"]
  #[doc = "  audio data in the source format, this function will convert it in-place"]
  #[doc = "  to the desired format."]
  #[doc = ""]
  #[doc = "  The data conversion may expand the size of the audio data, so the buffer"]
  #[doc = "  \\c cvt->buf should be allocated after the \\c cvt structure is initialized by"]
  #[doc = "  SDL_BuildAudioCVT(), and should be \\c cvt->len*cvt->len_mult bytes long."]
  #[doc = ""]
  #[doc = "  \\return 0 on success or -1 if \\c cvt->buf is NULL."]
  #[link_name = "\u{1}_SDL_ConvertAudio"]
  pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_AudioStream {
  _unused: [u8; 0],
}
pub type SDL_AudioStream = _SDL_AudioStream;
extern "C" {
  #[doc = "  Create a new audio stream"]
  #[doc = ""]
  #[doc = "  \\param src_format The format of the source audio"]
  #[doc = "  \\param src_channels The number of channels of the source audio"]
  #[doc = "  \\param src_rate The sampling rate of the source audio"]
  #[doc = "  \\param dst_format The format of the desired audio output"]
  #[doc = "  \\param dst_channels The number of channels of the desired audio output"]
  #[doc = "  \\param dst_rate The sampling rate of the desired audio output"]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  #[link_name = "\u{1}_SDL_NewAudioStream"]
  pub fn SDL_NewAudioStream(
    src_format: SDL_AudioFormat,
    src_channels: Uint8,
    src_rate: libc::c_int,
    dst_format: SDL_AudioFormat,
    dst_channels: Uint8,
    dst_rate: libc::c_int,
  ) -> *mut SDL_AudioStream;
}
extern "C" {
  #[doc = "  Add data to be converted/resampled to the stream"]
  #[doc = ""]
  #[doc = "  \\param stream The stream the audio data is being added to"]
  #[doc = "  \\param buf A pointer to the audio data to add"]
  #[doc = "  \\param len The number of bytes to write to the stream"]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  #[link_name = "\u{1}_SDL_AudioStreamPut"]
  pub fn SDL_AudioStreamPut(
    stream: *mut SDL_AudioStream,
    buf: *const libc::c_void,
    len: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get converted/resampled data from the stream"]
  #[doc = ""]
  #[doc = "  \\param stream The stream the audio is being requested from"]
  #[doc = "  \\param buf A buffer to fill with audio data"]
  #[doc = "  \\param len The maximum number of bytes to fill"]
  #[doc = "  \\return The number of bytes read from the stream, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  #[link_name = "\u{1}_SDL_AudioStreamGet"]
  pub fn SDL_AudioStreamGet(
    stream: *mut SDL_AudioStream,
    buf: *mut libc::c_void,
    len: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = " Get the number of converted/resampled bytes available. The stream may be"]
  #[doc = "  buffering data behind the scenes until it has enough to resample"]
  #[doc = "  correctly, so this number might be lower than what you expect, or even"]
  #[doc = "  be zero. Add more data or flush the stream if you need the data now."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  #[link_name = "\u{1}_SDL_AudioStreamAvailable"]
  pub fn SDL_AudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
  #[doc = " Tell the stream that you're done sending data, and anything being buffered"]
  #[doc = "  should be converted/resampled and made available immediately."]
  #[doc = ""]
  #[doc = " It is legal to add more data to a stream after flushing, but there will"]
  #[doc = "  be audio gaps in the output. Generally this is intended to signal the"]
  #[doc = "  end of input, so the complete output becomes available."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  #[link_name = "\u{1}_SDL_AudioStreamFlush"]
  pub fn SDL_AudioStreamFlush(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
  #[doc = "  Clear any pending data in the stream without converting it"]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  #[link_name = "\u{1}_SDL_AudioStreamClear"]
  pub fn SDL_AudioStreamClear(stream: *mut SDL_AudioStream);
}
extern "C" {
  #[doc = " Free an audio stream"]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[link_name = "\u{1}_SDL_FreeAudioStream"]
  pub fn SDL_FreeAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
  #[doc = "  This takes two audio buffers of the playing audio format and mixes"]
  #[doc = "  them, performing addition, volume adjustment, and overflow clipping."]
  #[doc = "  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME"]
  #[doc = "  for full audio volume.  Note this does not change hardware volume."]
  #[doc = "  This is provided for convenience -- you can mix your own audio data."]
  #[link_name = "\u{1}_SDL_MixAudio"]
  pub fn SDL_MixAudio(dst: *mut Uint8, src: *const Uint8, len: Uint32, volume: libc::c_int);
}
extern "C" {
  #[doc = "  This works like SDL_MixAudio(), but you specify the audio format instead of"]
  #[doc = "  using the format of audio device 1. Thus it can be used when no audio"]
  #[doc = "  device is open at all."]
  #[link_name = "\u{1}_SDL_MixAudioFormat"]
  pub fn SDL_MixAudioFormat(
    dst: *mut Uint8,
    src: *const Uint8,
    format: SDL_AudioFormat,
    len: Uint32,
    volume: libc::c_int,
  );
}
extern "C" {
  #[doc = "  Queue more audio on non-callback devices."]
  #[doc = ""]
  #[doc = "  (If you are looking to retrieve queued audio from a non-callback capture"]
  #[doc = "  device, you want SDL_DequeueAudio() instead. This will return -1 to"]
  #[doc = "  signify an error if you use it with capture devices.)"]
  #[doc = ""]
  #[doc = "  SDL offers two ways to feed audio to the device: you can either supply a"]
  #[doc = "  callback that SDL triggers with some frequency to obtain more audio"]
  #[doc = "  (pull method), or you can supply no callback, and then SDL will expect"]
  #[doc = "  you to supply data at regular intervals (push method) with this function."]
  #[doc = ""]
  #[doc = "  There are no limits on the amount of data you can queue, short of"]
  #[doc = "  exhaustion of address space. Queued data will drain to the device as"]
  #[doc = "  necessary without further intervention from you. If the device needs"]
  #[doc = "  audio but there is not enough queued, it will play silence to make up"]
  #[doc = "  the difference. This means you will have skips in your audio playback"]
  #[doc = "  if you aren't routinely queueing sufficient data."]
  #[doc = ""]
  #[doc = "  This function copies the supplied data, so you are safe to free it when"]
  #[doc = "  the function returns. This function is thread-safe, but queueing to the"]
  #[doc = "  same device from two threads at once does not promise which buffer will"]
  #[doc = "  be queued first."]
  #[doc = ""]
  #[doc = "  You may not queue audio on a device that is using an application-supplied"]
  #[doc = "  callback; doing so returns an error. You have to use the audio callback"]
  #[doc = "  or queue audio with this function, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before queueing; SDL"]
  #[doc = "  handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID to which we will queue audio."]
  #[doc = "  \\param data The data to queue to the device for later playback."]
  #[doc = "  \\param len The number of bytes (not samples!) to which (data) points."]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetQueuedAudioSize"]
  #[doc = "  \\sa SDL_ClearQueuedAudio"]
  #[link_name = "\u{1}_SDL_QueueAudio"]
  pub fn SDL_QueueAudio(
    dev: SDL_AudioDeviceID,
    data: *const libc::c_void,
    len: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Dequeue more audio on non-callback devices."]
  #[doc = ""]
  #[doc = "  (If you are looking to queue audio for output on a non-callback playback"]
  #[doc = "  device, you want SDL_QueueAudio() instead. This will always return 0"]
  #[doc = "  if you use it with playback devices.)"]
  #[doc = ""]
  #[doc = "  SDL offers two ways to retrieve audio from a capture device: you can"]
  #[doc = "  either supply a callback that SDL triggers with some frequency as the"]
  #[doc = "  device records more audio data, (push method), or you can supply no"]
  #[doc = "  callback, and then SDL will expect you to retrieve data at regular"]
  #[doc = "  intervals (pull method) with this function."]
  #[doc = ""]
  #[doc = "  There are no limits on the amount of data you can queue, short of"]
  #[doc = "  exhaustion of address space. Data from the device will keep queuing as"]
  #[doc = "  necessary without further intervention from you. This means you will"]
  #[doc = "  eventually run out of memory if you aren't routinely dequeueing data."]
  #[doc = ""]
  #[doc = "  Capture devices will not queue data when paused; if you are expecting"]
  #[doc = "  to not need captured audio for some length of time, use"]
  #[doc = "  SDL_PauseAudioDevice() to stop the capture device from queueing more"]
  #[doc = "  data. This can be useful during, say, level loading times. When"]
  #[doc = "  unpaused, capture devices will start queueing data from that point,"]
  #[doc = "  having flushed any capturable data available while paused."]
  #[doc = ""]
  #[doc = "  This function is thread-safe, but dequeueing from the same device from"]
  #[doc = "  two threads at once does not promise which thread will dequeued data"]
  #[doc = "  first."]
  #[doc = ""]
  #[doc = "  You may not dequeue audio from a device that is using an"]
  #[doc = "  application-supplied callback; doing so returns an error. You have to use"]
  #[doc = "  the audio callback, or dequeue audio with this function, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before queueing; SDL"]
  #[doc = "  handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID from which we will dequeue audio."]
  #[doc = "  \\param data A pointer into where audio data should be copied."]
  #[doc = "  \\param len The number of bytes (not samples!) to which (data) points."]
  #[doc = "  \\return number of bytes dequeued, which could be less than requested."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetQueuedAudioSize"]
  #[doc = "  \\sa SDL_ClearQueuedAudio"]
  #[link_name = "\u{1}_SDL_DequeueAudio"]
  pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID, data: *mut libc::c_void, len: Uint32) -> Uint32;
}
extern "C" {
  #[doc = "  Get the number of bytes of still-queued audio."]
  #[doc = ""]
  #[doc = "  For playback device:"]
  #[doc = ""]
  #[doc = "    This is the number of bytes that have been queued for playback with"]
  #[doc = "    SDL_QueueAudio(), but have not yet been sent to the hardware. This"]
  #[doc = "    number may shrink at any time, so this only informs of pending data."]
  #[doc = ""]
  #[doc = "    Once we've sent it to the hardware, this function can not decide the"]
  #[doc = "    exact byte boundary of what has been played. It's possible that we just"]
  #[doc = "    gave the hardware several kilobytes right before you called this"]
  #[doc = "    function, but it hasn't played any of it yet, or maybe half of it, etc."]
  #[doc = ""]
  #[doc = "  For capture devices:"]
  #[doc = ""]
  #[doc = "    This is the number of bytes that have been captured by the device and"]
  #[doc = "    are waiting for you to dequeue. This number may grow at any time, so"]
  #[doc = "    this only informs of the lower-bound of available data."]
  #[doc = ""]
  #[doc = "  You may not queue audio on a device that is using an application-supplied"]
  #[doc = "  callback; calling this function on such a device always returns 0."]
  #[doc = "  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use"]
  #[doc = "  the audio callback, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before querying; SDL"]
  #[doc = "  handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID of which we will query queued audio size."]
  #[doc = "  \\return Number of bytes (not samples!) of queued audio."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueueAudio"]
  #[doc = "  \\sa SDL_ClearQueuedAudio"]
  #[link_name = "\u{1}_SDL_GetQueuedAudioSize"]
  pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
  #[doc = "  Drop any queued audio data. For playback devices, this is any queued data"]
  #[doc = "  still waiting to be submitted to the hardware. For capture devices, this"]
  #[doc = "  is any data that was queued by the device that hasn't yet been dequeued by"]
  #[doc = "  the application."]
  #[doc = ""]
  #[doc = "  Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For"]
  #[doc = "  playback devices, the hardware will start playing silence if more audio"]
  #[doc = "  isn't queued. Unpaused capture devices will start filling the queue again"]
  #[doc = "  as soon as they have more data available (which, depending on the state"]
  #[doc = "  of the hardware and the thread, could be before this function call"]
  #[doc = "  returns!)."]
  #[doc = ""]
  #[doc = "  This will not prevent playback of queued audio that's already been sent"]
  #[doc = "  to the hardware, as we can not undo that, so expect there to be some"]
  #[doc = "  fraction of a second of audio that might still be heard. This can be"]
  #[doc = "  useful if you want to, say, drop any pending music during a level change"]
  #[doc = "  in your game."]
  #[doc = ""]
  #[doc = "  You may not queue audio on a device that is using an application-supplied"]
  #[doc = "  callback; calling this function on such a device is always a no-op."]
  #[doc = "  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use"]
  #[doc = "  the audio callback, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before clearing the"]
  #[doc = "  queue; SDL handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  This function always succeeds and thus returns void."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID of which to clear the audio queue."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueueAudio"]
  #[doc = "  \\sa SDL_GetQueuedAudioSize"]
  #[link_name = "\u{1}_SDL_ClearQueuedAudio"]
  pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
  #[link_name = "\u{1}_SDL_LockAudio"]
  pub fn SDL_LockAudio();
}
extern "C" {
  #[link_name = "\u{1}_SDL_LockAudioDevice"]
  pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  #[link_name = "\u{1}_SDL_UnlockAudio"]
  pub fn SDL_UnlockAudio();
}
extern "C" {
  #[link_name = "\u{1}_SDL_UnlockAudioDevice"]
  pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  #[doc = "  This function shuts down audio processing and closes the audio device."]
  #[link_name = "\u{1}_SDL_CloseAudio"]
  pub fn SDL_CloseAudio();
}
extern "C" {
  #[link_name = "\u{1}_SDL_CloseAudioDevice"]
  pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  #[doc = " \\brief Put UTF-8 text into the clipboard"]
  #[doc = ""]
  #[doc = " \\sa SDL_GetClipboardText()"]
  #[link_name = "\u{1}_SDL_SetClipboardText"]
  pub fn SDL_SetClipboardText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()"]
  #[doc = ""]
  #[doc = " \\sa SDL_SetClipboardText()"]
  #[link_name = "\u{1}_SDL_GetClipboardText"]
  pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
extern "C" {
  #[doc = " \\brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty"]
  #[doc = ""]
  #[doc = " \\sa SDL_GetClipboardText()"]
  #[link_name = "\u{1}_SDL_HasClipboardText"]
  pub fn SDL_HasClipboardText() -> SDL_bool::Type;
}
pub type __m64 = [libc::c_longlong; 1usize];
pub type __v1di = [libc::c_longlong; 1usize];
pub type __v2si = [libc::c_int; 2usize];
pub type __v4hi = [libc::c_short; 4usize];
pub type __v8qi = [libc::c_char; 8usize];
pub type __v4si = [libc::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [libc::c_uint; 4usize];
extern "C" {
  #[link_name = "\u{1}__mm_sfence"]
  pub fn _mm_sfence();
}
extern "C" {
  #[link_name = "\u{1}__mm_getcsr"]
  pub fn _mm_getcsr() -> libc::c_uint;
}
extern "C" {
  #[link_name = "\u{1}__mm_setcsr"]
  pub fn _mm_setcsr(__i: libc::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [libc::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [libc::c_longlong; 2usize];
pub type __v8hi = [libc::c_short; 8usize];
pub type __v16qi = [libc::c_char; 16usize];
pub type __v2du = [libc::c_ulonglong; 2usize];
pub type __v8hu = [libc::c_ushort; 8usize];
pub type __v16qu = [libc::c_uchar; 16usize];
pub type __v16qs = [libc::c_schar; 16usize];
extern "C" {
  #[link_name = "\u{1}__mm_clflush"]
  pub fn _mm_clflush(__p: *const libc::c_void);
}
extern "C" {
  #[link_name = "\u{1}__mm_lfence"]
  pub fn _mm_lfence();
}
extern "C" {
  #[link_name = "\u{1}__mm_mfence"]
  pub fn _mm_mfence();
}
extern "C" {
  #[link_name = "\u{1}__mm_pause"]
  pub fn _mm_pause();
}
extern "C" {
  #[doc = "  This function returns the number of CPU cores available."]
  #[link_name = "\u{1}_SDL_GetCPUCount"]
  pub fn SDL_GetCPUCount() -> libc::c_int;
}
extern "C" {
  #[doc = "  This function returns the L1 cache line size of the CPU"]
  #[doc = ""]
  #[doc = "  This is useful for determining multi-threaded structure padding"]
  #[doc = "  or SIMD prefetch sizes."]
  #[link_name = "\u{1}_SDL_GetCPUCacheLineSize"]
  pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has the RDTSC instruction."]
  #[link_name = "\u{1}_SDL_HasRDTSC"]
  pub fn SDL_HasRDTSC() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AltiVec features."]
  #[link_name = "\u{1}_SDL_HasAltiVec"]
  pub fn SDL_HasAltiVec() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has MMX features."]
  #[link_name = "\u{1}_SDL_HasMMX"]
  pub fn SDL_HasMMX() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has 3DNow! features."]
  #[link_name = "\u{1}_SDL_Has3DNow"]
  pub fn SDL_Has3DNow() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE features."]
  #[link_name = "\u{1}_SDL_HasSSE"]
  pub fn SDL_HasSSE() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE2 features."]
  #[link_name = "\u{1}_SDL_HasSSE2"]
  pub fn SDL_HasSSE2() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE3 features."]
  #[link_name = "\u{1}_SDL_HasSSE3"]
  pub fn SDL_HasSSE3() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE4.1 features."]
  #[link_name = "\u{1}_SDL_HasSSE41"]
  pub fn SDL_HasSSE41() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE4.2 features."]
  #[link_name = "\u{1}_SDL_HasSSE42"]
  pub fn SDL_HasSSE42() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AVX features."]
  #[link_name = "\u{1}_SDL_HasAVX"]
  pub fn SDL_HasAVX() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AVX2 features."]
  #[link_name = "\u{1}_SDL_HasAVX2"]
  pub fn SDL_HasAVX2() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AVX-512F (foundation) features."]
  #[link_name = "\u{1}_SDL_HasAVX512F"]
  pub fn SDL_HasAVX512F() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has NEON (ARM SIMD) features."]
  #[link_name = "\u{1}_SDL_HasNEON"]
  pub fn SDL_HasNEON() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns the amount of RAM configured in the system, in MB."]
  #[link_name = "\u{1}_SDL_GetSystemRAM"]
  pub fn SDL_GetSystemRAM() -> libc::c_int;
}
pub mod _bindgen_ty_1 {
  #[doc = " Pixel type."]
  pub type Type = u32;
  pub const SDL_PIXELTYPE_UNKNOWN: Type = 0;
  pub const SDL_PIXELTYPE_INDEX1: Type = 1;
  pub const SDL_PIXELTYPE_INDEX4: Type = 2;
  pub const SDL_PIXELTYPE_INDEX8: Type = 3;
  pub const SDL_PIXELTYPE_PACKED8: Type = 4;
  pub const SDL_PIXELTYPE_PACKED16: Type = 5;
  pub const SDL_PIXELTYPE_PACKED32: Type = 6;
  pub const SDL_PIXELTYPE_ARRAYU8: Type = 7;
  pub const SDL_PIXELTYPE_ARRAYU16: Type = 8;
  pub const SDL_PIXELTYPE_ARRAYU32: Type = 9;
  pub const SDL_PIXELTYPE_ARRAYF16: Type = 10;
  pub const SDL_PIXELTYPE_ARRAYF32: Type = 11;
}
pub mod _bindgen_ty_2 {
  #[doc = " Bitmap pixel order, high bit -> low bit."]
  pub type Type = u32;
  pub const SDL_BITMAPORDER_NONE: Type = 0;
  pub const SDL_BITMAPORDER_4321: Type = 1;
  pub const SDL_BITMAPORDER_1234: Type = 2;
}
pub mod _bindgen_ty_3 {
  #[doc = " Packed component order, high bit -> low bit."]
  pub type Type = u32;
  pub const SDL_PACKEDORDER_NONE: Type = 0;
  pub const SDL_PACKEDORDER_XRGB: Type = 1;
  pub const SDL_PACKEDORDER_RGBX: Type = 2;
  pub const SDL_PACKEDORDER_ARGB: Type = 3;
  pub const SDL_PACKEDORDER_RGBA: Type = 4;
  pub const SDL_PACKEDORDER_XBGR: Type = 5;
  pub const SDL_PACKEDORDER_BGRX: Type = 6;
  pub const SDL_PACKEDORDER_ABGR: Type = 7;
  pub const SDL_PACKEDORDER_BGRA: Type = 8;
}
pub mod _bindgen_ty_4 {
  #[doc = " Array component order, low byte -> high byte."]
  pub type Type = u32;
  pub const SDL_ARRAYORDER_NONE: Type = 0;
  pub const SDL_ARRAYORDER_RGB: Type = 1;
  pub const SDL_ARRAYORDER_RGBA: Type = 2;
  pub const SDL_ARRAYORDER_ARGB: Type = 3;
  pub const SDL_ARRAYORDER_BGR: Type = 4;
  pub const SDL_ARRAYORDER_BGRA: Type = 5;
  pub const SDL_ARRAYORDER_ABGR: Type = 6;
}
pub mod _bindgen_ty_5 {
  #[doc = " Packed component layout."]
  pub type Type = u32;
  pub const SDL_PACKEDLAYOUT_NONE: Type = 0;
  pub const SDL_PACKEDLAYOUT_332: Type = 1;
  pub const SDL_PACKEDLAYOUT_4444: Type = 2;
  pub const SDL_PACKEDLAYOUT_1555: Type = 3;
  pub const SDL_PACKEDLAYOUT_5551: Type = 4;
  pub const SDL_PACKEDLAYOUT_565: Type = 5;
  pub const SDL_PACKEDLAYOUT_8888: Type = 6;
  pub const SDL_PACKEDLAYOUT_2101010: Type = 7;
  pub const SDL_PACKEDLAYOUT_1010102: Type = 8;
}
pub mod _bindgen_ty_6 {
  pub type Type = u32;
  pub const SDL_PIXELFORMAT_UNKNOWN: Type = 0;
  pub const SDL_PIXELFORMAT_INDEX1LSB: Type = 286261504;
  pub const SDL_PIXELFORMAT_INDEX1MSB: Type = 287310080;
  pub const SDL_PIXELFORMAT_INDEX4LSB: Type = 303039488;
  pub const SDL_PIXELFORMAT_INDEX4MSB: Type = 304088064;
  pub const SDL_PIXELFORMAT_INDEX8: Type = 318769153;
  pub const SDL_PIXELFORMAT_RGB332: Type = 336660481;
  pub const SDL_PIXELFORMAT_RGB444: Type = 353504258;
  pub const SDL_PIXELFORMAT_RGB555: Type = 353570562;
  pub const SDL_PIXELFORMAT_BGR555: Type = 357764866;
  pub const SDL_PIXELFORMAT_ARGB4444: Type = 355602434;
  pub const SDL_PIXELFORMAT_RGBA4444: Type = 356651010;
  pub const SDL_PIXELFORMAT_ABGR4444: Type = 359796738;
  pub const SDL_PIXELFORMAT_BGRA4444: Type = 360845314;
  pub const SDL_PIXELFORMAT_ARGB1555: Type = 355667970;
  pub const SDL_PIXELFORMAT_RGBA5551: Type = 356782082;
  pub const SDL_PIXELFORMAT_ABGR1555: Type = 359862274;
  pub const SDL_PIXELFORMAT_BGRA5551: Type = 360976386;
  pub const SDL_PIXELFORMAT_RGB565: Type = 353701890;
  pub const SDL_PIXELFORMAT_BGR565: Type = 357896194;
  pub const SDL_PIXELFORMAT_RGB24: Type = 386930691;
  pub const SDL_PIXELFORMAT_BGR24: Type = 390076419;
  pub const SDL_PIXELFORMAT_RGB888: Type = 370546692;
  pub const SDL_PIXELFORMAT_RGBX8888: Type = 371595268;
  pub const SDL_PIXELFORMAT_BGR888: Type = 374740996;
  pub const SDL_PIXELFORMAT_BGRX8888: Type = 375789572;
  pub const SDL_PIXELFORMAT_ARGB8888: Type = 372645892;
  pub const SDL_PIXELFORMAT_RGBA8888: Type = 373694468;
  pub const SDL_PIXELFORMAT_ABGR8888: Type = 376840196;
  pub const SDL_PIXELFORMAT_BGRA8888: Type = 377888772;
  pub const SDL_PIXELFORMAT_ARGB2101010: Type = 372711428;
  pub const SDL_PIXELFORMAT_RGBA32: Type = 376840196;
  pub const SDL_PIXELFORMAT_ARGB32: Type = 377888772;
  pub const SDL_PIXELFORMAT_BGRA32: Type = 372645892;
  pub const SDL_PIXELFORMAT_ABGR32: Type = 373694468;
  #[doc = "< Planar mode: Y + V + U  (3 planes)"]
  pub const SDL_PIXELFORMAT_YV12: Type = 842094169;
  #[doc = "< Planar mode: Y + U + V  (3 planes)"]
  pub const SDL_PIXELFORMAT_IYUV: Type = 1448433993;
  #[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
  pub const SDL_PIXELFORMAT_YUY2: Type = 844715353;
  #[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
  pub const SDL_PIXELFORMAT_UYVY: Type = 1498831189;
  #[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
  pub const SDL_PIXELFORMAT_YVYU: Type = 1431918169;
  #[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
  pub const SDL_PIXELFORMAT_NV12: Type = 842094158;
  #[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
  pub const SDL_PIXELFORMAT_NV21: Type = 825382478;
  #[doc = "< Android video texture format"]
  pub const SDL_PIXELFORMAT_EXTERNAL_OES: Type = 542328143;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Color {
  pub r: Uint8,
  pub g: Uint8,
  pub b: Uint8,
  pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Color>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_Color))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Color>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_Color))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(b)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).a as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(a)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Palette {
  pub ncolors: libc::c_int,
  pub colors: *mut SDL_Color,
  pub version: Uint32,
  pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Palette>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_Palette))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Palette>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Palette))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).ncolors as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(ncolors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).colors as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(colors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).version as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).refcount as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(refcount)
    )
  );
}
impl Default for SDL_Palette {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\note Everything in the pixel format structure is read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_PixelFormat {
  pub format: Uint32,
  pub palette: *mut SDL_Palette,
  pub BitsPerPixel: Uint8,
  pub BytesPerPixel: Uint8,
  pub padding: [Uint8; 2usize],
  pub Rmask: Uint32,
  pub Gmask: Uint32,
  pub Bmask: Uint32,
  pub Amask: Uint32,
  pub Rloss: Uint8,
  pub Gloss: Uint8,
  pub Bloss: Uint8,
  pub Aloss: Uint8,
  pub Rshift: Uint8,
  pub Gshift: Uint8,
  pub Bshift: Uint8,
  pub Ashift: Uint8,
  pub refcount: libc::c_int,
  pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
  assert_eq!(
    ::core::mem::size_of::<SDL_PixelFormat>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_PixelFormat))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_PixelFormat>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_PixelFormat))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).format as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).palette as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(palette)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BitsPerPixel as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(BitsPerPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BytesPerPixel as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(BytesPerPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).padding as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rmask as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gmask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bmask as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Amask as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Amask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rloss as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gloss as *const _ as usize },
    37usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bloss as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Aloss as *const _ as usize },
    39usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Aloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rshift as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gshift as *const _ as usize },
    41usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bshift as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Ashift as *const _ as usize },
    43usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Ashift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).refcount as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(next)
    )
  );
}
impl Default for SDL_PixelFormat {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[doc = " \\brief Get the human readable name of a pixel format"]
  #[link_name = "\u{1}_SDL_GetPixelFormatName"]
  pub fn SDL_GetPixelFormatName(format: Uint32) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Convert one of the enumerated pixel formats to a bpp and RGBA masks."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MasksToPixelFormatEnum()"]
  #[link_name = "\u{1}_SDL_PixelFormatEnumToMasks"]
  pub fn SDL_PixelFormatEnumToMasks(
    format: Uint32,
    bpp: *mut libc::c_int,
    Rmask: *mut Uint32,
    Gmask: *mut Uint32,
    Bmask: *mut Uint32,
    Amask: *mut Uint32,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Convert a bpp and RGBA masks to an enumerated pixel format."]
  #[doc = ""]
  #[doc = "  \\return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion"]
  #[doc = "          wasn't possible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_PixelFormatEnumToMasks()"]
  #[link_name = "\u{1}_SDL_MasksToPixelFormatEnum"]
  pub fn SDL_MasksToPixelFormatEnum(
    bpp: libc::c_int,
    Rmask: Uint32,
    Gmask: Uint32,
    Bmask: Uint32,
    Amask: Uint32,
  ) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Create an SDL_PixelFormat structure from a pixel format enum."]
  #[link_name = "\u{1}_SDL_AllocFormat"]
  pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
  #[doc = "  \\brief Free an SDL_PixelFormat structure."]
  #[link_name = "\u{1}_SDL_FreeFormat"]
  pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
  #[doc = "  \\brief Create a palette structure with the specified number of color"]
  #[doc = "         entries."]
  #[doc = ""]
  #[doc = "  \\return A new palette, or NULL if there wasn't enough memory."]
  #[doc = ""]
  #[doc = "  \\note The palette entries are initialized to white."]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreePalette()"]
  #[link_name = "\u{1}_SDL_AllocPalette"]
  pub fn SDL_AllocPalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
extern "C" {
  #[doc = "  \\brief Set the palette for a pixel format structure."]
  #[link_name = "\u{1}_SDL_SetPixelFormatPalette"]
  pub fn SDL_SetPixelFormatPalette(
    format: *mut SDL_PixelFormat,
    palette: *mut SDL_Palette,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set a range of colors in a palette."]
  #[doc = ""]
  #[doc = "  \\param palette    The palette to modify."]
  #[doc = "  \\param colors     An array of colors to copy into the palette."]
  #[doc = "  \\param firstcolor The index of the first palette entry to modify."]
  #[doc = "  \\param ncolors    The number of entries to modify."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if not all of the colors could be set."]
  #[link_name = "\u{1}_SDL_SetPaletteColors"]
  pub fn SDL_SetPaletteColors(
    palette: *mut SDL_Palette,
    colors: *const SDL_Color,
    firstcolor: libc::c_int,
    ncolors: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Free a palette created with SDL_AllocPalette()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_AllocPalette()"]
  #[link_name = "\u{1}_SDL_FreePalette"]
  pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
  #[doc = "  \\brief Maps an RGB triple to an opaque pixel value for a given pixel format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MapRGBA"]
  #[link_name = "\u{1}_SDL_MapRGB"]
  pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Maps an RGBA quadruple to a pixel value for a given pixel format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MapRGB"]
  #[link_name = "\u{1}_SDL_MapRGBA"]
  pub fn SDL_MapRGBA(
    format: *const SDL_PixelFormat,
    r: Uint8,
    g: Uint8,
    b: Uint8,
    a: Uint8,
  ) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Get the RGB components from a pixel of the specified format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRGBA"]
  #[link_name = "\u{1}_SDL_GetRGB"]
  pub fn SDL_GetRGB(
    pixel: Uint32,
    format: *const SDL_PixelFormat,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
  );
}
extern "C" {
  #[doc = "  \\brief Get the RGBA components from a pixel of the specified format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRGB"]
  #[link_name = "\u{1}_SDL_GetRGBA"]
  pub fn SDL_GetRGBA(
    pixel: Uint32,
    format: *const SDL_PixelFormat,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
    a: *mut Uint8,
  );
}
extern "C" {
  #[doc = "  \\brief Calculate a 256 entry gamma ramp for a gamma value."]
  #[link_name = "\u{1}_SDL_CalculateGammaRamp"]
  pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
#[doc = "  \\brief  The structure that defines a point"]
#[doc = ""]
#[doc = "  \\sa SDL_EnclosePoints"]
#[doc = "  \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Point {
  pub x: libc::c_int,
  pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Point>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_Point))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Point>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Point))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Point>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Point),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Point>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Point),
      "::",
      stringify!(y)
    )
  );
}
#[doc = "  \\brief A rectangle, with the origin at the upper left."]
#[doc = ""]
#[doc = "  \\sa SDL_RectEmpty"]
#[doc = "  \\sa SDL_RectEquals"]
#[doc = "  \\sa SDL_HasIntersection"]
#[doc = "  \\sa SDL_IntersectRect"]
#[doc = "  \\sa SDL_UnionRect"]
#[doc = "  \\sa SDL_EnclosePoints"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Rect {
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub w: libc::c_int,
  pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Rect>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Rect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Rect>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Rect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).w as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).h as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(h)
    )
  );
}
extern "C" {
  #[doc = "  \\brief Determine whether two rectangles intersect."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
  #[link_name = "\u{1}_SDL_HasIntersection"]
  pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Calculate the intersection of two rectangles."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
  #[link_name = "\u{1}_SDL_IntersectRect"]
  pub fn SDL_IntersectRect(
    A: *const SDL_Rect,
    B: *const SDL_Rect,
    result: *mut SDL_Rect,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Calculate the union of two rectangles."]
  #[link_name = "\u{1}_SDL_UnionRect"]
  pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Calculate a minimal rectangle enclosing a set of points"]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if any points were within the clipping rect"]
  #[link_name = "\u{1}_SDL_EnclosePoints"]
  pub fn SDL_EnclosePoints(
    points: *const SDL_Point,
    count: libc::c_int,
    clip: *const SDL_Rect,
    result: *mut SDL_Rect,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Calculate the intersection of a rectangle and line segment."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
  #[link_name = "\u{1}_SDL_IntersectRectAndLine"]
  pub fn SDL_IntersectRectAndLine(
    rect: *const SDL_Rect,
    X1: *mut libc::c_int,
    Y1: *mut libc::c_int,
    X2: *mut libc::c_int,
    Y2: *mut libc::c_int,
  ) -> SDL_bool::Type;
}
pub mod SDL_BlendMode {
  #[doc = "  \\brief The blend mode used in SDL_RenderCopy() and drawing operations."]
  pub type Type = u32;
  #[doc = "< no blending"]
  #[doc = "dstRGBA = srcRGBA"]
  pub const SDL_BLENDMODE_NONE: Type = 0;
  #[doc = "< alpha blending"]
  #[doc = "dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))"]
  #[doc = "dstA = srcA + (dstA * (1-srcA))"]
  pub const SDL_BLENDMODE_BLEND: Type = 1;
  #[doc = "< additive blending"]
  #[doc = "dstRGB = (srcRGB * srcA) + dstRGB"]
  #[doc = "dstA = dstA"]
  pub const SDL_BLENDMODE_ADD: Type = 2;
  #[doc = "< color modulate"]
  #[doc = "dstRGB = srcRGB * dstRGB"]
  #[doc = "dstA = dstA"]
  pub const SDL_BLENDMODE_MOD: Type = 4;
  pub const SDL_BLENDMODE_INVALID: Type = 2147483647;
}
pub mod SDL_BlendOperation {
  #[doc = "  \\brief The blend operation used when combining source and destination pixel components"]
  pub type Type = u32;
  #[doc = "< dst + src: supported by all renderers"]
  pub const SDL_BLENDOPERATION_ADD: Type = 1;
  #[doc = "< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES"]
  pub const SDL_BLENDOPERATION_SUBTRACT: Type = 2;
  #[doc = "< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES"]
  pub const SDL_BLENDOPERATION_REV_SUBTRACT: Type = 3;
  #[doc = "< min(dst, src) : supported by D3D11"]
  pub const SDL_BLENDOPERATION_MINIMUM: Type = 4;
  #[doc = "< max(dst, src) : supported by D3D11"]
  pub const SDL_BLENDOPERATION_MAXIMUM: Type = 5;
}
pub mod SDL_BlendFactor {
  #[doc = "  \\brief The normalized factor used to multiply pixel components"]
  pub type Type = u32;
  #[doc = "< 0, 0, 0, 0"]
  pub const SDL_BLENDFACTOR_ZERO: Type = 1;
  #[doc = "< 1, 1, 1, 1"]
  pub const SDL_BLENDFACTOR_ONE: Type = 2;
  #[doc = "< srcR, srcG, srcB, srcA"]
  pub const SDL_BLENDFACTOR_SRC_COLOR: Type = 3;
  #[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR: Type = 4;
  #[doc = "< srcA, srcA, srcA, srcA"]
  pub const SDL_BLENDFACTOR_SRC_ALPHA: Type = 5;
  #[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: Type = 6;
  #[doc = "< dstR, dstG, dstB, dstA"]
  pub const SDL_BLENDFACTOR_DST_COLOR: Type = 7;
  #[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR: Type = 8;
  #[doc = "< dstA, dstA, dstA, dstA"]
  pub const SDL_BLENDFACTOR_DST_ALPHA: Type = 9;
  #[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA: Type = 10;
}
extern "C" {
  #[doc = "  \\brief Create a custom blend mode, which may or may not be supported by a given renderer"]
  #[doc = ""]
  #[doc = "  \\param srcColorFactor"]
  #[doc = "  \\param dstColorFactor"]
  #[doc = "  \\param colorOperation"]
  #[doc = "  \\param srcAlphaFactor"]
  #[doc = "  \\param dstAlphaFactor"]
  #[doc = "  \\param alphaOperation"]
  #[doc = ""]
  #[doc = "  The result of the blend mode operation will be:"]
  #[doc = "      dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor"]
  #[doc = "  and"]
  #[doc = "      dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor"]
  #[link_name = "\u{1}_SDL_ComposeCustomBlendMode"]
  pub fn SDL_ComposeCustomBlendMode(
    srcColorFactor: SDL_BlendFactor::Type,
    dstColorFactor: SDL_BlendFactor::Type,
    colorOperation: SDL_BlendOperation::Type,
    srcAlphaFactor: SDL_BlendFactor::Type,
    dstAlphaFactor: SDL_BlendFactor::Type,
    alphaOperation: SDL_BlendOperation::Type,
  ) -> SDL_BlendMode::Type;
}
#[doc = " \\brief A collection of pixels used in software blitting."]
#[doc = ""]
#[doc = " \\note  This structure should be treated as read-only, except for \\c pixels,"]
#[doc = "        which, if not NULL, contains the raw pixel data for the surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Surface {
  #[doc = "< Read-only"]
  pub flags: Uint32,
  #[doc = "< Read-only"]
  pub format: *mut SDL_PixelFormat,
  #[doc = "< Read-only"]
  pub w: libc::c_int,
  #[doc = "< Read-only"]
  pub h: libc::c_int,
  #[doc = "< Read-only"]
  pub pitch: libc::c_int,
  #[doc = "< Read-write"]
  pub pixels: *mut libc::c_void,
  #[doc = "< Read-write"]
  pub userdata: *mut libc::c_void,
  #[doc = "< Read-only"]
  pub locked: libc::c_int,
  #[doc = "< Read-only"]
  pub lock_data: *mut libc::c_void,
  #[doc = "< Read-only"]
  pub clip_rect: SDL_Rect,
  #[doc = "< Private"]
  pub map: *mut SDL_BlitMap,
  #[doc = "< Read-mostly"]
  pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Surface>(),
    96usize,
    concat!("Size of: ", stringify!(SDL_Surface))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Surface>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Surface))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).format as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).w as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).h as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pitch as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(pitch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pixels as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(pixels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).userdata as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(userdata)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).locked as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(locked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).lock_data as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(lock_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).clip_rect as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(clip_rect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).map as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(map)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).refcount as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(refcount)
    )
  );
}
impl Default for SDL_Surface {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = " \\brief The type of function used for surface blitting functions."]
pub type SDL_blit = ::core::option::Option<
  unsafe extern "C" fn(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int,
>;
pub mod SDL_YUV_CONVERSION_MODE {
  #[doc = " \\brief The formula used for converting between YUV and RGB"]
  pub type Type = u32;
  #[doc = "< Full range JPEG"]
  pub const SDL_YUV_CONVERSION_JPEG: Type = 0;
  #[doc = "< BT.601 (the default)"]
  pub const SDL_YUV_CONVERSION_BT601: Type = 1;
  #[doc = "< BT.709"]
  pub const SDL_YUV_CONVERSION_BT709: Type = 2;
  #[doc = "< BT.601 for SD content, BT.709 for HD content"]
  pub const SDL_YUV_CONVERSION_AUTOMATIC: Type = 3;
}
extern "C" {
  #[doc = "  Allocate and free an RGB surface."]
  #[doc = ""]
  #[doc = "  If the depth is 4 or 8 bits, an empty palette is allocated for the surface."]
  #[doc = "  If the depth is greater than 8 bits, the pixel format is set using the"]
  #[doc = "  flags '[RGB]mask'."]
  #[doc = ""]
  #[doc = "  If the function runs out of memory, it will return NULL."]
  #[doc = ""]
  #[doc = "  \\param flags The \\c flags are obsolete and should be set to 0."]
  #[doc = "  \\param width The width in pixels of the surface to create."]
  #[doc = "  \\param height The height in pixels of the surface to create."]
  #[doc = "  \\param depth The depth in bits of the surface to create."]
  #[doc = "  \\param Rmask The red mask of the surface to create."]
  #[doc = "  \\param Gmask The green mask of the surface to create."]
  #[doc = "  \\param Bmask The blue mask of the surface to create."]
  #[doc = "  \\param Amask The alpha mask of the surface to create."]
  #[link_name = "\u{1}_SDL_CreateRGBSurface"]
  pub fn SDL_CreateRGBSurface(
    flags: Uint32,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    Rmask: Uint32,
    Gmask: Uint32,
    Bmask: Uint32,
    Amask: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[link_name = "\u{1}_SDL_CreateRGBSurfaceWithFormat"]
  pub fn SDL_CreateRGBSurfaceWithFormat(
    flags: Uint32,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    format: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[link_name = "\u{1}_SDL_CreateRGBSurfaceFrom"]
  pub fn SDL_CreateRGBSurfaceFrom(
    pixels: *mut libc::c_void,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    pitch: libc::c_int,
    Rmask: Uint32,
    Gmask: Uint32,
    Bmask: Uint32,
    Amask: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[link_name = "\u{1}_SDL_CreateRGBSurfaceWithFormatFrom"]
  pub fn SDL_CreateRGBSurfaceWithFormatFrom(
    pixels: *mut libc::c_void,
    width: libc::c_int,
    height: libc::c_int,
    depth: libc::c_int,
    pitch: libc::c_int,
    format: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[link_name = "\u{1}_SDL_FreeSurface"]
  pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
  #[doc = "  \\brief Set the palette used by a surface."]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if the surface format doesn't use a palette."]
  #[doc = ""]
  #[doc = "  \\note A single palette can be shared with many surfaces."]
  #[link_name = "\u{1}_SDL_SetSurfacePalette"]
  pub fn SDL_SetSurfacePalette(surface: *mut SDL_Surface, palette: *mut SDL_Palette)
    -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets up a surface for directly accessing the pixels."]
  #[doc = ""]
  #[doc = "  Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write"]
  #[doc = "  to and read from \\c surface->pixels, using the pixel format stored in"]
  #[doc = "  \\c surface->format.  Once you are done accessing the surface, you should"]
  #[doc = "  use SDL_UnlockSurface() to release it."]
  #[doc = ""]
  #[doc = "  Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates"]
  #[doc = "  to 0, then you can read and write to the surface at any time, and the"]
  #[doc = "  pixel format of the surface will not change."]
  #[doc = ""]
  #[doc = "  No operating system or library calls should be made between lock/unlock"]
  #[doc = "  pairs, as critical system locks may be held during this time."]
  #[doc = ""]
  #[doc = "  SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked."]
  #[doc = ""]
  #[doc = "  \\sa SDL_UnlockSurface()"]
  #[link_name = "\u{1}_SDL_LockSurface"]
  pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
  #[doc = " \\sa SDL_LockSurface()"]
  #[link_name = "\u{1}_SDL_UnlockSurface"]
  pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
  #[doc = "  Load a surface from a seekable SDL data stream (memory or file)."]
  #[doc = ""]
  #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
  #[doc = ""]
  #[doc = "  The new surface should be freed with SDL_FreeSurface()."]
  #[doc = ""]
  #[doc = "  \\return the new surface, or NULL if there was an error."]
  #[link_name = "\u{1}_SDL_LoadBMP_RW"]
  pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: libc::c_int) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = "  Save a surface to a seekable SDL data stream (memory or file)."]
  #[doc = ""]
  #[doc = "  Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the"]
  #[doc = "  BMP directly. Other RGB formats with 8-bit or higher get converted to a"]
  #[doc = "  24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit"]
  #[doc = "  surface before they are saved. YUV and paletted 1-bit and 4-bit formats are"]
  #[doc = "  not supported."]
  #[doc = ""]
  #[doc = "  If \\c freedst is non-zero, the stream will be closed after being written."]
  #[doc = ""]
  #[doc = "  \\return 0 if successful or -1 if there was an error."]
  #[link_name = "\u{1}_SDL_SaveBMP_RW"]
  pub fn SDL_SaveBMP_RW(
    surface: *mut SDL_Surface,
    dst: *mut SDL_RWops,
    freedst: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the RLE acceleration hint for a surface."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid"]
  #[doc = ""]
  #[doc = "  \\note If RLE is enabled, colorkey and alpha blending blits are much faster,"]
  #[doc = "        but the surface must be locked before directly accessing the pixels."]
  #[link_name = "\u{1}_SDL_SetSurfaceRLE"]
  pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, flag: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the color key (transparent pixel) in a blittable surface."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update"]
  #[doc = "  \\param flag Non-zero to enable colorkey and 0 to disable colorkey"]
  #[doc = "  \\param key The transparent pixel in the native surface format"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid"]
  #[doc = ""]
  #[doc = "  You can pass SDL_RLEACCEL to enable RLE accelerated blits."]
  #[link_name = "\u{1}_SDL_SetColorKey"]
  pub fn SDL_SetColorKey(surface: *mut SDL_Surface, flag: libc::c_int, key: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Returns whether the surface has a color key"]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key"]
  #[link_name = "\u{1}_SDL_HasColorKey"]
  pub fn SDL_HasColorKey(surface: *mut SDL_Surface) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Gets the color key (transparent pixel) in a blittable surface."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update"]
  #[doc = "  \\param key A pointer filled in with the transparent pixel in the native"]
  #[doc = "             surface format"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid or colorkey is not"]
  #[doc = "          enabled."]
  #[link_name = "\u{1}_SDL_GetColorKey"]
  pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional color value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update."]
  #[doc = "  \\param r The red color value multiplied into blit operations."]
  #[doc = "  \\param g The green color value multiplied into blit operations."]
  #[doc = "  \\param b The blue color value multiplied into blit operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetSurfaceColorMod()"]
  #[link_name = "\u{1}_SDL_SetSurfaceColorMod"]
  pub fn SDL_SetSurfaceColorMod(
    surface: *mut SDL_Surface,
    r: Uint8,
    g: Uint8,
    b: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional color value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to query."]
  #[doc = "  \\param r A pointer filled in with the current red color value."]
  #[doc = "  \\param g A pointer filled in with the current green color value."]
  #[doc = "  \\param b A pointer filled in with the current blue color value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetSurfaceColorMod()"]
  #[link_name = "\u{1}_SDL_GetSurfaceColorMod"]
  pub fn SDL_GetSurfaceColorMod(
    surface: *mut SDL_Surface,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional alpha value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update."]
  #[doc = "  \\param alpha The alpha value multiplied into blit operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetSurfaceAlphaMod()"]
  #[link_name = "\u{1}_SDL_SetSurfaceAlphaMod"]
  pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional alpha value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to query."]
  #[doc = "  \\param alpha A pointer filled in with the current alpha value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetSurfaceAlphaMod()"]
  #[link_name = "\u{1}_SDL_GetSurfaceAlphaMod"]
  pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the blend mode used for blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update."]
  #[doc = "  \\param blendMode ::SDL_BlendMode to use for blit blending."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the parameters are not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetSurfaceBlendMode()"]
  #[link_name = "\u{1}_SDL_SetSurfaceBlendMode"]
  pub fn SDL_SetSurfaceBlendMode(
    surface: *mut SDL_Surface,
    blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the blend mode used for blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface   The surface to query."]
  #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetSurfaceBlendMode()"]
  #[link_name = "\u{1}_SDL_GetSurfaceBlendMode"]
  pub fn SDL_GetSurfaceBlendMode(
    surface: *mut SDL_Surface,
    blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Sets the clipping rectangle for the destination surface in a blit."]
  #[doc = ""]
  #[doc = "  If the clip rectangle is NULL, clipping will be disabled."]
  #[doc = ""]
  #[doc = "  If the clip rectangle doesn't intersect the surface, the function will"]
  #[doc = "  return SDL_FALSE and blits will be completely clipped.  Otherwise the"]
  #[doc = "  function returns SDL_TRUE and blits to the surface will be clipped to"]
  #[doc = "  the intersection of the surface area and the clipping rectangle."]
  #[doc = ""]
  #[doc = "  Note that blits are automatically clipped to the edges of the source"]
  #[doc = "  and destination surfaces."]
  #[link_name = "\u{1}_SDL_SetClipRect"]
  pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Gets the clipping rectangle for the destination surface in a blit."]
  #[doc = ""]
  #[doc = "  \\c rect must be a pointer to a valid rectangle which will be filled"]
  #[doc = "  with the correct values."]
  #[link_name = "\u{1}_SDL_GetClipRect"]
  pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
  #[link_name = "\u{1}_SDL_DuplicateSurface"]
  pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = "  Creates a new surface of the specified format, and then copies and maps"]
  #[doc = "  the given surface to it so the blit of the converted surface will be as"]
  #[doc = "  fast as possible.  If this function fails, it returns NULL."]
  #[doc = ""]
  #[doc = "  The \\c flags parameter is passed to SDL_CreateRGBSurface() and has those"]
  #[doc = "  semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and"]
  #[doc = "  SDL will try to RLE accelerate colorkey and alpha blits in the resulting"]
  #[doc = "  surface."]
  #[link_name = "\u{1}_SDL_ConvertSurface"]
  pub fn SDL_ConvertSurface(
    src: *mut SDL_Surface,
    fmt: *const SDL_PixelFormat,
    flags: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[link_name = "\u{1}_SDL_ConvertSurfaceFormat"]
  pub fn SDL_ConvertSurfaceFormat(
    src: *mut SDL_Surface,
    pixel_format: Uint32,
    flags: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = " \\brief Copy a block of pixels of one format to another format"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if there was an error"]
  #[link_name = "\u{1}_SDL_ConvertPixels"]
  pub fn SDL_ConvertPixels(
    width: libc::c_int,
    height: libc::c_int,
    src_format: Uint32,
    src: *const libc::c_void,
    src_pitch: libc::c_int,
    dst_format: Uint32,
    dst: *mut libc::c_void,
    dst_pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Performs a fast fill of the given rectangle with \\c color."]
  #[doc = ""]
  #[doc = "  If \\c rect is NULL, the whole surface will be filled with \\c color."]
  #[doc = ""]
  #[doc = "  The color should be a pixel of the format used by the surface, and"]
  #[doc = "  can be generated by the SDL_MapRGB() function."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[link_name = "\u{1}_SDL_FillRect"]
  pub fn SDL_FillRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32) -> libc::c_int;
}
extern "C" {
  #[link_name = "\u{1}_SDL_FillRects"]
  pub fn SDL_FillRects(
    dst: *mut SDL_Surface,
    rects: *const SDL_Rect,
    count: libc::c_int,
    color: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is the public blit function, SDL_BlitSurface(), and it performs"]
  #[doc = "  rectangle validation and clipping before passing it to SDL_LowerBlit()"]
  #[link_name = "\u{1}_SDL_UpperBlit"]
  pub fn SDL_UpperBlit(
    src: *mut SDL_Surface,
    srcrect: *const SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is a semi-private blit function and it performs low-level surface"]
  #[doc = "  blitting only."]
  #[link_name = "\u{1}_SDL_LowerBlit"]
  pub fn SDL_LowerBlit(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Perform a fast, low quality, stretch blit between two surfaces of the"]
  #[doc = "         same pixel format."]
  #[doc = ""]
  #[doc = "  \\note This function uses a static buffer, and is not thread-safe."]
  #[link_name = "\u{1}_SDL_SoftStretch"]
  pub fn SDL_SoftStretch(
    src: *mut SDL_Surface,
    srcrect: *const SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *const SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is the public scaled blit function, SDL_BlitScaled(), and it performs"]
  #[doc = "  rectangle validation and clipping before passing it to SDL_LowerBlitScaled()"]
  #[link_name = "\u{1}_SDL_UpperBlitScaled"]
  pub fn SDL_UpperBlitScaled(
    src: *mut SDL_Surface,
    srcrect: *const SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is a semi-private blit function and it performs low-level surface"]
  #[doc = "  scaled blitting only."]
  #[link_name = "\u{1}_SDL_LowerBlitScaled"]
  pub fn SDL_LowerBlitScaled(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the YUV conversion mode"]
  #[link_name = "\u{1}_SDL_SetYUVConversionMode"]
  pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE::Type);
}
extern "C" {
  #[doc = "  \\brief Get the YUV conversion mode"]
  #[link_name = "\u{1}_SDL_GetYUVConversionMode"]
  pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE::Type;
}
extern "C" {
  #[doc = "  \\brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC"]
  #[link_name = "\u{1}_SDL_GetYUVConversionModeForResolution"]
  pub fn SDL_GetYUVConversionModeForResolution(
    width: libc::c_int,
    height: libc::c_int,
  ) -> SDL_YUV_CONVERSION_MODE::Type;
}
#[doc = "  \\brief  The structure that defines a display mode"]
#[doc = ""]
#[doc = "  \\sa SDL_GetNumDisplayModes()"]
#[doc = "  \\sa SDL_GetDisplayMode()"]
#[doc = "  \\sa SDL_GetDesktopDisplayMode()"]
#[doc = "  \\sa SDL_GetCurrentDisplayMode()"]
#[doc = "  \\sa SDL_GetClosestDisplayMode()"]
#[doc = "  \\sa SDL_SetWindowDisplayMode()"]
#[doc = "  \\sa SDL_GetWindowDisplayMode()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_DisplayMode {
  #[doc = "< pixel format"]
  pub format: Uint32,
  #[doc = "< width, in screen coordinates"]
  pub w: libc::c_int,
  #[doc = "< height, in screen coordinates"]
  pub h: libc::c_int,
  #[doc = "< refresh rate (or zero for unspecified)"]
  pub refresh_rate: libc::c_int,
  #[doc = "< driver-specific data, initialize to 0"]
  pub driverdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DisplayMode>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_DisplayMode))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DisplayMode>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DisplayMode))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).format as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).w as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).h as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).refresh_rate as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(refresh_rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).driverdata as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(driverdata)
    )
  );
}
impl Default for SDL_DisplayMode {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
  _unused: [u8; 0],
}
pub mod SDL_WindowFlags {
  #[doc = "  \\brief The flags on a window"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowFlags()"]
  pub type Type = u32;
  #[doc = "< fullscreen window"]
  pub const SDL_WINDOW_FULLSCREEN: Type = 1;
  #[doc = "< window usable with OpenGL context"]
  pub const SDL_WINDOW_OPENGL: Type = 2;
  #[doc = "< window is visible"]
  pub const SDL_WINDOW_SHOWN: Type = 4;
  #[doc = "< window is not visible"]
  pub const SDL_WINDOW_HIDDEN: Type = 8;
  #[doc = "< no window decoration"]
  pub const SDL_WINDOW_BORDERLESS: Type = 16;
  #[doc = "< window can be resized"]
  pub const SDL_WINDOW_RESIZABLE: Type = 32;
  #[doc = "< window is minimized"]
  pub const SDL_WINDOW_MINIMIZED: Type = 64;
  #[doc = "< window is maximized"]
  pub const SDL_WINDOW_MAXIMIZED: Type = 128;
  #[doc = "< window has grabbed input focus"]
  pub const SDL_WINDOW_INPUT_GRABBED: Type = 256;
  #[doc = "< window has input focus"]
  pub const SDL_WINDOW_INPUT_FOCUS: Type = 512;
  #[doc = "< window has mouse focus"]
  pub const SDL_WINDOW_MOUSE_FOCUS: Type = 1024;
  pub const SDL_WINDOW_FULLSCREEN_DESKTOP: Type = 4097;
  #[doc = "< window not created by SDL"]
  pub const SDL_WINDOW_FOREIGN: Type = 2048;
  #[doc = "< window should be created in high-DPI mode if supported."]
  #[doc = "On macOS NSHighResolutionCapable must be set true in the"]
  #[doc = "application's Info.plist for this to have any effect."]
  pub const SDL_WINDOW_ALLOW_HIGHDPI: Type = 8192;
  #[doc = "< window has mouse captured (unrelated to INPUT_GRABBED)"]
  pub const SDL_WINDOW_MOUSE_CAPTURE: Type = 16384;
  #[doc = "< window should always be above others"]
  pub const SDL_WINDOW_ALWAYS_ON_TOP: Type = 32768;
  #[doc = "< window should not be added to the taskbar"]
  pub const SDL_WINDOW_SKIP_TASKBAR: Type = 65536;
  #[doc = "< window should be treated as a utility window"]
  pub const SDL_WINDOW_UTILITY: Type = 131072;
  #[doc = "< window should be treated as a tooltip"]
  pub const SDL_WINDOW_TOOLTIP: Type = 262144;
  #[doc = "< window should be treated as a popup menu"]
  pub const SDL_WINDOW_POPUP_MENU: Type = 524288;
  #[doc = "< window usable for Vulkan surface"]
  pub const SDL_WINDOW_VULKAN: Type = 268435456;
}
pub mod SDL_WindowEventID {
  #[doc = "  \\brief Event subtype for window events"]
  pub type Type = u32;
  #[doc = "< Never used"]
  pub const SDL_WINDOWEVENT_NONE: Type = 0;
  #[doc = "< Window has been shown"]
  pub const SDL_WINDOWEVENT_SHOWN: Type = 1;
  #[doc = "< Window has been hidden"]
  pub const SDL_WINDOWEVENT_HIDDEN: Type = 2;
  #[doc = "< Window has been exposed and should be"]
  #[doc = "redrawn"]
  pub const SDL_WINDOWEVENT_EXPOSED: Type = 3;
  #[doc = "< Window has been moved to data1, data2"]
  pub const SDL_WINDOWEVENT_MOVED: Type = 4;
  #[doc = "< Window has been resized to data1xdata2"]
  pub const SDL_WINDOWEVENT_RESIZED: Type = 5;
  #[doc = "< The window size has changed, either as"]
  #[doc = "a result of an API call or through the"]
  #[doc = "system or user changing the window size."]
  pub const SDL_WINDOWEVENT_SIZE_CHANGED: Type = 6;
  #[doc = "< Window has been minimized"]
  pub const SDL_WINDOWEVENT_MINIMIZED: Type = 7;
  #[doc = "< Window has been maximized"]
  pub const SDL_WINDOWEVENT_MAXIMIZED: Type = 8;
  #[doc = "< Window has been restored to normal size"]
  #[doc = "and position"]
  pub const SDL_WINDOWEVENT_RESTORED: Type = 9;
  #[doc = "< Window has gained mouse focus"]
  pub const SDL_WINDOWEVENT_ENTER: Type = 10;
  #[doc = "< Window has lost mouse focus"]
  pub const SDL_WINDOWEVENT_LEAVE: Type = 11;
  #[doc = "< Window has gained keyboard focus"]
  pub const SDL_WINDOWEVENT_FOCUS_GAINED: Type = 12;
  #[doc = "< Window has lost keyboard focus"]
  pub const SDL_WINDOWEVENT_FOCUS_LOST: Type = 13;
  #[doc = "< The window manager requests that the window be closed"]
  pub const SDL_WINDOWEVENT_CLOSE: Type = 14;
  #[doc = "< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)"]
  pub const SDL_WINDOWEVENT_TAKE_FOCUS: Type = 15;
  #[doc = "< Window had a hit test that wasn't SDL_HITTEST_NORMAL."]
  pub const SDL_WINDOWEVENT_HIT_TEST: Type = 16;
}
pub mod SDL_DisplayEventID {
  #[doc = "  \\brief Event subtype for display events"]
  pub type Type = u32;
  #[doc = "< Never used"]
  pub const SDL_DISPLAYEVENT_NONE: Type = 0;
  #[doc = "< Display orientation has changed to data1"]
  pub const SDL_DISPLAYEVENT_ORIENTATION: Type = 1;
}
pub mod SDL_DisplayOrientation {
  pub type Type = u32;
  #[doc = "< The display orientation can't be determined"]
  pub const SDL_ORIENTATION_UNKNOWN: Type = 0;
  #[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
  pub const SDL_ORIENTATION_LANDSCAPE: Type = 1;
  #[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
  pub const SDL_ORIENTATION_LANDSCAPE_FLIPPED: Type = 2;
  #[doc = "< The display is in portrait mode"]
  pub const SDL_ORIENTATION_PORTRAIT: Type = 3;
  #[doc = "< The display is in portrait mode, upside down"]
  pub const SDL_ORIENTATION_PORTRAIT_FLIPPED: Type = 4;
}
#[doc = "  \\brief An opaque handle to an OpenGL context."]
pub type SDL_GLContext = *mut libc::c_void;
pub mod SDL_GLattr {
  #[doc = "  \\brief OpenGL configuration attributes"]
  pub type Type = u32;
  pub const SDL_GL_RED_SIZE: Type = 0;
  pub const SDL_GL_GREEN_SIZE: Type = 1;
  pub const SDL_GL_BLUE_SIZE: Type = 2;
  pub const SDL_GL_ALPHA_SIZE: Type = 3;
  pub const SDL_GL_BUFFER_SIZE: Type = 4;
  pub const SDL_GL_DOUBLEBUFFER: Type = 5;
  pub const SDL_GL_DEPTH_SIZE: Type = 6;
  pub const SDL_GL_STENCIL_SIZE: Type = 7;
  pub const SDL_GL_ACCUM_RED_SIZE: Type = 8;
  pub const SDL_GL_ACCUM_GREEN_SIZE: Type = 9;
  pub const SDL_GL_ACCUM_BLUE_SIZE: Type = 10;
  pub const SDL_GL_ACCUM_ALPHA_SIZE: Type = 11;
  pub const SDL_GL_STEREO: Type = 12;
  pub const SDL_GL_MULTISAMPLEBUFFERS: Type = 13;
  pub const SDL_GL_MULTISAMPLESAMPLES: Type = 14;
  pub const SDL_GL_ACCELERATED_VISUAL: Type = 15;
  pub const SDL_GL_RETAINED_BACKING: Type = 16;
  pub const SDL_GL_CONTEXT_MAJOR_VERSION: Type = 17;
  pub const SDL_GL_CONTEXT_MINOR_VERSION: Type = 18;
  pub const SDL_GL_CONTEXT_EGL: Type = 19;
  pub const SDL_GL_CONTEXT_FLAGS: Type = 20;
  pub const SDL_GL_CONTEXT_PROFILE_MASK: Type = 21;
  pub const SDL_GL_SHARE_WITH_CURRENT_CONTEXT: Type = 22;
  pub const SDL_GL_FRAMEBUFFER_SRGB_CAPABLE: Type = 23;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR: Type = 24;
  pub const SDL_GL_CONTEXT_RESET_NOTIFICATION: Type = 25;
  pub const SDL_GL_CONTEXT_NO_ERROR: Type = 26;
}
pub mod SDL_GLprofile {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_PROFILE_CORE: Type = 1;
  pub const SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: Type = 2;
  #[doc = "< GLX_CONTEXT_ES2_PROFILE_BIT_EXT"]
  pub const SDL_GL_CONTEXT_PROFILE_ES: Type = 4;
}
pub mod SDL_GLcontextFlag {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_DEBUG_FLAG: Type = 1;
  pub const SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: Type = 2;
  pub const SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: Type = 4;
  pub const SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: Type = 8;
}
pub mod SDL_GLcontextReleaseFlag {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: Type = 0;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: Type = 1;
}
pub mod SDL_GLContextResetNotification {
  pub type Type = u32;
  pub const SDL_GL_CONTEXT_RESET_NO_NOTIFICATION: Type = 0;
  pub const SDL_GL_CONTEXT_RESET_LOSE_CONTEXT: Type = 1;
}
extern "C" {
  #[doc = "  \\brief Get the number of video drivers compiled into SDL"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetVideoDriver()"]
  #[link_name = "\u{1}_SDL_GetNumVideoDrivers"]
  pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the name of a built in video driver."]
  #[doc = ""]
  #[doc = "  \\note The video drivers are presented in the order in which they are"]
  #[doc = "        normally checked during initialization."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDrivers()"]
  #[link_name = "\u{1}_SDL_GetVideoDriver"]
  pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Initialize the video subsystem, optionally specifying a video driver."]
  #[doc = ""]
  #[doc = "  \\param driver_name Initialize a specific driver by name, or NULL for the"]
  #[doc = "                     default video driver."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 on error"]
  #[doc = ""]
  #[doc = "  This function initializes the video subsystem; setting up a connection"]
  #[doc = "  to the window manager, etc, and determines the available display modes"]
  #[doc = "  and pixel formats, but does not initialize a window or graphics mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_VideoQuit()"]
  #[link_name = "\u{1}_SDL_VideoInit"]
  pub fn SDL_VideoInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Shuts down the video subsystem."]
  #[doc = ""]
  #[doc = "  This function closes all windows, and restores the original video mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_VideoInit()"]
  #[link_name = "\u{1}_SDL_VideoQuit"]
  pub fn SDL_VideoQuit();
}
extern "C" {
  #[doc = "  \\brief Returns the name of the currently initialized video driver."]
  #[doc = ""]
  #[doc = "  \\return The name of the current video driver or NULL if no driver"]
  #[doc = "          has been initialized"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDrivers()"]
  #[doc = "  \\sa SDL_GetVideoDriver()"]
  #[link_name = "\u{1}_SDL_GetCurrentVideoDriver"]
  pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Returns the number of available video displays."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetDisplayBounds()"]
  #[link_name = "\u{1}_SDL_GetNumVideoDisplays"]
  pub fn SDL_GetNumVideoDisplays() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the name of a display in UTF-8 encoding"]
  #[doc = ""]
  #[doc = "  \\return The name of a display, or NULL for an invalid display index."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  #[link_name = "\u{1}_SDL_GetDisplayName"]
  pub fn SDL_GetDisplayName(displayIndex: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the desktop area represented by a display, with the primary"]
  #[doc = "         display located at 0,0"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the index is out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  #[link_name = "\u{1}_SDL_GetDisplayBounds"]
  pub fn SDL_GetDisplayBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the usable desktop area represented by a display, with the"]
  #[doc = "         primary display located at 0,0"]
  #[doc = ""]
  #[doc = "  This is the same area as SDL_GetDisplayBounds() reports, but with portions"]
  #[doc = "  reserved by the system removed. For example, on Mac OS X, this subtracts"]
  #[doc = "  the area occupied by the menu bar and dock."]
  #[doc = ""]
  #[doc = "  Setting a window to be fullscreen generally bypasses these unusable areas,"]
  #[doc = "  so these are good guidelines for the maximum space available to a"]
  #[doc = "  non-fullscreen window."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the index is out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetDisplayBounds()"]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  #[link_name = "\u{1}_SDL_GetDisplayUsableBounds"]
  pub fn SDL_GetDisplayUsableBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the dots/pixels-per-inch for a display"]
  #[doc = ""]
  #[doc = "  \\note Diagonal, horizontal and vertical DPI can all be optionally"]
  #[doc = "        returned if the parameter is non-NULL."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if no DPI information is available or the index is out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  #[link_name = "\u{1}_SDL_GetDisplayDPI"]
  pub fn SDL_GetDisplayDPI(
    displayIndex: libc::c_int,
    ddpi: *mut f32,
    hdpi: *mut f32,
    vdpi: *mut f32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the orientation of a display"]
  #[doc = ""]
  #[doc = "  \\return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  #[link_name = "\u{1}_SDL_GetDisplayOrientation"]
  pub fn SDL_GetDisplayOrientation(displayIndex: libc::c_int) -> SDL_DisplayOrientation::Type;
}
extern "C" {
  #[doc = "  \\brief Returns the number of available display modes."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetDisplayMode()"]
  #[link_name = "\u{1}_SDL_GetNumDisplayModes"]
  pub fn SDL_GetNumDisplayModes(displayIndex: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about a specific display mode."]
  #[doc = ""]
  #[doc = "  \\note The display modes are sorted in this priority:"]
  #[doc = "        \\li bits per pixel -> more colors to fewer colors"]
  #[doc = "        \\li width -> largest to smallest"]
  #[doc = "        \\li height -> largest to smallest"]
  #[doc = "        \\li refresh rate -> highest to lowest"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumDisplayModes()"]
  #[link_name = "\u{1}_SDL_GetDisplayMode"]
  pub fn SDL_GetDisplayMode(
    displayIndex: libc::c_int,
    modeIndex: libc::c_int,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about the desktop display mode."]
  #[link_name = "\u{1}_SDL_GetDesktopDisplayMode"]
  pub fn SDL_GetDesktopDisplayMode(
    displayIndex: libc::c_int,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about the current display mode."]
  #[link_name = "\u{1}_SDL_GetCurrentDisplayMode"]
  pub fn SDL_GetCurrentDisplayMode(
    displayIndex: libc::c_int,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the closest match to the requested display mode."]
  #[doc = ""]
  #[doc = "  \\param displayIndex The index of display from which mode should be queried."]
  #[doc = "  \\param mode The desired display mode"]
  #[doc = "  \\param closest A pointer to a display mode to be filled in with the closest"]
  #[doc = "                 match of the available display modes."]
  #[doc = ""]
  #[doc = "  \\return The passed in value \\c closest, or NULL if no matching video mode"]
  #[doc = "          was available."]
  #[doc = ""]
  #[doc = "  The available display modes are scanned, and \\c closest is filled in with the"]
  #[doc = "  closest mode matching the requested mode and returned.  The mode format and"]
  #[doc = "  refresh_rate default to the desktop mode if they are 0.  The modes are"]
  #[doc = "  scanned with size being first priority, format being second priority, and"]
  #[doc = "  finally checking the refresh_rate.  If all the available modes are too"]
  #[doc = "  small, then NULL is returned."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumDisplayModes()"]
  #[doc = "  \\sa SDL_GetDisplayMode()"]
  #[link_name = "\u{1}_SDL_GetClosestDisplayMode"]
  pub fn SDL_GetClosestDisplayMode(
    displayIndex: libc::c_int,
    mode: *const SDL_DisplayMode,
    closest: *mut SDL_DisplayMode,
  ) -> *mut SDL_DisplayMode;
}
extern "C" {
  #[doc = "  \\brief Get the display index associated with a window."]
  #[doc = ""]
  #[doc = "  \\return the display index of the display containing the center of the"]
  #[doc = "          window, or -1 on error."]
  #[link_name = "\u{1}_SDL_GetWindowDisplayIndex"]
  pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the display mode used when a fullscreen window is visible."]
  #[doc = ""]
  #[doc = "  By default the window's dimensions and the desktop format and refresh rate"]
  #[doc = "  are used."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the display mode should be set."]
  #[doc = "  \\param mode The mode to use, or NULL for the default mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the display mode failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowDisplayMode()"]
  #[doc = "  \\sa SDL_SetWindowFullscreen()"]
  #[link_name = "\u{1}_SDL_SetWindowDisplayMode"]
  pub fn SDL_SetWindowDisplayMode(
    window: *mut SDL_Window,
    mode: *const SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about the display mode used when a fullscreen"]
  #[doc = "         window is visible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
  #[doc = "  \\sa SDL_SetWindowFullscreen()"]
  #[link_name = "\u{1}_SDL_GetWindowDisplayMode"]
  pub fn SDL_GetWindowDisplayMode(
    window: *mut SDL_Window,
    mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the pixel format associated with the window."]
  #[link_name = "\u{1}_SDL_GetWindowPixelFormat"]
  pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Create a window with the specified position, dimensions, and flags."]
  #[doc = ""]
  #[doc = "  \\param title The title of the window, in UTF-8 encoding."]
  #[doc = "  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param w     The width of the window, in screen coordinates."]
  #[doc = "  \\param h     The height of the window, in screen coordinates."]
  #[doc = "  \\param flags The flags for the window, a mask of any of the following:"]
  #[doc = "               ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,"]
  #[doc = "               ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,"]
  #[doc = "               ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,"]
  #[doc = "               ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,"]
  #[doc = "               ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN."]
  #[doc = ""]
  #[doc = "  \\return The created window, or NULL if window creation failed."]
  #[doc = ""]
  #[doc = "  If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size"]
  #[doc = "  in pixels may differ from its size in screen coordinates on platforms with"]
  #[doc = "  high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query"]
  #[doc = "  the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),"]
  #[doc = "  SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the"]
  #[doc = "  drawable size in pixels."]
  #[doc = ""]
  #[doc = "  If the window is created with any of the SDL_WINDOW_OPENGL or"]
  #[doc = "  SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function"]
  #[doc = "  (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the"]
  #[doc = "  corresponding UnloadLibrary function is called by SDL_DestroyWindow()."]
  #[doc = ""]
  #[doc = "  If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,"]
  #[doc = "  SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail."]
  #[doc = ""]
  #[doc = "  \\note On non-Apple devices, SDL requires you to either not link to the"]
  #[doc = "        Vulkan loader or link to a dynamic library version. This limitation"]
  #[doc = "        may be removed in a future version of SDL."]
  #[doc = ""]
  #[doc = "  \\sa SDL_DestroyWindow()"]
  #[doc = "  \\sa SDL_GL_LoadLibrary()"]
  #[doc = "  \\sa SDL_Vulkan_LoadLibrary()"]
  #[link_name = "\u{1}_SDL_CreateWindow"]
  pub fn SDL_CreateWindow(
    title: *const libc::c_char,
    x: libc::c_int,
    y: libc::c_int,
    w: libc::c_int,
    h: libc::c_int,
    flags: Uint32,
  ) -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Create an SDL window from an existing native window."]
  #[doc = ""]
  #[doc = "  \\param data A pointer to driver-dependent window creation data"]
  #[doc = ""]
  #[doc = "  \\return The created window, or NULL if window creation failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_DestroyWindow()"]
  #[link_name = "\u{1}_SDL_CreateWindowFrom"]
  pub fn SDL_CreateWindowFrom(data: *const libc::c_void) -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get the numeric ID of a window, for logging purposes."]
  #[link_name = "\u{1}_SDL_GetWindowID"]
  pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Get a window from a stored ID, or NULL if it doesn't exist."]
  #[link_name = "\u{1}_SDL_GetWindowFromID"]
  pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get the window flags."]
  #[link_name = "\u{1}_SDL_GetWindowFlags"]
  pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Set the title of a window, in UTF-8 format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowTitle()"]
  #[link_name = "\u{1}_SDL_SetWindowTitle"]
  pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char);
}
extern "C" {
  #[doc = "  \\brief Get the title of a window, in UTF-8 format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowTitle()"]
  #[link_name = "\u{1}_SDL_GetWindowTitle"]
  pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Set the icon for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the icon should be set."]
  #[doc = "  \\param icon The icon for the window."]
  #[link_name = "\u{1}_SDL_SetWindowIcon"]
  pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
  #[doc = "  \\brief Associate an arbitrary named pointer with a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to associate with the pointer."]
  #[doc = "  \\param name     The name of the pointer."]
  #[doc = "  \\param userdata The associated pointer."]
  #[doc = ""]
  #[doc = "  \\return The previous value associated with 'name'"]
  #[doc = ""]
  #[doc = "  \\note The name is case-sensitive."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowData()"]
  #[link_name = "\u{1}_SDL_SetWindowData"]
  pub fn SDL_SetWindowData(
    window: *mut SDL_Window,
    name: *const libc::c_char,
    userdata: *mut libc::c_void,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Retrieve the data pointer associated with a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param name     The name of the pointer."]
  #[doc = ""]
  #[doc = "  \\return The value associated with 'name'"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowData()"]
  #[link_name = "\u{1}_SDL_GetWindowData"]
  pub fn SDL_GetWindowData(window: *mut SDL_Window, name: *const libc::c_char)
    -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Set the position of a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to reposition."]
  #[doc = "  \\param x        The x coordinate of the window in screen coordinates, or"]
  #[doc = "                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param y        The y coordinate of the window in screen coordinates, or"]
  #[doc = "                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = ""]
  #[doc = "  \\note The window coordinate origin is the upper left of the display."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowPosition()"]
  #[link_name = "\u{1}_SDL_SetWindowPosition"]
  pub fn SDL_SetWindowPosition(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the position of a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param x        Pointer to variable for storing the x position, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = "  \\param y        Pointer to variable for storing the y position, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowPosition()"]
  #[link_name = "\u{1}_SDL_GetWindowPosition"]
  pub fn SDL_GetWindowPosition(window: *mut SDL_Window, x: *mut libc::c_int, y: *mut libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Set the size of a window's client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to resize."]
  #[doc = "  \\param w        The width of the window, in screen coordinates. Must be >0."]
  #[doc = "  \\param h        The height of the window, in screen coordinates. Must be >0."]
  #[doc = ""]
  #[doc = "  \\note Fullscreen windows automatically match the size of the display mode,"]
  #[doc = "        and you should use SDL_SetWindowDisplayMode() to change their size."]
  #[doc = ""]
  #[doc = "  The window size in screen coordinates may differ from the size in pixels, if"]
  #[doc = "  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with"]
  #[doc = "  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or"]
  #[doc = "  SDL_GetRendererOutputSize() to get the real client area size in pixels."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSize()"]
  #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
  #[link_name = "\u{1}_SDL_SetWindowSize"]
  pub fn SDL_SetWindowSize(window: *mut SDL_Window, w: libc::c_int, h: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the size of a window's client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param w        Pointer to variable for storing the width, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = "  \\param h        Pointer to variable for storing the height, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = ""]
  #[doc = "  The window size in screen coordinates may differ from the size in pixels, if"]
  #[doc = "  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with"]
  #[doc = "  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or"]
  #[doc = "  SDL_GetRendererOutputSize() to get the real client area size in pixels."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowSize()"]
  #[link_name = "\u{1}_SDL_GetWindowSize"]
  pub fn SDL_GetWindowSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the size of a window's borders (decorations) around the client area."]
  #[doc = ""]
  #[doc = "  \\param window The window to query."]
  #[doc = "  \\param top Pointer to variable for storing the size of the top border. NULL is permitted."]
  #[doc = "  \\param left Pointer to variable for storing the size of the left border. NULL is permitted."]
  #[doc = "  \\param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted."]
  #[doc = "  \\param right Pointer to variable for storing the size of the right border. NULL is permitted."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if getting this information is not supported."]
  #[doc = ""]
  #[doc = "  \\note if this function fails (returns -1), the size values will be"]
  #[doc = "        initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as"]
  #[doc = "        if the window in question was borderless."]
  #[link_name = "\u{1}_SDL_GetWindowBordersSize"]
  pub fn SDL_GetWindowBordersSize(
    window: *mut SDL_Window,
    top: *mut libc::c_int,
    left: *mut libc::c_int,
    bottom: *mut libc::c_int,
    right: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the minimum size of a window's client area."]
  #[doc = ""]
  #[doc = "  \\param window    The window to set a new minimum size."]
  #[doc = "  \\param min_w     The minimum width of the window, must be >0"]
  #[doc = "  \\param min_h     The minimum height of the window, must be >0"]
  #[doc = ""]
  #[doc = "  \\note You can't change the minimum size of a fullscreen window, it"]
  #[doc = "        automatically matches the size of the display mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMinimumSize()"]
  #[doc = "  \\sa SDL_SetWindowMaximumSize()"]
  #[link_name = "\u{1}_SDL_SetWindowMinimumSize"]
  pub fn SDL_SetWindowMinimumSize(window: *mut SDL_Window, min_w: libc::c_int, min_h: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the minimum size of a window's client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param w        Pointer to variable for storing the minimum width, may be NULL"]
  #[doc = "  \\param h        Pointer to variable for storing the minimum height, may be NULL"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMaximumSize()"]
  #[doc = "  \\sa SDL_SetWindowMinimumSize()"]
  #[link_name = "\u{1}_SDL_GetWindowMinimumSize"]
  pub fn SDL_GetWindowMinimumSize(
    window: *mut SDL_Window,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
extern "C" {
  #[doc = "  \\brief Set the maximum size of a window's client area."]
  #[doc = ""]
  #[doc = "  \\param window    The window to set a new maximum size."]
  #[doc = "  \\param max_w     The maximum width of the window, must be >0"]
  #[doc = "  \\param max_h     The maximum height of the window, must be >0"]
  #[doc = ""]
  #[doc = "  \\note You can't change the maximum size of a fullscreen window, it"]
  #[doc = "        automatically matches the size of the display mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMaximumSize()"]
  #[doc = "  \\sa SDL_SetWindowMinimumSize()"]
  #[link_name = "\u{1}_SDL_SetWindowMaximumSize"]
  pub fn SDL_SetWindowMaximumSize(window: *mut SDL_Window, max_w: libc::c_int, max_h: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the maximum size of a window's client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param w        Pointer to variable for storing the maximum width, may be NULL"]
  #[doc = "  \\param h        Pointer to variable for storing the maximum height, may be NULL"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMinimumSize()"]
  #[doc = "  \\sa SDL_SetWindowMaximumSize()"]
  #[link_name = "\u{1}_SDL_GetWindowMaximumSize"]
  pub fn SDL_GetWindowMaximumSize(
    window: *mut SDL_Window,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
extern "C" {
  #[doc = "  \\brief Set the border state of a window."]
  #[doc = ""]
  #[doc = "  This will add or remove the window's SDL_WINDOW_BORDERLESS flag and"]
  #[doc = "  add or remove the border from the actual window. This is a no-op if the"]
  #[doc = "  window's border already matches the requested state."]
  #[doc = ""]
  #[doc = "  \\param window The window of which to change the border state."]
  #[doc = "  \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border."]
  #[doc = ""]
  #[doc = "  \\note You can't change the border state of a fullscreen window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowFlags()"]
  #[link_name = "\u{1}_SDL_SetWindowBordered"]
  pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool::Type);
}
extern "C" {
  #[doc = "  \\brief Set the user-resizable state of a window."]
  #[doc = ""]
  #[doc = "  This will add or remove the window's SDL_WINDOW_RESIZABLE flag and"]
  #[doc = "  allow/disallow user resizing of the window. This is a no-op if the"]
  #[doc = "  window's resizable state already matches the requested state."]
  #[doc = ""]
  #[doc = "  \\param window The window of which to change the resizable state."]
  #[doc = "  \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow."]
  #[doc = ""]
  #[doc = "  \\note You can't change the resizable state of a fullscreen window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowFlags()"]
  #[link_name = "\u{1}_SDL_SetWindowResizable"]
  pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool::Type);
}
extern "C" {
  #[doc = "  \\brief Show a window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HideWindow()"]
  #[link_name = "\u{1}_SDL_ShowWindow"]
  pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Hide a window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_ShowWindow()"]
  #[link_name = "\u{1}_SDL_HideWindow"]
  pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Raise a window above other windows and set the input focus."]
  #[link_name = "\u{1}_SDL_RaiseWindow"]
  pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Make a window as large as possible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RestoreWindow()"]
  #[link_name = "\u{1}_SDL_MaximizeWindow"]
  pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Minimize a window to an iconic representation."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RestoreWindow()"]
  #[link_name = "\u{1}_SDL_MinimizeWindow"]
  pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Restore the size and position of a minimized or maximized window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MaximizeWindow()"]
  #[doc = "  \\sa SDL_MinimizeWindow()"]
  #[link_name = "\u{1}_SDL_RestoreWindow"]
  pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Set a window's fullscreen state."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the display mode failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
  #[doc = "  \\sa SDL_GetWindowDisplayMode()"]
  #[link_name = "\u{1}_SDL_SetWindowFullscreen"]
  pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the SDL surface associated with the window."]
  #[doc = ""]
  #[doc = "  \\return The window's framebuffer surface, or NULL on error."]
  #[doc = ""]
  #[doc = "  A new surface will be created with the optimal format for the window,"]
  #[doc = "  if necessary. This surface will be freed when the window is destroyed."]
  #[doc = ""]
  #[doc = "  \\note You may not combine this with 3D or the rendering API on this window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_UpdateWindowSurface()"]
  #[doc = "  \\sa SDL_UpdateWindowSurfaceRects()"]
  #[link_name = "\u{1}_SDL_GetWindowSurface"]
  pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = "  \\brief Copy the window surface to the screen."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSurface()"]
  #[doc = "  \\sa SDL_UpdateWindowSurfaceRects()"]
  #[link_name = "\u{1}_SDL_UpdateWindowSurface"]
  pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Copy a number of rectangles on the window surface to the screen."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSurface()"]
  #[doc = "  \\sa SDL_UpdateWindowSurface()"]
  #[link_name = "\u{1}_SDL_UpdateWindowSurfaceRects"]
  pub fn SDL_UpdateWindowSurfaceRects(
    window: *mut SDL_Window,
    rects: *const SDL_Rect,
    numrects: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set a window's input grab mode."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the input grab mode should be set."]
  #[doc = "  \\param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input."]
  #[doc = ""]
  #[doc = "  If the caller enables a grab while another window is currently grabbed,"]
  #[doc = "  the other window loses its grab in favor of the caller's window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowGrab()"]
  #[link_name = "\u{1}_SDL_SetWindowGrab"]
  pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool::Type);
}
extern "C" {
  #[doc = "  \\brief Get a window's input grab mode."]
  #[doc = ""]
  #[doc = "  \\return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowGrab()"]
  #[link_name = "\u{1}_SDL_GetWindowGrab"]
  pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Get the window that currently has an input grab enabled."]
  #[doc = ""]
  #[doc = "  \\return This returns the window if input is grabbed, and NULL otherwise."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowGrab()"]
  #[link_name = "\u{1}_SDL_GetGrabbedWindow"]
  pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Set the brightness (gamma correction) for a window."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the brightness isn't supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowBrightness()"]
  #[doc = "  \\sa SDL_SetWindowGammaRamp()"]
  #[link_name = "\u{1}_SDL_SetWindowBrightness"]
  pub fn SDL_SetWindowBrightness(window: *mut SDL_Window, brightness: f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the brightness (gamma correction) for a window."]
  #[doc = ""]
  #[doc = "  \\return The last brightness value passed to SDL_SetWindowBrightness()"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowBrightness()"]
  #[link_name = "\u{1}_SDL_GetWindowBrightness"]
  pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
  #[doc = "  \\brief Set the opacity for a window"]
  #[doc = ""]
  #[doc = "  \\param window The window which will be made transparent or opaque"]
  #[doc = "  \\param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be"]
  #[doc = "                 clamped internally between 0.0f and 1.0f."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the opacity isn't supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowOpacity()"]
  #[link_name = "\u{1}_SDL_SetWindowOpacity"]
  pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the opacity of a window."]
  #[doc = ""]
  #[doc = "  If transparency isn't supported on this platform, opacity will be reported"]
  #[doc = "  as 1.0f without error."]
  #[doc = ""]
  #[doc = "  \\param window The window in question."]
  #[doc = "  \\param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error (invalid window, etc)."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowOpacity()"]
  #[link_name = "\u{1}_SDL_GetWindowOpacity"]
  pub fn SDL_GetWindowOpacity(window: *mut SDL_Window, out_opacity: *mut f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)"]
  #[doc = ""]
  #[doc = "  \\param modal_window The window that should be modal"]
  #[doc = "  \\param parent_window The parent window"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 otherwise."]
  #[link_name = "\u{1}_SDL_SetWindowModalFor"]
  pub fn SDL_SetWindowModalFor(
    modal_window: *mut SDL_Window,
    parent_window: *mut SDL_Window,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Explicitly sets input focus to the window."]
  #[doc = ""]
  #[doc = "  You almost certainly want SDL_RaiseWindow() instead of this function. Use"]
  #[doc = "  this with caution, as you might give focus to a window that's completely"]
  #[doc = "  obscured by other windows."]
  #[doc = ""]
  #[doc = "  \\param window The window that should get the input focus"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 otherwise."]
  #[doc = "  \\sa SDL_RaiseWindow()"]
  #[link_name = "\u{1}_SDL_SetWindowInputFocus"]
  pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the gamma ramp for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the gamma ramp should be set."]
  #[doc = "  \\param red The translation table for the red channel, or NULL."]
  #[doc = "  \\param green The translation table for the green channel, or NULL."]
  #[doc = "  \\param blue The translation table for the blue channel, or NULL."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if gamma ramps are unsupported."]
  #[doc = ""]
  #[doc = "  Set the gamma translation table for the red, green, and blue channels"]
  #[doc = "  of the video hardware.  Each table is an array of 256 16-bit quantities,"]
  #[doc = "  representing a mapping between the input and output for that channel."]
  #[doc = "  The input is the index into the array, and the output is the 16-bit"]
  #[doc = "  gamma value at that index, scaled to the output color precision."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowGammaRamp()"]
  #[link_name = "\u{1}_SDL_SetWindowGammaRamp"]
  pub fn SDL_SetWindowGammaRamp(
    window: *mut SDL_Window,
    red: *const Uint16,
    green: *const Uint16,
    blue: *const Uint16,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the gamma ramp for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window from which the gamma ramp should be queried."]
  #[doc = "  \\param red   A pointer to a 256 element array of 16-bit quantities to hold"]
  #[doc = "               the translation table for the red channel, or NULL."]
  #[doc = "  \\param green A pointer to a 256 element array of 16-bit quantities to hold"]
  #[doc = "               the translation table for the green channel, or NULL."]
  #[doc = "  \\param blue  A pointer to a 256 element array of 16-bit quantities to hold"]
  #[doc = "               the translation table for the blue channel, or NULL."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if gamma ramps are unsupported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowGammaRamp()"]
  #[link_name = "\u{1}_SDL_GetWindowGammaRamp"]
  pub fn SDL_GetWindowGammaRamp(
    window: *mut SDL_Window,
    red: *mut Uint16,
    green: *mut Uint16,
    blue: *mut Uint16,
  ) -> libc::c_int;
}
pub mod SDL_HitTestResult {
  #[doc = "  \\brief Possible return values from the SDL_HitTest callback."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HitTest"]
  pub type Type = u32;
  #[doc = "< Region is normal. No special properties."]
  pub const SDL_HITTEST_NORMAL: Type = 0;
  #[doc = "< Region can drag entire window."]
  pub const SDL_HITTEST_DRAGGABLE: Type = 1;
  pub const SDL_HITTEST_RESIZE_TOPLEFT: Type = 2;
  pub const SDL_HITTEST_RESIZE_TOP: Type = 3;
  pub const SDL_HITTEST_RESIZE_TOPRIGHT: Type = 4;
  pub const SDL_HITTEST_RESIZE_RIGHT: Type = 5;
  pub const SDL_HITTEST_RESIZE_BOTTOMRIGHT: Type = 6;
  pub const SDL_HITTEST_RESIZE_BOTTOM: Type = 7;
  pub const SDL_HITTEST_RESIZE_BOTTOMLEFT: Type = 8;
  pub const SDL_HITTEST_RESIZE_LEFT: Type = 9;
}
#[doc = "  \\brief Callback used for hit-testing."]
#[doc = ""]
#[doc = "  \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::core::option::Option<
  unsafe extern "C" fn(
    win: *mut SDL_Window,
    area: *const SDL_Point,
    data: *mut libc::c_void,
  ) -> SDL_HitTestResult::Type,
>;
extern "C" {
  #[doc = "  \\brief Provide a callback that decides if a window region has special properties."]
  #[doc = ""]
  #[doc = "  Normally windows are dragged and resized by decorations provided by the"]
  #[doc = "  system window manager (a title bar, borders, etc), but for some apps, it"]
  #[doc = "  makes sense to drag them from somewhere else inside the window itself; for"]
  #[doc = "  example, one might have a borderless window that wants to be draggable"]
  #[doc = "  from any part, or simulate its own title bar, etc."]
  #[doc = ""]
  #[doc = "  This function lets the app provide a callback that designates pieces of"]
  #[doc = "  a given window as special. This callback is run during event processing"]
  #[doc = "  if we need to tell the OS to treat a region of the window specially; the"]
  #[doc = "  use of this callback is known as \"hit testing.\""]
  #[doc = ""]
  #[doc = "  Mouse input may not be delivered to your application if it is within"]
  #[doc = "  a special area; the OS will often apply that input to moving the window or"]
  #[doc = "  resizing the window and not deliver it to the application."]
  #[doc = ""]
  #[doc = "  Specifying NULL for a callback disables hit-testing. Hit-testing is"]
  #[doc = "  disabled by default."]
  #[doc = ""]
  #[doc = "  Platforms that don't support this functionality will return -1"]
  #[doc = "  unconditionally, even if you're attempting to disable hit-testing."]
  #[doc = ""]
  #[doc = "  Your callback may fire at any time, and its firing does not indicate any"]
  #[doc = "  specific behavior (for example, on Windows, this certainly might fire"]
  #[doc = "  when the OS is deciding whether to drag your window, but it fires for lots"]
  #[doc = "  of other reasons, too, some unrelated to anything you probably care about"]
  #[doc = "  _and when the mouse isn't actually at the location it is testing_)."]
  #[doc = "  Since this can fire at any time, you should try to keep your callback"]
  #[doc = "  efficient, devoid of allocations, etc."]
  #[doc = ""]
  #[doc = "  \\param window The window to set hit-testing on."]
  #[doc = "  \\param callback The callback to call when doing a hit-test."]
  #[doc = "  \\param callback_data An app-defined void pointer passed to the callback."]
  #[doc = "  \\return 0 on success, -1 on error (including unsupported)."]
  #[link_name = "\u{1}_SDL_SetWindowHitTest"]
  pub fn SDL_SetWindowHitTest(
    window: *mut SDL_Window,
    callback: SDL_HitTest,
    callback_data: *mut libc::c_void,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Destroy a window."]
  #[link_name = "\u{1}_SDL_DestroyWindow"]
  pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Returns whether the screensaver is currently enabled (default off)."]
  #[doc = ""]
  #[doc = "  \\sa SDL_EnableScreenSaver()"]
  #[doc = "  \\sa SDL_DisableScreenSaver()"]
  #[link_name = "\u{1}_SDL_IsScreenSaverEnabled"]
  pub fn SDL_IsScreenSaverEnabled() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Allow the screen to be blanked by a screensaver"]
  #[doc = ""]
  #[doc = "  \\sa SDL_IsScreenSaverEnabled()"]
  #[doc = "  \\sa SDL_DisableScreenSaver()"]
  #[link_name = "\u{1}_SDL_EnableScreenSaver"]
  pub fn SDL_EnableScreenSaver();
}
extern "C" {
  #[doc = "  \\brief Prevent the screen from being blanked by a screensaver"]
  #[doc = ""]
  #[doc = "  \\sa SDL_IsScreenSaverEnabled()"]
  #[doc = "  \\sa SDL_EnableScreenSaver()"]
  #[link_name = "\u{1}_SDL_DisableScreenSaver"]
  pub fn SDL_DisableScreenSaver();
}
extern "C" {
  #[doc = "  \\brief Dynamically load an OpenGL library."]
  #[doc = ""]
  #[doc = "  \\param path The platform dependent OpenGL library name, or NULL to open the"]
  #[doc = "              default OpenGL library."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the library couldn't be loaded."]
  #[doc = ""]
  #[doc = "  This should be done after initializing the video driver, but before"]
  #[doc = "  creating any OpenGL windows.  If no OpenGL library is loaded, the default"]
  #[doc = "  library will be loaded upon creation of the first OpenGL window."]
  #[doc = ""]
  #[doc = "  \\note If you do this, you need to retrieve all of the GL functions used in"]
  #[doc = "        your program from the dynamic library using SDL_GL_GetProcAddress()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_GetProcAddress()"]
  #[doc = "  \\sa SDL_GL_UnloadLibrary()"]
  #[link_name = "\u{1}_SDL_GL_LoadLibrary"]
  pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the address of an OpenGL function."]
  #[link_name = "\u{1}_SDL_GL_GetProcAddress"]
  pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_LoadLibrary()"]
  #[link_name = "\u{1}_SDL_GL_UnloadLibrary"]
  pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
  #[doc = "  \\brief Return true if an OpenGL extension is supported for the current"]
  #[doc = "         context."]
  #[link_name = "\u{1}_SDL_GL_ExtensionSupported"]
  pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Reset all previously set OpenGL context attributes to their default values"]
  #[link_name = "\u{1}_SDL_GL_ResetAttributes"]
  pub fn SDL_GL_ResetAttributes();
}
extern "C" {
  #[doc = "  \\brief Set an OpenGL window attribute before window creation."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the attribute could not be set."]
  #[link_name = "\u{1}_SDL_GL_SetAttribute"]
  pub fn SDL_GL_SetAttribute(attr: SDL_GLattr::Type, value: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the actual value for an attribute from the current context."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the attribute could not be retrieved."]
  #[doc = "          The integer at \\c value will be modified in either case."]
  #[link_name = "\u{1}_SDL_GL_GetAttribute"]
  pub fn SDL_GL_GetAttribute(attr: SDL_GLattr::Type, value: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create an OpenGL context for use with an OpenGL window, and make it"]
  #[doc = "         current."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_DeleteContext()"]
  #[link_name = "\u{1}_SDL_GL_CreateContext"]
  pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
  #[doc = "  \\brief Set up an OpenGL context for rendering into an OpenGL window."]
  #[doc = ""]
  #[doc = "  \\note The context must have been created with a compatible window."]
  #[link_name = "\u{1}_SDL_GL_MakeCurrent"]
  pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the currently active OpenGL window."]
  #[link_name = "\u{1}_SDL_GL_GetCurrentWindow"]
  pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get the currently active OpenGL context."]
  #[link_name = "\u{1}_SDL_GL_GetCurrentContext"]
  pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
  #[doc = "  \\brief Get the size of a window's underlying drawable in pixels (for use"]
  #[doc = "         with glViewport)."]
  #[doc = ""]
  #[doc = "  \\param window   Window from which the drawable size should be queried"]
  #[doc = "  \\param w        Pointer to variable for storing the width in pixels, may be NULL"]
  #[doc = "  \\param h        Pointer to variable for storing the height in pixels, may be NULL"]
  #[doc = ""]
  #[doc = " This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI"]
  #[doc = " drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a"]
  #[doc = " platform with high-DPI support (Apple calls this \"Retina\"), and not disabled"]
  #[doc = " by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSize()"]
  #[doc = "  \\sa SDL_CreateWindow()"]
  #[link_name = "\u{1}_SDL_GL_GetDrawableSize"]
  pub fn SDL_GL_GetDrawableSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Set the swap interval for the current OpenGL context."]
  #[doc = ""]
  #[doc = "  \\param interval 0 for immediate updates, 1 for updates synchronized with the"]
  #[doc = "                  vertical retrace. If the system supports it, you may"]
  #[doc = "                  specify -1 to allow late swaps to happen immediately"]
  #[doc = "                  instead of waiting for the next retrace."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the swap interval is not supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_GetSwapInterval()"]
  #[link_name = "\u{1}_SDL_GL_SetSwapInterval"]
  pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the swap interval for the current OpenGL context."]
  #[doc = ""]
  #[doc = "  \\return 0 if there is no vertical retrace synchronization, 1 if the buffer"]
  #[doc = "          swap is synchronized with the vertical retrace, and -1 if late"]
  #[doc = "          swaps happen immediately instead of waiting for the next retrace."]
  #[doc = "          If the system can't determine the swap interval, or there isn't a"]
  #[doc = "          valid current context, this will return 0 as a safe default."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_SetSwapInterval()"]
  #[link_name = "\u{1}_SDL_GL_GetSwapInterval"]
  pub fn SDL_GL_GetSwapInterval() -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Swap the OpenGL buffers for a window, if double-buffering is"]
  #[doc = "        supported."]
  #[link_name = "\u{1}_SDL_GL_SwapWindow"]
  pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Delete an OpenGL context."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_CreateContext()"]
  #[link_name = "\u{1}_SDL_GL_DeleteContext"]
  pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
pub mod SDL_Scancode {
  #[doc = "  \\brief The SDL keyboard scancode representation."]
  #[doc = ""]
  #[doc = "  Values of this type are used to represent keyboard keys, among other places"]
  #[doc = "  in the \\link SDL_Keysym::scancode key.keysym.scancode \\endlink field of the"]
  #[doc = "  SDL_Event structure."]
  #[doc = ""]
  #[doc = "  The values in this enumeration are based on the USB usage page standard:"]
  #[doc = "  http://www.usb.org/developers/hidpage/Hut1_12v2.pdf"]
  pub type Type = u32;
  pub const SDL_SCANCODE_UNKNOWN: Type = 0;
  pub const SDL_SCANCODE_A: Type = 4;
  pub const SDL_SCANCODE_B: Type = 5;
  pub const SDL_SCANCODE_C: Type = 6;
  pub const SDL_SCANCODE_D: Type = 7;
  pub const SDL_SCANCODE_E: Type = 8;
  pub const SDL_SCANCODE_F: Type = 9;
  pub const SDL_SCANCODE_G: Type = 10;
  pub const SDL_SCANCODE_H: Type = 11;
  pub const SDL_SCANCODE_I: Type = 12;
  pub const SDL_SCANCODE_J: Type = 13;
  pub const SDL_SCANCODE_K: Type = 14;
  pub const SDL_SCANCODE_L: Type = 15;
  pub const SDL_SCANCODE_M: Type = 16;
  pub const SDL_SCANCODE_N: Type = 17;
  pub const SDL_SCANCODE_O: Type = 18;
  pub const SDL_SCANCODE_P: Type = 19;
  pub const SDL_SCANCODE_Q: Type = 20;
  pub const SDL_SCANCODE_R: Type = 21;
  pub const SDL_SCANCODE_S: Type = 22;
  pub const SDL_SCANCODE_T: Type = 23;
  pub const SDL_SCANCODE_U: Type = 24;
  pub const SDL_SCANCODE_V: Type = 25;
  pub const SDL_SCANCODE_W: Type = 26;
  pub const SDL_SCANCODE_X: Type = 27;
  pub const SDL_SCANCODE_Y: Type = 28;
  pub const SDL_SCANCODE_Z: Type = 29;
  pub const SDL_SCANCODE_1: Type = 30;
  pub const SDL_SCANCODE_2: Type = 31;
  pub const SDL_SCANCODE_3: Type = 32;
  pub const SDL_SCANCODE_4: Type = 33;
  pub const SDL_SCANCODE_5: Type = 34;
  pub const SDL_SCANCODE_6: Type = 35;
  pub const SDL_SCANCODE_7: Type = 36;
  pub const SDL_SCANCODE_8: Type = 37;
  pub const SDL_SCANCODE_9: Type = 38;
  pub const SDL_SCANCODE_0: Type = 39;
  pub const SDL_SCANCODE_RETURN: Type = 40;
  pub const SDL_SCANCODE_ESCAPE: Type = 41;
  pub const SDL_SCANCODE_BACKSPACE: Type = 42;
  pub const SDL_SCANCODE_TAB: Type = 43;
  pub const SDL_SCANCODE_SPACE: Type = 44;
  pub const SDL_SCANCODE_MINUS: Type = 45;
  pub const SDL_SCANCODE_EQUALS: Type = 46;
  pub const SDL_SCANCODE_LEFTBRACKET: Type = 47;
  pub const SDL_SCANCODE_RIGHTBRACKET: Type = 48;
  #[doc = "< Located at the lower left of the return"]
  #[doc = "   key on ISO keyboards and at the right end"]
  #[doc = "   of the QWERTY row on ANSI keyboards."]
  #[doc = "   Produces REVERSE SOLIDUS (backslash) and"]
  #[doc = "   VERTICAL LINE in a US layout, REVERSE"]
  #[doc = "   SOLIDUS and VERTICAL LINE in a UK Mac"]
  #[doc = "   layout, NUMBER SIGN and TILDE in a UK"]
  #[doc = "   Windows layout, DOLLAR SIGN and POUND SIGN"]
  #[doc = "   in a Swiss German layout, NUMBER SIGN and"]
  #[doc = "   APOSTROPHE in a German layout, GRAVE"]
  #[doc = "   ACCENT and POUND SIGN in a French Mac"]
  #[doc = "   layout, and ASTERISK and MICRO SIGN in a"]
  #[doc = "   French Windows layout."]
  pub const SDL_SCANCODE_BACKSLASH: Type = 49;
  #[doc = "< ISO USB keyboards actually use this code"]
  #[doc = "   instead of 49 for the same key, but all"]
  #[doc = "   OSes I've seen treat the two codes"]
  #[doc = "   identically. So, as an implementor, unless"]
  #[doc = "   your keyboard generates both of those"]
  #[doc = "   codes and your OS treats them differently,"]
  #[doc = "   you should generate SDL_SCANCODE_BACKSLASH"]
  #[doc = "   instead of this code. As a user, you"]
  #[doc = "   should not rely on this code because SDL"]
  #[doc = "   will never generate it with most (all?)"]
  #[doc = "   keyboards."]
  pub const SDL_SCANCODE_NONUSHASH: Type = 50;
  pub const SDL_SCANCODE_SEMICOLON: Type = 51;
  pub const SDL_SCANCODE_APOSTROPHE: Type = 52;
  #[doc = "< Located in the top left corner (on both ANSI"]
  #[doc = "   and ISO keyboards). Produces GRAVE ACCENT and"]
  #[doc = "   TILDE in a US Windows layout and in US and UK"]
  #[doc = "   Mac layouts on ANSI keyboards, GRAVE ACCENT"]
  #[doc = "   and NOT SIGN in a UK Windows layout, SECTION"]
  #[doc = "   SIGN and PLUS-MINUS SIGN in US and UK Mac"]
  #[doc = "   layouts on ISO keyboards, SECTION SIGN and"]
  #[doc = "   DEGREE SIGN in a Swiss German layout (Mac:"]
  #[doc = "   only on ISO keyboards), CIRCUMFLEX ACCENT and"]
  #[doc = "   DEGREE SIGN in a German layout (Mac: only on"]
  #[doc = "   ISO keyboards), SUPERSCRIPT TWO and TILDE in a"]
  #[doc = "   French Windows layout, COMMERCIAL AT and"]
  #[doc = "   NUMBER SIGN in a French Mac layout on ISO"]
  #[doc = "   keyboards, and LESS-THAN SIGN and GREATER-THAN"]
  #[doc = "   SIGN in a Swiss German, German, or French Mac"]
  #[doc = "   layout on ANSI keyboards."]
  pub const SDL_SCANCODE_GRAVE: Type = 53;
  pub const SDL_SCANCODE_COMMA: Type = 54;
  pub const SDL_SCANCODE_PERIOD: Type = 55;
  pub const SDL_SCANCODE_SLASH: Type = 56;
  pub const SDL_SCANCODE_CAPSLOCK: Type = 57;
  pub const SDL_SCANCODE_F1: Type = 58;
  pub const SDL_SCANCODE_F2: Type = 59;
  pub const SDL_SCANCODE_F3: Type = 60;
  pub const SDL_SCANCODE_F4: Type = 61;
  pub const SDL_SCANCODE_F5: Type = 62;
  pub const SDL_SCANCODE_F6: Type = 63;
  pub const SDL_SCANCODE_F7: Type = 64;
  pub const SDL_SCANCODE_F8: Type = 65;
  pub const SDL_SCANCODE_F9: Type = 66;
  pub const SDL_SCANCODE_F10: Type = 67;
  pub const SDL_SCANCODE_F11: Type = 68;
  pub const SDL_SCANCODE_F12: Type = 69;
  pub const SDL_SCANCODE_PRINTSCREEN: Type = 70;
  pub const SDL_SCANCODE_SCROLLLOCK: Type = 71;
  pub const SDL_SCANCODE_PAUSE: Type = 72;
  #[doc = "< insert on PC, help on some Mac keyboards (but"]
  #[doc = "does send code 73, not 117)"]
  pub const SDL_SCANCODE_INSERT: Type = 73;
  pub const SDL_SCANCODE_HOME: Type = 74;
  pub const SDL_SCANCODE_PAGEUP: Type = 75;
  pub const SDL_SCANCODE_DELETE: Type = 76;
  pub const SDL_SCANCODE_END: Type = 77;
  pub const SDL_SCANCODE_PAGEDOWN: Type = 78;
  pub const SDL_SCANCODE_RIGHT: Type = 79;
  pub const SDL_SCANCODE_LEFT: Type = 80;
  pub const SDL_SCANCODE_DOWN: Type = 81;
  pub const SDL_SCANCODE_UP: Type = 82;
  #[doc = "< num lock on PC, clear on Mac keyboards"]
  pub const SDL_SCANCODE_NUMLOCKCLEAR: Type = 83;
  pub const SDL_SCANCODE_KP_DIVIDE: Type = 84;
  pub const SDL_SCANCODE_KP_MULTIPLY: Type = 85;
  pub const SDL_SCANCODE_KP_MINUS: Type = 86;
  pub const SDL_SCANCODE_KP_PLUS: Type = 87;
  pub const SDL_SCANCODE_KP_ENTER: Type = 88;
  pub const SDL_SCANCODE_KP_1: Type = 89;
  pub const SDL_SCANCODE_KP_2: Type = 90;
  pub const SDL_SCANCODE_KP_3: Type = 91;
  pub const SDL_SCANCODE_KP_4: Type = 92;
  pub const SDL_SCANCODE_KP_5: Type = 93;
  pub const SDL_SCANCODE_KP_6: Type = 94;
  pub const SDL_SCANCODE_KP_7: Type = 95;
  pub const SDL_SCANCODE_KP_8: Type = 96;
  pub const SDL_SCANCODE_KP_9: Type = 97;
  pub const SDL_SCANCODE_KP_0: Type = 98;
  pub const SDL_SCANCODE_KP_PERIOD: Type = 99;
  #[doc = "< This is the additional key that ISO"]
  #[doc = "   keyboards have over ANSI ones,"]
  #[doc = "   located between left shift and Y."]
  #[doc = "   Produces GRAVE ACCENT and TILDE in a"]
  #[doc = "   US or UK Mac layout, REVERSE SOLIDUS"]
  #[doc = "   (backslash) and VERTICAL LINE in a"]
  #[doc = "   US or UK Windows layout, and"]
  #[doc = "   LESS-THAN SIGN and GREATER-THAN SIGN"]
  #[doc = "   in a Swiss German, German, or French"]
  #[doc = "   layout."]
  pub const SDL_SCANCODE_NONUSBACKSLASH: Type = 100;
  #[doc = "< windows contextual menu, compose"]
  pub const SDL_SCANCODE_APPLICATION: Type = 101;
  #[doc = "< The USB document says this is a status flag,"]
  #[doc = "   not a physical key - but some Mac keyboards"]
  #[doc = "   do have a power key."]
  pub const SDL_SCANCODE_POWER: Type = 102;
  pub const SDL_SCANCODE_KP_EQUALS: Type = 103;
  pub const SDL_SCANCODE_F13: Type = 104;
  pub const SDL_SCANCODE_F14: Type = 105;
  pub const SDL_SCANCODE_F15: Type = 106;
  pub const SDL_SCANCODE_F16: Type = 107;
  pub const SDL_SCANCODE_F17: Type = 108;
  pub const SDL_SCANCODE_F18: Type = 109;
  pub const SDL_SCANCODE_F19: Type = 110;
  pub const SDL_SCANCODE_F20: Type = 111;
  pub const SDL_SCANCODE_F21: Type = 112;
  pub const SDL_SCANCODE_F22: Type = 113;
  pub const SDL_SCANCODE_F23: Type = 114;
  pub const SDL_SCANCODE_F24: Type = 115;
  pub const SDL_SCANCODE_EXECUTE: Type = 116;
  pub const SDL_SCANCODE_HELP: Type = 117;
  pub const SDL_SCANCODE_MENU: Type = 118;
  pub const SDL_SCANCODE_SELECT: Type = 119;
  pub const SDL_SCANCODE_STOP: Type = 120;
  #[doc = "< redo"]
  pub const SDL_SCANCODE_AGAIN: Type = 121;
  pub const SDL_SCANCODE_UNDO: Type = 122;
  pub const SDL_SCANCODE_CUT: Type = 123;
  pub const SDL_SCANCODE_COPY: Type = 124;
  pub const SDL_SCANCODE_PASTE: Type = 125;
  pub const SDL_SCANCODE_FIND: Type = 126;
  pub const SDL_SCANCODE_MUTE: Type = 127;
  pub const SDL_SCANCODE_VOLUMEUP: Type = 128;
  pub const SDL_SCANCODE_VOLUMEDOWN: Type = 129;
  pub const SDL_SCANCODE_KP_COMMA: Type = 133;
  pub const SDL_SCANCODE_KP_EQUALSAS400: Type = 134;
  #[doc = "< used on Asian keyboards, see"]
  #[doc = "footnotes in USB doc"]
  pub const SDL_SCANCODE_INTERNATIONAL1: Type = 135;
  pub const SDL_SCANCODE_INTERNATIONAL2: Type = 136;
  #[doc = "< Yen"]
  pub const SDL_SCANCODE_INTERNATIONAL3: Type = 137;
  pub const SDL_SCANCODE_INTERNATIONAL4: Type = 138;
  pub const SDL_SCANCODE_INTERNATIONAL5: Type = 139;
  pub const SDL_SCANCODE_INTERNATIONAL6: Type = 140;
  pub const SDL_SCANCODE_INTERNATIONAL7: Type = 141;
  pub const SDL_SCANCODE_INTERNATIONAL8: Type = 142;
  pub const SDL_SCANCODE_INTERNATIONAL9: Type = 143;
  #[doc = "< Hangul/English toggle"]
  pub const SDL_SCANCODE_LANG1: Type = 144;
  #[doc = "< Hanja conversion"]
  pub const SDL_SCANCODE_LANG2: Type = 145;
  #[doc = "< Katakana"]
  pub const SDL_SCANCODE_LANG3: Type = 146;
  #[doc = "< Hiragana"]
  pub const SDL_SCANCODE_LANG4: Type = 147;
  #[doc = "< Zenkaku/Hankaku"]
  pub const SDL_SCANCODE_LANG5: Type = 148;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG6: Type = 149;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG7: Type = 150;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG8: Type = 151;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG9: Type = 152;
  #[doc = "< Erase-Eaze"]
  pub const SDL_SCANCODE_ALTERASE: Type = 153;
  pub const SDL_SCANCODE_SYSREQ: Type = 154;
  pub const SDL_SCANCODE_CANCEL: Type = 155;
  pub const SDL_SCANCODE_CLEAR: Type = 156;
  pub const SDL_SCANCODE_PRIOR: Type = 157;
  pub const SDL_SCANCODE_RETURN2: Type = 158;
  pub const SDL_SCANCODE_SEPARATOR: Type = 159;
  pub const SDL_SCANCODE_OUT: Type = 160;
  pub const SDL_SCANCODE_OPER: Type = 161;
  pub const SDL_SCANCODE_CLEARAGAIN: Type = 162;
  pub const SDL_SCANCODE_CRSEL: Type = 163;
  pub const SDL_SCANCODE_EXSEL: Type = 164;
  pub const SDL_SCANCODE_KP_00: Type = 176;
  pub const SDL_SCANCODE_KP_000: Type = 177;
  pub const SDL_SCANCODE_THOUSANDSSEPARATOR: Type = 178;
  pub const SDL_SCANCODE_DECIMALSEPARATOR: Type = 179;
  pub const SDL_SCANCODE_CURRENCYUNIT: Type = 180;
  pub const SDL_SCANCODE_CURRENCYSUBUNIT: Type = 181;
  pub const SDL_SCANCODE_KP_LEFTPAREN: Type = 182;
  pub const SDL_SCANCODE_KP_RIGHTPAREN: Type = 183;
  pub const SDL_SCANCODE_KP_LEFTBRACE: Type = 184;
  pub const SDL_SCANCODE_KP_RIGHTBRACE: Type = 185;
  pub const SDL_SCANCODE_KP_TAB: Type = 186;
  pub const SDL_SCANCODE_KP_BACKSPACE: Type = 187;
  pub const SDL_SCANCODE_KP_A: Type = 188;
  pub const SDL_SCANCODE_KP_B: Type = 189;
  pub const SDL_SCANCODE_KP_C: Type = 190;
  pub const SDL_SCANCODE_KP_D: Type = 191;
  pub const SDL_SCANCODE_KP_E: Type = 192;
  pub const SDL_SCANCODE_KP_F: Type = 193;
  pub const SDL_SCANCODE_KP_XOR: Type = 194;
  pub const SDL_SCANCODE_KP_POWER: Type = 195;
  pub const SDL_SCANCODE_KP_PERCENT: Type = 196;
  pub const SDL_SCANCODE_KP_LESS: Type = 197;
  pub const SDL_SCANCODE_KP_GREATER: Type = 198;
  pub const SDL_SCANCODE_KP_AMPERSAND: Type = 199;
  pub const SDL_SCANCODE_KP_DBLAMPERSAND: Type = 200;
  pub const SDL_SCANCODE_KP_VERTICALBAR: Type = 201;
  pub const SDL_SCANCODE_KP_DBLVERTICALBAR: Type = 202;
  pub const SDL_SCANCODE_KP_COLON: Type = 203;
  pub const SDL_SCANCODE_KP_HASH: Type = 204;
  pub const SDL_SCANCODE_KP_SPACE: Type = 205;
  pub const SDL_SCANCODE_KP_AT: Type = 206;
  pub const SDL_SCANCODE_KP_EXCLAM: Type = 207;
  pub const SDL_SCANCODE_KP_MEMSTORE: Type = 208;
  pub const SDL_SCANCODE_KP_MEMRECALL: Type = 209;
  pub const SDL_SCANCODE_KP_MEMCLEAR: Type = 210;
  pub const SDL_SCANCODE_KP_MEMADD: Type = 211;
  pub const SDL_SCANCODE_KP_MEMSUBTRACT: Type = 212;
  pub const SDL_SCANCODE_KP_MEMMULTIPLY: Type = 213;
  pub const SDL_SCANCODE_KP_MEMDIVIDE: Type = 214;
  pub const SDL_SCANCODE_KP_PLUSMINUS: Type = 215;
  pub const SDL_SCANCODE_KP_CLEAR: Type = 216;
  pub const SDL_SCANCODE_KP_CLEARENTRY: Type = 217;
  pub const SDL_SCANCODE_KP_BINARY: Type = 218;
  pub const SDL_SCANCODE_KP_OCTAL: Type = 219;
  pub const SDL_SCANCODE_KP_DECIMAL: Type = 220;
  pub const SDL_SCANCODE_KP_HEXADECIMAL: Type = 221;
  pub const SDL_SCANCODE_LCTRL: Type = 224;
  pub const SDL_SCANCODE_LSHIFT: Type = 225;
  #[doc = "< alt, option"]
  pub const SDL_SCANCODE_LALT: Type = 226;
  #[doc = "< windows, command (apple), meta"]
  pub const SDL_SCANCODE_LGUI: Type = 227;
  pub const SDL_SCANCODE_RCTRL: Type = 228;
  pub const SDL_SCANCODE_RSHIFT: Type = 229;
  #[doc = "< alt gr, option"]
  pub const SDL_SCANCODE_RALT: Type = 230;
  #[doc = "< windows, command (apple), meta"]
  pub const SDL_SCANCODE_RGUI: Type = 231;
  #[doc = "< I'm not sure if this is really not covered"]
  #[doc = "   by any of the above, but since there's a"]
  #[doc = "   special KMOD_MODE for it I'm adding it here"]
  pub const SDL_SCANCODE_MODE: Type = 257;
  pub const SDL_SCANCODE_AUDIONEXT: Type = 258;
  pub const SDL_SCANCODE_AUDIOPREV: Type = 259;
  pub const SDL_SCANCODE_AUDIOSTOP: Type = 260;
  pub const SDL_SCANCODE_AUDIOPLAY: Type = 261;
  pub const SDL_SCANCODE_AUDIOMUTE: Type = 262;
  pub const SDL_SCANCODE_MEDIASELECT: Type = 263;
  pub const SDL_SCANCODE_WWW: Type = 264;
  pub const SDL_SCANCODE_MAIL: Type = 265;
  pub const SDL_SCANCODE_CALCULATOR: Type = 266;
  pub const SDL_SCANCODE_COMPUTER: Type = 267;
  pub const SDL_SCANCODE_AC_SEARCH: Type = 268;
  pub const SDL_SCANCODE_AC_HOME: Type = 269;
  pub const SDL_SCANCODE_AC_BACK: Type = 270;
  pub const SDL_SCANCODE_AC_FORWARD: Type = 271;
  pub const SDL_SCANCODE_AC_STOP: Type = 272;
  pub const SDL_SCANCODE_AC_REFRESH: Type = 273;
  pub const SDL_SCANCODE_AC_BOOKMARKS: Type = 274;
  pub const SDL_SCANCODE_BRIGHTNESSDOWN: Type = 275;
  pub const SDL_SCANCODE_BRIGHTNESSUP: Type = 276;
  #[doc = "< display mirroring/dual display"]
  #[doc = "switch, video mode switch"]
  pub const SDL_SCANCODE_DISPLAYSWITCH: Type = 277;
  pub const SDL_SCANCODE_KBDILLUMTOGGLE: Type = 278;
  pub const SDL_SCANCODE_KBDILLUMDOWN: Type = 279;
  pub const SDL_SCANCODE_KBDILLUMUP: Type = 280;
  pub const SDL_SCANCODE_EJECT: Type = 281;
  pub const SDL_SCANCODE_SLEEP: Type = 282;
  pub const SDL_SCANCODE_APP1: Type = 283;
  pub const SDL_SCANCODE_APP2: Type = 284;
  pub const SDL_SCANCODE_AUDIOREWIND: Type = 285;
  pub const SDL_SCANCODE_AUDIOFASTFORWARD: Type = 286;
  #[doc = "< not a key, just marks the number of scancodes"]
  #[doc = "for array bounds"]
  pub const SDL_NUM_SCANCODES: Type = 512;
}
#[doc = "  \\brief The SDL virtual key representation."]
#[doc = ""]
#[doc = "  Values of this type are used to represent keyboard keys using the current"]
#[doc = "  layout of the keyboard.  These values include Unicode values representing"]
#[doc = "  the unmodified character that would be generated by pressing the key, or"]
#[doc = "  an SDLK_* constant for those keys that do not generate characters."]
#[doc = ""]
#[doc = "  A special exception is the number keys at the top of the keyboard which"]
#[doc = "  always map to SDLK_0...SDLK_9, regardless of layout."]
pub type SDL_Keycode = Sint32;
pub mod _bindgen_ty_7 {
  pub type Type = u32;
  pub const SDLK_UNKNOWN: Type = 0;
  pub const SDLK_RETURN: Type = 13;
  pub const SDLK_ESCAPE: Type = 27;
  pub const SDLK_BACKSPACE: Type = 8;
  pub const SDLK_TAB: Type = 9;
  pub const SDLK_SPACE: Type = 32;
  pub const SDLK_EXCLAIM: Type = 33;
  pub const SDLK_QUOTEDBL: Type = 34;
  pub const SDLK_HASH: Type = 35;
  pub const SDLK_PERCENT: Type = 37;
  pub const SDLK_DOLLAR: Type = 36;
  pub const SDLK_AMPERSAND: Type = 38;
  pub const SDLK_QUOTE: Type = 39;
  pub const SDLK_LEFTPAREN: Type = 40;
  pub const SDLK_RIGHTPAREN: Type = 41;
  pub const SDLK_ASTERISK: Type = 42;
  pub const SDLK_PLUS: Type = 43;
  pub const SDLK_COMMA: Type = 44;
  pub const SDLK_MINUS: Type = 45;
  pub const SDLK_PERIOD: Type = 46;
  pub const SDLK_SLASH: Type = 47;
  pub const SDLK_0: Type = 48;
  pub const SDLK_1: Type = 49;
  pub const SDLK_2: Type = 50;
  pub const SDLK_3: Type = 51;
  pub const SDLK_4: Type = 52;
  pub const SDLK_5: Type = 53;
  pub const SDLK_6: Type = 54;
  pub const SDLK_7: Type = 55;
  pub const SDLK_8: Type = 56;
  pub const SDLK_9: Type = 57;
  pub const SDLK_COLON: Type = 58;
  pub const SDLK_SEMICOLON: Type = 59;
  pub const SDLK_LESS: Type = 60;
  pub const SDLK_EQUALS: Type = 61;
  pub const SDLK_GREATER: Type = 62;
  pub const SDLK_QUESTION: Type = 63;
  pub const SDLK_AT: Type = 64;
  pub const SDLK_LEFTBRACKET: Type = 91;
  pub const SDLK_BACKSLASH: Type = 92;
  pub const SDLK_RIGHTBRACKET: Type = 93;
  pub const SDLK_CARET: Type = 94;
  pub const SDLK_UNDERSCORE: Type = 95;
  pub const SDLK_BACKQUOTE: Type = 96;
  pub const SDLK_a: Type = 97;
  pub const SDLK_b: Type = 98;
  pub const SDLK_c: Type = 99;
  pub const SDLK_d: Type = 100;
  pub const SDLK_e: Type = 101;
  pub const SDLK_f: Type = 102;
  pub const SDLK_g: Type = 103;
  pub const SDLK_h: Type = 104;
  pub const SDLK_i: Type = 105;
  pub const SDLK_j: Type = 106;
  pub const SDLK_k: Type = 107;
  pub const SDLK_l: Type = 108;
  pub const SDLK_m: Type = 109;
  pub const SDLK_n: Type = 110;
  pub const SDLK_o: Type = 111;
  pub const SDLK_p: Type = 112;
  pub const SDLK_q: Type = 113;
  pub const SDLK_r: Type = 114;
  pub const SDLK_s: Type = 115;
  pub const SDLK_t: Type = 116;
  pub const SDLK_u: Type = 117;
  pub const SDLK_v: Type = 118;
  pub const SDLK_w: Type = 119;
  pub const SDLK_x: Type = 120;
  pub const SDLK_y: Type = 121;
  pub const SDLK_z: Type = 122;
  pub const SDLK_CAPSLOCK: Type = 1073741881;
  pub const SDLK_F1: Type = 1073741882;
  pub const SDLK_F2: Type = 1073741883;
  pub const SDLK_F3: Type = 1073741884;
  pub const SDLK_F4: Type = 1073741885;
  pub const SDLK_F5: Type = 1073741886;
  pub const SDLK_F6: Type = 1073741887;
  pub const SDLK_F7: Type = 1073741888;
  pub const SDLK_F8: Type = 1073741889;
  pub const SDLK_F9: Type = 1073741890;
  pub const SDLK_F10: Type = 1073741891;
  pub const SDLK_F11: Type = 1073741892;
  pub const SDLK_F12: Type = 1073741893;
  pub const SDLK_PRINTSCREEN: Type = 1073741894;
  pub const SDLK_SCROLLLOCK: Type = 1073741895;
  pub const SDLK_PAUSE: Type = 1073741896;
  pub const SDLK_INSERT: Type = 1073741897;
  pub const SDLK_HOME: Type = 1073741898;
  pub const SDLK_PAGEUP: Type = 1073741899;
  pub const SDLK_DELETE: Type = 127;
  pub const SDLK_END: Type = 1073741901;
  pub const SDLK_PAGEDOWN: Type = 1073741902;
  pub const SDLK_RIGHT: Type = 1073741903;
  pub const SDLK_LEFT: Type = 1073741904;
  pub const SDLK_DOWN: Type = 1073741905;
  pub const SDLK_UP: Type = 1073741906;
  pub const SDLK_NUMLOCKCLEAR: Type = 1073741907;
  pub const SDLK_KP_DIVIDE: Type = 1073741908;
  pub const SDLK_KP_MULTIPLY: Type = 1073741909;
  pub const SDLK_KP_MINUS: Type = 1073741910;
  pub const SDLK_KP_PLUS: Type = 1073741911;
  pub const SDLK_KP_ENTER: Type = 1073741912;
  pub const SDLK_KP_1: Type = 1073741913;
  pub const SDLK_KP_2: Type = 1073741914;
  pub const SDLK_KP_3: Type = 1073741915;
  pub const SDLK_KP_4: Type = 1073741916;
  pub const SDLK_KP_5: Type = 1073741917;
  pub const SDLK_KP_6: Type = 1073741918;
  pub const SDLK_KP_7: Type = 1073741919;
  pub const SDLK_KP_8: Type = 1073741920;
  pub const SDLK_KP_9: Type = 1073741921;
  pub const SDLK_KP_0: Type = 1073741922;
  pub const SDLK_KP_PERIOD: Type = 1073741923;
  pub const SDLK_APPLICATION: Type = 1073741925;
  pub const SDLK_POWER: Type = 1073741926;
  pub const SDLK_KP_EQUALS: Type = 1073741927;
  pub const SDLK_F13: Type = 1073741928;
  pub const SDLK_F14: Type = 1073741929;
  pub const SDLK_F15: Type = 1073741930;
  pub const SDLK_F16: Type = 1073741931;
  pub const SDLK_F17: Type = 1073741932;
  pub const SDLK_F18: Type = 1073741933;
  pub const SDLK_F19: Type = 1073741934;
  pub const SDLK_F20: Type = 1073741935;
  pub const SDLK_F21: Type = 1073741936;
  pub const SDLK_F22: Type = 1073741937;
  pub const SDLK_F23: Type = 1073741938;
  pub const SDLK_F24: Type = 1073741939;
  pub const SDLK_EXECUTE: Type = 1073741940;
  pub const SDLK_HELP: Type = 1073741941;
  pub const SDLK_MENU: Type = 1073741942;
  pub const SDLK_SELECT: Type = 1073741943;
  pub const SDLK_STOP: Type = 1073741944;
  pub const SDLK_AGAIN: Type = 1073741945;
  pub const SDLK_UNDO: Type = 1073741946;
  pub const SDLK_CUT: Type = 1073741947;
  pub const SDLK_COPY: Type = 1073741948;
  pub const SDLK_PASTE: Type = 1073741949;
  pub const SDLK_FIND: Type = 1073741950;
  pub const SDLK_MUTE: Type = 1073741951;
  pub const SDLK_VOLUMEUP: Type = 1073741952;
  pub const SDLK_VOLUMEDOWN: Type = 1073741953;
  pub const SDLK_KP_COMMA: Type = 1073741957;
  pub const SDLK_KP_EQUALSAS400: Type = 1073741958;
  pub const SDLK_ALTERASE: Type = 1073741977;
  pub const SDLK_SYSREQ: Type = 1073741978;
  pub const SDLK_CANCEL: Type = 1073741979;
  pub const SDLK_CLEAR: Type = 1073741980;
  pub const SDLK_PRIOR: Type = 1073741981;
  pub const SDLK_RETURN2: Type = 1073741982;
  pub const SDLK_SEPARATOR: Type = 1073741983;
  pub const SDLK_OUT: Type = 1073741984;
  pub const SDLK_OPER: Type = 1073741985;
  pub const SDLK_CLEARAGAIN: Type = 1073741986;
  pub const SDLK_CRSEL: Type = 1073741987;
  pub const SDLK_EXSEL: Type = 1073741988;
  pub const SDLK_KP_00: Type = 1073742000;
  pub const SDLK_KP_000: Type = 1073742001;
  pub const SDLK_THOUSANDSSEPARATOR: Type = 1073742002;
  pub const SDLK_DECIMALSEPARATOR: Type = 1073742003;
  pub const SDLK_CURRENCYUNIT: Type = 1073742004;
  pub const SDLK_CURRENCYSUBUNIT: Type = 1073742005;
  pub const SDLK_KP_LEFTPAREN: Type = 1073742006;
  pub const SDLK_KP_RIGHTPAREN: Type = 1073742007;
  pub const SDLK_KP_LEFTBRACE: Type = 1073742008;
  pub const SDLK_KP_RIGHTBRACE: Type = 1073742009;
  pub const SDLK_KP_TAB: Type = 1073742010;
  pub const SDLK_KP_BACKSPACE: Type = 1073742011;
  pub const SDLK_KP_A: Type = 1073742012;
  pub const SDLK_KP_B: Type = 1073742013;
  pub const SDLK_KP_C: Type = 1073742014;
  pub const SDLK_KP_D: Type = 1073742015;
  pub const SDLK_KP_E: Type = 1073742016;
  pub const SDLK_KP_F: Type = 1073742017;
  pub const SDLK_KP_XOR: Type = 1073742018;
  pub const SDLK_KP_POWER: Type = 1073742019;
  pub const SDLK_KP_PERCENT: Type = 1073742020;
  pub const SDLK_KP_LESS: Type = 1073742021;
  pub const SDLK_KP_GREATER: Type = 1073742022;
  pub const SDLK_KP_AMPERSAND: Type = 1073742023;
  pub const SDLK_KP_DBLAMPERSAND: Type = 1073742024;
  pub const SDLK_KP_VERTICALBAR: Type = 1073742025;
  pub const SDLK_KP_DBLVERTICALBAR: Type = 1073742026;
  pub const SDLK_KP_COLON: Type = 1073742027;
  pub const SDLK_KP_HASH: Type = 1073742028;
  pub const SDLK_KP_SPACE: Type = 1073742029;
  pub const SDLK_KP_AT: Type = 1073742030;
  pub const SDLK_KP_EXCLAM: Type = 1073742031;
  pub const SDLK_KP_MEMSTORE: Type = 1073742032;
  pub const SDLK_KP_MEMRECALL: Type = 1073742033;
  pub const SDLK_KP_MEMCLEAR: Type = 1073742034;
  pub const SDLK_KP_MEMADD: Type = 1073742035;
  pub const SDLK_KP_MEMSUBTRACT: Type = 1073742036;
  pub const SDLK_KP_MEMMULTIPLY: Type = 1073742037;
  pub const SDLK_KP_MEMDIVIDE: Type = 1073742038;
  pub const SDLK_KP_PLUSMINUS: Type = 1073742039;
  pub const SDLK_KP_CLEAR: Type = 1073742040;
  pub const SDLK_KP_CLEARENTRY: Type = 1073742041;
  pub const SDLK_KP_BINARY: Type = 1073742042;
  pub const SDLK_KP_OCTAL: Type = 1073742043;
  pub const SDLK_KP_DECIMAL: Type = 1073742044;
  pub const SDLK_KP_HEXADECIMAL: Type = 1073742045;
  pub const SDLK_LCTRL: Type = 1073742048;
  pub const SDLK_LSHIFT: Type = 1073742049;
  pub const SDLK_LALT: Type = 1073742050;
  pub const SDLK_LGUI: Type = 1073742051;
  pub const SDLK_RCTRL: Type = 1073742052;
  pub const SDLK_RSHIFT: Type = 1073742053;
  pub const SDLK_RALT: Type = 1073742054;
  pub const SDLK_RGUI: Type = 1073742055;
  pub const SDLK_MODE: Type = 1073742081;
  pub const SDLK_AUDIONEXT: Type = 1073742082;
  pub const SDLK_AUDIOPREV: Type = 1073742083;
  pub const SDLK_AUDIOSTOP: Type = 1073742084;
  pub const SDLK_AUDIOPLAY: Type = 1073742085;
  pub const SDLK_AUDIOMUTE: Type = 1073742086;
  pub const SDLK_MEDIASELECT: Type = 1073742087;
  pub const SDLK_WWW: Type = 1073742088;
  pub const SDLK_MAIL: Type = 1073742089;
  pub const SDLK_CALCULATOR: Type = 1073742090;
  pub const SDLK_COMPUTER: Type = 1073742091;
  pub const SDLK_AC_SEARCH: Type = 1073742092;
  pub const SDLK_AC_HOME: Type = 1073742093;
  pub const SDLK_AC_BACK: Type = 1073742094;
  pub const SDLK_AC_FORWARD: Type = 1073742095;
  pub const SDLK_AC_STOP: Type = 1073742096;
  pub const SDLK_AC_REFRESH: Type = 1073742097;
  pub const SDLK_AC_BOOKMARKS: Type = 1073742098;
  pub const SDLK_BRIGHTNESSDOWN: Type = 1073742099;
  pub const SDLK_BRIGHTNESSUP: Type = 1073742100;
  pub const SDLK_DISPLAYSWITCH: Type = 1073742101;
  pub const SDLK_KBDILLUMTOGGLE: Type = 1073742102;
  pub const SDLK_KBDILLUMDOWN: Type = 1073742103;
  pub const SDLK_KBDILLUMUP: Type = 1073742104;
  pub const SDLK_EJECT: Type = 1073742105;
  pub const SDLK_SLEEP: Type = 1073742106;
  pub const SDLK_APP1: Type = 1073742107;
  pub const SDLK_APP2: Type = 1073742108;
  pub const SDLK_AUDIOREWIND: Type = 1073742109;
  pub const SDLK_AUDIOFASTFORWARD: Type = 1073742110;
}
pub mod SDL_Keymod {
  #[doc = " \\brief Enumeration of valid key mods (possibly OR'd together)."]
  pub type Type = u32;
  pub const KMOD_NONE: Type = 0;
  pub const KMOD_LSHIFT: Type = 1;
  pub const KMOD_RSHIFT: Type = 2;
  pub const KMOD_LCTRL: Type = 64;
  pub const KMOD_RCTRL: Type = 128;
  pub const KMOD_LALT: Type = 256;
  pub const KMOD_RALT: Type = 512;
  pub const KMOD_LGUI: Type = 1024;
  pub const KMOD_RGUI: Type = 2048;
  pub const KMOD_NUM: Type = 4096;
  pub const KMOD_CAPS: Type = 8192;
  pub const KMOD_MODE: Type = 16384;
  pub const KMOD_RESERVED: Type = 32768;
}
#[doc = "  \\brief The SDL keysym structure, used in key events."]
#[doc = ""]
#[doc = "  \\note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Keysym {
  #[doc = "< SDL physical key code - see ::SDL_Scancode for details"]
  pub scancode: SDL_Scancode::Type,
  #[doc = "< SDL virtual key code - see ::SDL_Keycode for details"]
  pub sym: SDL_Keycode,
  #[doc = "< current key modifiers"]
  pub mod_: Uint16,
  pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Keysym>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Keysym))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Keysym>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Keysym))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).scancode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(scancode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).sym as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(sym)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).mod_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(mod_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).unused as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(unused)
    )
  );
}
impl Default for SDL_Keysym {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[doc = "  \\brief Get the window which currently has keyboard focus."]
  #[link_name = "\u{1}_SDL_GetKeyboardFocus"]
  pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get a snapshot of the current state of the keyboard."]
  #[doc = ""]
  #[doc = "  \\param numkeys if non-NULL, receives the length of the returned array."]
  #[doc = ""]
  #[doc = "  \\return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values."]
  #[doc = ""]
  #[doc = "  \\b Example:"]
  #[doc = "  \\code"]
  #[doc = "  const Uint8 *state = SDL_GetKeyboardState(NULL);"]
  #[doc = "  if ( state[SDL_SCANCODE_RETURN] )   {"]
  #[doc = "      printf(\"<RETURN> is pressed.\\n\");"]
  #[doc = "  }"]
  #[doc = "  \\endcode"]
  #[link_name = "\u{1}_SDL_GetKeyboardState"]
  pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const Uint8;
}
extern "C" {
  #[doc = "  \\brief Get the current key modifier state for the keyboard."]
  #[link_name = "\u{1}_SDL_GetModState"]
  pub fn SDL_GetModState() -> SDL_Keymod::Type;
}
extern "C" {
  #[doc = "  \\brief Set the current key modifier state for the keyboard."]
  #[doc = ""]
  #[doc = "  \\note This does not change the keyboard state, only the key modifier flags."]
  #[link_name = "\u{1}_SDL_SetModState"]
  pub fn SDL_SetModState(modstate: SDL_Keymod::Type);
}
extern "C" {
  #[doc = "  \\brief Get the key code corresponding to the given scancode according"]
  #[doc = "         to the current keyboard layout."]
  #[doc = ""]
  #[doc = "  See ::SDL_Keycode for details."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetKeyName()"]
  #[link_name = "\u{1}_SDL_GetKeyFromScancode"]
  pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode::Type) -> SDL_Keycode;
}
extern "C" {
  #[doc = "  \\brief Get the scancode corresponding to the given key code according to the"]
  #[doc = "         current keyboard layout."]
  #[doc = ""]
  #[doc = "  See ::SDL_Scancode for details."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetScancodeName()"]
  #[link_name = "\u{1}_SDL_GetScancodeFromKey"]
  pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode::Type;
}
extern "C" {
  #[doc = "  \\brief Get a human-readable name for a scancode."]
  #[doc = ""]
  #[doc = "  \\return A pointer to the name for the scancode."]
  #[doc = "          If the scancode doesn't have a name, this function returns"]
  #[doc = "          an empty string (\"\")."]
  #[doc = ""]
  #[doc = "  \\sa SDL_Scancode"]
  #[link_name = "\u{1}_SDL_GetScancodeName"]
  pub fn SDL_GetScancodeName(scancode: SDL_Scancode::Type) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get a scancode from a human-readable name"]
  #[doc = ""]
  #[doc = "  \\return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized"]
  #[doc = ""]
  #[doc = "  \\sa SDL_Scancode"]
  #[link_name = "\u{1}_SDL_GetScancodeFromName"]
  pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode::Type;
}
extern "C" {
  #[doc = "  \\brief Get a human-readable name for a key."]
  #[doc = ""]
  #[doc = "  \\return A pointer to a UTF-8 string that stays valid at least until the next"]
  #[doc = "          call to this function. If you need it around any longer, you must"]
  #[doc = "          copy it.  If the key doesn't have a name, this function returns an"]
  #[doc = "          empty string (\"\")."]
  #[doc = ""]
  #[doc = "  \\sa SDL_Keycode"]
  #[link_name = "\u{1}_SDL_GetKeyName"]
  pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get a key code from a human-readable name"]
  #[doc = ""]
  #[doc = "  \\return key code, or SDLK_UNKNOWN if the name wasn't recognized"]
  #[doc = ""]
  #[doc = "  \\sa SDL_Keycode"]
  #[link_name = "\u{1}_SDL_GetKeyFromName"]
  pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
extern "C" {
  #[doc = "  \\brief Start accepting Unicode text input events."]
  #[doc = "         This function will show the on-screen keyboard if supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StopTextInput()"]
  #[doc = "  \\sa SDL_SetTextInputRect()"]
  #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
  #[link_name = "\u{1}_SDL_StartTextInput"]
  pub fn SDL_StartTextInput();
}
extern "C" {
  #[doc = "  \\brief Return whether or not Unicode text input events are enabled."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StartTextInput()"]
  #[doc = "  \\sa SDL_StopTextInput()"]
  #[link_name = "\u{1}_SDL_IsTextInputActive"]
  pub fn SDL_IsTextInputActive() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Stop receiving any text input events."]
  #[doc = "         This function will hide the on-screen keyboard if supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StartTextInput()"]
  #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
  #[link_name = "\u{1}_SDL_StopTextInput"]
  pub fn SDL_StopTextInput();
}
extern "C" {
  #[doc = "  \\brief Set the rectangle used to type Unicode text inputs."]
  #[doc = "         This is used as a hint for IME and on-screen keyboard placement."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StartTextInput()"]
  #[link_name = "\u{1}_SDL_SetTextInputRect"]
  pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Returns whether the platform has some screen keyboard support."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if some keyboard support is available else SDL_FALSE."]
  #[doc = ""]
  #[doc = "  \\note Not all screen keyboard functions are supported on all platforms."]
  #[doc = ""]
  #[doc = "  \\sa SDL_IsScreenKeyboardShown()"]
  #[link_name = "\u{1}_SDL_HasScreenKeyboardSupport"]
  pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Returns whether the screen keyboard is shown for given window."]
  #[doc = ""]
  #[doc = "  \\param window The window for which screen keyboard should be queried."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if screen keyboard is shown else SDL_FALSE."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
  #[link_name = "\u{1}_SDL_IsScreenKeyboardShown"]
  pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
  _unused: [u8; 0],
}
pub mod SDL_SystemCursor {
  #[doc = " \\brief Cursor types for SDL_CreateSystemCursor()."]
  pub type Type = u32;
  #[doc = "< Arrow"]
  pub const SDL_SYSTEM_CURSOR_ARROW: Type = 0;
  #[doc = "< I-beam"]
  pub const SDL_SYSTEM_CURSOR_IBEAM: Type = 1;
  #[doc = "< Wait"]
  pub const SDL_SYSTEM_CURSOR_WAIT: Type = 2;
  #[doc = "< Crosshair"]
  pub const SDL_SYSTEM_CURSOR_CROSSHAIR: Type = 3;
  #[doc = "< Small wait cursor (or Wait if not available)"]
  pub const SDL_SYSTEM_CURSOR_WAITARROW: Type = 4;
  #[doc = "< Double arrow pointing northwest and southeast"]
  pub const SDL_SYSTEM_CURSOR_SIZENWSE: Type = 5;
  #[doc = "< Double arrow pointing northeast and southwest"]
  pub const SDL_SYSTEM_CURSOR_SIZENESW: Type = 6;
  #[doc = "< Double arrow pointing west and east"]
  pub const SDL_SYSTEM_CURSOR_SIZEWE: Type = 7;
  #[doc = "< Double arrow pointing north and south"]
  pub const SDL_SYSTEM_CURSOR_SIZENS: Type = 8;
  #[doc = "< Four pointed arrow pointing north, south, east, and west"]
  pub const SDL_SYSTEM_CURSOR_SIZEALL: Type = 9;
  #[doc = "< Slashed circle or crossbones"]
  pub const SDL_SYSTEM_CURSOR_NO: Type = 10;
  #[doc = "< Hand"]
  pub const SDL_SYSTEM_CURSOR_HAND: Type = 11;
  pub const SDL_NUM_SYSTEM_CURSORS: Type = 12;
}
pub mod SDL_MouseWheelDirection {
  #[doc = " \\brief Scroll direction types for the Scroll event"]
  pub type Type = u32;
  #[doc = "< The scroll direction is normal"]
  pub const SDL_MOUSEWHEEL_NORMAL: Type = 0;
  #[doc = "< The scroll direction is flipped / natural"]
  pub const SDL_MOUSEWHEEL_FLIPPED: Type = 1;
}
extern "C" {
  #[doc = "  \\brief Get the window which currently has mouse focus."]
  #[link_name = "\u{1}_SDL_GetMouseFocus"]
  pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Retrieve the current state of the mouse."]
  #[doc = ""]
  #[doc = "  The current button state is returned as a button bitmask, which can"]
  #[doc = "  be tested using the SDL_BUTTON(X) macros, and x and y are set to the"]
  #[doc = "  mouse cursor position relative to the focus window for the currently"]
  #[doc = "  selected mouse.  You can pass NULL for either x or y."]
  #[link_name = "\u{1}_SDL_GetMouseState"]
  pub fn SDL_GetMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Get the current state of the mouse, in relation to the desktop"]
  #[doc = ""]
  #[doc = "  This works just like SDL_GetMouseState(), but the coordinates will be"]
  #[doc = "  reported relative to the top-left of the desktop. This can be useful if"]
  #[doc = "  you need to track the mouse outside of a specific window and"]
  #[doc = "  SDL_CaptureMouse() doesn't fit your needs. For example, it could be"]
  #[doc = "  useful if you need to track the mouse while dragging a window, where"]
  #[doc = "  coordinates relative to a window might not be in sync at all times."]
  #[doc = ""]
  #[doc = "  \\note SDL_GetMouseState() returns the mouse position as SDL understands"]
  #[doc = "        it from the last pump of the event queue. This function, however,"]
  #[doc = "        queries the OS for the current mouse position, and as such, might"]
  #[doc = "        be a slightly less efficient function. Unless you know what you're"]
  #[doc = "        doing and have a good reason to use this function, you probably want"]
  #[doc = "        SDL_GetMouseState() instead."]
  #[doc = ""]
  #[doc = "  \\param x Returns the current X coord, relative to the desktop. Can be NULL."]
  #[doc = "  \\param y Returns the current Y coord, relative to the desktop. Can be NULL."]
  #[doc = "  \\return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetMouseState"]
  #[link_name = "\u{1}_SDL_GetGlobalMouseState"]
  pub fn SDL_GetGlobalMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Retrieve the relative state of the mouse."]
  #[doc = ""]
  #[doc = "  The current button state is returned as a button bitmask, which can"]
  #[doc = "  be tested using the SDL_BUTTON(X) macros, and x and y are set to the"]
  #[doc = "  mouse deltas since the last call to SDL_GetRelativeMouseState()."]
  #[link_name = "\u{1}_SDL_GetRelativeMouseState"]
  pub fn SDL_GetRelativeMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Moves the mouse to the given position within the window."]
  #[doc = ""]
  #[doc = "  \\param window The window to move the mouse into, or NULL for the current mouse focus"]
  #[doc = "  \\param x The x coordinate within the window"]
  #[doc = "  \\param y The y coordinate within the window"]
  #[doc = ""]
  #[doc = "  \\note This function generates a mouse motion event"]
  #[link_name = "\u{1}_SDL_WarpMouseInWindow"]
  pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Moves the mouse to the given position in global screen space."]
  #[doc = ""]
  #[doc = "  \\param x The x coordinate"]
  #[doc = "  \\param y The y coordinate"]
  #[doc = "  \\return 0 on success, -1 on error (usually: unsupported by a platform)."]
  #[doc = ""]
  #[doc = "  \\note This function generates a mouse motion event"]
  #[link_name = "\u{1}_SDL_WarpMouseGlobal"]
  pub fn SDL_WarpMouseGlobal(x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set relative mouse mode."]
  #[doc = ""]
  #[doc = "  \\param enabled Whether or not to enable relative mode"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if relative mode is not supported."]
  #[doc = ""]
  #[doc = "  While the mouse is in relative mode, the cursor is hidden, and the"]
  #[doc = "  driver will try to report continuous motion in the current window."]
  #[doc = "  Only relative motion events will be delivered, the mouse position"]
  #[doc = "  will not change."]
  #[doc = ""]
  #[doc = "  \\note This function will flush any pending mouse motion."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRelativeMouseMode()"]
  #[link_name = "\u{1}_SDL_SetRelativeMouseMode"]
  pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool::Type) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Capture the mouse, to track input outside an SDL window."]
  #[doc = ""]
  #[doc = "  \\param enabled Whether or not to enable capturing"]
  #[doc = ""]
  #[doc = "  Capturing enables your app to obtain mouse events globally, instead of"]
  #[doc = "  just within your window. Not all video targets support this function."]
  #[doc = "  When capturing is enabled, the current window will get all mouse events,"]
  #[doc = "  but unlike relative mode, no change is made to the cursor and it is"]
  #[doc = "  not restrained to your window."]
  #[doc = ""]
  #[doc = "  This function may also deny mouse input to other windows--both those in"]
  #[doc = "  your application and others on the system--so you should use this"]
  #[doc = "  function sparingly, and in small bursts. For example, you might want to"]
  #[doc = "  track the mouse while the user is dragging something, until the user"]
  #[doc = "  releases a mouse button. It is not recommended that you capture the mouse"]
  #[doc = "  for long periods of time, such as the entire time your app is running."]
  #[doc = ""]
  #[doc = "  While captured, mouse events still report coordinates relative to the"]
  #[doc = "  current (foreground) window, but those coordinates may be outside the"]
  #[doc = "  bounds of the window (including negative values). Capturing is only"]
  #[doc = "  allowed for the foreground window. If the window loses focus while"]
  #[doc = "  capturing, the capture will be disabled automatically."]
  #[doc = ""]
  #[doc = "  While capturing is enabled, the current window will have the"]
  #[doc = "  SDL_WINDOW_MOUSE_CAPTURE flag set."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if not supported."]
  #[link_name = "\u{1}_SDL_CaptureMouse"]
  pub fn SDL_CaptureMouse(enabled: SDL_bool::Type) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Query whether relative mouse mode is enabled."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetRelativeMouseMode()"]
  #[link_name = "\u{1}_SDL_GetRelativeMouseMode"]
  pub fn SDL_GetRelativeMouseMode() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Create a cursor, using the specified bitmap data and"]
  #[doc = "         mask (in MSB format)."]
  #[doc = ""]
  #[doc = "  The cursor width must be a multiple of 8 bits."]
  #[doc = ""]
  #[doc = "  The cursor is created in black and white according to the following:"]
  #[doc = "  <table>"]
  #[doc = "  <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>"]
  #[doc = "  <tr><td>  0   </td><td>  1   </td><td> White </td></tr>"]
  #[doc = "  <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>"]
  #[doc = "  <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>"]
  #[doc = "  <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black"]
  #[doc = "                                         if not. </td></tr>"]
  #[doc = "  </table>"]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreeCursor()"]
  #[link_name = "\u{1}_SDL_CreateCursor"]
  pub fn SDL_CreateCursor(
    data: *const Uint8,
    mask: *const Uint8,
    w: libc::c_int,
    h: libc::c_int,
    hot_x: libc::c_int,
    hot_y: libc::c_int,
  ) -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Create a color cursor."]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreeCursor()"]
  #[link_name = "\u{1}_SDL_CreateColorCursor"]
  pub fn SDL_CreateColorCursor(
    surface: *mut SDL_Surface,
    hot_x: libc::c_int,
    hot_y: libc::c_int,
  ) -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Create a system cursor."]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreeCursor()"]
  #[link_name = "\u{1}_SDL_CreateSystemCursor"]
  pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor::Type) -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Set the active cursor."]
  #[link_name = "\u{1}_SDL_SetCursor"]
  pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
  #[doc = "  \\brief Return the active cursor."]
  #[link_name = "\u{1}_SDL_GetCursor"]
  pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Return the default cursor."]
  #[link_name = "\u{1}_SDL_GetDefaultCursor"]
  pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Frees a cursor created with SDL_CreateCursor() or similar functions."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateCursor()"]
  #[doc = "  \\sa SDL_CreateColorCursor()"]
  #[doc = "  \\sa SDL_CreateSystemCursor()"]
  #[link_name = "\u{1}_SDL_FreeCursor"]
  pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
  #[doc = "  \\brief Toggle whether or not the cursor is shown."]
  #[doc = ""]
  #[doc = "  \\param toggle 1 to show the cursor, 0 to hide it, -1 to query the current"]
  #[doc = "                state."]
  #[doc = ""]
  #[doc = "  \\return 1 if the cursor is shown, or 0 if the cursor is hidden."]
  #[link_name = "\u{1}_SDL_ShowCursor"]
  pub fn SDL_ShowCursor(toggle: libc::c_int) -> libc::c_int;
}
#[doc = " The joystick structure used to identify an SDL joystick"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
  _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoystickGUID {
  pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoystickGUID>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoystickGUID))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoystickGUID>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_JoystickGUID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoystickGUID>())).data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoystickGUID),
      "::",
      stringify!(data)
    )
  );
}
#[doc = " This is a unique ID for a joystick for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application. If the joystick is"]
#[doc = " disconnected and reconnected, it will get a new ID."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_JoystickID = Sint32;
pub mod SDL_JoystickType {
  pub type Type = u32;
  pub const SDL_JOYSTICK_TYPE_UNKNOWN: Type = 0;
  pub const SDL_JOYSTICK_TYPE_GAMECONTROLLER: Type = 1;
  pub const SDL_JOYSTICK_TYPE_WHEEL: Type = 2;
  pub const SDL_JOYSTICK_TYPE_ARCADE_STICK: Type = 3;
  pub const SDL_JOYSTICK_TYPE_FLIGHT_STICK: Type = 4;
  pub const SDL_JOYSTICK_TYPE_DANCE_PAD: Type = 5;
  pub const SDL_JOYSTICK_TYPE_GUITAR: Type = 6;
  pub const SDL_JOYSTICK_TYPE_DRUM_KIT: Type = 7;
  pub const SDL_JOYSTICK_TYPE_ARCADE_PAD: Type = 8;
  pub const SDL_JOYSTICK_TYPE_THROTTLE: Type = 9;
}
pub mod SDL_JoystickPowerLevel {
  pub type Type = i32;
  pub const SDL_JOYSTICK_POWER_UNKNOWN: Type = -1;
  pub const SDL_JOYSTICK_POWER_EMPTY: Type = 0;
  pub const SDL_JOYSTICK_POWER_LOW: Type = 1;
  pub const SDL_JOYSTICK_POWER_MEDIUM: Type = 2;
  pub const SDL_JOYSTICK_POWER_FULL: Type = 3;
  pub const SDL_JOYSTICK_POWER_WIRED: Type = 4;
  pub const SDL_JOYSTICK_POWER_MAX: Type = 5;
}
extern "C" {
  #[doc = " Locking for multi-threaded access to the joystick API"]
  #[doc = ""]
  #[doc = " If you are using the joystick API or handling events from multiple threads"]
  #[doc = " you should use these locking functions to protect access to the joysticks."]
  #[doc = ""]
  #[doc = " In particular, you are guaranteed that the joystick list won't change, so"]
  #[doc = " the API functions that take a joystick index will be valid, and joystick"]
  #[doc = " and game controller events will not be delivered."]
  #[link_name = "\u{1}_SDL_LockJoysticks"]
  pub fn SDL_LockJoysticks();
}
extern "C" {
  #[link_name = "\u{1}_SDL_UnlockJoysticks"]
  pub fn SDL_UnlockJoysticks();
}
extern "C" {
  #[doc = "  Count the number of joysticks attached to the system right now"]
  #[link_name = "\u{1}_SDL_NumJoysticks"]
  pub fn SDL_NumJoysticks() -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the implementation dependent name of a joystick."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If no name can be found, this function returns NULL."]
  #[link_name = "\u{1}_SDL_JoystickNameForIndex"]
  pub fn SDL_JoystickNameForIndex(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the player index of a joystick, or -1 if it's not available"]
  #[doc = "  This can be called before any joysticks are opened."]
  #[link_name = "\u{1}_SDL_JoystickGetDevicePlayerIndex"]
  pub fn SDL_JoystickGetDevicePlayerIndex(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Return the GUID for the joystick at this index"]
  #[doc = "  This can be called before any joysticks are opened."]
  #[link_name = "\u{1}_SDL_JoystickGetDeviceGUID"]
  pub fn SDL_JoystickGetDeviceGUID(device_index: libc::c_int) -> SDL_JoystickGUID;
}
extern "C" {
  #[doc = "  Get the USB vendor ID of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the vendor ID isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_JoystickGetDeviceVendor"]
  pub fn SDL_JoystickGetDeviceVendor(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  #[doc = "  Get the USB product ID of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the product ID isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_JoystickGetDeviceProduct"]
  pub fn SDL_JoystickGetDeviceProduct(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  #[doc = "  Get the product version of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the product version isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_JoystickGetDeviceProductVersion"]
  pub fn SDL_JoystickGetDeviceProductVersion(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  #[doc = "  Get the type of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[link_name = "\u{1}_SDL_JoystickGetDeviceType"]
  pub fn SDL_JoystickGetDeviceType(device_index: libc::c_int) -> SDL_JoystickType::Type;
}
extern "C" {
  #[doc = "  Get the instance ID of a joystick."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the index is out of range, this function will return -1."]
  #[link_name = "\u{1}_SDL_JoystickGetDeviceInstanceID"]
  pub fn SDL_JoystickGetDeviceInstanceID(device_index: libc::c_int) -> SDL_JoystickID;
}
extern "C" {
  #[doc = "  Open a joystick for use."]
  #[doc = "  The index passed as an argument refers to the N'th joystick on the system."]
  #[doc = "  This index is not the value which will identify this joystick in future"]
  #[doc = "  joystick events.  The joystick's instance id (::SDL_JoystickID) will be used"]
  #[doc = "  there instead."]
  #[doc = ""]
  #[doc = "  \\return A joystick identifier, or NULL if an error occurred."]
  #[link_name = "\u{1}_SDL_JoystickOpen"]
  pub fn SDL_JoystickOpen(device_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
  #[doc = " Return the SDL_Joystick associated with an instance id."]
  #[link_name = "\u{1}_SDL_JoystickFromInstanceID"]
  pub fn SDL_JoystickFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
  #[doc = "  Return the name for this currently opened joystick."]
  #[doc = "  If no name can be found, this function returns NULL."]
  #[link_name = "\u{1}_SDL_JoystickName"]
  pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the player index of an opened joystick, or -1 if it's not available"]
  #[doc = ""]
  #[doc = "  For XInput controllers this returns the XInput user index."]
  #[link_name = "\u{1}_SDL_JoystickGetPlayerIndex"]
  pub fn SDL_JoystickGetPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Return the GUID for this opened joystick"]
  #[link_name = "\u{1}_SDL_JoystickGetGUID"]
  pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
  #[doc = "  Get the USB vendor ID of an opened joystick, if available."]
  #[doc = "  If the vendor ID isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_JoystickGetVendor"]
  pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  #[doc = "  Get the USB product ID of an opened joystick, if available."]
  #[doc = "  If the product ID isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_JoystickGetProduct"]
  pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  #[doc = "  Get the product version of an opened joystick, if available."]
  #[doc = "  If the product version isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_JoystickGetProductVersion"]
  pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  #[doc = "  Get the type of an opened joystick."]
  #[link_name = "\u{1}_SDL_JoystickGetType"]
  pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick) -> SDL_JoystickType::Type;
}
extern "C" {
  #[doc = "  Return a string representation for this guid. pszGUID must point to at least 33 bytes"]
  #[doc = "  (32 for the string plus a NULL terminator)."]
  #[link_name = "\u{1}_SDL_JoystickGetGUIDString"]
  pub fn SDL_JoystickGetGUIDString(
    guid: SDL_JoystickGUID,
    pszGUID: *mut libc::c_char,
    cbGUID: libc::c_int,
  );
}
extern "C" {
  #[doc = "  Convert a string into a joystick guid"]
  #[link_name = "\u{1}_SDL_JoystickGetGUIDFromString"]
  pub fn SDL_JoystickGetGUIDFromString(pchGUID: *const libc::c_char) -> SDL_JoystickGUID;
}
extern "C" {
  #[doc = "  Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not."]
  #[link_name = "\u{1}_SDL_JoystickGetAttached"]
  pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the instance ID of an opened joystick or -1 if the joystick is invalid."]
  #[link_name = "\u{1}_SDL_JoystickInstanceID"]
  pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
  #[doc = "  Get the number of general axis controls on a joystick."]
  #[link_name = "\u{1}_SDL_JoystickNumAxes"]
  pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of trackballs on a joystick."]
  #[doc = ""]
  #[doc = "  Joystick trackballs have only relative motion events associated"]
  #[doc = "  with them and their state cannot be polled."]
  #[link_name = "\u{1}_SDL_JoystickNumBalls"]
  pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of POV hats on a joystick."]
  #[link_name = "\u{1}_SDL_JoystickNumHats"]
  pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of buttons on a joystick."]
  #[link_name = "\u{1}_SDL_JoystickNumButtons"]
  pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Update the current state of the open joysticks."]
  #[doc = ""]
  #[doc = "  This is called automatically by the event loop if any joystick"]
  #[doc = "  events are enabled."]
  #[link_name = "\u{1}_SDL_JoystickUpdate"]
  pub fn SDL_JoystickUpdate();
}
extern "C" {
  #[doc = "  Enable/disable joystick event polling."]
  #[doc = ""]
  #[doc = "  If joystick events are disabled, you must call SDL_JoystickUpdate()"]
  #[doc = "  yourself and check the state of the joystick when you want joystick"]
  #[doc = "  information."]
  #[doc = ""]
  #[doc = "  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
  #[link_name = "\u{1}_SDL_JoystickEventState"]
  pub fn SDL_JoystickEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the current state of an axis control on a joystick."]
  #[doc = ""]
  #[doc = "  The state is a value ranging from -32768 to 32767."]
  #[doc = ""]
  #[doc = "  The axis indices start at index 0."]
  #[link_name = "\u{1}_SDL_JoystickGetAxis"]
  pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
extern "C" {
  #[doc = "  Get the initial state of an axis control on a joystick."]
  #[doc = ""]
  #[doc = "  The state is a value ranging from -32768 to 32767."]
  #[doc = ""]
  #[doc = "  The axis indices start at index 0."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not."]
  #[link_name = "\u{1}_SDL_JoystickGetAxisInitialState"]
  pub fn SDL_JoystickGetAxisInitialState(
    joystick: *mut SDL_Joystick,
    axis: libc::c_int,
    state: *mut Sint16,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the current state of a POV hat on a joystick."]
  #[doc = ""]
  #[doc = "  The hat indices start at index 0."]
  #[doc = ""]
  #[doc = "  \\return The return value is one of the following positions:"]
  #[doc = "           - ::SDL_HAT_CENTERED"]
  #[doc = "           - ::SDL_HAT_UP"]
  #[doc = "           - ::SDL_HAT_RIGHT"]
  #[doc = "           - ::SDL_HAT_DOWN"]
  #[doc = "           - ::SDL_HAT_LEFT"]
  #[doc = "           - ::SDL_HAT_RIGHTUP"]
  #[doc = "           - ::SDL_HAT_RIGHTDOWN"]
  #[doc = "           - ::SDL_HAT_LEFTUP"]
  #[doc = "           - ::SDL_HAT_LEFTDOWN"]
  #[link_name = "\u{1}_SDL_JoystickGetHat"]
  pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
extern "C" {
  #[doc = "  Get the ball axis change since the last poll."]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if you passed it invalid parameters."]
  #[doc = ""]
  #[doc = "  The ball indices start at index 0."]
  #[link_name = "\u{1}_SDL_JoystickGetBall"]
  pub fn SDL_JoystickGetBall(
    joystick: *mut SDL_Joystick,
    ball: libc::c_int,
    dx: *mut libc::c_int,
    dy: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the current state of a button on a joystick."]
  #[doc = ""]
  #[doc = "  The button indices start at index 0."]
  #[link_name = "\u{1}_SDL_JoystickGetButton"]
  pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> Uint8;
}
extern "C" {
  #[doc = "  Trigger a rumble effect"]
  #[doc = "  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling."]
  #[doc = ""]
  #[doc = "  \\param joystick The joystick to vibrate"]
  #[doc = "  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param duration_ms The duration of the rumble effect, in milliseconds"]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if rumble isn't supported on this joystick"]
  #[link_name = "\u{1}_SDL_JoystickRumble"]
  pub fn SDL_JoystickRumble(
    joystick: *mut SDL_Joystick,
    low_frequency_rumble: Uint16,
    high_frequency_rumble: Uint16,
    duration_ms: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Close a joystick previously opened with SDL_JoystickOpen()."]
  #[link_name = "\u{1}_SDL_JoystickClose"]
  pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
  #[doc = "  Return the battery level of this joystick"]
  #[link_name = "\u{1}_SDL_JoystickCurrentPowerLevel"]
  pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick)
    -> SDL_JoystickPowerLevel::Type;
}
#[doc = " The gamecontroller structure used to identify an SDL game controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_GameController {
  _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
pub mod SDL_GameControllerBindType {
  pub type Type = u32;
  pub const SDL_CONTROLLER_BINDTYPE_NONE: Type = 0;
  pub const SDL_CONTROLLER_BINDTYPE_BUTTON: Type = 1;
  pub const SDL_CONTROLLER_BINDTYPE_AXIS: Type = 2;
  pub const SDL_CONTROLLER_BINDTYPE_HAT: Type = 3;
}
#[doc = "  Get the SDL joystick layer binding for this controller button/axis mapping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
  pub bindType: SDL_GameControllerBindType::Type,
  pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
  pub button: libc::c_int,
  pub axis: libc::c_int,
  pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
  pub hat: libc::c_int,
  pub hat_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hat)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat_mask
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hat_mask)
    )
  );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).button as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).axis as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).hat as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(hat)
    )
  );
}
impl Default for SDL_GameControllerButtonBind__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_GameControllerButtonBind__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_GameControllerButtonBind__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).bindType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind),
      "::",
      stringify!(bindType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).value as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind),
      "::",
      stringify!(value)
    )
  );
}
impl Default for SDL_GameControllerButtonBind {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_GameControllerButtonBind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_GameControllerButtonBind {{ bindType: {:?}, value: {:?} }}",
      self.bindType, self.value
    )
  }
}
extern "C" {
  #[doc = "  Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()"]
  #[doc = "  A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt"]
  #[doc = ""]
  #[doc = "  If \\c freerw is non-zero, the stream will be closed after being read."]
  #[doc = ""]
  #[doc = " \\return number of mappings added, -1 on error"]
  #[link_name = "\u{1}_SDL_GameControllerAddMappingsFromRW"]
  pub fn SDL_GameControllerAddMappingsFromRW(
    rw: *mut SDL_RWops,
    freerw: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Add or update an existing mapping configuration"]
  #[doc = ""]
  #[doc = " \\return 1 if mapping is added, 0 if updated, -1 on error"]
  #[link_name = "\u{1}_SDL_GameControllerAddMapping"]
  pub fn SDL_GameControllerAddMapping(mappingString: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of mappings installed"]
  #[doc = ""]
  #[doc = "  \\return the number of mappings"]
  #[link_name = "\u{1}_SDL_GameControllerNumMappings"]
  pub fn SDL_GameControllerNumMappings() -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the mapping at a particular index."]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range."]
  #[link_name = "\u{1}_SDL_GameControllerMappingForIndex"]
  pub fn SDL_GameControllerMappingForIndex(mapping_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Get a mapping string for a GUID"]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
  #[link_name = "\u{1}_SDL_GameControllerMappingForGUID"]
  pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Get a mapping string for an open GameController"]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
  #[link_name = "\u{1}_SDL_GameControllerMapping"]
  pub fn SDL_GameControllerMapping(gamecontroller: *mut SDL_GameController) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Is the joystick on this index supported by the game controller interface?"]
  #[link_name = "\u{1}_SDL_IsGameController"]
  pub fn SDL_IsGameController(joystick_index: libc::c_int) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the implementation dependent name of a game controller."]
  #[doc = "  This can be called before any controllers are opened."]
  #[doc = "  If no name can be found, this function returns NULL."]
  #[link_name = "\u{1}_SDL_GameControllerNameForIndex"]
  pub fn SDL_GameControllerNameForIndex(joystick_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the mapping of a game controller."]
  #[doc = "  This can be called before any controllers are opened."]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
  #[link_name = "\u{1}_SDL_GameControllerMappingForDeviceIndex"]
  pub fn SDL_GameControllerMappingForDeviceIndex(joystick_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Open a game controller for use."]
  #[doc = "  The index passed as an argument refers to the N'th game controller on the system."]
  #[doc = "  This index is not the value which will identify this controller in future"]
  #[doc = "  controller events.  The joystick's instance id (::SDL_JoystickID) will be"]
  #[doc = "  used there instead."]
  #[doc = ""]
  #[doc = "  \\return A controller identifier, or NULL if an error occurred."]
  #[link_name = "\u{1}_SDL_GameControllerOpen"]
  pub fn SDL_GameControllerOpen(joystick_index: libc::c_int) -> *mut SDL_GameController;
}
extern "C" {
  #[doc = " Return the SDL_GameController associated with an instance id."]
  #[link_name = "\u{1}_SDL_GameControllerFromInstanceID"]
  pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_GameController;
}
extern "C" {
  #[doc = "  Return the name for this currently opened controller"]
  #[link_name = "\u{1}_SDL_GameControllerName"]
  pub fn SDL_GameControllerName(gamecontroller: *mut SDL_GameController) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the player index of an opened game controller, or -1 if it's not available"]
  #[doc = ""]
  #[doc = "  For XInput controllers this returns the XInput user index."]
  #[link_name = "\u{1}_SDL_GameControllerGetPlayerIndex"]
  pub fn SDL_GameControllerGetPlayerIndex(gamecontroller: *mut SDL_GameController) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the USB vendor ID of an opened controller, if available."]
  #[doc = "  If the vendor ID isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_GameControllerGetVendor"]
  pub fn SDL_GameControllerGetVendor(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  #[doc = "  Get the USB product ID of an opened controller, if available."]
  #[doc = "  If the product ID isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_GameControllerGetProduct"]
  pub fn SDL_GameControllerGetProduct(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  #[doc = "  Get the product version of an opened controller, if available."]
  #[doc = "  If the product version isn't available this function returns 0."]
  #[link_name = "\u{1}_SDL_GameControllerGetProductVersion"]
  pub fn SDL_GameControllerGetProductVersion(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  #[doc = "  Returns SDL_TRUE if the controller has been opened and currently connected,"]
  #[doc = "  or SDL_FALSE if it has not."]
  #[link_name = "\u{1}_SDL_GameControllerGetAttached"]
  pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the underlying joystick object used by a controller"]
  #[link_name = "\u{1}_SDL_GameControllerGetJoystick"]
  pub fn SDL_GameControllerGetJoystick(
    gamecontroller: *mut SDL_GameController,
  ) -> *mut SDL_Joystick;
}
extern "C" {
  #[doc = "  Enable/disable controller event polling."]
  #[doc = ""]
  #[doc = "  If controller events are disabled, you must call SDL_GameControllerUpdate()"]
  #[doc = "  yourself and check the state of the controller when you want controller"]
  #[doc = "  information."]
  #[doc = ""]
  #[doc = "  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
  #[link_name = "\u{1}_SDL_GameControllerEventState"]
  pub fn SDL_GameControllerEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Update the current state of the open game controllers."]
  #[doc = ""]
  #[doc = "  This is called automatically by the event loop if any game controller"]
  #[doc = "  events are enabled."]
  #[link_name = "\u{1}_SDL_GameControllerUpdate"]
  pub fn SDL_GameControllerUpdate();
}
pub mod SDL_GameControllerAxis {
  #[doc = "  The list of axes available from a controller"]
  #[doc = ""]
  #[doc = "  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,"]
  #[doc = "  and are centered within ~8000 of zero, though advanced UI will allow users to set"]
  #[doc = "  or autodetect the dead zone, which varies between controllers."]
  #[doc = ""]
  #[doc = "  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX."]
  pub type Type = i32;
  pub const SDL_CONTROLLER_AXIS_INVALID: Type = -1;
  pub const SDL_CONTROLLER_AXIS_LEFTX: Type = 0;
  pub const SDL_CONTROLLER_AXIS_LEFTY: Type = 1;
  pub const SDL_CONTROLLER_AXIS_RIGHTX: Type = 2;
  pub const SDL_CONTROLLER_AXIS_RIGHTY: Type = 3;
  pub const SDL_CONTROLLER_AXIS_TRIGGERLEFT: Type = 4;
  pub const SDL_CONTROLLER_AXIS_TRIGGERRIGHT: Type = 5;
  pub const SDL_CONTROLLER_AXIS_MAX: Type = 6;
}
extern "C" {
  #[doc = "  turn this string into a axis mapping"]
  #[link_name = "\u{1}_SDL_GameControllerGetAxisFromString"]
  pub fn SDL_GameControllerGetAxisFromString(
    pchString: *const libc::c_char,
  ) -> SDL_GameControllerAxis::Type;
}
extern "C" {
  #[doc = "  turn this axis enum into a string mapping"]
  #[link_name = "\u{1}_SDL_GameControllerGetStringForAxis"]
  pub fn SDL_GameControllerGetStringForAxis(
    axis: SDL_GameControllerAxis::Type,
  ) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
  #[link_name = "\u{1}_SDL_GameControllerGetBindForAxis"]
  pub fn SDL_GameControllerGetBindForAxis(
    gamecontroller: *mut SDL_GameController,
    axis: SDL_GameControllerAxis::Type,
  ) -> SDL_GameControllerButtonBind;
}
extern "C" {
  #[doc = "  Get the current state of an axis control on a game controller."]
  #[doc = ""]
  #[doc = "  The state is a value ranging from -32768 to 32767 (except for the triggers,"]
  #[doc = "  which range from 0 to 32767)."]
  #[doc = ""]
  #[doc = "  The axis indices start at index 0."]
  #[link_name = "\u{1}_SDL_GameControllerGetAxis"]
  pub fn SDL_GameControllerGetAxis(
    gamecontroller: *mut SDL_GameController,
    axis: SDL_GameControllerAxis::Type,
  ) -> Sint16;
}
pub mod SDL_GameControllerButton {
  #[doc = "  The list of buttons available from a controller"]
  pub type Type = i32;
  pub const SDL_CONTROLLER_BUTTON_INVALID: Type = -1;
  pub const SDL_CONTROLLER_BUTTON_A: Type = 0;
  pub const SDL_CONTROLLER_BUTTON_B: Type = 1;
  pub const SDL_CONTROLLER_BUTTON_X: Type = 2;
  pub const SDL_CONTROLLER_BUTTON_Y: Type = 3;
  pub const SDL_CONTROLLER_BUTTON_BACK: Type = 4;
  pub const SDL_CONTROLLER_BUTTON_GUIDE: Type = 5;
  pub const SDL_CONTROLLER_BUTTON_START: Type = 6;
  pub const SDL_CONTROLLER_BUTTON_LEFTSTICK: Type = 7;
  pub const SDL_CONTROLLER_BUTTON_RIGHTSTICK: Type = 8;
  pub const SDL_CONTROLLER_BUTTON_LEFTSHOULDER: Type = 9;
  pub const SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: Type = 10;
  pub const SDL_CONTROLLER_BUTTON_DPAD_UP: Type = 11;
  pub const SDL_CONTROLLER_BUTTON_DPAD_DOWN: Type = 12;
  pub const SDL_CONTROLLER_BUTTON_DPAD_LEFT: Type = 13;
  pub const SDL_CONTROLLER_BUTTON_DPAD_RIGHT: Type = 14;
  pub const SDL_CONTROLLER_BUTTON_MAX: Type = 15;
}
extern "C" {
  #[doc = "  turn this string into a button mapping"]
  #[link_name = "\u{1}_SDL_GameControllerGetButtonFromString"]
  pub fn SDL_GameControllerGetButtonFromString(
    pchString: *const libc::c_char,
  ) -> SDL_GameControllerButton::Type;
}
extern "C" {
  #[doc = "  turn this button enum into a string mapping"]
  #[link_name = "\u{1}_SDL_GameControllerGetStringForButton"]
  pub fn SDL_GameControllerGetStringForButton(
    button: SDL_GameControllerButton::Type,
  ) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
  #[link_name = "\u{1}_SDL_GameControllerGetBindForButton"]
  pub fn SDL_GameControllerGetBindForButton(
    gamecontroller: *mut SDL_GameController,
    button: SDL_GameControllerButton::Type,
  ) -> SDL_GameControllerButtonBind;
}
extern "C" {
  #[doc = "  Get the current state of a button on a game controller."]
  #[doc = ""]
  #[doc = "  The button indices start at index 0."]
  #[link_name = "\u{1}_SDL_GameControllerGetButton"]
  pub fn SDL_GameControllerGetButton(
    gamecontroller: *mut SDL_GameController,
    button: SDL_GameControllerButton::Type,
  ) -> Uint8;
}
extern "C" {
  #[doc = "  Trigger a rumble effect"]
  #[doc = "  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling."]
  #[doc = ""]
  #[doc = "  \\param gamecontroller The controller to vibrate"]
  #[doc = "  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param duration_ms The duration of the rumble effect, in milliseconds"]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if rumble isn't supported on this joystick"]
  #[link_name = "\u{1}_SDL_GameControllerRumble"]
  pub fn SDL_GameControllerRumble(
    gamecontroller: *mut SDL_GameController,
    low_frequency_rumble: Uint16,
    high_frequency_rumble: Uint16,
    duration_ms: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Close a controller previously opened with SDL_GameControllerOpen()."]
  #[link_name = "\u{1}_SDL_GameControllerClose"]
  pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Finger {
  pub id: SDL_FingerID,
  pub x: f32,
  pub y: f32,
  pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Finger>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_Finger))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Finger>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Finger))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).id as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).x as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).y as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).pressure as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(pressure)
    )
  );
}
extern "C" {
  #[doc = "  \\brief Get the number of registered touch devices."]
  #[link_name = "\u{1}_SDL_GetNumTouchDevices"]
  pub fn SDL_GetNumTouchDevices() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the touch ID with the given index, or 0 if the index is invalid."]
  #[link_name = "\u{1}_SDL_GetTouchDevice"]
  pub fn SDL_GetTouchDevice(index: libc::c_int) -> SDL_TouchID;
}
extern "C" {
  #[doc = "  \\brief Get the number of active fingers for a given touch device."]
  #[link_name = "\u{1}_SDL_GetNumTouchFingers"]
  pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the finger object of the given touch, with the given index."]
  #[link_name = "\u{1}_SDL_GetTouchFinger"]
  pub fn SDL_GetTouchFinger(touchID: SDL_TouchID, index: libc::c_int) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
  #[doc = "  \\brief Begin Recording a gesture on the specified touch, or all touches (-1)"]
  #[doc = ""]
  #[doc = ""]
  #[link_name = "\u{1}_SDL_RecordGesture"]
  pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Save all currently loaded Dollar Gesture templates"]
  #[doc = ""]
  #[doc = ""]
  #[link_name = "\u{1}_SDL_SaveAllDollarTemplates"]
  pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Save a currently loaded Dollar Gesture template"]
  #[doc = ""]
  #[doc = ""]
  #[link_name = "\u{1}_SDL_SaveDollarTemplate"]
  pub fn SDL_SaveDollarTemplate(gestureId: SDL_GestureID, dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Load Dollar Gesture templates from a file"]
  #[doc = ""]
  #[doc = ""]
  #[link_name = "\u{1}_SDL_LoadDollarTemplates"]
  pub fn SDL_LoadDollarTemplates(touchId: SDL_TouchID, src: *mut SDL_RWops) -> libc::c_int;
}
pub mod SDL_EventType {
  #[doc = " \\brief The types of events that can be delivered."]
  pub type Type = u32;
  #[doc = "< Unused (do not remove)"]
  pub const SDL_FIRSTEVENT: Type = 0;
  #[doc = "< User-requested quit"]
  pub const SDL_QUIT: Type = 256;
  #[doc = "< The application is being terminated by the OS"]
  #[doc = "Called on iOS in applicationWillTerminate()"]
  #[doc = "Called on Android in onDestroy()"]
  pub const SDL_APP_TERMINATING: Type = 257;
  #[doc = "< The application is low on memory, free memory if possible."]
  #[doc = "Called on iOS in applicationDidReceiveMemoryWarning()"]
  #[doc = "Called on Android in onLowMemory()"]
  pub const SDL_APP_LOWMEMORY: Type = 258;
  #[doc = "< The application is about to enter the background"]
  #[doc = "Called on iOS in applicationWillResignActive()"]
  #[doc = "Called on Android in onPause()"]
  pub const SDL_APP_WILLENTERBACKGROUND: Type = 259;
  #[doc = "< The application did enter the background and may not get CPU for some time"]
  #[doc = "Called on iOS in applicationDidEnterBackground()"]
  #[doc = "Called on Android in onPause()"]
  pub const SDL_APP_DIDENTERBACKGROUND: Type = 260;
  #[doc = "< The application is about to enter the foreground"]
  #[doc = "Called on iOS in applicationWillEnterForeground()"]
  #[doc = "Called on Android in onResume()"]
  pub const SDL_APP_WILLENTERFOREGROUND: Type = 261;
  #[doc = "< The application is now interactive"]
  #[doc = "Called on iOS in applicationDidBecomeActive()"]
  #[doc = "Called on Android in onResume()"]
  pub const SDL_APP_DIDENTERFOREGROUND: Type = 262;
  #[doc = "< Display state change"]
  pub const SDL_DISPLAYEVENT: Type = 336;
  #[doc = "< Window state change"]
  pub const SDL_WINDOWEVENT: Type = 512;
  #[doc = "< System specific event"]
  pub const SDL_SYSWMEVENT: Type = 513;
  #[doc = "< Key pressed"]
  pub const SDL_KEYDOWN: Type = 768;
  #[doc = "< Key released"]
  pub const SDL_KEYUP: Type = 769;
  #[doc = "< Keyboard text editing (composition)"]
  pub const SDL_TEXTEDITING: Type = 770;
  #[doc = "< Keyboard text input"]
  pub const SDL_TEXTINPUT: Type = 771;
  #[doc = "< Keymap changed due to a system event such as an"]
  #[doc = "input language or keyboard layout change."]
  pub const SDL_KEYMAPCHANGED: Type = 772;
  #[doc = "< Mouse moved"]
  pub const SDL_MOUSEMOTION: Type = 1024;
  #[doc = "< Mouse button pressed"]
  pub const SDL_MOUSEBUTTONDOWN: Type = 1025;
  #[doc = "< Mouse button released"]
  pub const SDL_MOUSEBUTTONUP: Type = 1026;
  #[doc = "< Mouse wheel motion"]
  pub const SDL_MOUSEWHEEL: Type = 1027;
  #[doc = "< Joystick axis motion"]
  pub const SDL_JOYAXISMOTION: Type = 1536;
  #[doc = "< Joystick trackball motion"]
  pub const SDL_JOYBALLMOTION: Type = 1537;
  #[doc = "< Joystick hat position change"]
  pub const SDL_JOYHATMOTION: Type = 1538;
  #[doc = "< Joystick button pressed"]
  pub const SDL_JOYBUTTONDOWN: Type = 1539;
  #[doc = "< Joystick button released"]
  pub const SDL_JOYBUTTONUP: Type = 1540;
  #[doc = "< A new joystick has been inserted into the system"]
  pub const SDL_JOYDEVICEADDED: Type = 1541;
  #[doc = "< An opened joystick has been removed"]
  pub const SDL_JOYDEVICEREMOVED: Type = 1542;
  #[doc = "< Game controller axis motion"]
  pub const SDL_CONTROLLERAXISMOTION: Type = 1616;
  #[doc = "< Game controller button pressed"]
  pub const SDL_CONTROLLERBUTTONDOWN: Type = 1617;
  #[doc = "< Game controller button released"]
  pub const SDL_CONTROLLERBUTTONUP: Type = 1618;
  #[doc = "< A new Game controller has been inserted into the system"]
  pub const SDL_CONTROLLERDEVICEADDED: Type = 1619;
  #[doc = "< An opened Game controller has been removed"]
  pub const SDL_CONTROLLERDEVICEREMOVED: Type = 1620;
  #[doc = "< The controller mapping was updated"]
  pub const SDL_CONTROLLERDEVICEREMAPPED: Type = 1621;
  pub const SDL_FINGERDOWN: Type = 1792;
  pub const SDL_FINGERUP: Type = 1793;
  pub const SDL_FINGERMOTION: Type = 1794;
  pub const SDL_DOLLARGESTURE: Type = 2048;
  pub const SDL_DOLLARRECORD: Type = 2049;
  pub const SDL_MULTIGESTURE: Type = 2050;
  #[doc = "< The clipboard changed"]
  pub const SDL_CLIPBOARDUPDATE: Type = 2304;
  #[doc = "< The system requests a file open"]
  pub const SDL_DROPFILE: Type = 4096;
  #[doc = "< text/plain drag-and-drop event"]
  pub const SDL_DROPTEXT: Type = 4097;
  #[doc = "< A new set of drops is beginning (NULL filename)"]
  pub const SDL_DROPBEGIN: Type = 4098;
  #[doc = "< Current set of drops is now complete (NULL filename)"]
  pub const SDL_DROPCOMPLETE: Type = 4099;
  #[doc = "< A new audio device is available"]
  pub const SDL_AUDIODEVICEADDED: Type = 4352;
  #[doc = "< An audio device has been removed."]
  pub const SDL_AUDIODEVICEREMOVED: Type = 4353;
  #[doc = "< A sensor was updated"]
  pub const SDL_SENSORUPDATE: Type = 4608;
  #[doc = "< The render targets have been reset and their contents need to be updated"]
  pub const SDL_RENDER_TARGETS_RESET: Type = 8192;
  #[doc = "< The device has been reset and all textures need to be recreated"]
  pub const SDL_RENDER_DEVICE_RESET: Type = 8193;
  #[doc = " Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,"]
  #[doc = "  and should be allocated with SDL_RegisterEvents()"]
  pub const SDL_USEREVENT: Type = 32768;
  #[doc = "  This last event is only for bounding internal arrays"]
  pub const SDL_LASTEVENT: Type = 65535;
}
#[doc = "  \\brief Fields shared by every event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_CommonEvent {
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_CommonEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_CommonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_CommonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_CommonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_CommonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_CommonEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[doc = "  \\brief Display state change event data (event.display.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_DisplayEvent {
  #[doc = "< ::SDL_DISPLAYEVENT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The associated display index"]
  pub display: Uint32,
  #[doc = "< ::SDL_DisplayEventID"]
  pub event: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< event dependent data"]
  pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DisplayEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_DisplayEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DisplayEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_DisplayEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).display as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).event as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(data1)
    )
  );
}
#[doc = "  \\brief Window state change event data (event.window.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_WindowEvent {
  #[doc = "< ::SDL_WINDOWEVENT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The associated window"]
  pub windowID: Uint32,
  #[doc = "< ::SDL_WindowEventID"]
  pub event: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< event dependent data"]
  pub data1: Sint32,
  #[doc = "< event dependent data"]
  pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowEvent>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_WindowEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_WindowEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).event as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data2 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(data2)
    )
  );
}
#[doc = "  \\brief Keyboard button event structure (event.key.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_KeyboardEvent {
  #[doc = "< ::SDL_KEYDOWN or ::SDL_KEYUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with keyboard focus, if any"]
  pub windowID: Uint32,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  #[doc = "< Non-zero if this is a key repeat"]
  pub repeat: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The key that was pressed or released"]
  pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_KeyboardEvent>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_KeyboardEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_KeyboardEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).state as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).repeat as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(repeat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).keysym as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(keysym)
    )
  );
}
impl Default for SDL_KeyboardEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief Keyboard text editing event structure (event.edit.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TextEditingEvent {
  #[doc = "< ::SDL_TEXTEDITING"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with keyboard focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The editing text"]
  pub text: [libc::c_char; 32usize],
  #[doc = "< The start cursor of selected editing text"]
  pub start: Sint32,
  #[doc = "< The length of selected editing text"]
  pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TextEditingEvent>(),
    52usize,
    concat!("Size of: ", stringify!(SDL_TextEditingEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TextEditingEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).text as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(text)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).start as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(start)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).length as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(length)
    )
  );
}
#[doc = "  \\brief Keyboard text input event structure (event.text.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TextInputEvent {
  #[doc = "< ::SDL_TEXTINPUT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with keyboard focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The input text"]
  pub text: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TextInputEvent>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_TextInputEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TextInputEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_TextInputEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).text as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(text)
    )
  );
}
#[doc = "  \\brief Mouse motion event structure (event.motion.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseMotionEvent {
  #[doc = "< ::SDL_MOUSEMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with mouse focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
  pub which: Uint32,
  #[doc = "< The current button state"]
  pub state: Uint32,
  #[doc = "< X coordinate, relative to window"]
  pub x: Sint32,
  #[doc = "< Y coordinate, relative to window"]
  pub y: Sint32,
  #[doc = "< The relative motion in the X direction"]
  pub xrel: Sint32,
  #[doc = "< The relative motion in the Y direction"]
  pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseMotionEvent>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseMotionEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).state as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).xrel as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(xrel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).yrel as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(yrel)
    )
  );
}
#[doc = "  \\brief Mouse button event structure (event.button.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseButtonEvent {
  #[doc = "< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with mouse focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
  pub which: Uint32,
  #[doc = "< The mouse button index"]
  pub button: Uint8,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  #[doc = "< 1 for single-click, 2 for double-click, etc."]
  pub clicks: Uint8,
  pub padding1: Uint8,
  #[doc = "< X coordinate, relative to window"]
  pub x: Sint32,
  #[doc = "< Y coordinate, relative to window"]
  pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseButtonEvent>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).button as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).state as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).clicks as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(clicks)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).padding1 as *const _ as usize },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(y)
    )
  );
}
#[doc = "  \\brief Mouse wheel event structure (event.wheel.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseWheelEvent {
  #[doc = "< ::SDL_MOUSEWHEEL"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with mouse focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
  pub which: Uint32,
  #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
  pub x: Sint32,
  #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
  pub y: Sint32,
  #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
  pub direction: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseWheelEvent>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseWheelEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).x as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).y as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).direction as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(direction)
    )
  );
}
#[doc = "  \\brief Joystick axis motion event structure (event.jaxis.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyAxisEvent {
  #[doc = "< ::SDL_JOYAXISMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick axis index"]
  pub axis: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The axis value (range: -32768 to 32767)"]
  pub value: Sint16,
  pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyAxisEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyAxisEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).axis as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding4 as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding4)
    )
  );
}
#[doc = "  \\brief Joystick trackball motion event structure (event.jball.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyBallEvent {
  #[doc = "< ::SDL_JOYBALLMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick trackball index"]
  pub ball: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The relative motion in the X direction"]
  pub xrel: Sint16,
  #[doc = "< The relative motion in the Y direction"]
  pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyBallEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_JoyBallEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyBallEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).ball as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(ball)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).xrel as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(xrel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).yrel as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(yrel)
    )
  );
}
#[doc = "  \\brief Joystick hat position change event structure (event.jhat.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyHatEvent {
  #[doc = "< ::SDL_JOYHATMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick hat index"]
  pub hat: Uint8,
  #[doc = "< The hat position value."]
  #[doc = "   \\sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP"]
  #[doc = "   \\sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT"]
  #[doc = "   \\sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN"]
  #[doc = ""]
  #[doc = "   Note that zero means the POV is centered."]
  pub value: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyHatEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoyHatEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyHatEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).hat as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(hat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).value as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[doc = "  \\brief Joystick button event structure (event.jbutton.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyButtonEvent {
  #[doc = "< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick button index"]
  pub button: Uint8,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyButtonEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).button as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).state as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[doc = "  \\brief Joystick device event structure (event.jdevice.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyDeviceEvent {
  #[doc = "< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED event"]
  pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyDeviceEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(which)
    )
  );
}
#[doc = "  \\brief Game controller axis motion event structure (event.caxis.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerAxisEvent {
  #[doc = "< ::SDL_CONTROLLERAXISMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The controller axis (SDL_GameControllerAxis)"]
  pub axis: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The axis value (range: -32768 to 32767)"]
  pub value: Sint16,
  pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerAxisEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerAxisEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).axis as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding4 as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding4)
    )
  );
}
#[doc = "  \\brief Game controller button event structure (event.cbutton.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerButtonEvent {
  #[doc = "< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The controller button (SDL_GameControllerButton)"]
  pub button: Uint8,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerButtonEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).timestamp as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).button as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).state as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[doc = "  \\brief Controller device event structure (event.cdevice.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerDeviceEvent {
  #[doc = "< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event"]
  pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerDeviceEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).timestamp as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(which)
    )
  );
}
#[doc = "  \\brief Audio device event structure (event.adevice.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_AudioDeviceEvent {
  #[doc = "< ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event"]
  pub which: Uint32,
  #[doc = "< zero if an output device, non-zero if a capture device."]
  pub iscapture: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioDeviceEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).iscapture as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(iscapture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding3)
    )
  );
}
#[doc = "  \\brief Touch finger event structure (event.tfinger.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TouchFingerEvent {
  #[doc = "< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The touch device id"]
  pub touchId: SDL_TouchID,
  pub fingerId: SDL_FingerID,
  #[doc = "< Normalized in the range 0...1"]
  pub x: f32,
  #[doc = "< Normalized in the range 0...1"]
  pub y: f32,
  #[doc = "< Normalized in the range -1...1"]
  pub dx: f32,
  #[doc = "< Normalized in the range -1...1"]
  pub dy: f32,
  #[doc = "< Normalized in the range 0...1"]
  pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TouchFingerEvent>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TouchFingerEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).fingerId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(fingerId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dx as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(dx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dy as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(dy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).pressure as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(pressure)
    )
  );
}
#[doc = "  \\brief Multiple Finger Gesture Event (event.mgesture.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MultiGestureEvent {
  #[doc = "< ::SDL_MULTIGESTURE"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The touch device id"]
  pub touchId: SDL_TouchID,
  pub dTheta: f32,
  pub dDist: f32,
  pub x: f32,
  pub y: f32,
  pub numFingers: Uint16,
  pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MultiGestureEvent>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MultiGestureEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dTheta as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(dTheta)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dDist as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(dDist)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).numFingers as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(numFingers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).padding as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(padding)
    )
  );
}
#[doc = " \\brief Dollar Gesture Event (event.dgesture.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_DollarGestureEvent {
  #[doc = "< ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The touch device id"]
  pub touchId: SDL_TouchID,
  pub gestureId: SDL_GestureID,
  pub numFingers: Uint32,
  pub error: f32,
  #[doc = "< Normalized center of gesture"]
  pub x: f32,
  #[doc = "< Normalized center of gesture"]
  pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DollarGestureEvent>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DollarGestureEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).gestureId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(gestureId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).numFingers as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(numFingers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).error as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(y)
    )
  );
}
#[doc = "  \\brief An event used to request a file open by the system (event.drop.*)"]
#[doc = "         This event is enabled by default, you can disable it with SDL_EventState()."]
#[doc = "  \\note If this event is enabled, you must free the filename in the event."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_DropEvent {
  #[doc = "< ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The file name, which should be freed with SDL_free(), is NULL on begin/complete"]
  pub file: *mut libc::c_char,
  #[doc = "< The window that was dropped on, if any"]
  pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DropEvent>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_DropEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DropEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DropEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).file as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(file)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).windowID as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(windowID)
    )
  );
}
impl Default for SDL_DropEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief Sensor event structure (event.sensor.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_SensorEvent {
  #[doc = "< ::SDL_SENSORUPDATE"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The instance ID of the sensor"]
  pub which: Sint32,
  #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData()"]
  pub data: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SensorEvent>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_SensorEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SensorEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SensorEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).data as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(data)
    )
  );
}
#[doc = "  \\brief The \"quit requested\" event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_QuitEvent {
  #[doc = "< ::SDL_QUIT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_QuitEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_QuitEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_QuitEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_QuitEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_QuitEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_QuitEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[doc = "  \\brief OS Specific event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_OSEvent {
  #[doc = "< ::SDL_QUIT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_OSEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_OSEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_OSEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_OSEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_OSEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_OSEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[doc = "  \\brief A user-defined event type (event.user.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_UserEvent {
  #[doc = "< ::SDL_USEREVENT through ::SDL_LASTEVENT-1"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The associated window if any"]
  pub windowID: Uint32,
  #[doc = "< User defined event code"]
  pub code: Sint32,
  #[doc = "< User defined data pointer"]
  pub data1: *mut libc::c_void,
  #[doc = "< User defined data pointer"]
  pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_UserEvent>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_UserEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_UserEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_UserEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).code as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(data2)
    )
  );
}
impl Default for SDL_UserEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMmsg {
  _unused: [u8; 0],
}
#[doc = "  \\brief A video driver dependent system event (event.syswm.*)"]
#[doc = "         This event is disabled by default, you can enable it with SDL_EventState()"]
#[doc = ""]
#[doc = "  \\note If you want to use this event, you should include SDL_syswm.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMEvent {
  #[doc = "< ::SDL_SYSWMEVENT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< driver dependent data, defined in SDL_syswm.h"]
  pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_SysWMEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_SysWMEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).msg as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(msg)
    )
  );
}
impl Default for SDL_SysWMEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief General event structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
  #[doc = "< Event type, shared with all events"]
  pub type_: Uint32,
  #[doc = "< Common event data"]
  pub common: SDL_CommonEvent,
  #[doc = "< Window event data"]
  pub display: SDL_DisplayEvent,
  #[doc = "< Window event data"]
  pub window: SDL_WindowEvent,
  #[doc = "< Keyboard event data"]
  pub key: SDL_KeyboardEvent,
  #[doc = "< Text editing event data"]
  pub edit: SDL_TextEditingEvent,
  #[doc = "< Text input event data"]
  pub text: SDL_TextInputEvent,
  #[doc = "< Mouse motion event data"]
  pub motion: SDL_MouseMotionEvent,
  #[doc = "< Mouse button event data"]
  pub button: SDL_MouseButtonEvent,
  #[doc = "< Mouse wheel event data"]
  pub wheel: SDL_MouseWheelEvent,
  #[doc = "< Joystick axis event data"]
  pub jaxis: SDL_JoyAxisEvent,
  #[doc = "< Joystick ball event data"]
  pub jball: SDL_JoyBallEvent,
  #[doc = "< Joystick hat event data"]
  pub jhat: SDL_JoyHatEvent,
  #[doc = "< Joystick button event data"]
  pub jbutton: SDL_JoyButtonEvent,
  #[doc = "< Joystick device change event data"]
  pub jdevice: SDL_JoyDeviceEvent,
  #[doc = "< Game Controller axis event data"]
  pub caxis: SDL_ControllerAxisEvent,
  #[doc = "< Game Controller button event data"]
  pub cbutton: SDL_ControllerButtonEvent,
  #[doc = "< Game Controller device event data"]
  pub cdevice: SDL_ControllerDeviceEvent,
  #[doc = "< Audio device event data"]
  pub adevice: SDL_AudioDeviceEvent,
  #[doc = "< Sensor event data"]
  pub sensor: SDL_SensorEvent,
  #[doc = "< Quit request event data"]
  pub quit: SDL_QuitEvent,
  #[doc = "< Custom event data"]
  pub user: SDL_UserEvent,
  #[doc = "< System dependent window event data"]
  pub syswm: SDL_SysWMEvent,
  #[doc = "< Touch finger event data"]
  pub tfinger: SDL_TouchFingerEvent,
  #[doc = "< Gesture event data"]
  pub mgesture: SDL_MultiGestureEvent,
  #[doc = "< Gesture event data"]
  pub dgesture: SDL_DollarGestureEvent,
  #[doc = "< Drag and drop event data"]
  pub drop: SDL_DropEvent,
  pub padding: [Uint8; 56usize],
  _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Event>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_Event))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Event>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Event))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).common as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(common)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).display as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).window as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).key as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(key)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).edit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(edit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).text as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(text)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).motion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(motion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).button as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).wheel as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(wheel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jaxis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jaxis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jball as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jball)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jhat as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jhat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jdevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jdevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).caxis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(caxis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).cbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(cbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).cdevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(cdevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).adevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(adevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).sensor as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(sensor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).quit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(quit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).user as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(user)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).syswm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(syswm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).tfinger as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(tfinger)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).mgesture as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(mgesture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).dgesture as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(dgesture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).drop as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(drop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).padding as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(padding)
    )
  );
}
impl Default for SDL_Event {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_Event {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_Event {{ union }}")
  }
}
extern "C" {
  #[doc = "  Pumps the event loop, gathering events from the input devices."]
  #[doc = ""]
  #[doc = "  This function updates the event queue and internal input device state."]
  #[doc = ""]
  #[doc = "  This should only be run in the thread that sets the video mode."]
  #[link_name = "\u{1}_SDL_PumpEvents"]
  pub fn SDL_PumpEvents();
}
pub mod SDL_eventaction {
  pub type Type = u32;
  pub const SDL_ADDEVENT: Type = 0;
  pub const SDL_PEEKEVENT: Type = 1;
  pub const SDL_GETEVENT: Type = 2;
}
extern "C" {
  #[doc = "  Checks the event queue for messages and optionally returns them."]
  #[doc = ""]
  #[doc = "  If \\c action is ::SDL_ADDEVENT, up to \\c numevents events will be added to"]
  #[doc = "  the back of the event queue."]
  #[doc = ""]
  #[doc = "  If \\c action is ::SDL_PEEKEVENT, up to \\c numevents events at the front"]
  #[doc = "  of the event queue, within the specified minimum and maximum type,"]
  #[doc = "  will be returned and will not be removed from the queue."]
  #[doc = ""]
  #[doc = "  If \\c action is ::SDL_GETEVENT, up to \\c numevents events at the front"]
  #[doc = "  of the event queue, within the specified minimum and maximum type,"]
  #[doc = "  will be returned and will be removed from the queue."]
  #[doc = ""]
  #[doc = "  \\return The number of events actually stored, or -1 if there was an error."]
  #[doc = ""]
  #[doc = "  This function is thread-safe."]
  #[link_name = "\u{1}_SDL_PeepEvents"]
  pub fn SDL_PeepEvents(
    events: *mut SDL_Event,
    numevents: libc::c_int,
    action: SDL_eventaction::Type,
    minType: Uint32,
    maxType: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Checks to see if certain event types are in the event queue."]
  #[link_name = "\u{1}_SDL_HasEvent"]
  pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool::Type;
}
extern "C" {
  #[link_name = "\u{1}_SDL_HasEvents"]
  pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function clears events from the event queue"]
  #[doc = "  This function only affects currently queued events. If you want to make"]
  #[doc = "  sure that all pending OS events are flushed, you can call SDL_PumpEvents()"]
  #[doc = "  on the main thread immediately before the flush call."]
  #[link_name = "\u{1}_SDL_FlushEvent"]
  pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
  #[link_name = "\u{1}_SDL_FlushEvents"]
  pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
  #[doc = "  \\brief Polls for currently pending events."]
  #[doc = ""]
  #[doc = "  \\return 1 if there are any pending events, or 0 if there are none available."]
  #[doc = ""]
  #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
  #[doc = "               stored in that area."]
  #[link_name = "\u{1}_SDL_PollEvent"]
  pub fn SDL_PollEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Waits indefinitely for the next available event."]
  #[doc = ""]
  #[doc = "  \\return 1, or 0 if there was an error while waiting for events."]
  #[doc = ""]
  #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
  #[doc = "               stored in that area."]
  #[link_name = "\u{1}_SDL_WaitEvent"]
  pub fn SDL_WaitEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Waits until the specified timeout (in milliseconds) for the next"]
  #[doc = "         available event."]
  #[doc = ""]
  #[doc = "  \\return 1, or 0 if there was an error while waiting for events."]
  #[doc = ""]
  #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
  #[doc = "               stored in that area."]
  #[doc = "  \\param timeout The timeout (in milliseconds) to wait for next event."]
  #[link_name = "\u{1}_SDL_WaitEventTimeout"]
  pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeout: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Add an event to the event queue."]
  #[doc = ""]
  #[doc = "  \\return 1 on success, 0 if the event was filtered, or -1 if the event queue"]
  #[doc = "          was full or there was some other error."]
  #[link_name = "\u{1}_SDL_PushEvent"]
  pub fn SDL_PushEvent(event: *mut SDL_Event) -> libc::c_int;
}
pub type SDL_EventFilter = ::core::option::Option<
  unsafe extern "C" fn(userdata: *mut libc::c_void, event: *mut SDL_Event) -> libc::c_int,
>;
extern "C" {
  #[doc = "  Sets up a filter to process all events before they change internal state and"]
  #[doc = "  are posted to the internal event queue."]
  #[doc = ""]
  #[doc = "  The filter is prototyped as:"]
  #[doc = "  \\code"]
  #[doc = "      int SDL_EventFilter(void *userdata, SDL_Event * event);"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  If the filter returns 1, then the event will be added to the internal queue."]
  #[doc = "  If it returns 0, then the event will be dropped from the queue, but the"]
  #[doc = "  internal state will still be updated.  This allows selective filtering of"]
  #[doc = "  dynamically arriving events."]
  #[doc = ""]
  #[doc = "  \\warning  Be very careful of what you do in the event filter function, as"]
  #[doc = "            it may run in a different thread!"]
  #[doc = ""]
  #[doc = "  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The"]
  #[doc = "  event filter is only called when the window manager desires to close the"]
  #[doc = "  application window.  If the event filter returns 1, then the window will"]
  #[doc = "  be closed, otherwise the window will remain open if possible."]
  #[doc = ""]
  #[doc = "  If the quit event is generated by an interrupt signal, it will bypass the"]
  #[doc = "  internal queue and be delivered to the application at the next event poll."]
  #[link_name = "\u{1}_SDL_SetEventFilter"]
  pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  Return the current event filter - can be used to \"chain\" filters."]
  #[doc = "  If there is no event filter set, this function returns SDL_FALSE."]
  #[link_name = "\u{1}_SDL_GetEventFilter"]
  pub fn SDL_GetEventFilter(
    filter: *mut SDL_EventFilter,
    userdata: *mut *mut libc::c_void,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Add a function which is called when an event is added to the queue."]
  #[link_name = "\u{1}_SDL_AddEventWatch"]
  pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  Remove an event watch function added with SDL_AddEventWatch()"]
  #[link_name = "\u{1}_SDL_DelEventWatch"]
  pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  Run the filter function on the current event queue, removing any"]
  #[doc = "  events for which the filter returns 0."]
  #[link_name = "\u{1}_SDL_FilterEvents"]
  pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  This function allows you to set the state of processing certain events."]
  #[doc = "   - If \\c state is set to ::SDL_IGNORE, that event will be automatically"]
  #[doc = "     dropped from the event queue and will not be filtered."]
  #[doc = "   - If \\c state is set to ::SDL_ENABLE, that event will be processed"]
  #[doc = "     normally."]
  #[doc = "   - If \\c state is set to ::SDL_QUERY, SDL_EventState() will return the"]
  #[doc = "     current processing state of the specified event."]
  #[link_name = "\u{1}_SDL_EventState"]
  pub fn SDL_EventState(type_: Uint32, state: libc::c_int) -> Uint8;
}
extern "C" {
  #[doc = "  This function allocates a set of user-defined events, and returns"]
  #[doc = "  the beginning event number for that set of events."]
  #[doc = ""]
  #[doc = "  If there aren't enough user-defined events left, this function"]
  #[doc = "  returns (Uint32)-1"]
  #[link_name = "\u{1}_SDL_RegisterEvents"]
  pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = " \\brief Get the path where the application resides."]
  #[doc = ""]
  #[doc = " Get the \"base path\". This is the directory where the application was run"]
  #[doc = "  from, which is probably the installation directory, and may or may not"]
  #[doc = "  be the process's current working directory."]
  #[doc = ""]
  #[doc = " This returns an absolute path in UTF-8 encoding, and is guaranteed to"]
  #[doc = "  end with a path separator ('\\\\' on Windows, '/' most other places)."]
  #[doc = ""]
  #[doc = " The pointer returned by this function is owned by you. Please call"]
  #[doc = "  SDL_free() on the pointer when you are done with it, or it will be a"]
  #[doc = "  memory leak. This is not necessarily a fast call, though, so you should"]
  #[doc = "  call this once near startup and save the string if you need it."]
  #[doc = ""]
  #[doc = " Some platforms can't determine the application's path, and on other"]
  #[doc = "  platforms, this might be meaningless. In such cases, this function will"]
  #[doc = "  return NULL."]
  #[doc = ""]
  #[doc = "  \\return String of base dir in UTF-8 encoding, or NULL on error."]
  #[doc = ""]
  #[doc = " \\sa SDL_GetPrefPath"]
  #[link_name = "\u{1}_SDL_GetBasePath"]
  pub fn SDL_GetBasePath() -> *mut libc::c_char;
}
extern "C" {
  #[doc = " \\brief Get the user-and-app-specific path where files can be written."]
  #[doc = ""]
  #[doc = " Get the \"pref dir\". This is meant to be where users can write personal"]
  #[doc = "  files (preferences and save games, etc) that are specific to your"]
  #[doc = "  application. This directory is unique per user, per application."]
  #[doc = ""]
  #[doc = " This function will decide the appropriate location in the native filesystem,"]
  #[doc = "  create the directory if necessary, and return a string of the absolute"]
  #[doc = "  path to the directory in UTF-8 encoding."]
  #[doc = ""]
  #[doc = " On Windows, the string might look like:"]
  #[doc = "  \"C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\\""]
  #[doc = ""]
  #[doc = " On Linux, the string might look like:"]
  #[doc = "  \"/home/bob/.local/share/My Program Name/\""]
  #[doc = ""]
  #[doc = " On Mac OS X, the string might look like:"]
  #[doc = "  \"/Users/bob/Library/Application Support/My Program Name/\""]
  #[doc = ""]
  #[doc = " (etc.)"]
  #[doc = ""]
  #[doc = " You specify the name of your organization (if it's not a real organization,"]
  #[doc = "  your name or an Internet domain you own might do) and the name of your"]
  #[doc = "  application. These should be untranslated proper names."]
  #[doc = ""]
  #[doc = " Both the org and app strings may become part of a directory name, so"]
  #[doc = "  please follow these rules:"]
  #[doc = ""]
  #[doc = "    - Try to use the same org string (including case-sensitivity) for"]
  #[doc = "      all your applications that use this function."]
  #[doc = "    - Always use a unique app string for each one, and make sure it never"]
  #[doc = "      changes for an app once you've decided on it."]
  #[doc = "    - Unicode characters are legal, as long as it's UTF-8 encoded, but..."]
  #[doc = "    - ...only use letters, numbers, and spaces. Avoid punctuation like"]
  #[doc = "      \"Game Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient."]
  #[doc = ""]
  #[doc = " This returns an absolute path in UTF-8 encoding, and is guaranteed to"]
  #[doc = "  end with a path separator ('\\\\' on Windows, '/' most other places)."]
  #[doc = ""]
  #[doc = " The pointer returned by this function is owned by you. Please call"]
  #[doc = "  SDL_free() on the pointer when you are done with it, or it will be a"]
  #[doc = "  memory leak. This is not necessarily a fast call, though, so you should"]
  #[doc = "  call this once near startup and save the string if you need it."]
  #[doc = ""]
  #[doc = " You should assume the path returned by this function is the only safe"]
  #[doc = "  place to write files (and that SDL_GetBasePath(), while it might be"]
  #[doc = "  writable, or even the parent of the returned path, aren't where you"]
  #[doc = "  should be writing things)."]
  #[doc = ""]
  #[doc = " Some platforms can't determine the pref path, and on other"]
  #[doc = "  platforms, this might be meaningless. In such cases, this function will"]
  #[doc = "  return NULL."]
  #[doc = ""]
  #[doc = "   \\param org The name of your organization."]
  #[doc = "   \\param app The name of your application."]
  #[doc = "  \\return UTF-8 string of user dir in platform-dependent notation. NULL"]
  #[doc = "          if there's a problem (creating directory failed, etc)."]
  #[doc = ""]
  #[doc = " \\sa SDL_GetBasePath"]
  #[link_name = "\u{1}_SDL_GetPrefPath"]
  pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char) -> *mut libc::c_char;
}
#[doc = "  \\typedef SDL_Haptic"]
#[doc = ""]
#[doc = "  \\brief The haptic structure used to identify an SDL haptic."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticOpen"]
#[doc = "  \\sa SDL_HapticOpenFromJoystick"]
#[doc = "  \\sa SDL_HapticClose"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Haptic {
  _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
#[doc = "  \\brief Structure that represents a haptic direction."]
#[doc = ""]
#[doc = "  This is the direction where the force comes from,"]
#[doc = "  instead of the direction in which the force is exerted."]
#[doc = ""]
#[doc = "  Directions can be specified by:"]
#[doc = "   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates."]
#[doc = "   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates."]
#[doc = "   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates."]
#[doc = ""]
#[doc = "  Cardinal directions of the haptic device are relative to the positioning"]
#[doc = "  of the device.  North is considered to be away from the user."]
#[doc = ""]
#[doc = "  The following diagram represents the cardinal directions:"]
#[doc = "  \\verbatim"]
#[doc = ".--."]
#[doc = "|__| .-------."]
#[doc = "|=.| |.-----.|"]
#[doc = "|--| ||     ||"]
#[doc = "|  | |'-----'|"]
#[doc = "|__|~')_____('"]
#[doc = "[ COMPUTER ]"]
#[doc = ""]
#[doc = ""]
#[doc = "North (0,-1)"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|"]
#[doc = "(-1,0)  West <----[ HAPTIC ]----> East (1,0)"]
#[doc = "|"]
#[doc = "|"]
#[doc = "v"]
#[doc = "South (0,1)"]
#[doc = ""]
#[doc = ""]
#[doc = "[ USER ]"]
#[doc = "\\|||/"]
#[doc = "(o o)"]
#[doc = "---ooO-(_)-Ooo---"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a"]
#[doc = "  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses"]
#[doc = "  the first \\c dir parameter.  The cardinal directions would be:"]
#[doc = "   - North: 0 (0 degrees)"]
#[doc = "   - East: 9000 (90 degrees)"]
#[doc = "   - South: 18000 (180 degrees)"]
#[doc = "   - West: 27000 (270 degrees)"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions"]
#[doc = "  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses"]
#[doc = "  the first three \\c dir parameters.  The cardinal directions would be:"]
#[doc = "   - North:  0,-1, 0"]
#[doc = "   - East:   1, 0, 0"]
#[doc = "   - South:  0, 1, 0"]
#[doc = "   - West:  -1, 0, 0"]
#[doc = ""]
#[doc = "  The Z axis represents the height of the effect if supported, otherwise"]
#[doc = "  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you"]
#[doc = "  can use any multiple you want, only the direction matters."]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations."]
#[doc = "  The first two \\c dir parameters are used.  The \\c dir parameters are as"]
#[doc = "  follows (all values are in hundredths of degrees):"]
#[doc = "   - Degrees from (1, 0) rotated towards (0, 1)."]
#[doc = "   - Degrees towards (0, 0, 1) (device needs at least 3 axes)."]
#[doc = ""]
#[doc = ""]
#[doc = "  Example of force coming from the south with all encodings (force coming"]
#[doc = "  from the south means the user will have to pull the stick to counteract):"]
#[doc = "  \\code"]
#[doc = "  SDL_HapticDirection direction;"]
#[doc = ""]
#[doc = "  // Cartesian directions"]
#[doc = "  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding."]
#[doc = "  direction.dir[0] = 0; // X position"]
#[doc = "  direction.dir[1] = 1; // Y position"]
#[doc = "  // Assuming the device has 2 axes, we don't need to specify third parameter."]
#[doc = ""]
#[doc = "  // Polar directions"]
#[doc = "  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding."]
#[doc = "  direction.dir[0] = 18000; // Polar only uses first parameter"]
#[doc = ""]
#[doc = "  // Spherical coordinates"]
#[doc = "  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding"]
#[doc = "  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_POLAR"]
#[doc = "  \\sa SDL_HAPTIC_CARTESIAN"]
#[doc = "  \\sa SDL_HAPTIC_SPHERICAL"]
#[doc = "  \\sa SDL_HapticEffect"]
#[doc = "  \\sa SDL_HapticNumAxes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticDirection {
  #[doc = "< The type of encoding."]
  pub type_: Uint8,
  #[doc = "< The encoded direction."]
  pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticDirection>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_HapticDirection))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticDirection>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticDirection))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticDirection),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).dir as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticDirection),
      "::",
      stringify!(dir)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Constant effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect."]
#[doc = ""]
#[doc = "  A constant effect applies a constant force in the specified direction"]
#[doc = "  to the joystick."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CONSTANT"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticConstant {
  #[doc = "< ::SDL_HAPTIC_CONSTANT"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Strength of the constant effect."]
  pub level: Sint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticConstant>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_HapticConstant))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticConstant>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticConstant))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).level as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_length as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_level as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_length as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_level as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(fade_level)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Periodic effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SINE"]
#[doc = "   - ::SDL_HAPTIC_LEFTRIGHT"]
#[doc = "   - ::SDL_HAPTIC_TRIANGLE"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = ""]
#[doc = "  A periodic effect consists in a wave-shaped effect that repeats itself"]
#[doc = "  over time.  The type determines the shape of the wave and the parameters"]
#[doc = "  determine the dimensions of the wave."]
#[doc = ""]
#[doc = "  Phase is given by hundredth of a degree meaning that giving the phase a value"]
#[doc = "  of 9000 will displace it 25% of its period.  Here are sample values:"]
#[doc = "   -     0: No phase displacement."]
#[doc = "   -  9000: Displaced 25% of its period."]
#[doc = "   - 18000: Displaced 50% of its period."]
#[doc = "   - 27000: Displaced 75% of its period."]
#[doc = "   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred."]
#[doc = ""]
#[doc = "  Examples:"]
#[doc = "  \\verbatim"]
#[doc = "SDL_HAPTIC_SINE"]
#[doc = "__      __      __      __"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SQUARE"]
#[doc = "__    __    __    __    __"]
#[doc = "|  |  |  |  |  |  |  |  |  |"]
#[doc = "|  |__|  |__|  |__|  |__|  |"]
#[doc = ""]
#[doc = "SDL_HAPTIC_TRIANGLE"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHUP"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "\\  |\\  |\\  |\\  |\\  |\\  |\\  |"]
#[doc = "\\ | \\ | \\ | \\ | \\ | \\ | \\ |"]
#[doc = "\\|  \\|  \\|  \\|  \\|  \\|  \\|"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_SINE"]
#[doc = "  \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = "  \\sa SDL_HAPTIC_TRIANGLE"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticPeriodic {
  #[doc = "< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,"]
  #[doc = "::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or"]
  #[doc = "::SDL_HAPTIC_SAWTOOTHDOWN"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Period of the wave."]
  pub period: Uint16,
  #[doc = "< Peak value; if negative, equivalent to 180 degrees extra phase shift."]
  pub magnitude: Sint16,
  #[doc = "< Mean value of the wave."]
  pub offset: Sint16,
  #[doc = "< Positive phase shift given by hundredth of a degree."]
  pub phase: Uint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticPeriodic>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_HapticPeriodic))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticPeriodic>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).period as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(period)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).magnitude as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(magnitude)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).offset as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).phase as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(phase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_length as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_level as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_length as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_level as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(fade_level)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Condition effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SPRING: Effect based on axes position."]
#[doc = "   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity."]
#[doc = "   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration."]
#[doc = "   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement."]
#[doc = ""]
#[doc = "  Direction is handled by condition internals instead of a direction member."]
#[doc = "  The condition effect specific members have three parameters.  The first"]
#[doc = "  refers to the X axis, the second refers to the Y axis and the third"]
#[doc = "  refers to the Z axis.  The right terms refer to the positive side of the"]
#[doc = "  axis and the left terms refer to the negative side of the axis.  Please"]
#[doc = "  refer to the ::SDL_HapticDirection diagram for which side is positive and"]
#[doc = "  which is negative."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticDirection"]
#[doc = "  \\sa SDL_HAPTIC_SPRING"]
#[doc = "  \\sa SDL_HAPTIC_DAMPER"]
#[doc = "  \\sa SDL_HAPTIC_INERTIA"]
#[doc = "  \\sa SDL_HAPTIC_FRICTION"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticCondition {
  #[doc = "< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,"]
  #[doc = "::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect - Not used ATM."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Level when joystick is to the positive side; max 0xFFFF."]
  pub right_sat: [Uint16; 3usize],
  #[doc = "< Level when joystick is to the negative side; max 0xFFFF."]
  pub left_sat: [Uint16; 3usize],
  #[doc = "< How fast to increase the force towards the positive side."]
  pub right_coeff: [Sint16; 3usize],
  #[doc = "< How fast to increase the force towards the negative side."]
  pub left_coeff: [Sint16; 3usize],
  #[doc = "< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered."]
  pub deadband: [Uint16; 3usize],
  #[doc = "< Position of the dead zone."]
  pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticCondition>(),
    68usize,
    concat!("Size of: ", stringify!(SDL_HapticCondition))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticCondition>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticCondition))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_sat as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(right_sat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_sat as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(left_sat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_coeff as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(right_coeff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_coeff as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(left_coeff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).deadband as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(deadband)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).center as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(center)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Ramp effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect."]
#[doc = ""]
#[doc = "  The ramp effect starts at start strength and ends at end strength."]
#[doc = "  It augments in linear fashion.  If you use attack and fade with a ramp"]
#[doc = "  the effects get added to the ramp effect making the effect become"]
#[doc = "  quadratic instead of linear."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_RAMP"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticRamp {
  #[doc = "< ::SDL_HAPTIC_RAMP"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Beginning strength level."]
  pub start: Sint16,
  #[doc = "< Ending strength level."]
  pub end: Sint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticRamp>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_HapticRamp))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticRamp>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticRamp))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).start as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(start)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).end as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(end)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_length as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_level as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_length as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_level as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(fade_level)
    )
  );
}
#[doc = " \\brief A structure containing a template for a Left/Right effect."]
#[doc = ""]
#[doc = " This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect."]
#[doc = ""]
#[doc = " The Left/Right effect is used to explicitly control the large and small"]
#[doc = " motors, commonly found in modern game controllers. The small (right) motor"]
#[doc = " is high frequency, and the large (left) motor is low frequency."]
#[doc = ""]
#[doc = " \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = " \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticLeftRight {
  #[doc = "< ::SDL_HAPTIC_LEFTRIGHT"]
  pub type_: Uint16,
  #[doc = "< Duration of the effect in milliseconds."]
  pub length: Uint32,
  #[doc = "< Control of the large controller motor."]
  pub large_magnitude: Uint16,
  #[doc = "< Control of the small controller motor."]
  pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticLeftRight>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_HapticLeftRight))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticLeftRight>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).length as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_HapticLeftRight>())).large_magnitude as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(large_magnitude)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_HapticLeftRight>())).small_magnitude as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(small_magnitude)
    )
  );
}
#[doc = "  \\brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  A custom force feedback effect is much like a periodic effect, where the"]
#[doc = "  application can define its exact shape.  You will have to allocate the"]
#[doc = "  data yourself.  Data should consist of channels * samples Uint16 samples."]
#[doc = ""]
#[doc = "  If channels is one, the effect is rotated using the defined direction."]
#[doc = "  Otherwise it uses the samples in data for the different axes."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CUSTOM"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_HapticCustom {
  #[doc = "< ::SDL_HAPTIC_CUSTOM"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Axes to use, minimum of one."]
  pub channels: Uint8,
  #[doc = "< Sample periods."]
  pub period: Uint16,
  #[doc = "< Amount of samples."]
  pub samples: Uint16,
  #[doc = "< Should contain channels*samples items."]
  pub data: *mut Uint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticCustom>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_HapticCustom))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticCustom>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_HapticCustom))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).channels as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).period as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(period)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).samples as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).data as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_length as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_level as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_length as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_level as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(fade_level)
    )
  );
}
impl Default for SDL_HapticCustom {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief The generic template for any haptic effect."]
#[doc = ""]
#[doc = "  All values max at 32767 (0x7FFF).  Signed values also can be negative."]
#[doc = "  Time values unless specified otherwise are in milliseconds."]
#[doc = ""]
#[doc = "  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767"]
#[doc = "  value.  Neither delay, interval, attack_length nor fade_length support"]
#[doc = "  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends."]
#[doc = ""]
#[doc = "  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of"]
#[doc = "  ::SDL_HAPTIC_INFINITY."]
#[doc = ""]
#[doc = "  Button triggers may not be supported on all devices, it is advised to not"]
#[doc = "  use them if possible.  Buttons start at index 1 instead of index 0 like"]
#[doc = "  the joystick."]
#[doc = ""]
#[doc = "  If both attack_length and fade_level are 0, the envelope is not used,"]
#[doc = "  otherwise both values are used."]
#[doc = ""]
#[doc = "  Common parts:"]
#[doc = "  \\code"]
#[doc = "  // Replay - All effects have this"]
#[doc = "  Uint32 length;        // Duration of effect (ms)."]
#[doc = "  Uint16 delay;         // Delay before starting effect."]
#[doc = ""]
#[doc = "  // Trigger - All effects have this"]
#[doc = "  Uint16 button;        // Button that triggers effect."]
#[doc = "  Uint16 interval;      // How soon before effect can be triggered again."]
#[doc = ""]
#[doc = "  // Envelope - All effects except condition effects have this"]
#[doc = "  Uint16 attack_length; // Duration of the attack (ms)."]
#[doc = "  Uint16 attack_level;  // Level at the start of the attack."]
#[doc = "  Uint16 fade_length;   // Duration of the fade out (ms)."]
#[doc = "  Uint16 fade_level;    // Level at the end of the fade."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = ""]
#[doc = "  Here we have an example of a constant effect evolution in time:"]
#[doc = "  \\verbatim"]
#[doc = "Strength"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|    effect level -->  _________________"]
#[doc = "|                     /                 \\"]
#[doc = "|                    /                   \\"]
#[doc = "|                   /                     \\"]
#[doc = "|                  /                       \\"]
#[doc = "| attack_level --> |                        \\"]
#[doc = "|                  |                        |  <---  fade_level"]
#[doc = "|"]
#[doc = "+--------------------------------------------------> Time"]
#[doc = "[--]                 [---]"]
#[doc = "attack_length        fade_length"]
#[doc = ""]
#[doc = "[------------------][-----------------------]"]
#[doc = "delay               length"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  Note either the attack_level or the fade_level may be above the actual"]
#[doc = "  effect level."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticConstant"]
#[doc = "  \\sa SDL_HapticPeriodic"]
#[doc = "  \\sa SDL_HapticCondition"]
#[doc = "  \\sa SDL_HapticRamp"]
#[doc = "  \\sa SDL_HapticLeftRight"]
#[doc = "  \\sa SDL_HapticCustom"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
  #[doc = "< Effect type."]
  pub type_: Uint16,
  #[doc = "< Constant effect."]
  pub constant: SDL_HapticConstant,
  #[doc = "< Periodic effect."]
  pub periodic: SDL_HapticPeriodic,
  #[doc = "< Condition effect."]
  pub condition: SDL_HapticCondition,
  #[doc = "< Ramp effect."]
  pub ramp: SDL_HapticRamp,
  #[doc = "< Left/Right effect."]
  pub leftright: SDL_HapticLeftRight,
  #[doc = "< Custom effect."]
  pub custom: SDL_HapticCustom,
  _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticEffect>(),
    72usize,
    concat!("Size of: ", stringify!(SDL_HapticEffect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticEffect>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_HapticEffect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).constant as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(constant)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).periodic as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(periodic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).condition as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(condition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).ramp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(ramp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).leftright as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(leftright)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).custom as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(custom)
    )
  );
}
impl Default for SDL_HapticEffect {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_HapticEffect {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_HapticEffect {{ union }}")
  }
}
extern "C" {
  #[doc = "  \\brief Count the number of haptic devices attached to the system."]
  #[doc = ""]
  #[doc = "  \\return Number of haptic devices detected on the system."]
  #[link_name = "\u{1}_SDL_NumHaptics"]
  pub fn SDL_NumHaptics() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the implementation dependent name of a haptic device."]
  #[doc = ""]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If no name can be found, this function returns NULL."]
  #[doc = ""]
  #[doc = "  \\param device_index Index of the device to get its name."]
  #[doc = "  \\return Name of the device or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NumHaptics"]
  #[link_name = "\u{1}_SDL_HapticName"]
  pub fn SDL_HapticName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Opens a haptic device for use."]
  #[doc = ""]
  #[doc = "  The index passed as an argument refers to the N'th haptic device on this"]
  #[doc = "  system."]
  #[doc = ""]
  #[doc = "  When opening a haptic device, its gain will be set to maximum and"]
  #[doc = "  autocenter will be disabled.  To modify these values use"]
  #[doc = "  SDL_HapticSetGain() and SDL_HapticSetAutocenter()."]
  #[doc = ""]
  #[doc = "  \\param device_index Index of the device to open."]
  #[doc = "  \\return Device identifier or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticIndex"]
  #[doc = "  \\sa SDL_HapticOpenFromMouse"]
  #[doc = "  \\sa SDL_HapticOpenFromJoystick"]
  #[doc = "  \\sa SDL_HapticClose"]
  #[doc = "  \\sa SDL_HapticSetGain"]
  #[doc = "  \\sa SDL_HapticSetAutocenter"]
  #[doc = "  \\sa SDL_HapticPause"]
  #[doc = "  \\sa SDL_HapticStopAll"]
  #[link_name = "\u{1}_SDL_HapticOpen"]
  pub fn SDL_HapticOpen(device_index: libc::c_int) -> *mut SDL_Haptic;
}
extern "C" {
  #[doc = "  \\brief Checks if the haptic device at index has been opened."]
  #[doc = ""]
  #[doc = "  \\param device_index Index to check to see if it has been opened."]
  #[doc = "  \\return 1 if it has been opened or 0 if it hasn't."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticIndex"]
  #[link_name = "\u{1}_SDL_HapticOpened"]
  pub fn SDL_HapticOpened(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Gets the index of a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to get the index of."]
  #[doc = "  \\return The index of the haptic device or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticOpened"]
  #[link_name = "\u{1}_SDL_HapticIndex"]
  pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Gets whether or not the current mouse has haptic capabilities."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpenFromMouse"]
  #[link_name = "\u{1}_SDL_MouseIsHaptic"]
  pub fn SDL_MouseIsHaptic() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Tries to open a haptic device from the current mouse."]
  #[doc = ""]
  #[doc = "  \\return The haptic device identifier or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MouseIsHaptic"]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[link_name = "\u{1}_SDL_HapticOpenFromMouse"]
  pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
  #[doc = "  \\brief Checks to see if a joystick has haptic features."]
  #[doc = ""]
  #[doc = "  \\param joystick Joystick to test for haptic capabilities."]
  #[doc = "  \\return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't"]
  #[doc = "          or -1 if an error occurred."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpenFromJoystick"]
  #[link_name = "\u{1}_SDL_JoystickIsHaptic"]
  pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Opens a haptic device for use from a joystick device."]
  #[doc = ""]
  #[doc = "  You must still close the haptic device separately.  It will not be closed"]
  #[doc = "  with the joystick."]
  #[doc = ""]
  #[doc = "  When opening from a joystick you should first close the haptic device before"]
  #[doc = "  closing the joystick device.  If not, on some implementations the haptic"]
  #[doc = "  device will also get unallocated and you'll be unable to use force feedback"]
  #[doc = "  on that device."]
  #[doc = ""]
  #[doc = "  \\param joystick Joystick to create a haptic device from."]
  #[doc = "  \\return A valid haptic device identifier on success or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticClose"]
  #[link_name = "\u{1}_SDL_HapticOpenFromJoystick"]
  pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
  #[doc = "  \\brief Closes a haptic device previously opened with SDL_HapticOpen()."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to close."]
  #[link_name = "\u{1}_SDL_HapticClose"]
  pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
  #[doc = "  \\brief Returns the number of effects a haptic device can store."]
  #[doc = ""]
  #[doc = "  On some platforms this isn't fully supported, and therefore is an"]
  #[doc = "  approximation.  Always check to see if your created effect was actually"]
  #[doc = "  created and do not rely solely on SDL_HapticNumEffects()."]
  #[doc = ""]
  #[doc = "  \\param haptic The haptic device to query effect max."]
  #[doc = "  \\return The number of effects the haptic device can store or"]
  #[doc = "          -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNumEffectsPlaying"]
  #[doc = "  \\sa SDL_HapticQuery"]
  #[link_name = "\u{1}_SDL_HapticNumEffects"]
  pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Returns the number of effects a haptic device can play at the same"]
  #[doc = "         time."]
  #[doc = ""]
  #[doc = "  This is not supported on all platforms, but will always return a value."]
  #[doc = "  Added here for the sake of completeness."]
  #[doc = ""]
  #[doc = "  \\param haptic The haptic device to query maximum playing effects."]
  #[doc = "  \\return The number of effects the haptic device can play at the same time"]
  #[doc = "          or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNumEffects"]
  #[doc = "  \\sa SDL_HapticQuery"]
  #[link_name = "\u{1}_SDL_HapticNumEffectsPlaying"]
  pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Gets the haptic device's supported features in bitwise manner."]
  #[doc = ""]
  #[doc = "  Example:"]
  #[doc = "  \\code"]
  #[doc = "  if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {"]
  #[doc = "      printf(\"We have constant haptic effect!\\n\");"]
  #[doc = "  }"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  \\param haptic The haptic device to query."]
  #[doc = "  \\return Haptic features in bitwise manner (OR'd)."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNumEffects"]
  #[doc = "  \\sa SDL_HapticEffectSupported"]
  #[link_name = "\u{1}_SDL_HapticQuery"]
  pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> libc::c_uint;
}
extern "C" {
  #[doc = "  \\brief Gets the number of haptic axes the device has."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticDirection"]
  #[link_name = "\u{1}_SDL_HapticNumAxes"]
  pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Checks to see if effect is supported by haptic."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to check on."]
  #[doc = "  \\param effect Effect to check to see if it is supported."]
  #[doc = "  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticQuery"]
  #[doc = "  \\sa SDL_HapticNewEffect"]
  #[link_name = "\u{1}_SDL_HapticEffectSupported"]
  pub fn SDL_HapticEffectSupported(
    haptic: *mut SDL_Haptic,
    effect: *mut SDL_HapticEffect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Creates a new haptic effect on the device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to create the effect on."]
  #[doc = "  \\param effect Properties of the effect to create."]
  #[doc = "  \\return The identifier of the effect on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticUpdateEffect"]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  #[link_name = "\u{1}_SDL_HapticNewEffect"]
  pub fn SDL_HapticNewEffect(haptic: *mut SDL_Haptic, effect: *mut SDL_HapticEffect)
    -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Updates the properties of an effect."]
  #[doc = ""]
  #[doc = "  Can be used dynamically, although behavior when dynamically changing"]
  #[doc = "  direction may be strange.  Specifically the effect may reupload itself"]
  #[doc = "  and start playing from the start.  You cannot change the type either when"]
  #[doc = "  running SDL_HapticUpdateEffect()."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device that has the effect."]
  #[doc = "  \\param effect Identifier of the effect to update."]
  #[doc = "  \\param data New effect properties to use."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNewEffect"]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  #[link_name = "\u{1}_SDL_HapticUpdateEffect"]
  pub fn SDL_HapticUpdateEffect(
    haptic: *mut SDL_Haptic,
    effect: libc::c_int,
    data: *mut SDL_HapticEffect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Runs the haptic effect on its associated haptic device."]
  #[doc = ""]
  #[doc = "  If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over"]
  #[doc = "  repeating the envelope (attack and fade) every time.  If you only want the"]
  #[doc = "  effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length"]
  #[doc = "  parameter."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to run the effect on."]
  #[doc = "  \\param effect Identifier of the haptic effect to run."]
  #[doc = "  \\param iterations Number of iterations to run the effect. Use"]
  #[doc = "         ::SDL_HAPTIC_INFINITY for infinity."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticStopEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  #[doc = "  \\sa SDL_HapticGetEffectStatus"]
  #[link_name = "\u{1}_SDL_HapticRunEffect"]
  pub fn SDL_HapticRunEffect(
    haptic: *mut SDL_Haptic,
    effect: libc::c_int,
    iterations: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Stops the haptic effect on its associated haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to stop the effect on."]
  #[doc = "  \\param effect Identifier of the effect to stop."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  #[link_name = "\u{1}_SDL_HapticStopEffect"]
  pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Destroys a haptic effect on the device."]
  #[doc = ""]
  #[doc = "  This will stop the effect if it's running.  Effects are automatically"]
  #[doc = "  destroyed when the device is closed."]
  #[doc = ""]
  #[doc = "  \\param haptic Device to destroy the effect on."]
  #[doc = "  \\param effect Identifier of the effect to destroy."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNewEffect"]
  #[link_name = "\u{1}_SDL_HapticDestroyEffect"]
  pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Gets the status of the current effect on the haptic device."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_STATUS feature."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to query the effect status on."]
  #[doc = "  \\param effect Identifier of the effect to query its status."]
  #[doc = "  \\return 0 if it isn't playing, 1 if it is playing or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticStopEffect"]
  #[link_name = "\u{1}_SDL_HapticGetEffectStatus"]
  pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the global gain of the device."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_GAIN feature."]
  #[doc = ""]
  #[doc = "  The user may specify the maximum gain by setting the environment variable"]
  #[doc = "  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to"]
  #[doc = "  SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the"]
  #[doc = "  maximum."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to set the gain on."]
  #[doc = "  \\param gain Value to set the gain to, should be between 0 and 100."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticQuery"]
  #[link_name = "\u{1}_SDL_HapticSetGain"]
  pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the global autocenter of the device."]
  #[doc = ""]
  #[doc = "  Autocenter should be between 0 and 100.  Setting it to 0 will disable"]
  #[doc = "  autocentering."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_AUTOCENTER feature."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to set autocentering on."]
  #[doc = "  \\param autocenter Value to set autocenter to, 0 disables autocentering."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticQuery"]
  #[link_name = "\u{1}_SDL_HapticSetAutocenter"]
  pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Pauses a haptic device."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_PAUSE feature.  Call"]
  #[doc = "  SDL_HapticUnpause() to resume playback."]
  #[doc = ""]
  #[doc = "  Do not modify the effects nor add new ones while the device is paused."]
  #[doc = "  That can cause all sorts of weird errors."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to pause."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticUnpause"]
  #[link_name = "\u{1}_SDL_HapticPause"]
  pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Unpauses a haptic device."]
  #[doc = ""]
  #[doc = "  Call to unpause after SDL_HapticPause()."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to unpause."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticPause"]
  #[link_name = "\u{1}_SDL_HapticUnpause"]
  pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Stops all the currently playing effects on a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to stop."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[link_name = "\u{1}_SDL_HapticStopAll"]
  pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Checks to see if rumble is supported on a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to check to see if it supports rumble."]
  #[doc = "  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRumbleInit"]
  #[doc = "  \\sa SDL_HapticRumblePlay"]
  #[doc = "  \\sa SDL_HapticRumbleStop"]
  #[link_name = "\u{1}_SDL_HapticRumbleSupported"]
  pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Initializes the haptic device for simple rumble playback."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to initialize for simple rumble playback."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticRumbleSupported"]
  #[doc = "  \\sa SDL_HapticRumblePlay"]
  #[doc = "  \\sa SDL_HapticRumbleStop"]
  #[link_name = "\u{1}_SDL_HapticRumbleInit"]
  pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Runs simple rumble on a haptic device"]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to play rumble effect on."]
  #[doc = "  \\param strength Strength of the rumble to play as a 0-1 float value."]
  #[doc = "  \\param length Length of the rumble to play in milliseconds."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRumbleSupported"]
  #[doc = "  \\sa SDL_HapticRumbleInit"]
  #[doc = "  \\sa SDL_HapticRumbleStop"]
  #[link_name = "\u{1}_SDL_HapticRumblePlay"]
  pub fn SDL_HapticRumblePlay(
    haptic: *mut SDL_Haptic,
    strength: f32,
    length: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Stops the simple rumble on a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic to stop the rumble on."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRumbleSupported"]
  #[doc = "  \\sa SDL_HapticRumbleInit"]
  #[doc = "  \\sa SDL_HapticRumblePlay"]
  #[link_name = "\u{1}_SDL_HapticRumbleStop"]
  pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> libc::c_int;
}
pub mod SDL_HintPriority {
  #[doc = "  \\brief  An enumeration of hint priorities"]
  pub type Type = u32;
  pub const SDL_HINT_DEFAULT: Type = 0;
  pub const SDL_HINT_NORMAL: Type = 1;
  pub const SDL_HINT_OVERRIDE: Type = 2;
}
extern "C" {
  #[doc = "  \\brief Set a hint with a specific priority"]
  #[doc = ""]
  #[doc = "  The priority controls the behavior when setting a hint that already"]
  #[doc = "  has a value.  Hints will replace existing hints of their priority and"]
  #[doc = "  lower.  Environment variables are considered to have override priority."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
  #[link_name = "\u{1}_SDL_SetHintWithPriority"]
  pub fn SDL_SetHintWithPriority(
    name: *const libc::c_char,
    value: *const libc::c_char,
    priority: SDL_HintPriority::Type,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Set a hint with normal priority"]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
  #[link_name = "\u{1}_SDL_SetHint"]
  pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Get a hint"]
  #[doc = ""]
  #[doc = "  \\return The string value of a hint variable."]
  #[link_name = "\u{1}_SDL_GetHint"]
  pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get a hint"]
  #[doc = ""]
  #[doc = "  \\return The boolean value of a hint variable."]
  #[link_name = "\u{1}_SDL_GetHintBoolean"]
  pub fn SDL_GetHintBoolean(
    name: *const libc::c_char,
    default_value: SDL_bool::Type,
  ) -> SDL_bool::Type;
}
#[doc = " \\brief type definition of the hint callback function."]
pub type SDL_HintCallback = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    name: *const libc::c_char,
    oldValue: *const libc::c_char,
    newValue: *const libc::c_char,
  ),
>;
extern "C" {
  #[doc = "  \\brief Add a function to watch a particular hint"]
  #[doc = ""]
  #[doc = "  \\param name The hint to watch"]
  #[doc = "  \\param callback The function to call when the hint value changes"]
  #[doc = "  \\param userdata A pointer to pass to the callback function"]
  #[link_name = "\u{1}_SDL_AddHintCallback"]
  pub fn SDL_AddHintCallback(
    name: *const libc::c_char,
    callback: SDL_HintCallback,
    userdata: *mut libc::c_void,
  );
}
extern "C" {
  #[doc = "  \\brief Remove a function watching a particular hint"]
  #[doc = ""]
  #[doc = "  \\param name The hint being watched"]
  #[doc = "  \\param callback The function being called when the hint value changes"]
  #[doc = "  \\param userdata A pointer being passed to the callback function"]
  #[link_name = "\u{1}_SDL_DelHintCallback"]
  pub fn SDL_DelHintCallback(
    name: *const libc::c_char,
    callback: SDL_HintCallback,
    userdata: *mut libc::c_void,
  );
}
extern "C" {
  #[doc = "  \\brief  Clear all hints"]
  #[doc = ""]
  #[doc = "  This function is called during SDL_Quit() to free stored hints."]
  #[link_name = "\u{1}_SDL_ClearHints"]
  pub fn SDL_ClearHints();
}
extern "C" {
  #[doc = "  This function dynamically loads a shared object and returns a pointer"]
  #[doc = "  to the object handle (or NULL if there was an error)."]
  #[doc = "  The 'sofile' parameter is a system dependent name of the object file."]
  #[link_name = "\u{1}_SDL_LoadObject"]
  pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  Given an object handle, this function looks up the address of the"]
  #[doc = "  named function in the shared object and returns it.  This address"]
  #[doc = "  is no longer valid after calling SDL_UnloadObject()."]
  #[link_name = "\u{1}_SDL_LoadFunction"]
  pub fn SDL_LoadFunction(
    handle: *mut libc::c_void,
    name: *const libc::c_char,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  Unload a shared object from memory."]
  #[link_name = "\u{1}_SDL_UnloadObject"]
  pub fn SDL_UnloadObject(handle: *mut libc::c_void);
}
pub mod _bindgen_ty_8 {
  #[doc = "  \\brief The predefined log categories"]
  #[doc = ""]
  #[doc = "  By default the application category is enabled at the INFO level,"]
  #[doc = "  the assert category is enabled at the WARN level, test is enabled"]
  #[doc = "  at the VERBOSE level and all other categories are enabled at the"]
  #[doc = "  CRITICAL level."]
  pub type Type = u32;
  pub const SDL_LOG_CATEGORY_APPLICATION: Type = 0;
  pub const SDL_LOG_CATEGORY_ERROR: Type = 1;
  pub const SDL_LOG_CATEGORY_ASSERT: Type = 2;
  pub const SDL_LOG_CATEGORY_SYSTEM: Type = 3;
  pub const SDL_LOG_CATEGORY_AUDIO: Type = 4;
  pub const SDL_LOG_CATEGORY_VIDEO: Type = 5;
  pub const SDL_LOG_CATEGORY_RENDER: Type = 6;
  pub const SDL_LOG_CATEGORY_INPUT: Type = 7;
  pub const SDL_LOG_CATEGORY_TEST: Type = 8;
  pub const SDL_LOG_CATEGORY_RESERVED1: Type = 9;
  pub const SDL_LOG_CATEGORY_RESERVED2: Type = 10;
  pub const SDL_LOG_CATEGORY_RESERVED3: Type = 11;
  pub const SDL_LOG_CATEGORY_RESERVED4: Type = 12;
  pub const SDL_LOG_CATEGORY_RESERVED5: Type = 13;
  pub const SDL_LOG_CATEGORY_RESERVED6: Type = 14;
  pub const SDL_LOG_CATEGORY_RESERVED7: Type = 15;
  pub const SDL_LOG_CATEGORY_RESERVED8: Type = 16;
  pub const SDL_LOG_CATEGORY_RESERVED9: Type = 17;
  pub const SDL_LOG_CATEGORY_RESERVED10: Type = 18;
  pub const SDL_LOG_CATEGORY_CUSTOM: Type = 19;
}
pub mod SDL_LogPriority {
  #[doc = "  \\brief The predefined log priorities"]
  pub type Type = u32;
  pub const SDL_LOG_PRIORITY_VERBOSE: Type = 1;
  pub const SDL_LOG_PRIORITY_DEBUG: Type = 2;
  pub const SDL_LOG_PRIORITY_INFO: Type = 3;
  pub const SDL_LOG_PRIORITY_WARN: Type = 4;
  pub const SDL_LOG_PRIORITY_ERROR: Type = 5;
  pub const SDL_LOG_PRIORITY_CRITICAL: Type = 6;
  pub const SDL_NUM_LOG_PRIORITIES: Type = 7;
}
extern "C" {
  #[doc = "  \\brief Set the priority of all log categories"]
  #[link_name = "\u{1}_SDL_LogSetAllPriority"]
  pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority::Type);
}
extern "C" {
  #[doc = "  \\brief Set the priority of a particular log category"]
  #[link_name = "\u{1}_SDL_LogSetPriority"]
  pub fn SDL_LogSetPriority(category: libc::c_int, priority: SDL_LogPriority::Type);
}
extern "C" {
  #[doc = "  \\brief Get the priority of a particular log category"]
  #[link_name = "\u{1}_SDL_LogGetPriority"]
  pub fn SDL_LogGetPriority(category: libc::c_int) -> SDL_LogPriority::Type;
}
extern "C" {
  #[doc = "  \\brief Reset all priorities to default."]
  #[doc = ""]
  #[doc = "  \\note This is called in SDL_Quit()."]
  #[link_name = "\u{1}_SDL_LogResetPriorities"]
  pub fn SDL_LogResetPriorities();
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO"]
  #[link_name = "\u{1}_SDL_Log"]
  pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_VERBOSE"]
  #[link_name = "\u{1}_SDL_LogVerbose"]
  pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_DEBUG"]
  #[link_name = "\u{1}_SDL_LogDebug"]
  pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_INFO"]
  #[link_name = "\u{1}_SDL_LogInfo"]
  pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_WARN"]
  #[link_name = "\u{1}_SDL_LogWarn"]
  pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_ERROR"]
  #[link_name = "\u{1}_SDL_LogError"]
  pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_CRITICAL"]
  #[link_name = "\u{1}_SDL_LogCritical"]
  pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with the specified category and priority."]
  #[link_name = "\u{1}_SDL_LogMessage"]
  pub fn SDL_LogMessage(
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    fmt: *const libc::c_char,
    ...
  );
}
extern "C" {
  #[doc = "  \\brief Log a message with the specified category and priority."]
  #[link_name = "\u{1}_SDL_LogMessageV"]
  pub fn SDL_LogMessageV(
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    fmt: *const libc::c_char,
    ap: *mut __va_list_tag,
  );
}
#[doc = "  \\brief The prototype for the log output function"]
pub type SDL_LogOutputFunction = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    message: *const libc::c_char,
  ),
>;
extern "C" {
  #[doc = "  \\brief Get the current log output function."]
  #[link_name = "\u{1}_SDL_LogGetOutputFunction"]
  pub fn SDL_LogGetOutputFunction(
    callback: *mut SDL_LogOutputFunction,
    userdata: *mut *mut libc::c_void,
  );
}
extern "C" {
  #[doc = "  \\brief This function allows you to replace the default log output"]
  #[doc = "         function with one of your own."]
  #[link_name = "\u{1}_SDL_LogSetOutputFunction"]
  pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
pub mod SDL_MessageBoxFlags {
  #[doc = " \\brief SDL_MessageBox flags. If supported will display warning icon, etc."]
  pub type Type = u32;
  #[doc = "< error dialog"]
  pub const SDL_MESSAGEBOX_ERROR: Type = 16;
  #[doc = "< warning dialog"]
  pub const SDL_MESSAGEBOX_WARNING: Type = 32;
  #[doc = "< informational dialog"]
  pub const SDL_MESSAGEBOX_INFORMATION: Type = 64;
}
pub mod SDL_MessageBoxButtonFlags {
  #[doc = " \\brief Flags for SDL_MessageBoxButtonData."]
  pub type Type = u32;
  #[doc = "< Marks the default button when return is hit"]
  pub const SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT: Type = 1;
  #[doc = "< Marks the default button when escape is hit"]
  pub const SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT: Type = 2;
}
#[doc = "  \\brief Individual button data."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxButtonData {
  #[doc = "< ::SDL_MessageBoxButtonFlags"]
  pub flags: Uint32,
  #[doc = "< User defined button id (value returned via SDL_ShowMessageBox)"]
  pub buttonid: libc::c_int,
  #[doc = "< The UTF-8 button text"]
  pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxButtonData>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxButtonData>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).buttonid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(buttonid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).text as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(text)
    )
  );
}
impl Default for SDL_MessageBoxButtonData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = " \\brief RGB value used in a message box color scheme"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxColor {
  pub r: Uint8,
  pub g: Uint8,
  pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxColor>(),
    3usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxColor))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxColor>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(b)
    )
  );
}
pub mod SDL_MessageBoxColorType {
  pub type Type = u32;
  pub const SDL_MESSAGEBOX_COLOR_BACKGROUND: Type = 0;
  pub const SDL_MESSAGEBOX_COLOR_TEXT: Type = 1;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_BORDER: Type = 2;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND: Type = 3;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED: Type = 4;
  pub const SDL_MESSAGEBOX_COLOR_MAX: Type = 5;
}
#[doc = " \\brief A set of colors to use for message box dialogs"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxColorScheme {
  pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxColorScheme>(),
    15usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxColorScheme>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColorScheme>())).colors as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColorScheme),
      "::",
      stringify!(colors)
    )
  );
}
#[doc = "  \\brief MessageBox structure containing title, text, window, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxData {
  #[doc = "< ::SDL_MessageBoxFlags"]
  pub flags: Uint32,
  #[doc = "< Parent window, can be NULL"]
  pub window: *mut SDL_Window,
  #[doc = "< UTF-8 title"]
  pub title: *const libc::c_char,
  #[doc = "< UTF-8 message text"]
  pub message: *const libc::c_char,
  pub numbuttons: libc::c_int,
  pub buttons: *const SDL_MessageBoxButtonData,
  #[doc = "< ::SDL_MessageBoxColorScheme, can be NULL to use system settings"]
  pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxData>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxData>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).window as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).title as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(title)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).message as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).numbuttons as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(numbuttons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).buttons as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(buttons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).colorScheme as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(colorScheme)
    )
  );
}
impl Default for SDL_MessageBoxData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[doc = "  \\brief Create a modal message box."]
  #[doc = ""]
  #[doc = "  \\param messageboxdata The SDL_MessageBoxData structure with title, text, etc."]
  #[doc = "  \\param buttonid The pointer to which user id of hit button should be copied."]
  #[doc = ""]
  #[doc = "  \\return -1 on error, otherwise 0 and buttonid contains user id of button"]
  #[doc = "          hit or -1 if dialog was closed."]
  #[doc = ""]
  #[doc = "  \\note This function should be called on the thread that created the parent"]
  #[doc = "        window, or on the main thread if the messagebox has no parent.  It will"]
  #[doc = "        block execution of that thread until the user clicks a button or"]
  #[doc = "        closes the messagebox."]
  #[link_name = "\u{1}_SDL_ShowMessageBox"]
  pub fn SDL_ShowMessageBox(
    messageboxdata: *const SDL_MessageBoxData,
    buttonid: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a simple modal message box"]
  #[doc = ""]
  #[doc = "  \\param flags    ::SDL_MessageBoxFlags"]
  #[doc = "  \\param title    UTF-8 title text"]
  #[doc = "  \\param message  UTF-8 message text"]
  #[doc = "  \\param window   The parent window, or NULL for no parent"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_ShowMessageBox"]
  #[link_name = "\u{1}_SDL_ShowSimpleMessageBox"]
  pub fn SDL_ShowSimpleMessageBox(
    flags: Uint32,
    title: *const libc::c_char,
    message: *const libc::c_char,
    window: *mut SDL_Window,
  ) -> libc::c_int;
}
pub mod SDL_PowerState {
  #[doc = "  \\brief The basic state for the system's power supply."]
  pub type Type = u32;
  #[doc = "< cannot determine power status"]
  pub const SDL_POWERSTATE_UNKNOWN: Type = 0;
  #[doc = "< Not plugged in, running on the battery"]
  pub const SDL_POWERSTATE_ON_BATTERY: Type = 1;
  #[doc = "< Plugged in, no battery available"]
  pub const SDL_POWERSTATE_NO_BATTERY: Type = 2;
  #[doc = "< Plugged in, charging battery"]
  pub const SDL_POWERSTATE_CHARGING: Type = 3;
  #[doc = "< Plugged in, battery charged"]
  pub const SDL_POWERSTATE_CHARGED: Type = 4;
}
extern "C" {
  #[doc = "  \\brief Get the current power supply details."]
  #[doc = ""]
  #[doc = "  \\param secs Seconds of battery life left. You can pass a NULL here if"]
  #[doc = "              you don't care. Will return -1 if we can't determine a"]
  #[doc = "              value, or we're not running on a battery."]
  #[doc = ""]
  #[doc = "  \\param pct Percentage of battery life left, between 0 and 100. You can"]
  #[doc = "             pass a NULL here if you don't care. Will return -1 if we"]
  #[doc = "             can't determine a value, or we're not running on a battery."]
  #[doc = ""]
  #[doc = "  \\return The state of the battery (if any)."]
  #[link_name = "\u{1}_SDL_GetPowerInfo"]
  pub fn SDL_GetPowerInfo(secs: *mut libc::c_int, pct: *mut libc::c_int) -> SDL_PowerState::Type;
}
pub mod SDL_RendererFlags {
  #[doc = "  \\brief Flags used when creating a rendering context"]
  pub type Type = u32;
  #[doc = "< The renderer is a software fallback"]
  pub const SDL_RENDERER_SOFTWARE: Type = 1;
  #[doc = "< The renderer uses hardware"]
  #[doc = "acceleration"]
  pub const SDL_RENDERER_ACCELERATED: Type = 2;
  #[doc = "< Present is synchronized"]
  #[doc = "with the refresh rate"]
  pub const SDL_RENDERER_PRESENTVSYNC: Type = 4;
  #[doc = "< The renderer supports"]
  #[doc = "rendering to texture"]
  pub const SDL_RENDERER_TARGETTEXTURE: Type = 8;
}
#[doc = "  \\brief Information on the capabilities of a render driver or context."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RendererInfo {
  #[doc = "< The name of the renderer"]
  pub name: *const libc::c_char,
  #[doc = "< Supported ::SDL_RendererFlags"]
  pub flags: Uint32,
  #[doc = "< The number of available texture formats"]
  pub num_texture_formats: Uint32,
  #[doc = "< The available texture formats"]
  pub texture_formats: [Uint32; 16usize],
  #[doc = "< The maximum texture width"]
  pub max_texture_width: libc::c_int,
  #[doc = "< The maximum texture height"]
  pub max_texture_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RendererInfo>(),
    88usize,
    concat!("Size of: ", stringify!(SDL_RendererInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RendererInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_RendererInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RendererInfo>())).num_texture_formats as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(num_texture_formats)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).texture_formats as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(texture_formats)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_width as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(max_texture_width)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_height as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(max_texture_height)
    )
  );
}
impl Default for SDL_RendererInfo {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub mod SDL_TextureAccess {
  #[doc = "  \\brief The access pattern allowed for a texture."]
  pub type Type = u32;
  #[doc = "< Changes rarely, not lockable"]
  pub const SDL_TEXTUREACCESS_STATIC: Type = 0;
  #[doc = "< Changes frequently, lockable"]
  pub const SDL_TEXTUREACCESS_STREAMING: Type = 1;
  #[doc = "< Texture can be used as a render target"]
  pub const SDL_TEXTUREACCESS_TARGET: Type = 2;
}
pub mod SDL_TextureModulate {
  #[doc = "  \\brief The texture channel modulation used in SDL_RenderCopy()."]
  pub type Type = u32;
  #[doc = "< No modulation"]
  pub const SDL_TEXTUREMODULATE_NONE: Type = 0;
  #[doc = "< srcC = srcC * color"]
  pub const SDL_TEXTUREMODULATE_COLOR: Type = 1;
  #[doc = "< srcA = srcA * alpha"]
  pub const SDL_TEXTUREMODULATE_ALPHA: Type = 2;
}
pub mod SDL_RendererFlip {
  #[doc = "  \\brief Flip constants for SDL_RenderCopyEx"]
  pub type Type = u32;
  #[doc = "< Do not flip"]
  pub const SDL_FLIP_NONE: Type = 0;
  #[doc = "< flip horizontally"]
  pub const SDL_FLIP_HORIZONTAL: Type = 1;
  #[doc = "< flip vertically"]
  pub const SDL_FLIP_VERTICAL: Type = 2;
}
#[doc = "  \\brief A structure representing rendering state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Renderer {
  _unused: [u8; 0],
}
#[doc = "  \\brief An efficient driver-specific representation of pixel data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Texture {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "  \\brief Get the number of 2D rendering drivers available for the current"]
  #[doc = "         display."]
  #[doc = ""]
  #[doc = "  A render driver is a set of code that handles rendering and texture"]
  #[doc = "  management on a particular display.  Normally there is only one, but"]
  #[doc = "  some drivers may have several available with different capabilities."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRenderDriverInfo()"]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  #[link_name = "\u{1}_SDL_GetNumRenderDrivers"]
  pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get information about a specific 2D rendering driver for the current"]
  #[doc = "         display."]
  #[doc = ""]
  #[doc = "  \\param index The index of the driver to query information about."]
  #[doc = "  \\param info  A pointer to an SDL_RendererInfo struct to be filled with"]
  #[doc = "               information on the rendering driver."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 if the index was out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  #[link_name = "\u{1}_SDL_GetRenderDriverInfo"]
  pub fn SDL_GetRenderDriverInfo(index: libc::c_int, info: *mut SDL_RendererInfo) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a window and default renderer"]
  #[doc = ""]
  #[doc = "  \\param width    The width of the window"]
  #[doc = "  \\param height   The height of the window"]
  #[doc = "  \\param window_flags The flags used to create the window"]
  #[doc = "  \\param window   A pointer filled with the window, or NULL on error"]
  #[doc = "  \\param renderer A pointer filled with the renderer, or NULL on error"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_CreateWindowAndRenderer"]
  pub fn SDL_CreateWindowAndRenderer(
    width: libc::c_int,
    height: libc::c_int,
    window_flags: Uint32,
    window: *mut *mut SDL_Window,
    renderer: *mut *mut SDL_Renderer,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a 2D rendering context for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window where rendering is displayed."]
  #[doc = "  \\param index    The index of the rendering driver to initialize, or -1 to"]
  #[doc = "                  initialize the first one supporting the requested flags."]
  #[doc = "  \\param flags    ::SDL_RendererFlags."]
  #[doc = ""]
  #[doc = "  \\return A valid rendering context or NULL if there was an error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateSoftwareRenderer()"]
  #[doc = "  \\sa SDL_GetRendererInfo()"]
  #[doc = "  \\sa SDL_DestroyRenderer()"]
  #[link_name = "\u{1}_SDL_CreateRenderer"]
  pub fn SDL_CreateRenderer(
    window: *mut SDL_Window,
    index: libc::c_int,
    flags: Uint32,
  ) -> *mut SDL_Renderer;
}
extern "C" {
  #[doc = "  \\brief Create a 2D software rendering context for a surface."]
  #[doc = ""]
  #[doc = "  \\param surface The surface where rendering is done."]
  #[doc = ""]
  #[doc = "  \\return A valid rendering context or NULL if there was an error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  #[doc = "  \\sa SDL_DestroyRenderer()"]
  #[link_name = "\u{1}_SDL_CreateSoftwareRenderer"]
  pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
  #[doc = "  \\brief Get the renderer associated with a window."]
  #[link_name = "\u{1}_SDL_GetRenderer"]
  pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
  #[doc = "  \\brief Get information about a rendering context."]
  #[link_name = "\u{1}_SDL_GetRendererInfo"]
  pub fn SDL_GetRendererInfo(
    renderer: *mut SDL_Renderer,
    info: *mut SDL_RendererInfo,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the output size in pixels of a rendering context."]
  #[link_name = "\u{1}_SDL_GetRendererOutputSize"]
  pub fn SDL_GetRendererOutputSize(
    renderer: *mut SDL_Renderer,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a texture for a rendering context."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer."]
  #[doc = "  \\param format The format of the texture."]
  #[doc = "  \\param access One of the enumerated values in ::SDL_TextureAccess."]
  #[doc = "  \\param w      The width of the texture in pixels."]
  #[doc = "  \\param h      The height of the texture in pixels."]
  #[doc = ""]
  #[doc = "  \\return The created texture is returned, or NULL if no rendering context was"]
  #[doc = "          active,  the format was unsupported, or the width or height were out"]
  #[doc = "          of range."]
  #[doc = ""]
  #[doc = "  \\note The contents of the texture are not defined at creation."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueryTexture()"]
  #[doc = "  \\sa SDL_UpdateTexture()"]
  #[doc = "  \\sa SDL_DestroyTexture()"]
  #[link_name = "\u{1}_SDL_CreateTexture"]
  pub fn SDL_CreateTexture(
    renderer: *mut SDL_Renderer,
    format: Uint32,
    access: libc::c_int,
    w: libc::c_int,
    h: libc::c_int,
  ) -> *mut SDL_Texture;
}
extern "C" {
  #[doc = "  \\brief Create a texture from an existing surface."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer."]
  #[doc = "  \\param surface The surface containing pixel data used to fill the texture."]
  #[doc = ""]
  #[doc = "  \\return The created texture is returned, or NULL on error."]
  #[doc = ""]
  #[doc = "  \\note The surface is not modified or freed by this function."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueryTexture()"]
  #[doc = "  \\sa SDL_DestroyTexture()"]
  #[link_name = "\u{1}_SDL_CreateTextureFromSurface"]
  pub fn SDL_CreateTextureFromSurface(
    renderer: *mut SDL_Renderer,
    surface: *mut SDL_Surface,
  ) -> *mut SDL_Texture;
}
extern "C" {
  #[doc = "  \\brief Query the attributes of a texture"]
  #[doc = ""]
  #[doc = "  \\param texture A texture to be queried."]
  #[doc = "  \\param format  A pointer filled in with the raw format of the texture.  The"]
  #[doc = "                 actual format may differ, but pixel transfers will use this"]
  #[doc = "                 format."]
  #[doc = "  \\param access  A pointer filled in with the actual access to the texture."]
  #[doc = "  \\param w       A pointer filled in with the width of the texture in pixels."]
  #[doc = "  \\param h       A pointer filled in with the height of the texture in pixels."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[link_name = "\u{1}_SDL_QueryTexture"]
  pub fn SDL_QueryTexture(
    texture: *mut SDL_Texture,
    format: *mut Uint32,
    access: *mut libc::c_int,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional color value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to update."]
  #[doc = "  \\param r       The red color value multiplied into copy operations."]
  #[doc = "  \\param g       The green color value multiplied into copy operations."]
  #[doc = "  \\param b       The blue color value multiplied into copy operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or color modulation"]
  #[doc = "          is not supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetTextureColorMod()"]
  #[link_name = "\u{1}_SDL_SetTextureColorMod"]
  pub fn SDL_SetTextureColorMod(
    texture: *mut SDL_Texture,
    r: Uint8,
    g: Uint8,
    b: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional color value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to query."]
  #[doc = "  \\param r         A pointer filled in with the current red color value."]
  #[doc = "  \\param g         A pointer filled in with the current green color value."]
  #[doc = "  \\param b         A pointer filled in with the current blue color value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetTextureColorMod()"]
  #[link_name = "\u{1}_SDL_GetTextureColorMod"]
  pub fn SDL_GetTextureColorMod(
    texture: *mut SDL_Texture,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional alpha value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to update."]
  #[doc = "  \\param alpha     The alpha value multiplied into copy operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or alpha modulation"]
  #[doc = "          is not supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetTextureAlphaMod()"]
  #[link_name = "\u{1}_SDL_SetTextureAlphaMod"]
  pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional alpha value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to query."]
  #[doc = "  \\param alpha     A pointer filled in with the current alpha value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetTextureAlphaMod()"]
  #[link_name = "\u{1}_SDL_GetTextureAlphaMod"]
  pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the blend mode used for texture copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to update."]
  #[doc = "  \\param blendMode ::SDL_BlendMode to use for texture blending."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or the blend mode is"]
  #[doc = "          not supported."]
  #[doc = ""]
  #[doc = "  \\note If the blend mode is not supported, the closest supported mode is"]
  #[doc = "        chosen."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetTextureBlendMode()"]
  #[link_name = "\u{1}_SDL_SetTextureBlendMode"]
  pub fn SDL_SetTextureBlendMode(
    texture: *mut SDL_Texture,
    blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the blend mode used for texture copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to query."]
  #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetTextureBlendMode()"]
  #[link_name = "\u{1}_SDL_GetTextureBlendMode"]
  pub fn SDL_GetTextureBlendMode(
    texture: *mut SDL_Texture,
    blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Update the given texture rectangle with new pixel data."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to update"]
  #[doc = "  \\param rect      A pointer to the rectangle of pixels to update, or NULL to"]
  #[doc = "                   update the entire texture."]
  #[doc = "  \\param pixels    The raw pixel data in the format of the texture."]
  #[doc = "  \\param pitch     The number of bytes in a row of pixel data, including padding between lines."]
  #[doc = ""]
  #[doc = "  The pixel data must be in the format of the texture. The pixel format can be"]
  #[doc = "  queried with SDL_QueryTexture."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\note This is a fairly slow function."]
  #[link_name = "\u{1}_SDL_UpdateTexture"]
  pub fn SDL_UpdateTexture(
    texture: *mut SDL_Texture,
    rect: *const SDL_Rect,
    pixels: *const libc::c_void,
    pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to update"]
  #[doc = "  \\param rect      A pointer to the rectangle of pixels to update, or NULL to"]
  #[doc = "                   update the entire texture."]
  #[doc = "  \\param Yplane    The raw pixel data for the Y plane."]
  #[doc = "  \\param Ypitch    The number of bytes between rows of pixel data for the Y plane."]
  #[doc = "  \\param Uplane    The raw pixel data for the U plane."]
  #[doc = "  \\param Upitch    The number of bytes between rows of pixel data for the U plane."]
  #[doc = "  \\param Vplane    The raw pixel data for the V plane."]
  #[doc = "  \\param Vpitch    The number of bytes between rows of pixel data for the V plane."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\note You can use SDL_UpdateTexture() as long as your pixel data is"]
  #[doc = "        a contiguous block of Y and U/V planes in the proper order, but"]
  #[doc = "        this function is available if your pixel data is not contiguous."]
  #[link_name = "\u{1}_SDL_UpdateYUVTexture"]
  pub fn SDL_UpdateYUVTexture(
    texture: *mut SDL_Texture,
    rect: *const SDL_Rect,
    Yplane: *const Uint8,
    Ypitch: libc::c_int,
    Uplane: *const Uint8,
    Upitch: libc::c_int,
    Vplane: *const Uint8,
    Vpitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Lock a portion of the texture for write-only pixel access."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to lock for access, which was created with"]
  #[doc = "                   ::SDL_TEXTUREACCESS_STREAMING."]
  #[doc = "  \\param rect      A pointer to the rectangle to lock for access. If the rect"]
  #[doc = "                   is NULL, the entire texture will be locked."]
  #[doc = "  \\param pixels    This is filled in with a pointer to the locked pixels,"]
  #[doc = "                   appropriately offset by the locked area."]
  #[doc = "  \\param pitch     This is filled in with the pitch of the locked pixels."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING."]
  #[doc = ""]
  #[doc = "  \\sa SDL_UnlockTexture()"]
  #[link_name = "\u{1}_SDL_LockTexture"]
  pub fn SDL_LockTexture(
    texture: *mut SDL_Texture,
    rect: *const SDL_Rect,
    pixels: *mut *mut libc::c_void,
    pitch: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Unlock a texture, uploading the changes to video memory, if needed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_LockTexture()"]
  #[link_name = "\u{1}_SDL_UnlockTexture"]
  pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
  #[doc = " \\brief Determines whether a window supports the use of render targets"]
  #[doc = ""]
  #[doc = " \\param renderer The renderer that will be checked"]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if supported, SDL_FALSE if not."]
  #[link_name = "\u{1}_SDL_RenderTargetSupported"]
  pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Set a texture as the current rendering target."]
  #[doc = ""]
  #[doc = " \\param renderer The renderer."]
  #[doc = " \\param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target"]
  #[doc = ""]
  #[doc = " \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRenderTarget()"]
  #[link_name = "\u{1}_SDL_SetRenderTarget"]
  pub fn SDL_SetRenderTarget(renderer: *mut SDL_Renderer, texture: *mut SDL_Texture)
    -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get the current render target or NULL for the default render target."]
  #[doc = ""]
  #[doc = " \\return The current render target"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetRenderTarget()"]
  #[link_name = "\u{1}_SDL_GetRenderTarget"]
  pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
  #[doc = "  \\brief Set device independent resolution for rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which resolution should be set."]
  #[doc = "  \\param w      The width of the logical resolution"]
  #[doc = "  \\param h      The height of the logical resolution"]
  #[doc = ""]
  #[doc = "  This function uses the viewport and scaling functionality to allow a fixed logical"]
  #[doc = "  resolution for rendering, regardless of the actual output resolution.  If the actual"]
  #[doc = "  output resolution doesn't have the same aspect ratio the output rendering will be"]
  #[doc = "  centered within the output display."]
  #[doc = ""]
  #[doc = "  If the output display is a window, mouse events in the window will be filtered"]
  #[doc = "  and scaled so they seem to arrive within the logical resolution."]
  #[doc = ""]
  #[doc = "  \\note If this function results in scaling or subpixel drawing by the"]
  #[doc = "        rendering backend, it will be handled using the appropriate"]
  #[doc = "        quality hints."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetLogicalSize()"]
  #[doc = "  \\sa SDL_RenderSetScale()"]
  #[doc = "  \\sa SDL_RenderSetViewport()"]
  #[link_name = "\u{1}_SDL_RenderSetLogicalSize"]
  pub fn SDL_RenderSetLogicalSize(
    renderer: *mut SDL_Renderer,
    w: libc::c_int,
    h: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get device independent resolution for rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which resolution should be queried."]
  #[doc = "  \\param w      A pointer filled with the width of the logical resolution"]
  #[doc = "  \\param h      A pointer filled with the height of the logical resolution"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  #[link_name = "\u{1}_SDL_RenderGetLogicalSize"]
  pub fn SDL_RenderGetLogicalSize(
    renderer: *mut SDL_Renderer,
    w: *mut libc::c_int,
    h: *mut libc::c_int,
  );
}
extern "C" {
  #[doc = "  \\brief Set whether to force integer scales for resolution-independent rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which integer scaling should be set."]
  #[doc = "  \\param enable   Enable or disable integer scaling"]
  #[doc = ""]
  #[doc = "  This function restricts the logical viewport to integer values - that is, when"]
  #[doc = "  a resolution is between two multiples of a logical size, the viewport size is"]
  #[doc = "  rounded down to the lower multiple."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  #[link_name = "\u{1}_SDL_RenderSetIntegerScale"]
  pub fn SDL_RenderSetIntegerScale(
    renderer: *mut SDL_Renderer,
    enable: SDL_bool::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get whether integer scales are forced for resolution-independent rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which integer scaling should be queried."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetIntegerScale()"]
  #[link_name = "\u{1}_SDL_RenderGetIntegerScale"]
  pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Set the drawing area for rendering on the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which the drawing area should be set."]
  #[doc = "  \\param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target."]
  #[doc = ""]
  #[doc = "  The x,y of the viewport rect represents the origin for rendering."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\note If the window associated with the renderer is resized, the viewport is automatically reset."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetViewport()"]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  #[link_name = "\u{1}_SDL_RenderSetViewport"]
  pub fn SDL_RenderSetViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the drawing area for the current target."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetViewport()"]
  #[link_name = "\u{1}_SDL_RenderGetViewport"]
  pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Set the clip rectangle for the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which clip rectangle should be set."]
  #[doc = "  \\param rect   A pointer to the rectangle to set as the clip rectangle, or"]
  #[doc = "                NULL to disable clipping."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetClipRect()"]
  #[link_name = "\u{1}_SDL_RenderSetClipRect"]
  pub fn SDL_RenderSetClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the clip rectangle for the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which clip rectangle should be queried."]
  #[doc = "  \\param rect   A pointer filled in with the current clip rectangle, or"]
  #[doc = "                an empty rectangle if clipping is disabled."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetClipRect()"]
  #[link_name = "\u{1}_SDL_RenderGetClipRect"]
  pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Get whether clipping is enabled on the given renderer."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which clip state should be queried."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetClipRect()"]
  #[link_name = "\u{1}_SDL_RenderIsClipEnabled"]
  pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Set the drawing scale for rendering on the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which the drawing scale should be set."]
  #[doc = "  \\param scaleX The horizontal scaling factor"]
  #[doc = "  \\param scaleY The vertical scaling factor"]
  #[doc = ""]
  #[doc = "  The drawing coordinates are scaled by the x/y scaling factors"]
  #[doc = "  before they are used by the renderer.  This allows resolution"]
  #[doc = "  independent drawing with a single coordinate system."]
  #[doc = ""]
  #[doc = "  \\note If this results in scaling or subpixel drawing by the"]
  #[doc = "        rendering backend, it will be handled using the appropriate"]
  #[doc = "        quality hints.  For best results use integer scaling factors."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetScale()"]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  #[link_name = "\u{1}_SDL_RenderSetScale"]
  pub fn SDL_RenderSetScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the drawing scale for the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which drawing scale should be queried."]
  #[doc = "  \\param scaleX A pointer filled in with the horizontal scaling factor"]
  #[doc = "  \\param scaleY A pointer filled in with the vertical scaling factor"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetScale()"]
  #[link_name = "\u{1}_SDL_RenderGetScale"]
  pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
  #[doc = "  \\brief Set the color used for drawing operations (Rect, Line and Clear)."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which drawing color should be set."]
  #[doc = "  \\param r The red value used to draw on the rendering target."]
  #[doc = "  \\param g The green value used to draw on the rendering target."]
  #[doc = "  \\param b The blue value used to draw on the rendering target."]
  #[doc = "  \\param a The alpha value used to draw on the rendering target, usually"]
  #[doc = "           ::SDL_ALPHA_OPAQUE (255)."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_SetRenderDrawColor"]
  pub fn SDL_SetRenderDrawColor(
    renderer: *mut SDL_Renderer,
    r: Uint8,
    g: Uint8,
    b: Uint8,
    a: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the color used for drawing operations (Rect, Line and Clear)."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which drawing color should be queried."]
  #[doc = "  \\param r A pointer to the red value used to draw on the rendering target."]
  #[doc = "  \\param g A pointer to the green value used to draw on the rendering target."]
  #[doc = "  \\param b A pointer to the blue value used to draw on the rendering target."]
  #[doc = "  \\param a A pointer to the alpha value used to draw on the rendering target,"]
  #[doc = "           usually ::SDL_ALPHA_OPAQUE (255)."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_GetRenderDrawColor"]
  pub fn SDL_GetRenderDrawColor(
    renderer: *mut SDL_Renderer,
    r: *mut Uint8,
    g: *mut Uint8,
    b: *mut Uint8,
    a: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the blend mode used for drawing operations (Fill and Line)."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which blend mode should be set."]
  #[doc = "  \\param blendMode ::SDL_BlendMode to use for blending."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\note If the blend mode is not supported, the closest supported mode is"]
  #[doc = "        chosen."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRenderDrawBlendMode()"]
  #[link_name = "\u{1}_SDL_SetRenderDrawBlendMode"]
  pub fn SDL_SetRenderDrawBlendMode(
    renderer: *mut SDL_Renderer,
    blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the blend mode used for drawing operations."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which blend mode should be queried."]
  #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetRenderDrawBlendMode()"]
  #[link_name = "\u{1}_SDL_GetRenderDrawBlendMode"]
  pub fn SDL_GetRenderDrawBlendMode(
    renderer: *mut SDL_Renderer,
    blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Clear the current rendering target with the drawing color"]
  #[doc = ""]
  #[doc = "  This function clears the entire rendering target, ignoring the viewport and"]
  #[doc = "  the clip rectangle."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderClear"]
  pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a point on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw a point."]
  #[doc = "  \\param x The x coordinate of the point."]
  #[doc = "  \\param y The y coordinate of the point."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderDrawPoint"]
  pub fn SDL_RenderDrawPoint(
    renderer: *mut SDL_Renderer,
    x: libc::c_int,
    y: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw multiple points on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw multiple points."]
  #[doc = "  \\param points The points to draw"]
  #[doc = "  \\param count The number of points to draw"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderDrawPoints"]
  pub fn SDL_RenderDrawPoints(
    renderer: *mut SDL_Renderer,
    points: *const SDL_Point,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a line on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw a line."]
  #[doc = "  \\param x1 The x coordinate of the start point."]
  #[doc = "  \\param y1 The y coordinate of the start point."]
  #[doc = "  \\param x2 The x coordinate of the end point."]
  #[doc = "  \\param y2 The y coordinate of the end point."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderDrawLine"]
  pub fn SDL_RenderDrawLine(
    renderer: *mut SDL_Renderer,
    x1: libc::c_int,
    y1: libc::c_int,
    x2: libc::c_int,
    y2: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a series of connected lines on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw multiple lines."]
  #[doc = "  \\param points The points along the lines"]
  #[doc = "  \\param count The number of points, drawing count-1 lines"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderDrawLines"]
  pub fn SDL_RenderDrawLines(
    renderer: *mut SDL_Renderer,
    points: *const SDL_Point,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a rectangle on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw a rectangle."]
  #[doc = "  \\param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderDrawRect"]
  pub fn SDL_RenderDrawRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw some number of rectangles on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw multiple rectangles."]
  #[doc = "  \\param rects A pointer to an array of destination rectangles."]
  #[doc = "  \\param count The number of rectangles."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderDrawRects"]
  pub fn SDL_RenderDrawRects(
    renderer: *mut SDL_Renderer,
    rects: *const SDL_Rect,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill a rectangle on the current rendering target with the drawing color."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should fill a rectangle."]
  #[doc = "  \\param rect A pointer to the destination rectangle, or NULL for the entire"]
  #[doc = "              rendering target."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderFillRect"]
  pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill some number of rectangles on the current rendering target with the drawing color."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should fill multiple rectangles."]
  #[doc = "  \\param rects A pointer to an array of destination rectangles."]
  #[doc = "  \\param count The number of rectangles."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderFillRects"]
  pub fn SDL_RenderFillRects(
    renderer: *mut SDL_Renderer,
    rects: *const SDL_Rect,
    count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Copy a portion of the texture to the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
  #[doc = "  \\param texture The source texture."]
  #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
  #[doc = "                   texture."]
  #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
  #[doc = "                   entire rendering target."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderCopy"]
  pub fn SDL_RenderCopy(
    renderer: *mut SDL_Renderer,
    texture: *mut SDL_Texture,
    srcrect: *const SDL_Rect,
    dstrect: *const SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
  #[doc = "  \\param texture The source texture."]
  #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
  #[doc = "                   texture."]
  #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
  #[doc = "                   entire rendering target."]
  #[doc = "  \\param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction"]
  #[doc = "  \\param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2)."]
  #[doc = "  \\param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[link_name = "\u{1}_SDL_RenderCopyEx"]
  pub fn SDL_RenderCopyEx(
    renderer: *mut SDL_Renderer,
    texture: *mut SDL_Texture,
    srcrect: *const SDL_Rect,
    dstrect: *const SDL_Rect,
    angle: f64,
    center: *const SDL_Point,
    flip: SDL_RendererFlip::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Read pixels from the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which pixels should be read."]
  #[doc = "  \\param rect   A pointer to the rectangle to read, or NULL for the entire"]
  #[doc = "                render target."]
  #[doc = "  \\param format The desired format of the pixel data, or 0 to use the format"]
  #[doc = "                of the rendering target"]
  #[doc = "  \\param pixels A pointer to be filled in with the pixel data"]
  #[doc = "  \\param pitch  The pitch of the pixels parameter."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if pixel reading is not supported."]
  #[doc = ""]
  #[doc = "  \\warning This is a very slow operation, and should not be used frequently."]
  #[link_name = "\u{1}_SDL_RenderReadPixels"]
  pub fn SDL_RenderReadPixels(
    renderer: *mut SDL_Renderer,
    rect: *const SDL_Rect,
    format: Uint32,
    pixels: *mut libc::c_void,
    pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Update the screen with rendering performed."]
  #[link_name = "\u{1}_SDL_RenderPresent"]
  pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
  #[doc = "  \\brief Destroy the specified texture."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateTexture()"]
  #[doc = "  \\sa SDL_CreateTextureFromSurface()"]
  #[link_name = "\u{1}_SDL_DestroyTexture"]
  pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
  #[doc = "  \\brief Destroy the rendering context for a window and free associated"]
  #[doc = "         textures."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  #[link_name = "\u{1}_SDL_DestroyRenderer"]
  pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
  #[doc = "  \\brief Bind the texture to the current OpenGL/ES/ES2 context for use with"]
  #[doc = "         OpenGL instructions."]
  #[doc = ""]
  #[doc = "  \\param texture  The SDL texture to bind"]
  #[doc = "  \\param texw     A pointer to a float that will be filled with the texture width"]
  #[doc = "  \\param texh     A pointer to a float that will be filled with the texture height"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the operation is not supported"]
  #[link_name = "\u{1}_SDL_GL_BindTexture"]
  pub fn SDL_GL_BindTexture(
    texture: *mut SDL_Texture,
    texw: *mut f32,
    texh: *mut f32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Unbind a texture from the current OpenGL/ES/ES2 context."]
  #[doc = ""]
  #[doc = "  \\param texture  The SDL texture to unbind"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the operation is not supported"]
  #[link_name = "\u{1}_SDL_GL_UnbindTexture"]
  pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the CAMetalLayer associated with the given Metal renderer"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer to query"]
  #[doc = ""]
  #[doc = "  \\return CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetMetalCommandEncoder()"]
  #[link_name = "\u{1}_SDL_RenderGetMetalLayer"]
  pub fn SDL_RenderGetMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Get the Metal command encoder for the current frame"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer to query"]
  #[doc = ""]
  #[doc = "  \\return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetMetalLayer()"]
  #[link_name = "\u{1}_SDL_RenderGetMetalCommandEncoder"]
  pub fn SDL_RenderGetMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
#[doc = "  \\brief SDL_sensor.h"]
#[doc = ""]
#[doc = "  In order to use these functions, SDL_Init() must have been called"]
#[doc = "  with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system"]
#[doc = "  for sensors, and load appropriate drivers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Sensor {
  _unused: [u8; 0],
}
pub type SDL_Sensor = _SDL_Sensor;
#[doc = " This is a unique ID for a sensor for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_SensorID = Sint32;
pub mod SDL_SensorType {
  pub type Type = i32;
  #[doc = "< Returned for an invalid sensor"]
  pub const SDL_SENSOR_INVALID: Type = -1;
  #[doc = "< Unknown sensor type"]
  pub const SDL_SENSOR_UNKNOWN: Type = 0;
  #[doc = "< Accelerometer"]
  pub const SDL_SENSOR_ACCEL: Type = 1;
  #[doc = "< Gyroscope"]
  pub const SDL_SENSOR_GYRO: Type = 2;
}
extern "C" {
  #[doc = "  \\brief Count the number of sensors attached to the system right now"]
  #[link_name = "\u{1}_SDL_NumSensors"]
  pub fn SDL_NumSensors() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the implementation dependent name of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor name, or NULL if device_index is out of range."]
  #[link_name = "\u{1}_SDL_SensorGetDeviceName"]
  pub fn SDL_SensorGetDeviceName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor type, or SDL_SENSOR_INVALID if device_index is out of range."]
  #[link_name = "\u{1}_SDL_SensorGetDeviceType"]
  pub fn SDL_SensorGetDeviceType(device_index: libc::c_int) -> SDL_SensorType::Type;
}
extern "C" {
  #[doc = "  \\brief Get the platform dependent type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor platform dependent type, or -1 if device_index is out of range."]
  #[link_name = "\u{1}_SDL_SensorGetDeviceNonPortableType"]
  pub fn SDL_SensorGetDeviceNonPortableType(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the instance ID of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor instance ID, or -1 if device_index is out of range."]
  #[link_name = "\u{1}_SDL_SensorGetDeviceInstanceID"]
  pub fn SDL_SensorGetDeviceInstanceID(device_index: libc::c_int) -> SDL_SensorID;
}
extern "C" {
  #[doc = "  \\brief Open a sensor for use."]
  #[doc = ""]
  #[doc = "  The index passed as an argument refers to the N'th sensor on the system."]
  #[doc = ""]
  #[doc = "  \\return A sensor identifier, or NULL if an error occurred."]
  #[link_name = "\u{1}_SDL_SensorOpen"]
  pub fn SDL_SensorOpen(device_index: libc::c_int) -> *mut SDL_Sensor;
}
extern "C" {
  #[doc = " Return the SDL_Sensor associated with an instance id."]
  #[link_name = "\u{1}_SDL_SensorFromInstanceID"]
  pub fn SDL_SensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
  #[doc = "  \\brief Get the implementation dependent name of a sensor."]
  #[doc = ""]
  #[doc = "  \\return The sensor name, or NULL if the sensor is NULL."]
  #[link_name = "\u{1}_SDL_SensorGetName"]
  pub fn SDL_SensorGetName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL."]
  #[link_name = "\u{1}_SDL_SensorGetType"]
  pub fn SDL_SensorGetType(sensor: *mut SDL_Sensor) -> SDL_SensorType::Type;
}
extern "C" {
  #[doc = "  \\brief Get the platform dependent type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor platform dependent type, or -1 if the sensor is NULL."]
  #[link_name = "\u{1}_SDL_SensorGetNonPortableType"]
  pub fn SDL_SensorGetNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the instance ID of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor instance ID, or -1 if the sensor is NULL."]
  #[link_name = "\u{1}_SDL_SensorGetInstanceID"]
  pub fn SDL_SensorGetInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
  #[doc = "  Get the current state of an opened sensor."]
  #[doc = ""]
  #[doc = "  The number of values and interpretation of the data is sensor dependent."]
  #[doc = ""]
  #[doc = "  \\param sensor The sensor to query"]
  #[doc = "  \\param data A pointer filled with the current sensor state"]
  #[doc = "  \\param num_values The number of values to write to data"]
  #[doc = ""]
  #[doc = "  \\return 0 or -1 if an error occurred."]
  #[link_name = "\u{1}_SDL_SensorGetData"]
  pub fn SDL_SensorGetData(
    sensor: *mut SDL_Sensor,
    data: *mut f32,
    num_values: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Close a sensor previously opened with SDL_SensorOpen()"]
  #[link_name = "\u{1}_SDL_SensorClose"]
  pub fn SDL_SensorClose(sensor: *mut SDL_Sensor);
}
extern "C" {
  #[doc = "  Update the current state of the open sensors."]
  #[doc = ""]
  #[doc = "  This is called automatically by the event loop if sensor events are enabled."]
  #[doc = ""]
  #[doc = "  This needs to be called from the thread that initialized the sensor subsystem."]
  #[link_name = "\u{1}_SDL_SensorUpdate"]
  pub fn SDL_SensorUpdate();
}
extern "C" {
  #[doc = "  \\brief Create a window that can be shaped with the specified position, dimensions, and flags."]
  #[doc = ""]
  #[doc = "  \\param title The title of the window, in UTF-8 encoding."]
  #[doc = "  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param w     The width of the window."]
  #[doc = "  \\param h     The height of the window."]
  #[doc = "  \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:"]
  #[doc = "               ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,"]
  #[doc = "               ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,"]
  #[doc = "               ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,"]
  #[doc = "       ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset."]
  #[doc = ""]
  #[doc = "  \\return The window created, or NULL if window creation failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_DestroyWindow()"]
  #[link_name = "\u{1}_SDL_CreateShapedWindow"]
  pub fn SDL_CreateShapedWindow(
    title: *const libc::c_char,
    x: libc::c_uint,
    y: libc::c_uint,
    w: libc::c_uint,
    h: libc::c_uint,
    flags: Uint32,
  ) -> *mut SDL_Window;
}
extern "C" {
  #[doc = " \\brief Return whether the given window is a shaped window."]
  #[doc = ""]
  #[doc = " \\param window The window to query for being shaped."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL."]
  #[doc = ""]
  #[doc = " \\sa SDL_CreateShapedWindow"]
  #[link_name = "\u{1}_SDL_IsShapedWindow"]
  pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool::Type;
}
pub mod WindowShapeMode {
  #[doc = " \\brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union."]
  pub type Type = u32;
  #[doc = " \\brief The default mode, a binarized alpha cutoff of 1."]
  pub const ShapeModeDefault: Type = 0;
  #[doc = " \\brief A binarized alpha cutoff with a given integer value."]
  pub const ShapeModeBinarizeAlpha: Type = 1;
  #[doc = " \\brief A binarized alpha cutoff with a given integer value, but with the opposite comparison."]
  pub const ShapeModeReverseBinarizeAlpha: Type = 2;
  #[doc = " \\brief A color key is applied."]
  pub const ShapeModeColorKey: Type = 3;
}
#[doc = " \\brief A union containing parameters for shaped windows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
  #[doc = " \\brief A cutoff alpha value for binarization of the window shape's alpha channel."]
  pub binarizationCutoff: Uint8,
  pub colorKey: SDL_Color,
  _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowShapeParams>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_WindowShapeParams))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowShapeParams>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_WindowShapeParams>())).binarizationCutoff as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeParams),
      "::",
      stringify!(binarizationCutoff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeParams>())).colorKey as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeParams),
      "::",
      stringify!(colorKey)
    )
  );
}
impl Default for SDL_WindowShapeParams {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_WindowShapeParams {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_WindowShapeParams {{ union }}")
  }
}
#[doc = " \\brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
  #[doc = " \\brief The mode of these window-shape parameters."]
  pub mode: WindowShapeMode::Type,
  #[doc = " \\brief Window-shape parameters."]
  pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowShapeMode>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_WindowShapeMode))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowShapeMode>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).mode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeMode),
      "::",
      stringify!(mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).parameters as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeMode),
      "::",
      stringify!(parameters)
    )
  );
}
impl Default for SDL_WindowShapeMode {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_WindowShapeMode {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_WindowShapeMode {{ mode: {:?}, parameters: {:?} }}",
      self.mode, self.parameters
    )
  }
}
extern "C" {
  #[doc = " \\brief Set the shape and parameters of a shaped window."]
  #[doc = ""]
  #[doc = " \\param window The shaped window whose parameters should be set."]
  #[doc = " \\param shape A surface encoding the desired shape for the window."]
  #[doc = " \\param shape_mode The parameters to set for the shaped window."]
  #[doc = ""]
  #[doc = " \\return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW"]
  #[doc = "           if the SDL_Window given does not reference a valid shaped window."]
  #[doc = ""]
  #[doc = " \\sa SDL_WindowShapeMode"]
  #[doc = " \\sa SDL_GetShapedWindowMode."]
  #[link_name = "\u{1}_SDL_SetWindowShape"]
  pub fn SDL_SetWindowShape(
    window: *mut SDL_Window,
    shape: *mut SDL_Surface,
    shape_mode: *mut SDL_WindowShapeMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get the shape parameters of a shaped window."]
  #[doc = ""]
  #[doc = " \\param window The shaped window whose parameters should be retrieved."]
  #[doc = " \\param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape."]
  #[doc = ""]
  #[doc = " \\return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode"]
  #[doc = "           data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if"]
  #[doc = "           the SDL_Window given is a shapeable window currently lacking a shape."]
  #[doc = ""]
  #[doc = " \\sa SDL_WindowShapeMode"]
  #[doc = " \\sa SDL_SetWindowShape"]
  #[link_name = "\u{1}_SDL_GetShapedWindowMode"]
  pub fn SDL_GetShapedWindowMode(
    window: *mut SDL_Window,
    shape_mode: *mut SDL_WindowShapeMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "\\brief Return true if the current device is a tablet."]
  #[link_name = "\u{1}_SDL_IsTablet"]
  pub fn SDL_IsTablet() -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Get the number of milliseconds since the SDL library initialization."]
  #[doc = ""]
  #[doc = " \\note This value wraps if the program runs for more than ~49 days."]
  #[link_name = "\u{1}_SDL_GetTicks"]
  pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
  #[doc = " \\brief Get the current value of the high resolution counter"]
  #[link_name = "\u{1}_SDL_GetPerformanceCounter"]
  pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
  #[doc = " \\brief Get the count per second of the high resolution counter"]
  #[link_name = "\u{1}_SDL_GetPerformanceFrequency"]
  pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
  #[doc = " \\brief Wait a specified number of milliseconds before returning."]
  #[link_name = "\u{1}_SDL_Delay"]
  pub fn SDL_Delay(ms: Uint32);
}
#[doc = "  Function prototype for the timer callback function."]
#[doc = ""]
#[doc = "  The callback function is passed the current timer interval and returns"]
#[doc = "  the next timer interval.  If the returned value is the same as the one"]
#[doc = "  passed in, the periodic alarm continues, otherwise a new alarm is"]
#[doc = "  scheduled.  If the callback returns 0, the periodic alarm is cancelled."]
pub type SDL_TimerCallback = ::core::option::Option<
  unsafe extern "C" fn(interval: Uint32, param: *mut libc::c_void) -> Uint32,
>;
#[doc = " Definition of the timer ID type."]
pub type SDL_TimerID = libc::c_int;
extern "C" {
  #[doc = " \\brief Add a new timer to the pool of timers already running."]
  #[doc = ""]
  #[doc = " \\return A timer ID, or 0 when an error occurs."]
  #[link_name = "\u{1}_SDL_AddTimer"]
  pub fn SDL_AddTimer(
    interval: Uint32,
    callback: SDL_TimerCallback,
    param: *mut libc::c_void,
  ) -> SDL_TimerID;
}
extern "C" {
  #[doc = " \\brief Remove a timer knowing its ID."]
  #[doc = ""]
  #[doc = " \\return A boolean value indicating success or failure."]
  #[doc = ""]
  #[doc = " \\warning It is not safe to remove a timer multiple times."]
  #[link_name = "\u{1}_SDL_RemoveTimer"]
  pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool::Type;
}
#[doc = "  \\brief Information the version of SDL in use."]
#[doc = ""]
#[doc = "  Represents the library's version as three levels: major revision"]
#[doc = "  (increments with massive changes, additions, and enhancements),"]
#[doc = "  minor revision (increments with backwards-compatible changes to the"]
#[doc = "  major revision), and patchlevel (increments with fixes to the minor"]
#[doc = "  revision)."]
#[doc = ""]
#[doc = "  \\sa SDL_VERSION"]
#[doc = "  \\sa SDL_GetVersion"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_version {
  #[doc = "< major version"]
  pub major: Uint8,
  #[doc = "< minor version"]
  pub minor: Uint8,
  #[doc = "< update version"]
  pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
  assert_eq!(
    ::core::mem::size_of::<SDL_version>(),
    3usize,
    concat!("Size of: ", stringify!(SDL_version))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_version>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_version))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).major as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(major)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).minor as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(minor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).patch as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(patch)
    )
  );
}
extern "C" {
  #[doc = "  \\brief Get the version of SDL that is linked against your program."]
  #[doc = ""]
  #[doc = "  If you are linking to SDL dynamically, then it is possible that the"]
  #[doc = "  current version will be different than the version you compiled against."]
  #[doc = "  This function returns the current version, while SDL_VERSION() is a"]
  #[doc = "  macro that tells you what version you compiled with."]
  #[doc = ""]
  #[doc = "  \\code"]
  #[doc = "  SDL_version compiled;"]
  #[doc = "  SDL_version linked;"]
  #[doc = ""]
  #[doc = "  SDL_VERSION(&compiled);"]
  #[doc = "  SDL_GetVersion(&linked);"]
  #[doc = "  printf(\"We compiled against SDL version %d.%d.%d ...\\n\","]
  #[doc = "         compiled.major, compiled.minor, compiled.patch);"]
  #[doc = "  printf(\"But we linked against SDL version %d.%d.%d.\\n\","]
  #[doc = "         linked.major, linked.minor, linked.patch);"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  This function may be called safely at any time, even before SDL_Init()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_VERSION"]
  #[link_name = "\u{1}_SDL_GetVersion"]
  pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
  #[doc = "  \\brief Get the code revision of SDL that is linked against your program."]
  #[doc = ""]
  #[doc = "  Returns an arbitrary string (a hash value) uniquely identifying the"]
  #[doc = "  exact revision of the SDL library in use, and is only useful in comparing"]
  #[doc = "  against other revisions. It is NOT an incrementing number."]
  #[link_name = "\u{1}_SDL_GetRevision"]
  pub fn SDL_GetRevision() -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the revision number of SDL that is linked against your program."]
  #[doc = ""]
  #[doc = "  Returns a number uniquely identifying the exact revision of the SDL"]
  #[doc = "  library in use. It is an incrementing number based on commits to"]
  #[doc = "  hg.libsdl.org."]
  #[link_name = "\u{1}_SDL_GetRevisionNumber"]
  pub fn SDL_GetRevisionNumber() -> libc::c_int;
}
extern "C" {
  #[doc = "  This function initializes  the subsystems specified by \\c flags"]
  #[link_name = "\u{1}_SDL_Init"]
  pub fn SDL_Init(flags: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  This function initializes specific SDL subsystems"]
  #[doc = ""]
  #[doc = "  Subsystem initialization is ref-counted, you must call"]
  #[doc = "  SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly"]
  #[doc = "  shutdown a subsystem manually (or call SDL_Quit() to force shutdown)."]
  #[doc = "  If a subsystem is already loaded then this call will"]
  #[doc = "  increase the ref-count and return."]
  #[link_name = "\u{1}_SDL_InitSubSystem"]
  pub fn SDL_InitSubSystem(flags: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  This function cleans up specific SDL subsystems"]
  #[link_name = "\u{1}_SDL_QuitSubSystem"]
  pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
  #[doc = "  This function returns a mask of the specified subsystems which have"]
  #[doc = "  previously been initialized."]
  #[doc = ""]
  #[doc = "  If \\c flags is 0, it returns a mask of all initialized subsystems."]
  #[link_name = "\u{1}_SDL_WasInit"]
  pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
  #[doc = "  This function cleans up all initialized subsystems. You should"]
  #[doc = "  call it upon all exit conditions."]
  #[link_name = "\u{1}_SDL_Quit"]
  pub fn SDL_Quit();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __va_list_tag {
  pub gp_offset: libc::c_uint,
  pub fp_offset: libc::c_uint,
  pub overflow_arg_area: *mut libc::c_void,
  pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
  assert_eq!(
    ::core::mem::size_of::<__va_list_tag>(),
    24usize,
    concat!("Size of: ", stringify!(__va_list_tag))
  );
  assert_eq!(
    ::core::mem::align_of::<__va_list_tag>(),
    8usize,
    concat!("Alignment of ", stringify!(__va_list_tag))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(gp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(fp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(overflow_arg_area)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(reg_save_area)
    )
  );
}
impl Default for __va_list_tag {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "< Private"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_BlitMap {
  pub _address: u8,
}