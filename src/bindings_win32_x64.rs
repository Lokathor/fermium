/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  storage: Storage,
  align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  #[inline]
  pub fn new(storage: Storage) -> Self {
    Self { storage, align: [] }
  }
  #[inline]
  pub fn get_bit(&self, index: usize) -> bool {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = self.storage.as_ref()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    byte & mask == mask
  }
  #[inline]
  pub fn set_bit(&mut self, index: usize, val: bool) {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = &mut self.storage.as_mut()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    if val {
      *byte |= mask;
    } else {
      *byte &= !mask;
    }
  }
  #[inline]
  pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if self.get_bit(i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      self.set_bit(index + bit_offset, val_bit_is_set);
    }
  }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
  #[inline]
  pub fn new() -> Self {
    __IncompleteArrayField(::core::marker::PhantomData, [])
  }
  #[inline]
  pub unsafe fn as_ptr(&self) -> *const T {
    ::core::mem::transmute(self)
  }
  #[inline]
  pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
    ::core::mem::transmute(self)
  }
  #[inline]
  pub unsafe fn as_slice(&self, len: usize) -> &[T] {
    ::core::slice::from_raw_parts(self.as_ptr(), len)
  }
  #[inline]
  pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
    ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
  }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
  fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    fmt.write_str("__IncompleteArrayField")
  }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
  #[inline]
  fn clone(&self) -> Self {
    Self::new()
  }
}
pub const HAVE_WINAPIFAMILY_H: u32 = 1;
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY: u32 = 100;
pub const __WINDOWS__: u32 = 1;
pub const __WIN32__: u32 = 1;
pub const SIZEOF_VOIDP: u32 = 8;
pub const HAVE_DDRAW_H: u32 = 1;
pub const HAVE_DINPUT_H: u32 = 1;
pub const HAVE_DSOUND_H: u32 = 1;
pub const HAVE_DXGI_H: u32 = 1;
pub const HAVE_XINPUT_H: u32 = 1;
pub const HAVE_MMDEVICEAPI_H: u32 = 1;
pub const HAVE_AUDIOCLIENT_H: u32 = 1;
pub const HAVE_ENDPOINTVOLUME_H: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_STDDEF_H: u32 = 1;
pub const SDL_AUDIO_DRIVER_WASAPI: u32 = 1;
pub const SDL_AUDIO_DRIVER_DSOUND: u32 = 1;
pub const SDL_AUDIO_DRIVER_WINMM: u32 = 1;
pub const SDL_AUDIO_DRIVER_DISK: u32 = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_JOYSTICK_DINPUT: u32 = 1;
pub const SDL_JOYSTICK_XINPUT: u32 = 1;
pub const SDL_JOYSTICK_HIDAPI: u32 = 1;
pub const SDL_HAPTIC_DINPUT: u32 = 1;
pub const SDL_HAPTIC_XINPUT: u32 = 1;
pub const SDL_SENSOR_DUMMY: u32 = 1;
pub const SDL_LOADSO_WINDOWS: u32 = 1;
pub const SDL_THREAD_WINDOWS: u32 = 1;
pub const SDL_TIMER_WINDOWS: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_VIDEO_DRIVER_WINDOWS: u32 = 1;
pub const SDL_VIDEO_RENDER_D3D: u32 = 1;
pub const SDL_VIDEO_RENDER_D3D11: u32 = 0;
pub const SDL_VIDEO_OPENGL: u32 = 1;
pub const SDL_VIDEO_OPENGL_WGL: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL: u32 = 1;
pub const SDL_VIDEO_RENDER_OGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL_ES2: u32 = 1;
pub const SDL_VIDEO_OPENGL_EGL: u32 = 1;
pub const SDL_VIDEO_VULKAN: u32 = 1;
pub const SDL_POWER_WINDOWS: u32 = 1;
pub const SDL_FILESYSTEM_WINDOWS: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const SDL_PRIs64: &'static [u8; 5usize] = b"I64d\0";
pub const SDL_PRIu64: &'static [u8; 5usize] = b"I64u\0";
pub const SDL_PRIx64: &'static [u8; 5usize] = b"I64x\0";
pub const SDL_PRIX64: &'static [u8; 5usize] = b"I64X\0";
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const M_PI: f64 = 3.141592653589793;
pub const SDL_ASSERT_LEVEL: u32 = 1;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 0;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _P_WAIT: u32 = 0;
pub const _P_NOWAIT: u32 = 1;
pub const _OLD_P_OVERLAY: u32 = 2;
pub const _P_NOWAITO: u32 = 3;
pub const _P_DETACH: u32 = 4;
pub const _P_OVERLAY: u32 = 2;
pub const _WAIT_CHILD: u32 = 0;
pub const _WAIT_GRANDCHILD: u32 = 1;
pub const P_WAIT: u32 = 0;
pub const P_NOWAIT: u32 = 1;
pub const P_OVERLAY: u32 = 2;
pub const OLD_P_OVERLAY: u32 = 2;
pub const P_NOWAITO: u32 = 3;
pub const P_DETACH: u32 = 4;
pub const WAIT_CHILD: u32 = 0;
pub const WAIT_GRANDCHILD: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_AUDIOCVT_MAX_FILTERS: u32 = 9;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
  b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
  b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &'static [u8; 28usize] =
  b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &'static [u8; 29usize] =
  b"SDL_RENDER_LOGICAL_SIZE_MODE\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
  b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &'static [u8; 26usize] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &'static [u8; 39usize] =
  b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &'static [u8; 44usize] =
  b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &'static [u8; 29usize] =
  b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &'static [u8; 35usize] =
  b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &'static [u8; 31usize] =
  b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &'static [u8; 28usize] =
  b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &'static [u8; 30usize] =
  b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &'static [u8; 29usize] =
  b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &'static [u8; 31usize] =
  b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
  b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &'static [u8; 29usize] =
  b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &'static [u8; 23usize] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
  b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &'static [u8; 34usize] =
  b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &'static [u8; 35usize] =
  b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &'static [u8; 28usize] =
  b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
  b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &'static [u8; 26usize] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &'static [u8; 36usize] =
  b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &'static [u8; 34usize] =
  b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &'static [u8; 41usize] =
  b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
  b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &'static [u8; 20usize] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &'static [u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &'static [u8; 31usize] =
  b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &'static [u8; 26usize] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &'static [u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &'static [u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_ENABLE_STEAM_CONTROLLERS: &'static [u8; 29usize] =
  b"SDL_ENABLE_STEAM_CONTROLLERS\0";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &'static [u8; 34usize] =
  b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &'static [u8; 27usize] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &'static [u8; 22usize] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize] =
  b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
  b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &'static [u8; 29usize] =
  b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &'static [u8; 31usize] =
  b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &'static [u8; 29usize] =
  b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
  b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &'static [u8; 23usize] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION: &'static [u8; 44usize] =
  b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION: &'static [u8; 45usize] =
  b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &'static [u8; 25usize] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_ANDROID_SEPARATE_MOUSE_AND_TOUCH: &'static [u8; 37usize] =
  b"SDL_ANDROID_SEPARATE_MOUSE_AND_TOUCH\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &'static [u8; 29usize] =
  b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &'static [u8; 25usize] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &'static [u8; 32usize] =
  b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &'static [u8; 23usize] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &'static [u8; 31usize] =
  b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &'static [u8; 27usize] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &'static [u8; 34usize] =
  b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &'static [u8; 20usize] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &'static [u8; 24usize] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &'static [u8; 21usize] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &'static [u8; 26usize] = b"SDL_AUDIO_RESAMPLING_MODE\0";
pub const SDL_HINT_AUDIO_CATEGORY: &'static [u8; 19usize] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 9;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 62001;
pub const _WIN32_WINNT_NT4: u32 = 1024;
pub const _WIN32_WINNT_WIN2K: u32 = 1280;
pub const _WIN32_WINNT_WINXP: u32 = 1281;
pub const _WIN32_WINNT_WS03: u32 = 1282;
pub const _WIN32_WINNT_WIN6: u32 = 1536;
pub const _WIN32_WINNT_VISTA: u32 = 1536;
pub const _WIN32_WINNT_WS08: u32 = 1536;
pub const _WIN32_WINNT_LONGHORN: u32 = 1536;
pub const _WIN32_WINNT_WIN7: u32 = 1537;
pub const _WIN32_WINNT_WIN8: u32 = 1538;
pub const _WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_WINNT_WIN10: u32 = 2560;
pub const _WIN32_IE_IE20: u32 = 512;
pub const _WIN32_IE_IE30: u32 = 768;
pub const _WIN32_IE_IE302: u32 = 770;
pub const _WIN32_IE_IE40: u32 = 1024;
pub const _WIN32_IE_IE401: u32 = 1025;
pub const _WIN32_IE_IE50: u32 = 1280;
pub const _WIN32_IE_IE501: u32 = 1281;
pub const _WIN32_IE_IE55: u32 = 1360;
pub const _WIN32_IE_IE60: u32 = 1536;
pub const _WIN32_IE_IE60SP1: u32 = 1537;
pub const _WIN32_IE_IE60SP2: u32 = 1539;
pub const _WIN32_IE_IE70: u32 = 1792;
pub const _WIN32_IE_IE80: u32 = 2048;
pub const _WIN32_IE_IE90: u32 = 2304;
pub const _WIN32_IE_IE100: u32 = 2560;
pub const _WIN32_IE_IE110: u32 = 2560;
pub const _WIN32_IE_NT4: u32 = 512;
pub const _WIN32_IE_NT4SP1: u32 = 512;
pub const _WIN32_IE_NT4SP2: u32 = 512;
pub const _WIN32_IE_NT4SP3: u32 = 770;
pub const _WIN32_IE_NT4SP4: u32 = 1025;
pub const _WIN32_IE_NT4SP5: u32 = 1025;
pub const _WIN32_IE_NT4SP6: u32 = 1280;
pub const _WIN32_IE_WIN98: u32 = 1025;
pub const _WIN32_IE_WIN98SE: u32 = 1280;
pub const _WIN32_IE_WINME: u32 = 1360;
pub const _WIN32_IE_WIN2K: u32 = 1281;
pub const _WIN32_IE_WIN2KSP1: u32 = 1281;
pub const _WIN32_IE_WIN2KSP2: u32 = 1281;
pub const _WIN32_IE_WIN2KSP3: u32 = 1281;
pub const _WIN32_IE_WIN2KSP4: u32 = 1281;
pub const _WIN32_IE_XP: u32 = 1536;
pub const _WIN32_IE_XPSP1: u32 = 1537;
pub const _WIN32_IE_XPSP2: u32 = 1539;
pub const _WIN32_IE_WS03: u32 = 1538;
pub const _WIN32_IE_WS03SP1: u32 = 1539;
pub const _WIN32_IE_WIN6: u32 = 1792;
pub const _WIN32_IE_LONGHORN: u32 = 1792;
pub const _WIN32_IE_WIN7: u32 = 2048;
pub const _WIN32_IE_WIN8: u32 = 2560;
pub const _WIN32_IE_WINBLUE: u32 = 2560;
pub const _WIN32_IE_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_IE_WIN10: u32 = 2560;
pub const NTDDI_WIN2K: u32 = 83886080;
pub const NTDDI_WIN2KSP1: u32 = 83886336;
pub const NTDDI_WIN2KSP2: u32 = 83886592;
pub const NTDDI_WIN2KSP3: u32 = 83886848;
pub const NTDDI_WIN2KSP4: u32 = 83887104;
pub const NTDDI_WINXP: u32 = 83951616;
pub const NTDDI_WINXPSP1: u32 = 83951872;
pub const NTDDI_WINXPSP2: u32 = 83952128;
pub const NTDDI_WINXPSP3: u32 = 83952384;
pub const NTDDI_WINXPSP4: u32 = 83952640;
pub const NTDDI_WS03: u32 = 84017152;
pub const NTDDI_WS03SP1: u32 = 84017408;
pub const NTDDI_WS03SP2: u32 = 84017664;
pub const NTDDI_WS03SP3: u32 = 84017920;
pub const NTDDI_WS03SP4: u32 = 84018176;
pub const NTDDI_WIN6: u32 = 100663296;
pub const NTDDI_WIN6SP1: u32 = 100663552;
pub const NTDDI_WIN6SP2: u32 = 100663808;
pub const NTDDI_WIN6SP3: u32 = 100664064;
pub const NTDDI_WIN6SP4: u32 = 100664320;
pub const NTDDI_VISTA: u32 = 100663296;
pub const NTDDI_VISTASP1: u32 = 100663552;
pub const NTDDI_VISTASP2: u32 = 100663808;
pub const NTDDI_VISTASP3: u32 = 100664064;
pub const NTDDI_VISTASP4: u32 = 100664320;
pub const NTDDI_LONGHORN: u32 = 100663296;
pub const NTDDI_WS08: u32 = 100663552;
pub const NTDDI_WS08SP2: u32 = 100663808;
pub const NTDDI_WS08SP3: u32 = 100664064;
pub const NTDDI_WS08SP4: u32 = 100664320;
pub const NTDDI_WIN7: u32 = 100728832;
pub const NTDDI_WIN8: u32 = 100794368;
pub const NTDDI_WINBLUE: u32 = 100859904;
pub const NTDDI_WINTHRESHOLD: u32 = 167772160;
pub const NTDDI_WIN10: u32 = 167772160;
pub const NTDDI_WIN10_TH2: u32 = 167772161;
pub const NTDDI_WIN10_RS1: u32 = 167772162;
pub const NTDDI_WIN10_RS2: u32 = 167772163;
pub const NTDDI_WIN10_RS3: u32 = 167772164;
pub const WDK_NTDDI_VERSION: u32 = 167772164;
pub const OSVERSION_MASK: u32 = 4294901760;
pub const SPVERSION_MASK: u32 = 65280;
pub const SUBVERSION_MASK: u32 = 255;
pub const _WIN32_WINNT: u32 = 2560;
pub const NTDDI_VERSION: u32 = 167772164;
pub const WINVER: u32 = 2560;
pub const _WIN32_IE: u32 = 2560;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const __SAL_H_FULL_VER: u32 = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: u32 = 1;
pub const __drv_typeConst: u32 = 0;
pub const __drv_typeCond: u32 = 1;
pub const __drv_typeBitset: u32 = 2;
pub const __drv_typeExpr: u32 = 3;
pub const STRICT: u32 = 1;
pub const MAX_PATH: u32 = 260;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const ANYSIZE_ARRAY: u32 = 1;
pub const DISPATCH_LEVEL: u32 = 2;
pub const APC_LEVEL: u32 = 1;
pub const PASSIVE_LEVEL: u32 = 0;
pub const HIGH_LEVEL: u32 = 15;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const PRAGMA_DEPRECATED_DDK: u32 = 0;
pub const UCSCHAR_INVALID_CHARACTER: u32 = 4294967295;
pub const MIN_UCSCHAR: u32 = 0;
pub const MAX_UCSCHAR: u32 = 1114111;
pub const ALL_PROCESSOR_GROUPS: u32 = 65535;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64;
pub const MAXIMUM_PROCESSORS: u32 = 64;
pub const APPLICATION_ERROR_MASK: u32 = 536870912;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINCHAR: u32 = 128;
pub const MAXCHAR: u32 = 127;
pub const MINSHORT: u32 = 32768;
pub const MAXSHORT: u32 = 32767;
pub const MINLONG: u32 = 2147483648;
pub const MAXLONG: u32 = 2147483647;
pub const MAXBYTE: u32 = 255;
pub const MAXWORD: u32 = 65535;
pub const MAXDWORD: u32 = 4294967295;
pub const VER_SERVER_NT: u32 = 2147483648;
pub const VER_WORKSTATION_NT: u32 = 1073741824;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1;
pub const VER_SUITE_ENTERPRISE: u32 = 2;
pub const VER_SUITE_BACKOFFICE: u32 = 4;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8;
pub const VER_SUITE_TERMINAL: u32 = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64;
pub const VER_SUITE_DATACENTER: u32 = 128;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256;
pub const VER_SUITE_PERSONAL: u32 = 512;
pub const VER_SUITE_BLADE: u32 = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384;
pub const VER_SUITE_WH_SERVER: u32 = 32768;
pub const PRODUCT_UNDEFINED: u32 = 0;
pub const PRODUCT_ULTIMATE: u32 = 1;
pub const PRODUCT_HOME_BASIC: u32 = 2;
pub const PRODUCT_HOME_PREMIUM: u32 = 3;
pub const PRODUCT_ENTERPRISE: u32 = 4;
pub const PRODUCT_HOME_BASIC_N: u32 = 5;
pub const PRODUCT_BUSINESS: u32 = 6;
pub const PRODUCT_STANDARD_SERVER: u32 = 7;
pub const PRODUCT_DATACENTER_SERVER: u32 = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: u32 = 9;
pub const PRODUCT_ENTERPRISE_SERVER: u32 = 10;
pub const PRODUCT_STARTER: u32 = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: u32 = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: u32 = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: u32 = 15;
pub const PRODUCT_BUSINESS_N: u32 = 16;
pub const PRODUCT_WEB_SERVER: u32 = 17;
pub const PRODUCT_CLUSTER_SERVER: u32 = 18;
pub const PRODUCT_HOME_SERVER: u32 = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: u32 = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: u32 = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: u32 = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: u32 = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: u32 = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: u32 = 25;
pub const PRODUCT_HOME_PREMIUM_N: u32 = 26;
pub const PRODUCT_ENTERPRISE_N: u32 = 27;
pub const PRODUCT_ULTIMATE_N: u32 = 28;
pub const PRODUCT_WEB_SERVER_CORE: u32 = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: u32 = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: u32 = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: u32 = 32;
pub const PRODUCT_SERVER_FOUNDATION: u32 = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: u32 = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: u32 = 35;
pub const PRODUCT_STANDARD_SERVER_V: u32 = 36;
pub const PRODUCT_DATACENTER_SERVER_V: u32 = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: u32 = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: u32 = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: u32 = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: u32 = 41;
pub const PRODUCT_HYPERV: u32 = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: u32 = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: u32 = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: u32 = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: u32 = 46;
pub const PRODUCT_STARTER_N: u32 = 47;
pub const PRODUCT_PROFESSIONAL: u32 = 48;
pub const PRODUCT_PROFESSIONAL_N: u32 = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: u32 = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: u32 = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: u32 = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: u32 = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: u32 = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: u32 = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: u32 = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: u32 = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: u32 = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: u32 = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: u32 = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: u32 = 63;
pub const PRODUCT_CLUSTER_SERVER_V: u32 = 64;
pub const PRODUCT_EMBEDDED: u32 = 65;
pub const PRODUCT_STARTER_E: u32 = 66;
pub const PRODUCT_HOME_BASIC_E: u32 = 67;
pub const PRODUCT_HOME_PREMIUM_E: u32 = 68;
pub const PRODUCT_PROFESSIONAL_E: u32 = 69;
pub const PRODUCT_ENTERPRISE_E: u32 = 70;
pub const PRODUCT_ULTIMATE_E: u32 = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: u32 = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: u32 = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: u32 = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: u32 = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: u32 = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: u32 = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86;
pub const PRODUCT_THINPC: u32 = 87;
pub const PRODUCT_EMBEDDED_A: u32 = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89;
pub const PRODUCT_EMBEDDED_E: u32 = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: u32 = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: u32 = 96;
pub const PRODUCT_CORE_ARM: u32 = 97;
pub const PRODUCT_CORE_N: u32 = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: u32 = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: u32 = 100;
pub const PRODUCT_CORE: u32 = 101;
pub const PRODUCT_PROFESSIONAL_WMC: u32 = 103;
pub const PRODUCT_MOBILE_CORE: u32 = 104;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108;
pub const PRODUCT_NANO_SERVER: u32 = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110;
pub const PRODUCT_CORE_CONNECTED: u32 = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116;
pub const PRODUCT_CONNECTED_CAR: u32 = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118;
pub const PRODUCT_PPI_PRO: u32 = 119;
pub const PRODUCT_ARM64_SERVER: u32 = 120;
pub const PRODUCT_EDUCATION: u32 = 121;
pub const PRODUCT_EDUCATION_N: u32 = 122;
pub const PRODUCT_IOTUAP: u32 = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124;
pub const PRODUCT_ENTERPRISE_S: u32 = 125;
pub const PRODUCT_ENTERPRISE_S_N: u32 = 126;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: u32 = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: u32 = 130;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138;
pub const PRODUCT_PRO_CHINA: u32 = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: u32 = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: u32 = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148;
pub const PRODUCT_UTILITY_VM: u32 = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160;
pub const PRODUCT_PRO_WORKSTATION: u32 = 161;
pub const PRODUCT_PRO_WORKSTATION_N: u32 = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169;
pub const PRODUCT_ENTERPRISEG: u32 = 171;
pub const PRODUCT_ENTERPRISEGN: u32 = 172;
pub const PRODUCT_SERVERRDSH: u32 = 175;
pub const PRODUCT_CLOUD: u32 = 178;
pub const PRODUCT_CLOUDN: u32 = 179;
pub const PRODUCT_UNLICENSED: u32 = 2882382797;
pub const LANG_NEUTRAL: u32 = 0;
pub const LANG_INVARIANT: u32 = 127;
pub const LANG_AFRIKAANS: u32 = 54;
pub const LANG_ALBANIAN: u32 = 28;
pub const LANG_ALSATIAN: u32 = 132;
pub const LANG_AMHARIC: u32 = 94;
pub const LANG_ARABIC: u32 = 1;
pub const LANG_ARMENIAN: u32 = 43;
pub const LANG_ASSAMESE: u32 = 77;
pub const LANG_AZERI: u32 = 44;
pub const LANG_AZERBAIJANI: u32 = 44;
pub const LANG_BANGLA: u32 = 69;
pub const LANG_BASHKIR: u32 = 109;
pub const LANG_BASQUE: u32 = 45;
pub const LANG_BELARUSIAN: u32 = 35;
pub const LANG_BENGALI: u32 = 69;
pub const LANG_BRETON: u32 = 126;
pub const LANG_BOSNIAN: u32 = 26;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746;
pub const LANG_BULGARIAN: u32 = 2;
pub const LANG_CATALAN: u32 = 3;
pub const LANG_CENTRAL_KURDISH: u32 = 146;
pub const LANG_CHEROKEE: u32 = 92;
pub const LANG_CHINESE: u32 = 4;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748;
pub const LANG_CORSICAN: u32 = 131;
pub const LANG_CROATIAN: u32 = 26;
pub const LANG_CZECH: u32 = 5;
pub const LANG_DANISH: u32 = 6;
pub const LANG_DARI: u32 = 140;
pub const LANG_DIVEHI: u32 = 101;
pub const LANG_DUTCH: u32 = 19;
pub const LANG_ENGLISH: u32 = 9;
pub const LANG_ESTONIAN: u32 = 37;
pub const LANG_FAEROESE: u32 = 56;
pub const LANG_FARSI: u32 = 41;
pub const LANG_FILIPINO: u32 = 100;
pub const LANG_FINNISH: u32 = 11;
pub const LANG_FRENCH: u32 = 12;
pub const LANG_FRISIAN: u32 = 98;
pub const LANG_FULAH: u32 = 103;
pub const LANG_GALICIAN: u32 = 86;
pub const LANG_GEORGIAN: u32 = 55;
pub const LANG_GERMAN: u32 = 7;
pub const LANG_GREEK: u32 = 8;
pub const LANG_GREENLANDIC: u32 = 111;
pub const LANG_GUJARATI: u32 = 71;
pub const LANG_HAUSA: u32 = 104;
pub const LANG_HAWAIIAN: u32 = 117;
pub const LANG_HEBREW: u32 = 13;
pub const LANG_HINDI: u32 = 57;
pub const LANG_HUNGARIAN: u32 = 14;
pub const LANG_ICELANDIC: u32 = 15;
pub const LANG_IGBO: u32 = 112;
pub const LANG_INDONESIAN: u32 = 33;
pub const LANG_INUKTITUT: u32 = 93;
pub const LANG_IRISH: u32 = 60;
pub const LANG_ITALIAN: u32 = 16;
pub const LANG_JAPANESE: u32 = 17;
pub const LANG_KANNADA: u32 = 75;
pub const LANG_KASHMIRI: u32 = 96;
pub const LANG_KAZAK: u32 = 63;
pub const LANG_KHMER: u32 = 83;
pub const LANG_KICHE: u32 = 134;
pub const LANG_KINYARWANDA: u32 = 135;
pub const LANG_KONKANI: u32 = 87;
pub const LANG_KOREAN: u32 = 18;
pub const LANG_KYRGYZ: u32 = 64;
pub const LANG_LAO: u32 = 84;
pub const LANG_LATVIAN: u32 = 38;
pub const LANG_LITHUANIAN: u32 = 39;
pub const LANG_LOWER_SORBIAN: u32 = 46;
pub const LANG_LUXEMBOURGISH: u32 = 110;
pub const LANG_MACEDONIAN: u32 = 47;
pub const LANG_MALAY: u32 = 62;
pub const LANG_MALAYALAM: u32 = 76;
pub const LANG_MALTESE: u32 = 58;
pub const LANG_MANIPURI: u32 = 88;
pub const LANG_MAORI: u32 = 129;
pub const LANG_MAPUDUNGUN: u32 = 122;
pub const LANG_MARATHI: u32 = 78;
pub const LANG_MOHAWK: u32 = 124;
pub const LANG_MONGOLIAN: u32 = 80;
pub const LANG_NEPALI: u32 = 97;
pub const LANG_NORWEGIAN: u32 = 20;
pub const LANG_OCCITAN: u32 = 130;
pub const LANG_ODIA: u32 = 72;
pub const LANG_ORIYA: u32 = 72;
pub const LANG_PASHTO: u32 = 99;
pub const LANG_PERSIAN: u32 = 41;
pub const LANG_POLISH: u32 = 21;
pub const LANG_PORTUGUESE: u32 = 22;
pub const LANG_PULAR: u32 = 103;
pub const LANG_PUNJABI: u32 = 70;
pub const LANG_QUECHUA: u32 = 107;
pub const LANG_ROMANIAN: u32 = 24;
pub const LANG_ROMANSH: u32 = 23;
pub const LANG_RUSSIAN: u32 = 25;
pub const LANG_SAKHA: u32 = 133;
pub const LANG_SAMI: u32 = 59;
pub const LANG_SANSKRIT: u32 = 79;
pub const LANG_SCOTTISH_GAELIC: u32 = 145;
pub const LANG_SERBIAN: u32 = 26;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770;
pub const LANG_SINDHI: u32 = 89;
pub const LANG_SINHALESE: u32 = 91;
pub const LANG_SLOVAK: u32 = 27;
pub const LANG_SLOVENIAN: u32 = 36;
pub const LANG_SOTHO: u32 = 108;
pub const LANG_SPANISH: u32 = 10;
pub const LANG_SWAHILI: u32 = 65;
pub const LANG_SWEDISH: u32 = 29;
pub const LANG_SYRIAC: u32 = 90;
pub const LANG_TAJIK: u32 = 40;
pub const LANG_TAMAZIGHT: u32 = 95;
pub const LANG_TAMIL: u32 = 73;
pub const LANG_TATAR: u32 = 68;
pub const LANG_TELUGU: u32 = 74;
pub const LANG_THAI: u32 = 30;
pub const LANG_TIBETAN: u32 = 81;
pub const LANG_TIGRIGNA: u32 = 115;
pub const LANG_TIGRINYA: u32 = 115;
pub const LANG_TSWANA: u32 = 50;
pub const LANG_TURKISH: u32 = 31;
pub const LANG_TURKMEN: u32 = 66;
pub const LANG_UIGHUR: u32 = 128;
pub const LANG_UKRAINIAN: u32 = 34;
pub const LANG_UPPER_SORBIAN: u32 = 46;
pub const LANG_URDU: u32 = 32;
pub const LANG_UZBEK: u32 = 67;
pub const LANG_VALENCIAN: u32 = 3;
pub const LANG_VIETNAMESE: u32 = 42;
pub const LANG_WELSH: u32 = 82;
pub const LANG_WOLOF: u32 = 136;
pub const LANG_XHOSA: u32 = 52;
pub const LANG_YAKUT: u32 = 133;
pub const LANG_YI: u32 = 120;
pub const LANG_YORUBA: u32 = 106;
pub const LANG_ZULU: u32 = 53;
pub const SUBLANG_NEUTRAL: u32 = 0;
pub const SUBLANG_DEFAULT: u32 = 1;
pub const SUBLANG_SYS_DEFAULT: u32 = 2;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7;
pub const SUBLANG_ARABIC_OMAN: u32 = 8;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13;
pub const SUBLANG_ARABIC_UAE: u32 = 14;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15;
pub const SUBLANG_ARABIC_QATAR: u32 = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1;
pub const SUBLANG_AZERI_LATIN: u32 = 1;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2;
pub const SUBLANG_BANGLA_INDIA: u32 = 1;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1;
pub const SUBLANG_BENGALI_INDIA: u32 = 1;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8;
pub const SUBLANG_BRETON_FRANCE: u32 = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4;
pub const SUBLANG_CHINESE_MACAU: u32 = 5;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4;
pub const SUBLANG_DANISH_DENMARK: u32 = 1;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1;
pub const SUBLANG_DUTCH: u32 = 1;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2;
pub const SUBLANG_ENGLISH_US: u32 = 1;
pub const SUBLANG_ENGLISH_UK: u32 = 2;
pub const SUBLANG_ENGLISH_AUS: u32 = 3;
pub const SUBLANG_ENGLISH_CAN: u32 = 4;
pub const SUBLANG_ENGLISH_NZ: u32 = 5;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1;
pub const SUBLANG_FRENCH: u32 = 1;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3;
pub const SUBLANG_FRENCH_SWISS: u32 = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5;
pub const SUBLANG_FRENCH_MONACO: u32 = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1;
pub const SUBLANG_GERMAN: u32 = 1;
pub const SUBLANG_GERMAN_SWISS: u32 = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5;
pub const SUBLANG_GREEK_GREECE: u32 = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1;
pub const SUBLANG_HAWAIIAN_US: u32 = 1;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1;
pub const SUBLANG_HINDI_INDIA: u32 = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2;
pub const SUBLANG_IRISH_IRELAND: u32 = 2;
pub const SUBLANG_ITALIAN: u32 = 1;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1;
pub const SUBLANG_KANNADA_INDIA: u32 = 1;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1;
pub const SUBLANG_KONKANI_INDIA: u32 = 1;
pub const SUBLANG_KOREAN: u32 = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1;
pub const SUBLANG_LAO_LAO: u32 = 1;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1;
pub const SUBLANG_LITHUANIAN: u32 = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1;
pub const SUBLANG_MALTESE_MALTA: u32 = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1;
pub const SUBLANG_MARATHI_INDIA: u32 = 1;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2;
pub const SUBLANG_NEPALI_INDIA: u32 = 2;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1;
pub const SUBLANG_ODIA_INDIA: u32 = 1;
pub const SUBLANG_ORIYA_INDIA: u32 = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1;
pub const SUBLANG_POLISH_POLAND: u32 = 1;
pub const SUBLANG_PORTUGUESE: u32 = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2;
pub const SUBLANG_QUECHUA_PERU: u32 = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3;
pub const SUBLANG_SINDHI_INDIA: u32 = 1;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1;
pub const SUBLANG_SPANISH: u32 = 1;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2;
pub const SUBLANG_SPANISH_MODERN: u32 = 3;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9;
pub const SUBLANG_SPANISH_PERU: u32 = 10;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12;
pub const SUBLANG_SPANISH_CHILE: u32 = 13;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20;
pub const SUBLANG_SPANISH_US: u32 = 21;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1;
pub const SUBLANG_SWEDISH: u32 = 1;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4;
pub const SUBLANG_TAMIL_INDIA: u32 = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1;
pub const SUBLANG_TELUGU_INDIA: u32 = 1;
pub const SUBLANG_THAI_THAILAND: u32 = 1;
pub const SUBLANG_TIBETAN_PRC: u32 = 1;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1;
pub const SUBLANG_UIGHUR_PRC: u32 = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1;
pub const SUBLANG_URDU_INDIA: u32 = 2;
pub const SUBLANG_UZBEK_LATIN: u32 = 1;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1;
pub const SUBLANG_YI_PRC: u32 = 1;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1;
pub const SORT_DEFAULT: u32 = 0;
pub const SORT_INVARIANT_MATH: u32 = 1;
pub const SORT_JAPANESE_XJIS: u32 = 0;
pub const SORT_JAPANESE_UNICODE: u32 = 1;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4;
pub const SORT_CHINESE_BIG5: u32 = 0;
pub const SORT_CHINESE_PRCP: u32 = 0;
pub const SORT_CHINESE_UNICODE: u32 = 1;
pub const SORT_CHINESE_PRC: u32 = 2;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4;
pub const SORT_KOREAN_KSC: u32 = 0;
pub const SORT_KOREAN_UNICODE: u32 = 1;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0;
pub const SORT_GEORGIAN_MODERN: u32 = 1;
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127;
pub const _MM_HINT_T0: u32 = 1;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 3;
pub const _MM_HINT_NTA: u32 = 0;
pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const EXCEPTION_READ_FAULT: u32 = 0;
pub const EXCEPTION_WRITE_FAULT: u32 = 1;
pub const EXCEPTION_EXECUTE_FAULT: u32 = 8;
pub const CONTEXT_AMD64: u32 = 1048576;
pub const CONTEXT_CONTROL: u32 = 1048577;
pub const CONTEXT_INTEGER: u32 = 1048578;
pub const CONTEXT_SEGMENTS: u32 = 1048580;
pub const CONTEXT_FLOATING_POINT: u32 = 1048584;
pub const CONTEXT_DEBUG_REGISTERS: u32 = 1048592;
pub const CONTEXT_FULL: u32 = 1048587;
pub const CONTEXT_ALL: u32 = 1048607;
pub const CONTEXT_XSTATE: u32 = 1048640;
pub const CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const INITIAL_MXCSR: u32 = 8064;
pub const INITIAL_FPCSR: u32 = 639;
pub const RUNTIME_FUNCTION_INDIRECT: u32 = 1;
pub const UNW_FLAG_NHANDLER: u32 = 0;
pub const UNW_FLAG_EHANDLER: u32 = 1;
pub const UNW_FLAG_UHANDLER: u32 = 2;
pub const UNW_FLAG_CHAININFO: u32 = 4;
pub const UNW_FLAG_NO_EPILOGUE: u32 = 2147483648;
pub const UNWIND_HISTORY_TABLE_SIZE: u32 = 12;
pub const OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME: &'static [u8; 34usize] =
  b"OutOfProcessFunctionTableCallback\0";
pub const WOW64_CONTEXT_i386: u32 = 65536;
pub const WOW64_CONTEXT_i486: u32 = 65536;
pub const WOW64_CONTEXT_CONTROL: u32 = 65537;
pub const WOW64_CONTEXT_INTEGER: u32 = 65538;
pub const WOW64_CONTEXT_SEGMENTS: u32 = 65540;
pub const WOW64_CONTEXT_FLOATING_POINT: u32 = 65544;
pub const WOW64_CONTEXT_DEBUG_REGISTERS: u32 = 65552;
pub const WOW64_CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const WOW64_CONTEXT_FULL: u32 = 65543;
pub const WOW64_CONTEXT_ALL: u32 = 65599;
pub const WOW64_CONTEXT_XSTATE: u32 = 65600;
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const WOW64_CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const WOW64_CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const WOW64_CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const WOW64_SIZE_OF_80387_REGISTERS: u32 = 80;
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION: u32 = 512;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const SID_REVISION: u32 = 1;
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15;
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1;
pub const SECURITY_MAX_SID_STRING_CHARACTERS: u32 = 187;
pub const SID_HASH_SIZE: u32 = 32;
pub const SECURITY_NULL_RID: u32 = 0;
pub const SECURITY_WORLD_RID: u32 = 0;
pub const SECURITY_LOCAL_RID: u32 = 0;
pub const SECURITY_LOCAL_LOGON_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_RID: u32 = 0;
pub const SECURITY_CREATOR_GROUP_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_SERVER_RID: u32 = 2;
pub const SECURITY_CREATOR_GROUP_SERVER_RID: u32 = 3;
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID: u32 = 4;
pub const SECURITY_DIALUP_RID: u32 = 1;
pub const SECURITY_NETWORK_RID: u32 = 2;
pub const SECURITY_BATCH_RID: u32 = 3;
pub const SECURITY_INTERACTIVE_RID: u32 = 4;
pub const SECURITY_LOGON_IDS_RID: u32 = 5;
pub const SECURITY_LOGON_IDS_RID_COUNT: u32 = 3;
pub const SECURITY_SERVICE_RID: u32 = 6;
pub const SECURITY_ANONYMOUS_LOGON_RID: u32 = 7;
pub const SECURITY_PROXY_RID: u32 = 8;
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID: u32 = 9;
pub const SECURITY_SERVER_LOGON_RID: u32 = 9;
pub const SECURITY_PRINCIPAL_SELF_RID: u32 = 10;
pub const SECURITY_AUTHENTICATED_USER_RID: u32 = 11;
pub const SECURITY_RESTRICTED_CODE_RID: u32 = 12;
pub const SECURITY_TERMINAL_SERVER_RID: u32 = 13;
pub const SECURITY_REMOTE_LOGON_RID: u32 = 14;
pub const SECURITY_THIS_ORGANIZATION_RID: u32 = 15;
pub const SECURITY_IUSER_RID: u32 = 17;
pub const SECURITY_LOCAL_SYSTEM_RID: u32 = 18;
pub const SECURITY_LOCAL_SERVICE_RID: u32 = 19;
pub const SECURITY_NETWORK_SERVICE_RID: u32 = 20;
pub const SECURITY_NT_NON_UNIQUE: u32 = 21;
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT: u32 = 3;
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID: u32 = 22;
pub const SECURITY_BUILTIN_DOMAIN_RID: u32 = 32;
pub const SECURITY_WRITE_RESTRICTED_CODE_RID: u32 = 33;
pub const SECURITY_PACKAGE_BASE_RID: u32 = 64;
pub const SECURITY_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_PACKAGE_NTLM_RID: u32 = 10;
pub const SECURITY_PACKAGE_SCHANNEL_RID: u32 = 14;
pub const SECURITY_PACKAGE_DIGEST_RID: u32 = 21;
pub const SECURITY_CRED_TYPE_BASE_RID: u32 = 65;
pub const SECURITY_CRED_TYPE_RID_COUNT: u32 = 2;
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID: u32 = 1;
pub const SECURITY_MIN_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_RID_COUNT: u32 = 6;
pub const SECURITY_RESERVED_ID_BASE_RID: u32 = 81;
pub const SECURITY_APPPOOL_ID_BASE_RID: u32 = 82;
pub const SECURITY_APPPOOL_ID_RID_COUNT: u32 = 6;
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID: u32 = 83;
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID: u32 = 84;
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID: u32 = 85;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WMIHOST_ID_BASE_RID: u32 = 86;
pub const SECURITY_WMIHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_TASK_ID_BASE_RID: u32 = 87;
pub const SECURITY_NFS_ID_BASE_RID: u32 = 88;
pub const SECURITY_COM_ID_BASE_RID: u32 = 89;
pub const SECURITY_WINDOW_MANAGER_BASE_RID: u32 = 90;
pub const SECURITY_RDV_GFX_BASE_RID: u32 = 91;
pub const SECURITY_DASHOST_ID_BASE_RID: u32 = 92;
pub const SECURITY_DASHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMANAGER_ID_BASE_RID: u32 = 93;
pub const SECURITY_USERMANAGER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WINRM_ID_BASE_RID: u32 = 94;
pub const SECURITY_WINRM_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CCG_ID_BASE_RID: u32 = 95;
pub const SECURITY_UMFD_BASE_RID: u32 = 96;
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT: u32 = 6;
pub const SECURITY_MAX_BASE_RID: u32 = 111;
pub const SECURITY_MAX_ALWAYS_FILTERED: u32 = 999;
pub const SECURITY_MIN_NEVER_FILTERED: u32 = 1000;
pub const SECURITY_OTHER_ORGANIZATION_RID: u32 = 1000;
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID: u32 = 112;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10;
pub const SECURITY_LOCAL_ACCOUNT_RID: u32 = 113;
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID: u32 = 114;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED: u32 = 496;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS: u32 = 497;
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS: u32 = 498;
pub const FOREST_USER_RID_MAX: u32 = 499;
pub const DOMAIN_USER_RID_ADMIN: u32 = 500;
pub const DOMAIN_USER_RID_GUEST: u32 = 501;
pub const DOMAIN_USER_RID_KRBTGT: u32 = 502;
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT: u32 = 503;
pub const DOMAIN_USER_RID_WDAG_ACCOUNT: u32 = 504;
pub const DOMAIN_USER_RID_MAX: u32 = 999;
pub const DOMAIN_GROUP_RID_ADMINS: u32 = 512;
pub const DOMAIN_GROUP_RID_USERS: u32 = 513;
pub const DOMAIN_GROUP_RID_GUESTS: u32 = 514;
pub const DOMAIN_GROUP_RID_COMPUTERS: u32 = 515;
pub const DOMAIN_GROUP_RID_CONTROLLERS: u32 = 516;
pub const DOMAIN_GROUP_RID_CERT_ADMINS: u32 = 517;
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS: u32 = 518;
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS: u32 = 519;
pub const DOMAIN_GROUP_RID_POLICY_ADMINS: u32 = 520;
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS: u32 = 521;
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS: u32 = 522;
pub const DOMAIN_GROUP_RID_CDC_RESERVED: u32 = 524;
pub const DOMAIN_GROUP_RID_PROTECTED_USERS: u32 = 525;
pub const DOMAIN_GROUP_RID_KEY_ADMINS: u32 = 526;
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS: u32 = 527;
pub const DOMAIN_ALIAS_RID_ADMINS: u32 = 544;
pub const DOMAIN_ALIAS_RID_USERS: u32 = 545;
pub const DOMAIN_ALIAS_RID_GUESTS: u32 = 546;
pub const DOMAIN_ALIAS_RID_POWER_USERS: u32 = 547;
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS: u32 = 548;
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS: u32 = 549;
pub const DOMAIN_ALIAS_RID_PRINT_OPS: u32 = 550;
pub const DOMAIN_ALIAS_RID_BACKUP_OPS: u32 = 551;
pub const DOMAIN_ALIAS_RID_REPLICATOR: u32 = 552;
pub const DOMAIN_ALIAS_RID_RAS_SERVERS: u32 = 553;
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS: u32 = 554;
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS: u32 = 555;
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS: u32 = 556;
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS: u32 = 557;
pub const DOMAIN_ALIAS_RID_MONITORING_USERS: u32 = 558;
pub const DOMAIN_ALIAS_RID_LOGGING_USERS: u32 = 559;
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS: u32 = 560;
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS: u32 = 561;
pub const DOMAIN_ALIAS_RID_DCOM_USERS: u32 = 562;
pub const DOMAIN_ALIAS_RID_IUSERS: u32 = 568;
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS: u32 = 569;
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP: u32 = 571;
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP: u32 = 572;
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP: u32 = 573;
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP: u32 = 574;
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS: u32 = 575;
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS: u32 = 576;
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS: u32 = 577;
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS: u32 = 578;
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS: u32 = 579;
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS: u32 = 580;
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT: u32 = 581;
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS: u32 = 582;
pub const SECURITY_APP_PACKAGE_BASE_RID: u32 = 2;
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_APP_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CAPABILITY_BASE_RID: u32 = 3;
pub const SECURITY_CAPABILITY_APP_RID: u32 = 1024;
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT: u32 = 2;
pub const SECURITY_CAPABILITY_RID_COUNT: u32 = 5;
pub const SECURITY_PARENT_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CHILD_PACKAGE_RID_COUNT: u32 = 12;
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE: u32 = 1;
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE: u32 = 2;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT: u32 = 1;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER: u32 = 2;
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER: u32 = 3;
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY: u32 = 4;
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY: u32 = 5;
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY: u32 = 6;
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY: u32 = 7;
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION: u32 = 8;
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES: u32 = 9;
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE: u32 = 10;
pub const SECURITY_CAPABILITY_APPOINTMENTS: u32 = 11;
pub const SECURITY_CAPABILITY_CONTACTS: u32 = 12;
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER: u32 = 4096;
pub const SECURITY_MANDATORY_UNTRUSTED_RID: u32 = 0;
pub const SECURITY_MANDATORY_LOW_RID: u32 = 4096;
pub const SECURITY_MANDATORY_MEDIUM_RID: u32 = 8192;
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID: u32 = 8448;
pub const SECURITY_MANDATORY_HIGH_RID: u32 = 12288;
pub const SECURITY_MANDATORY_SYSTEM_RID: u32 = 16384;
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID: u32 = 20480;
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID: u32 = 16384;
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT: u32 = 1;
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID: u32 = 1;
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID: u32 = 2;
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID: u32 = 3;
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID: u32 = 4;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID: u32 = 5;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID: u32 = 6;
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT: u32 = 2;
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID: u32 = 512;
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID: u32 = 0;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID: u32 = 8192;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID: u32 = 4096;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID: u32 = 2048;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID: u32 = 0;
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885;
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649;
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044;
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631;
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464;
pub const SE_GROUP_MANDATORY: u32 = 1;
pub const SE_GROUP_ENABLED_BY_DEFAULT: u32 = 2;
pub const SE_GROUP_ENABLED: u32 = 4;
pub const SE_GROUP_OWNER: u32 = 8;
pub const SE_GROUP_USE_FOR_DENY_ONLY: u32 = 16;
pub const SE_GROUP_INTEGRITY: u32 = 32;
pub const SE_GROUP_INTEGRITY_ENABLED: u32 = 64;
pub const SE_GROUP_LOGON_ID: u32 = 3221225472;
pub const SE_GROUP_RESOURCE: u32 = 536870912;
pub const SE_GROUP_VALID_ATTRIBUTES: u32 = 3758096511;
pub const ACL_REVISION: u32 = 2;
pub const ACL_REVISION_DS: u32 = 4;
pub const ACL_REVISION1: u32 = 1;
pub const ACL_REVISION2: u32 = 2;
pub const ACL_REVISION3: u32 = 3;
pub const ACL_REVISION4: u32 = 4;
pub const MAX_ACL_REVISION: u32 = 4;
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0;
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0;
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1;
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2;
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3;
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4;
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7;
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8;
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16;
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19;
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20;
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21;
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21;
pub const OBJECT_INHERIT_ACE: u32 = 1;
pub const CONTAINER_INHERIT_ACE: u32 = 2;
pub const NO_PROPAGATE_INHERIT_ACE: u32 = 4;
pub const INHERIT_ONLY_ACE: u32 = 8;
pub const INHERITED_ACE: u32 = 16;
pub const VALID_INHERIT_FLAGS: u32 = 31;
pub const SUCCESSFUL_ACCESS_ACE_FLAG: u32 = 64;
pub const FAILED_ACCESS_ACE_FLAG: u32 = 128;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4;
pub const SYSTEM_MANDATORY_LABEL_VALID_MASK: u32 = 7;
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const ACE_OBJECT_TYPE_PRESENT: u32 = 1;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT: u32 = 2;
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1;
pub const SE_OWNER_DEFAULTED: u32 = 1;
pub const SE_GROUP_DEFAULTED: u32 = 2;
pub const SE_DACL_PRESENT: u32 = 4;
pub const SE_DACL_DEFAULTED: u32 = 8;
pub const SE_SACL_PRESENT: u32 = 16;
pub const SE_SACL_DEFAULTED: u32 = 32;
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256;
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512;
pub const SE_DACL_AUTO_INHERITED: u32 = 1024;
pub const SE_SACL_AUTO_INHERITED: u32 = 2048;
pub const SE_DACL_PROTECTED: u32 = 4096;
pub const SE_SACL_PROTECTED: u32 = 8192;
pub const SE_RM_CONTROL_VALID: u32 = 16384;
pub const SE_SELF_RELATIVE: u32 = 32768;
pub const ACCESS_OBJECT_GUID: u32 = 0;
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1;
pub const ACCESS_PROPERTY_GUID: u32 = 2;
pub const ACCESS_MAX_LEVEL: u32 = 4;
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1;
pub const ACCESS_DS_SOURCE_A: &'static [u8; 3usize] = b"DS\0";
pub const ACCESS_DS_SOURCE_W: &'static [u8; 3usize] = b"DS\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_A: &'static [u8; 25usize] = b"Directory Service Object\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_W: &'static [u8; 25usize] = b"Directory Service Object\0";
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT: u32 = 1;
pub const SE_PRIVILEGE_ENABLED: u32 = 2;
pub const SE_PRIVILEGE_USED_FOR_ACCESS: u32 = 2147483648;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1;
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680;
pub const ACCESS_REASON_DATA_MASK: u32 = 65535;
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648;
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7;
pub const SE_ACTIVATE_AS_USER_CAPABILITY: &'static [u8; 15usize] = b"activateAsUser\0";
pub const SE_CONSTRAINED_IMPERSONATION_CAPABILITY: &'static [u8; 25usize] =
  b"constrainedImpersonation\0";
pub const SE_SESSION_IMPERSONATION_CAPABILITY: &'static [u8; 21usize] = b"sessionImpersonation\0";
pub const SE_MUMA_CAPABILITY: &'static [u8; 5usize] = b"muma\0";
pub const SE_DEVELOPMENT_MODE_NETWORK_CAPABILITY: &'static [u8; 23usize] =
  b"developmentModeNetwork\0";
pub const TOKEN_ASSIGN_PRIMARY: u32 = 1;
pub const TOKEN_DUPLICATE: u32 = 2;
pub const TOKEN_IMPERSONATE: u32 = 4;
pub const TOKEN_QUERY: u32 = 8;
pub const TOKEN_QUERY_SOURCE: u32 = 16;
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 32;
pub const TOKEN_ADJUST_GROUPS: u32 = 64;
pub const TOKEN_ADJUST_DEFAULT: u32 = 128;
pub const TOKEN_ADJUST_SESSIONID: u32 = 256;
pub const TOKEN_ALL_ACCESS_P: u32 = 983295;
pub const TOKEN_ALL_ACCESS: u32 = 983551;
pub const TOKEN_READ: u32 = 131080;
pub const TOKEN_WRITE: u32 = 131296;
pub const TOKEN_EXECUTE: u32 = 131072;
pub const TOKEN_TRUST_CONSTRAINT_MASK: u32 = 131096;
pub const TOKEN_ACCESS_PSEUDO_HANDLE_WIN8: u32 = 24;
pub const TOKEN_ACCESS_PSEUDO_HANDLE: u32 = 24;
pub const TOKEN_MANDATORY_POLICY_OFF: u32 = 0;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP: u32 = 1;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN: u32 = 2;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK: u32 = 3;
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 59;
pub const TOKEN_SOURCE_LENGTH: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const SECURITY_DYNAMIC_TRACKING: u32 = 1;
pub const SECURITY_STATIC_TRACKING: u32 = 0;
pub const DISABLE_MAX_PRIVILEGE: u32 = 1;
pub const SANDBOX_INERT: u32 = 2;
pub const LUA_TOKEN: u32 = 4;
pub const WRITE_RESTRICTED: u32 = 8;
pub const OWNER_SECURITY_INFORMATION: u32 = 1;
pub const GROUP_SECURITY_INFORMATION: u32 = 2;
pub const DACL_SECURITY_INFORMATION: u32 = 4;
pub const SACL_SECURITY_INFORMATION: u32 = 8;
pub const LABEL_SECURITY_INFORMATION: u32 = 16;
pub const ATTRIBUTE_SECURITY_INFORMATION: u32 = 32;
pub const SCOPE_SECURITY_INFORMATION: u32 = 64;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: u32 = 128;
pub const ACCESS_FILTER_SECURITY_INFORMATION: u32 = 256;
pub const BACKUP_SECURITY_INFORMATION: u32 = 65536;
pub const PROTECTED_DACL_SECURITY_INFORMATION: u32 = 2147483648;
pub const PROTECTED_SACL_SECURITY_INFORMATION: u32 = 1073741824;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION: u32 = 536870912;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION: u32 = 268435456;
pub const SE_SIGNING_LEVEL_UNCHECKED: u32 = 0;
pub const SE_SIGNING_LEVEL_UNSIGNED: u32 = 1;
pub const SE_SIGNING_LEVEL_ENTERPRISE: u32 = 2;
pub const SE_SIGNING_LEVEL_CUSTOM_1: u32 = 3;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: u32 = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_2: u32 = 5;
pub const SE_SIGNING_LEVEL_STORE: u32 = 6;
pub const SE_SIGNING_LEVEL_CUSTOM_3: u32 = 7;
pub const SE_SIGNING_LEVEL_ANTIMALWARE: u32 = 7;
pub const SE_SIGNING_LEVEL_MICROSOFT: u32 = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4: u32 = 9;
pub const SE_SIGNING_LEVEL_CUSTOM_5: u32 = 10;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: u32 = 11;
pub const SE_SIGNING_LEVEL_WINDOWS: u32 = 12;
pub const SE_SIGNING_LEVEL_CUSTOM_7: u32 = 13;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: u32 = 14;
pub const SE_SIGNING_LEVEL_CUSTOM_6: u32 = 15;
pub const SE_LEARNING_MODE_FLAG_PERMISSIVE: u32 = 1;
pub const PROCESS_TERMINATE: u32 = 1;
pub const PROCESS_CREATE_THREAD: u32 = 2;
pub const PROCESS_SET_SESSIONID: u32 = 4;
pub const PROCESS_VM_OPERATION: u32 = 8;
pub const PROCESS_VM_READ: u32 = 16;
pub const PROCESS_VM_WRITE: u32 = 32;
pub const PROCESS_DUP_HANDLE: u32 = 64;
pub const PROCESS_CREATE_PROCESS: u32 = 128;
pub const PROCESS_SET_QUOTA: u32 = 256;
pub const PROCESS_SET_INFORMATION: u32 = 512;
pub const PROCESS_QUERY_INFORMATION: u32 = 1024;
pub const PROCESS_SUSPEND_RESUME: u32 = 2048;
pub const PROCESS_QUERY_LIMITED_INFORMATION: u32 = 4096;
pub const PROCESS_SET_LIMITED_INFORMATION: u32 = 8192;
pub const PROCESS_ALL_ACCESS: u32 = 2097151;
pub const THREAD_TERMINATE: u32 = 1;
pub const THREAD_SUSPEND_RESUME: u32 = 2;
pub const THREAD_GET_CONTEXT: u32 = 8;
pub const THREAD_SET_CONTEXT: u32 = 16;
pub const THREAD_QUERY_INFORMATION: u32 = 64;
pub const THREAD_SET_INFORMATION: u32 = 32;
pub const THREAD_SET_THREAD_TOKEN: u32 = 128;
pub const THREAD_IMPERSONATE: u32 = 256;
pub const THREAD_DIRECT_IMPERSONATION: u32 = 512;
pub const THREAD_SET_LIMITED_INFORMATION: u32 = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: u32 = 2048;
pub const THREAD_RESUME: u32 = 4096;
pub const THREAD_ALL_ACCESS: u32 = 2097151;
pub const JOB_OBJECT_ASSIGN_PROCESS: u32 = 1;
pub const JOB_OBJECT_SET_ATTRIBUTES: u32 = 2;
pub const JOB_OBJECT_QUERY: u32 = 4;
pub const JOB_OBJECT_TERMINATE: u32 = 8;
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES: u32 = 16;
pub const JOB_OBJECT_IMPERSONATE: u32 = 32;
pub const JOB_OBJECT_ALL_ACCESS: u32 = 2031679;
pub const FLS_MAXIMUM_AVAILABLE: u32 = 128;
pub const TLS_MINIMUM_AVAILABLE: u32 = 64;
pub const THREAD_DYNAMIC_CODE_ALLOW: u32 = 1;
pub const THREAD_BASE_PRIORITY_LOWRT: u32 = 15;
pub const THREAD_BASE_PRIORITY_MAX: u32 = 2;
pub const THREAD_BASE_PRIORITY_MIN: i32 = -2;
pub const THREAD_BASE_PRIORITY_IDLE: i32 = -15;
pub const MEMORY_PRIORITY_LOWEST: u32 = 0;
pub const MEMORY_PRIORITY_VERY_LOW: u32 = 1;
pub const MEMORY_PRIORITY_LOW: u32 = 2;
pub const MEMORY_PRIORITY_MEDIUM: u32 = 3;
pub const MEMORY_PRIORITY_BELOW_NORMAL: u32 = 4;
pub const MEMORY_PRIORITY_NORMAL: u32 = 5;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: u32 = 1;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: u32 = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: u32 = 8;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: u32 = 16;
pub const MAX_HW_COUNTERS: u32 = 16;
pub const THREAD_PROFILING_FLAG_DISPATCH: u32 = 1;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG: u32 = 64;
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB: u32 = 0;
pub const JOB_OBJECT_POST_AT_END_OF_JOB: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: u32 = 3;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO: u32 = 4;
pub const JOB_OBJECT_MSG_NEW_PROCESS: u32 = 6;
pub const JOB_OBJECT_MSG_EXIT_PROCESS: u32 = 7;
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: u32 = 8;
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT: u32 = 9;
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT: u32 = 10;
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT: u32 = 11;
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT: u32 = 12;
pub const JOB_OBJECT_MSG_SILO_TERMINATED: u32 = 13;
pub const JOB_OBJECT_MSG_MINIMUM: u32 = 1;
pub const JOB_OBJECT_MSG_MAXIMUM: u32 = 13;
pub const JOB_OBJECT_VALID_COMPLETION_FILTER: u32 = 16382;
pub const JOB_OBJECT_LIMIT_WORKINGSET: u32 = 1;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_LIMIT_JOB_TIME: u32 = 4;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS: u32 = 8;
pub const JOB_OBJECT_LIMIT_AFFINITY: u32 = 16;
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS: u32 = 32;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME: u32 = 64;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS: u32 = 128;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY: u32 = 256;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY: u32 = 512;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH: u32 = 512;
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION: u32 = 1024;
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK: u32 = 2048;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK: u32 = 4096;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: u32 = 8192;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY: u32 = 16384;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW: u32 = 32768;
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES: u32 = 65536;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES: u32 = 131072;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL: u32 = 524288;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL: u32 = 1048576;
pub const JOB_OBJECT_LIMIT_VALID_FLAGS: u32 = 524287;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS: u32 = 32767;
pub const JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS: u32 = 2064900;
pub const JOB_OBJECT_UILIMIT_NONE: u32 = 0;
pub const JOB_OBJECT_UILIMIT_HANDLES: u32 = 1;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD: u32 = 2;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD: u32 = 4;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS: u32 = 8;
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS: u32 = 16;
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS: u32 = 32;
pub const JOB_OBJECT_UILIMIT_DESKTOP: u32 = 64;
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS: u32 = 128;
pub const JOB_OBJECT_UILIMIT_ALL: u32 = 255;
pub const JOB_OBJECT_UI_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_SECURITY_NO_ADMIN: u32 = 1;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN: u32 = 2;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN: u32 = 4;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS: u32 = 8;
pub const JOB_OBJECT_SECURITY_VALID_FLAGS: u32 = 15;
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE: u32 = 1;
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED: u32 = 2;
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP: u32 = 4;
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY: u32 = 8;
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE: u32 = 16;
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS: u32 = 31;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const EVENT_ALL_ACCESS: u32 = 2031619;
pub const MUTANT_QUERY_STATE: u32 = 1;
pub const MUTANT_ALL_ACCESS: u32 = 2031617;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const SEMAPHORE_ALL_ACCESS: u32 = 2031619;
pub const TIMER_QUERY_STATE: u32 = 1;
pub const TIMER_MODIFY_STATE: u32 = 2;
pub const TIMER_ALL_ACCESS: u32 = 2031619;
pub const TIME_ZONE_ID_UNKNOWN: u32 = 0;
pub const TIME_ZONE_ID_STANDARD: u32 = 1;
pub const TIME_ZONE_ID_DAYLIGHT: u32 = 2;
pub const LTP_PC_SMT: u32 = 1;
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8;
pub const PROCESSOR_INTEL_386: u32 = 386;
pub const PROCESSOR_INTEL_486: u32 = 486;
pub const PROCESSOR_INTEL_PENTIUM: u32 = 586;
pub const PROCESSOR_INTEL_IA64: u32 = 2200;
pub const PROCESSOR_AMD_X8664: u32 = 8664;
pub const PROCESSOR_MIPS_R4000: u32 = 4000;
pub const PROCESSOR_ALPHA_21064: u32 = 21064;
pub const PROCESSOR_PPC_601: u32 = 601;
pub const PROCESSOR_PPC_603: u32 = 603;
pub const PROCESSOR_PPC_604: u32 = 604;
pub const PROCESSOR_PPC_620: u32 = 620;
pub const PROCESSOR_HITACHI_SH3: u32 = 10003;
pub const PROCESSOR_HITACHI_SH3E: u32 = 10004;
pub const PROCESSOR_HITACHI_SH4: u32 = 10005;
pub const PROCESSOR_MOTOROLA_821: u32 = 821;
pub const PROCESSOR_SHx_SH3: u32 = 103;
pub const PROCESSOR_SHx_SH4: u32 = 104;
pub const PROCESSOR_STRONGARM: u32 = 2577;
pub const PROCESSOR_ARM720: u32 = 1824;
pub const PROCESSOR_ARM820: u32 = 2080;
pub const PROCESSOR_ARM920: u32 = 2336;
pub const PROCESSOR_ARM_7TDMI: u32 = 70001;
pub const PROCESSOR_OPTIL: u32 = 18767;
pub const PROCESSOR_ARCHITECTURE_INTEL: u32 = 0;
pub const PROCESSOR_ARCHITECTURE_MIPS: u32 = 1;
pub const PROCESSOR_ARCHITECTURE_ALPHA: u32 = 2;
pub const PROCESSOR_ARCHITECTURE_PPC: u32 = 3;
pub const PROCESSOR_ARCHITECTURE_SHX: u32 = 4;
pub const PROCESSOR_ARCHITECTURE_ARM: u32 = 5;
pub const PROCESSOR_ARCHITECTURE_IA64: u32 = 6;
pub const PROCESSOR_ARCHITECTURE_ALPHA64: u32 = 7;
pub const PROCESSOR_ARCHITECTURE_MSIL: u32 = 8;
pub const PROCESSOR_ARCHITECTURE_AMD64: u32 = 9;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: u32 = 10;
pub const PROCESSOR_ARCHITECTURE_NEUTRAL: u32 = 11;
pub const PROCESSOR_ARCHITECTURE_ARM64: u32 = 12;
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64: u32 = 13;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64: u32 = 14;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN: u32 = 65535;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const XSTATE_LEGACY_FLOATING_POINT: u32 = 0;
pub const XSTATE_LEGACY_SSE: u32 = 1;
pub const XSTATE_GSSE: u32 = 2;
pub const XSTATE_AVX: u32 = 2;
pub const XSTATE_MPX_BNDREGS: u32 = 3;
pub const XSTATE_MPX_BNDCSR: u32 = 4;
pub const XSTATE_AVX512_KMASK: u32 = 5;
pub const XSTATE_AVX512_ZMM_H: u32 = 6;
pub const XSTATE_AVX512_ZMM: u32 = 7;
pub const XSTATE_IPT: u32 = 8;
pub const XSTATE_LWP: u32 = 62;
pub const MAXIMUM_XSTATE_FEATURES: u32 = 64;
pub const XSTATE_COMPACTION_ENABLE: u32 = 63;
pub const XSTATE_ALIGN_BIT: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: u32 = 2;
pub const XSTATE_CONTROLFLAG_VALID_MASK: u32 = 3;
pub const CFG_CALL_TARGET_VALID: u32 = 1;
pub const CFG_CALL_TARGET_PROCESSED: u32 = 2;
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID: u32 = 4;
pub const SECTION_QUERY: u32 = 1;
pub const SECTION_MAP_WRITE: u32 = 2;
pub const SECTION_MAP_READ: u32 = 4;
pub const SECTION_MAP_EXECUTE: u32 = 8;
pub const SECTION_EXTEND_SIZE: u32 = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: u32 = 32;
pub const SECTION_ALL_ACCESS: u32 = 983071;
pub const SESSION_QUERY_ACCESS: u32 = 1;
pub const SESSION_MODIFY_ACCESS: u32 = 2;
pub const SESSION_ALL_ACCESS: u32 = 983043;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_REVERT_TO_FILE_MAP: u32 = 2147483648;
pub const PAGE_ENCLAVE_THREAD_CONTROL: u32 = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: u32 = 1073741824;
pub const PAGE_TARGETS_INVALID: u32 = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: u32 = 536870912;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_WRITE_WATCH: u32 = 2097152;
pub const MEM_PHYSICAL: u32 = 4194304;
pub const MEM_ROTATE: u32 = 8388608;
pub const MEM_DIFFERENT_IMAGE_BASE_OK: u32 = 8388608;
pub const MEM_RESET_UNDO: u32 = 16777216;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const MEM_64K_PAGES: u32 = 541065216;
pub const SEC_64K_PAGES: u32 = 524288;
pub const SEC_FILE: u32 = 8388608;
pub const SEC_IMAGE: u32 = 16777216;
pub const SEC_PROTECTED_IMAGE: u32 = 33554432;
pub const SEC_RESERVE: u32 = 67108864;
pub const SEC_COMMIT: u32 = 134217728;
pub const SEC_NOCACHE: u32 = 268435456;
pub const SEC_WRITECOMBINE: u32 = 1073741824;
pub const SEC_LARGE_PAGES: u32 = 2147483648;
pub const SEC_IMAGE_NO_EXECUTE: u32 = 285212672;
pub const MEM_IMAGE: u32 = 16777216;
pub const WRITE_WATCH_FLAG_RESET: u32 = 1;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST: u32 = 1;
pub const ENCLAVE_TYPE_SGX: u32 = 1;
pub const ENCLAVE_TYPE_VBS: u32 = 16;
pub const ENCLAVE_VBS_FLAG_DEBUG: u32 = 1;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: u32 = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: u32 = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: u32 = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: u32 = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u32 = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: u32 = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: u32 = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: u32 = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: u32 = 131072;
pub const FILE_ATTRIBUTE_EA: u32 = 262144;
pub const FILE_ATTRIBUTE_PINNED: u32 = 524288;
pub const FILE_ATTRIBUTE_UNPINNED: u32 = 1048576;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN: u32 = 262144;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u32 = 4194304;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768;
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912;
pub const FILE_NOTIFY_CHANGE_FILE_NAME: u32 = 1;
pub const FILE_NOTIFY_CHANGE_DIR_NAME: u32 = 2;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES: u32 = 4;
pub const FILE_NOTIFY_CHANGE_SIZE: u32 = 8;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE: u32 = 16;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS: u32 = 32;
pub const FILE_NOTIFY_CHANGE_CREATION: u32 = 64;
pub const FILE_NOTIFY_CHANGE_SECURITY: u32 = 256;
pub const FILE_ACTION_ADDED: u32 = 1;
pub const FILE_ACTION_REMOVED: u32 = 2;
pub const FILE_ACTION_MODIFIED: u32 = 3;
pub const FILE_ACTION_RENAMED_OLD_NAME: u32 = 4;
pub const FILE_ACTION_RENAMED_NEW_NAME: u32 = 5;
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1;
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2;
pub const FILE_UNICODE_ON_DISK: u32 = 4;
pub const FILE_PERSISTENT_ACLS: u32 = 8;
pub const FILE_FILE_COMPRESSION: u32 = 16;
pub const FILE_VOLUME_QUOTAS: u32 = 32;
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64;
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128;
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024;
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768;
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536;
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072;
pub const FILE_NAMED_STREAMS: u32 = 262144;
pub const FILE_READ_ONLY_VOLUME: u32 = 524288;
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576;
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152;
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304;
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216;
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728;
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456;
pub const FILE_DAX_VOLUME: u32 = 536870912;
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4;
pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: u32 = 16384;
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0;
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1;
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2;
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2;
pub const IO_REPARSE_TAG_MOUNT_POINT: u32 = 2684354563;
pub const IO_REPARSE_TAG_HSM: u32 = 3221225476;
pub const IO_REPARSE_TAG_HSM2: u32 = 2147483654;
pub const IO_REPARSE_TAG_SIS: u32 = 2147483655;
pub const IO_REPARSE_TAG_WIM: u32 = 2147483656;
pub const IO_REPARSE_TAG_CSV: u32 = 2147483657;
pub const IO_REPARSE_TAG_DFS: u32 = 2147483658;
pub const IO_REPARSE_TAG_SYMLINK: u32 = 2684354572;
pub const IO_REPARSE_TAG_DFSR: u32 = 2147483666;
pub const IO_REPARSE_TAG_DEDUP: u32 = 2147483667;
pub const IO_REPARSE_TAG_NFS: u32 = 2147483668;
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER: u32 = 2147483669;
pub const IO_REPARSE_TAG_WOF: u32 = 2147483671;
pub const IO_REPARSE_TAG_WCI: u32 = 2147483672;
pub const IO_REPARSE_TAG_WCI_1: u32 = 2415923224;
pub const IO_REPARSE_TAG_GLOBAL_REPARSE: u32 = 2684354585;
pub const IO_REPARSE_TAG_CLOUD: u32 = 2415919130;
pub const IO_REPARSE_TAG_CLOUD_1: u32 = 2415923226;
pub const IO_REPARSE_TAG_CLOUD_2: u32 = 2415927322;
pub const IO_REPARSE_TAG_CLOUD_3: u32 = 2415931418;
pub const IO_REPARSE_TAG_CLOUD_4: u32 = 2415935514;
pub const IO_REPARSE_TAG_CLOUD_5: u32 = 2415939610;
pub const IO_REPARSE_TAG_CLOUD_6: u32 = 2415943706;
pub const IO_REPARSE_TAG_CLOUD_7: u32 = 2415947802;
pub const IO_REPARSE_TAG_CLOUD_8: u32 = 2415951898;
pub const IO_REPARSE_TAG_CLOUD_9: u32 = 2415955994;
pub const IO_REPARSE_TAG_CLOUD_A: u32 = 2415960090;
pub const IO_REPARSE_TAG_CLOUD_B: u32 = 2415964186;
pub const IO_REPARSE_TAG_CLOUD_C: u32 = 2415968282;
pub const IO_REPARSE_TAG_CLOUD_D: u32 = 2415972378;
pub const IO_REPARSE_TAG_CLOUD_E: u32 = 2415976474;
pub const IO_REPARSE_TAG_CLOUD_F: u32 = 2415980570;
pub const IO_REPARSE_TAG_CLOUD_MASK: u32 = 61440;
pub const IO_REPARSE_TAG_APPEXECLINK: u32 = 2147483675;
pub const IO_REPARSE_TAG_GVFS: u32 = 2415919132;
pub const IO_REPARSE_TAG_STORAGE_SYNC: u32 = 2147483678;
pub const IO_REPARSE_TAG_WCI_TOMBSTONE: u32 = 2684354591;
pub const IO_REPARSE_TAG_UNHANDLED: u32 = 2147483680;
pub const IO_REPARSE_TAG_ONEDRIVE: u32 = 2147483681;
pub const IO_REPARSE_TAG_GVFS_TOMBSTONE: u32 = 2684354594;
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4;
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32;
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1;
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536;
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144;
pub const IO_COMPLETION_MODIFY_STATE: u32 = 2;
pub const IO_COMPLETION_ALL_ACCESS: u32 = 2031619;
pub const IO_QOS_MAX_RESERVATION: u32 = 1000000000;
pub const SMB_CCF_APP_INSTANCE_EA_NAME: &'static [u8; 29usize] = b"ClusteredApplicationInstance\0";
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1;
pub const DUPLICATE_CLOSE_SOURCE: u32 = 1;
pub const DUPLICATE_SAME_ACCESS: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: u32 = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: u32 = 8;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: u32 = 3;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: u32 = 3;
pub const PROCESSOR_THROTTLE_DISABLED: u32 = 0;
pub const PROCESSOR_THROTTLE_ENABLED: u32 = 1;
pub const PROCESSOR_THROTTLE_AUTOMATIC: u32 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: u32 = 5;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED: u32 = 6;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 6;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: u32 = 255;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: u32 = 0;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: u32 = 0;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: u32 = 1270000000;
pub const PROCESSOR_DUTY_CYCLING_DISABLED: u32 = 0;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: u32 = 0;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED: u32 = 2;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL: u32 = 0;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE: u32 = 1;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: i64 = -2147483656;
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: u32 = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: u32 = 2;
pub const PDCAP_D0_SUPPORTED: u32 = 1;
pub const PDCAP_D1_SUPPORTED: u32 = 2;
pub const PDCAP_D2_SUPPORTED: u32 = 4;
pub const PDCAP_D3_SUPPORTED: u32 = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256;
pub const POWER_SETTING_VALUE_VERSION: u32 = 1;
pub const POWER_PLATFORM_ROLE_V1: u32 = 1;
pub const POWER_PLATFORM_ROLE_V2: u32 = 2;
pub const POWER_PLATFORM_ROLE_VERSION: u32 = 2;
pub const PROC_IDLE_BUCKET_COUNT: u32 = 6;
pub const PROC_IDLE_BUCKET_COUNT_EX: u32 = 16;
pub const ACPI_PPM_SOFTWARE_ALL: u32 = 252;
pub const ACPI_PPM_SOFTWARE_ANY: u32 = 253;
pub const ACPI_PPM_HARDWARE_ALL: u32 = 254;
pub const MS_PPM_SOFTWARE_ALL: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C2: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C3: u32 = 2;
pub const PPM_FIRMWARE_ACPI1TSTATES: u32 = 4;
pub const PPM_FIRMWARE_CST: u32 = 8;
pub const PPM_FIRMWARE_CSD: u32 = 16;
pub const PPM_FIRMWARE_PCT: u32 = 32;
pub const PPM_FIRMWARE_PSS: u32 = 64;
pub const PPM_FIRMWARE_XPSS: u32 = 128;
pub const PPM_FIRMWARE_PPC: u32 = 256;
pub const PPM_FIRMWARE_PSD: u32 = 512;
pub const PPM_FIRMWARE_PTC: u32 = 1024;
pub const PPM_FIRMWARE_TSS: u32 = 2048;
pub const PPM_FIRMWARE_TPC: u32 = 4096;
pub const PPM_FIRMWARE_TSD: u32 = 8192;
pub const PPM_FIRMWARE_PCCH: u32 = 16384;
pub const PPM_FIRMWARE_PCCP: u32 = 32768;
pub const PPM_FIRMWARE_OSC: u32 = 65536;
pub const PPM_FIRMWARE_PDC: u32 = 131072;
pub const PPM_FIRMWARE_CPC: u32 = 262144;
pub const PPM_FIRMWARE_LPI: u32 = 524288;
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES: u32 = 1;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1: u32 = 2;
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC: u32 = 3;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP: u32 = 4;
pub const PPM_IDLE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_IDLE_IMPLEMENTATION_CSTATES: u32 = 1;
pub const PPM_IDLE_IMPLEMENTATION_PEP: u32 = 2;
pub const PPM_IDLE_IMPLEMENTATION_MICROPEP: u32 = 3;
pub const PPM_IDLE_IMPLEMENTATION_LPISTATES: u32 = 4;
pub const POWER_ACTION_QUERY_ALLOWED: u32 = 1;
pub const POWER_ACTION_UI_ALLOWED: u32 = 2;
pub const POWER_ACTION_OVERRIDE_APPS: u32 = 4;
pub const POWER_ACTION_HIBERBOOT: u32 = 8;
pub const POWER_ACTION_USER_NOTIFY: u32 = 16;
pub const POWER_ACTION_DOZE_TO_HIBERNATE: u32 = 32;
pub const POWER_ACTION_PSEUDO_TRANSITION: u32 = 134217728;
pub const POWER_ACTION_LIGHTEST_FIRST: u32 = 268435456;
pub const POWER_ACTION_LOCK_CONSOLE: u32 = 536870912;
pub const POWER_ACTION_DISABLE_WAKES: u32 = 1073741824;
pub const POWER_ACTION_CRITICAL: u32 = 2147483648;
pub const POWER_LEVEL_USER_NOTIFY_TEXT: u32 = 1;
pub const POWER_LEVEL_USER_NOTIFY_SOUND: u32 = 2;
pub const POWER_LEVEL_USER_NOTIFY_EXEC: u32 = 4;
pub const POWER_USER_NOTIFY_BUTTON: u32 = 8;
pub const POWER_USER_NOTIFY_SHUTDOWN: u32 = 16;
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN: u32 = 32;
pub const POWER_FORCE_TRIGGER_RESET: u32 = 2147483648;
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK: u32 = 7;
pub const BATTERY_DISCHARGE_FLAGS_ENABLE: u32 = 2147483648;
pub const NUM_DISCHARGE_POLICIES: u32 = 4;
pub const DISCHARGE_POLICY_CRITICAL: u32 = 0;
pub const DISCHARGE_POLICY_LOW: u32 = 1;
pub const PROCESSOR_IDLESTATE_POLICY_COUNT: u32 = 3;
pub const PO_THROTTLE_NONE: u32 = 0;
pub const PO_THROTTLE_CONSTANT: u32 = 1;
pub const PO_THROTTLE_DEGRADE: u32 = 2;
pub const PO_THROTTLE_ADAPTIVE: u32 = 3;
pub const PO_THROTTLE_MAXIMUM: u32 = 4;
pub const HIBERFILE_TYPE_NONE: u32 = 0;
pub const HIBERFILE_TYPE_REDUCED: u32 = 1;
pub const HIBERFILE_TYPE_FULL: u32 = 2;
pub const HIBERFILE_TYPE_MAX: u32 = 3;
pub const IMAGE_DOS_SIGNATURE: u32 = 23117;
pub const IMAGE_OS2_SIGNATURE: u32 = 17742;
pub const IMAGE_OS2_SIGNATURE_LE: u32 = 17740;
pub const IMAGE_VXD_SIGNATURE: u32 = 17740;
pub const IMAGE_NT_SIGNATURE: u32 = 17744;
pub const IMAGE_SIZEOF_FILE_HEADER: u32 = 20;
pub const IMAGE_FILE_RELOCS_STRIPPED: u32 = 1;
pub const IMAGE_FILE_EXECUTABLE_IMAGE: u32 = 2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED: u32 = 4;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED: u32 = 8;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM: u32 = 16;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE: u32 = 32;
pub const IMAGE_FILE_BYTES_REVERSED_LO: u32 = 128;
pub const IMAGE_FILE_32BIT_MACHINE: u32 = 256;
pub const IMAGE_FILE_DEBUG_STRIPPED: u32 = 512;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: u32 = 1024;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP: u32 = 2048;
pub const IMAGE_FILE_SYSTEM: u32 = 4096;
pub const IMAGE_FILE_DLL: u32 = 8192;
pub const IMAGE_FILE_UP_SYSTEM_ONLY: u32 = 16384;
pub const IMAGE_FILE_BYTES_REVERSED_HI: u32 = 32768;
pub const IMAGE_FILE_MACHINE_UNKNOWN: u32 = 0;
pub const IMAGE_FILE_MACHINE_TARGET_HOST: u32 = 1;
pub const IMAGE_FILE_MACHINE_I386: u32 = 332;
pub const IMAGE_FILE_MACHINE_R3000: u32 = 354;
pub const IMAGE_FILE_MACHINE_R4000: u32 = 358;
pub const IMAGE_FILE_MACHINE_R10000: u32 = 360;
pub const IMAGE_FILE_MACHINE_WCEMIPSV2: u32 = 361;
pub const IMAGE_FILE_MACHINE_ALPHA: u32 = 388;
pub const IMAGE_FILE_MACHINE_SH3: u32 = 418;
pub const IMAGE_FILE_MACHINE_SH3DSP: u32 = 419;
pub const IMAGE_FILE_MACHINE_SH3E: u32 = 420;
pub const IMAGE_FILE_MACHINE_SH4: u32 = 422;
pub const IMAGE_FILE_MACHINE_SH5: u32 = 424;
pub const IMAGE_FILE_MACHINE_ARM: u32 = 448;
pub const IMAGE_FILE_MACHINE_THUMB: u32 = 450;
pub const IMAGE_FILE_MACHINE_ARMNT: u32 = 452;
pub const IMAGE_FILE_MACHINE_AM33: u32 = 467;
pub const IMAGE_FILE_MACHINE_POWERPC: u32 = 496;
pub const IMAGE_FILE_MACHINE_POWERPCFP: u32 = 497;
pub const IMAGE_FILE_MACHINE_IA64: u32 = 512;
pub const IMAGE_FILE_MACHINE_MIPS16: u32 = 614;
pub const IMAGE_FILE_MACHINE_ALPHA64: u32 = 644;
pub const IMAGE_FILE_MACHINE_MIPSFPU: u32 = 870;
pub const IMAGE_FILE_MACHINE_MIPSFPU16: u32 = 1126;
pub const IMAGE_FILE_MACHINE_AXP64: u32 = 644;
pub const IMAGE_FILE_MACHINE_TRICORE: u32 = 1312;
pub const IMAGE_FILE_MACHINE_CEF: u32 = 3311;
pub const IMAGE_FILE_MACHINE_EBC: u32 = 3772;
pub const IMAGE_FILE_MACHINE_AMD64: u32 = 34404;
pub const IMAGE_FILE_MACHINE_M32R: u32 = 36929;
pub const IMAGE_FILE_MACHINE_ARM64: u32 = 43620;
pub const IMAGE_FILE_MACHINE_CEE: u32 = 49390;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES: u32 = 16;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC: u32 = 267;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC: u32 = 523;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC: u32 = 263;
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC: u32 = 523;
pub const IMAGE_SUBSYSTEM_UNKNOWN: u32 = 0;
pub const IMAGE_SUBSYSTEM_NATIVE: u32 = 1;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI: u32 = 2;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI: u32 = 3;
pub const IMAGE_SUBSYSTEM_OS2_CUI: u32 = 5;
pub const IMAGE_SUBSYSTEM_POSIX_CUI: u32 = 7;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS: u32 = 8;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI: u32 = 9;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION: u32 = 10;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: u32 = 11;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: u32 = 12;
pub const IMAGE_SUBSYSTEM_EFI_ROM: u32 = 13;
pub const IMAGE_SUBSYSTEM_XBOX: u32 = 14;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION: u32 = 16;
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG: u32 = 17;
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA: u32 = 32;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE: u32 = 64;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY: u32 = 128;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT: u32 = 256;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION: u32 = 512;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH: u32 = 1024;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND: u32 = 2048;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER: u32 = 4096;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER: u32 = 8192;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF: u32 = 16384;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE: u32 = 32768;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT: u32 = 0;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT: u32 = 1;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE: u32 = 2;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION: u32 = 3;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY: u32 = 4;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC: u32 = 5;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG: u32 = 6;
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: u32 = 7;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR: u32 = 8;
pub const IMAGE_DIRECTORY_ENTRY_TLS: u32 = 9;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: u32 = 10;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: u32 = 11;
pub const IMAGE_DIRECTORY_ENTRY_IAT: u32 = 12;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: u32 = 13;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: u32 = 14;
pub const IMAGE_SIZEOF_SHORT_NAME: u32 = 8;
pub const IMAGE_SIZEOF_SECTION_HEADER: u32 = 40;
pub const IMAGE_SCN_TYPE_NO_PAD: u32 = 8;
pub const IMAGE_SCN_CNT_CODE: u32 = 32;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA: u32 = 64;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA: u32 = 128;
pub const IMAGE_SCN_LNK_OTHER: u32 = 256;
pub const IMAGE_SCN_LNK_INFO: u32 = 512;
pub const IMAGE_SCN_LNK_REMOVE: u32 = 2048;
pub const IMAGE_SCN_LNK_COMDAT: u32 = 4096;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC: u32 = 16384;
pub const IMAGE_SCN_GPREL: u32 = 32768;
pub const IMAGE_SCN_MEM_FARDATA: u32 = 32768;
pub const IMAGE_SCN_MEM_PURGEABLE: u32 = 131072;
pub const IMAGE_SCN_MEM_16BIT: u32 = 131072;
pub const IMAGE_SCN_MEM_LOCKED: u32 = 262144;
pub const IMAGE_SCN_MEM_PRELOAD: u32 = 524288;
pub const IMAGE_SCN_ALIGN_1BYTES: u32 = 1048576;
pub const IMAGE_SCN_ALIGN_2BYTES: u32 = 2097152;
pub const IMAGE_SCN_ALIGN_4BYTES: u32 = 3145728;
pub const IMAGE_SCN_ALIGN_8BYTES: u32 = 4194304;
pub const IMAGE_SCN_ALIGN_16BYTES: u32 = 5242880;
pub const IMAGE_SCN_ALIGN_32BYTES: u32 = 6291456;
pub const IMAGE_SCN_ALIGN_64BYTES: u32 = 7340032;
pub const IMAGE_SCN_ALIGN_128BYTES: u32 = 8388608;
pub const IMAGE_SCN_ALIGN_256BYTES: u32 = 9437184;
pub const IMAGE_SCN_ALIGN_512BYTES: u32 = 10485760;
pub const IMAGE_SCN_ALIGN_1024BYTES: u32 = 11534336;
pub const IMAGE_SCN_ALIGN_2048BYTES: u32 = 12582912;
pub const IMAGE_SCN_ALIGN_4096BYTES: u32 = 13631488;
pub const IMAGE_SCN_ALIGN_8192BYTES: u32 = 14680064;
pub const IMAGE_SCN_ALIGN_MASK: u32 = 15728640;
pub const IMAGE_SCN_LNK_NRELOC_OVFL: u32 = 16777216;
pub const IMAGE_SCN_MEM_DISCARDABLE: u32 = 33554432;
pub const IMAGE_SCN_MEM_NOT_CACHED: u32 = 67108864;
pub const IMAGE_SCN_MEM_NOT_PAGED: u32 = 134217728;
pub const IMAGE_SCN_MEM_SHARED: u32 = 268435456;
pub const IMAGE_SCN_MEM_EXECUTE: u32 = 536870912;
pub const IMAGE_SCN_MEM_READ: u32 = 1073741824;
pub const IMAGE_SCN_MEM_WRITE: u32 = 2147483648;
pub const IMAGE_SCN_SCALE_INDEX: u32 = 1;
pub const IMAGE_SIZEOF_SYMBOL: u32 = 18;
pub const IMAGE_SYM_SECTION_MAX: u32 = 65279;
pub const IMAGE_SYM_SECTION_MAX_EX: u32 = 2147483647;
pub const IMAGE_SYM_TYPE_NULL: u32 = 0;
pub const IMAGE_SYM_TYPE_VOID: u32 = 1;
pub const IMAGE_SYM_TYPE_CHAR: u32 = 2;
pub const IMAGE_SYM_TYPE_SHORT: u32 = 3;
pub const IMAGE_SYM_TYPE_INT: u32 = 4;
pub const IMAGE_SYM_TYPE_LONG: u32 = 5;
pub const IMAGE_SYM_TYPE_FLOAT: u32 = 6;
pub const IMAGE_SYM_TYPE_DOUBLE: u32 = 7;
pub const IMAGE_SYM_TYPE_STRUCT: u32 = 8;
pub const IMAGE_SYM_TYPE_UNION: u32 = 9;
pub const IMAGE_SYM_TYPE_ENUM: u32 = 10;
pub const IMAGE_SYM_TYPE_MOE: u32 = 11;
pub const IMAGE_SYM_TYPE_BYTE: u32 = 12;
pub const IMAGE_SYM_TYPE_WORD: u32 = 13;
pub const IMAGE_SYM_TYPE_UINT: u32 = 14;
pub const IMAGE_SYM_TYPE_DWORD: u32 = 15;
pub const IMAGE_SYM_TYPE_PCODE: u32 = 32768;
pub const IMAGE_SYM_DTYPE_NULL: u32 = 0;
pub const IMAGE_SYM_DTYPE_POINTER: u32 = 1;
pub const IMAGE_SYM_DTYPE_FUNCTION: u32 = 2;
pub const IMAGE_SYM_DTYPE_ARRAY: u32 = 3;
pub const IMAGE_SYM_CLASS_NULL: u32 = 0;
pub const IMAGE_SYM_CLASS_AUTOMATIC: u32 = 1;
pub const IMAGE_SYM_CLASS_EXTERNAL: u32 = 2;
pub const IMAGE_SYM_CLASS_STATIC: u32 = 3;
pub const IMAGE_SYM_CLASS_REGISTER: u32 = 4;
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF: u32 = 5;
pub const IMAGE_SYM_CLASS_LABEL: u32 = 6;
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL: u32 = 7;
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: u32 = 8;
pub const IMAGE_SYM_CLASS_ARGUMENT: u32 = 9;
pub const IMAGE_SYM_CLASS_STRUCT_TAG: u32 = 10;
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION: u32 = 11;
pub const IMAGE_SYM_CLASS_UNION_TAG: u32 = 12;
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION: u32 = 13;
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC: u32 = 14;
pub const IMAGE_SYM_CLASS_ENUM_TAG: u32 = 15;
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM: u32 = 16;
pub const IMAGE_SYM_CLASS_REGISTER_PARAM: u32 = 17;
pub const IMAGE_SYM_CLASS_BIT_FIELD: u32 = 18;
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL: u32 = 68;
pub const IMAGE_SYM_CLASS_BLOCK: u32 = 100;
pub const IMAGE_SYM_CLASS_FUNCTION: u32 = 101;
pub const IMAGE_SYM_CLASS_END_OF_STRUCT: u32 = 102;
pub const IMAGE_SYM_CLASS_FILE: u32 = 103;
pub const IMAGE_SYM_CLASS_SECTION: u32 = 104;
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL: u32 = 105;
pub const IMAGE_SYM_CLASS_CLR_TOKEN: u32 = 107;
pub const N_BTMASK: u32 = 15;
pub const N_TMASK: u32 = 48;
pub const N_TMASK1: u32 = 192;
pub const N_TMASK2: u32 = 240;
pub const N_BTSHFT: u32 = 4;
pub const N_TSHIFT: u32 = 2;
pub const IMAGE_COMDAT_SELECT_NODUPLICATES: u32 = 1;
pub const IMAGE_COMDAT_SELECT_ANY: u32 = 2;
pub const IMAGE_COMDAT_SELECT_SAME_SIZE: u32 = 3;
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH: u32 = 4;
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE: u32 = 5;
pub const IMAGE_COMDAT_SELECT_LARGEST: u32 = 6;
pub const IMAGE_COMDAT_SELECT_NEWEST: u32 = 7;
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY: u32 = 1;
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY: u32 = 2;
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS: u32 = 3;
pub const IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY: u32 = 4;
pub const IMAGE_REL_I386_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_I386_DIR16: u32 = 1;
pub const IMAGE_REL_I386_REL16: u32 = 2;
pub const IMAGE_REL_I386_DIR32: u32 = 6;
pub const IMAGE_REL_I386_DIR32NB: u32 = 7;
pub const IMAGE_REL_I386_SEG12: u32 = 9;
pub const IMAGE_REL_I386_SECTION: u32 = 10;
pub const IMAGE_REL_I386_SECREL: u32 = 11;
pub const IMAGE_REL_I386_TOKEN: u32 = 12;
pub const IMAGE_REL_I386_SECREL7: u32 = 13;
pub const IMAGE_REL_I386_REL32: u32 = 20;
pub const IMAGE_REL_MIPS_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_MIPS_REFHALF: u32 = 1;
pub const IMAGE_REL_MIPS_REFWORD: u32 = 2;
pub const IMAGE_REL_MIPS_JMPADDR: u32 = 3;
pub const IMAGE_REL_MIPS_REFHI: u32 = 4;
pub const IMAGE_REL_MIPS_REFLO: u32 = 5;
pub const IMAGE_REL_MIPS_GPREL: u32 = 6;
pub const IMAGE_REL_MIPS_LITERAL: u32 = 7;
pub const IMAGE_REL_MIPS_SECTION: u32 = 10;
pub const IMAGE_REL_MIPS_SECREL: u32 = 11;
pub const IMAGE_REL_MIPS_SECRELLO: u32 = 12;
pub const IMAGE_REL_MIPS_SECRELHI: u32 = 13;
pub const IMAGE_REL_MIPS_TOKEN: u32 = 14;
pub const IMAGE_REL_MIPS_JMPADDR16: u32 = 16;
pub const IMAGE_REL_MIPS_REFWORDNB: u32 = 34;
pub const IMAGE_REL_MIPS_PAIR: u32 = 37;
pub const IMAGE_REL_ALPHA_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ALPHA_REFLONG: u32 = 1;
pub const IMAGE_REL_ALPHA_REFQUAD: u32 = 2;
pub const IMAGE_REL_ALPHA_GPREL32: u32 = 3;
pub const IMAGE_REL_ALPHA_LITERAL: u32 = 4;
pub const IMAGE_REL_ALPHA_LITUSE: u32 = 5;
pub const IMAGE_REL_ALPHA_GPDISP: u32 = 6;
pub const IMAGE_REL_ALPHA_BRADDR: u32 = 7;
pub const IMAGE_REL_ALPHA_HINT: u32 = 8;
pub const IMAGE_REL_ALPHA_INLINE_REFLONG: u32 = 9;
pub const IMAGE_REL_ALPHA_REFHI: u32 = 10;
pub const IMAGE_REL_ALPHA_REFLO: u32 = 11;
pub const IMAGE_REL_ALPHA_PAIR: u32 = 12;
pub const IMAGE_REL_ALPHA_MATCH: u32 = 13;
pub const IMAGE_REL_ALPHA_SECTION: u32 = 14;
pub const IMAGE_REL_ALPHA_SECREL: u32 = 15;
pub const IMAGE_REL_ALPHA_REFLONGNB: u32 = 16;
pub const IMAGE_REL_ALPHA_SECRELLO: u32 = 17;
pub const IMAGE_REL_ALPHA_SECRELHI: u32 = 18;
pub const IMAGE_REL_ALPHA_REFQ3: u32 = 19;
pub const IMAGE_REL_ALPHA_REFQ2: u32 = 20;
pub const IMAGE_REL_ALPHA_REFQ1: u32 = 21;
pub const IMAGE_REL_ALPHA_GPRELLO: u32 = 22;
pub const IMAGE_REL_ALPHA_GPRELHI: u32 = 23;
pub const IMAGE_REL_PPC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_PPC_ADDR64: u32 = 1;
pub const IMAGE_REL_PPC_ADDR32: u32 = 2;
pub const IMAGE_REL_PPC_ADDR24: u32 = 3;
pub const IMAGE_REL_PPC_ADDR16: u32 = 4;
pub const IMAGE_REL_PPC_ADDR14: u32 = 5;
pub const IMAGE_REL_PPC_REL24: u32 = 6;
pub const IMAGE_REL_PPC_REL14: u32 = 7;
pub const IMAGE_REL_PPC_TOCREL16: u32 = 8;
pub const IMAGE_REL_PPC_TOCREL14: u32 = 9;
pub const IMAGE_REL_PPC_ADDR32NB: u32 = 10;
pub const IMAGE_REL_PPC_SECREL: u32 = 11;
pub const IMAGE_REL_PPC_SECTION: u32 = 12;
pub const IMAGE_REL_PPC_IFGLUE: u32 = 13;
pub const IMAGE_REL_PPC_IMGLUE: u32 = 14;
pub const IMAGE_REL_PPC_SECREL16: u32 = 15;
pub const IMAGE_REL_PPC_REFHI: u32 = 16;
pub const IMAGE_REL_PPC_REFLO: u32 = 17;
pub const IMAGE_REL_PPC_PAIR: u32 = 18;
pub const IMAGE_REL_PPC_SECRELLO: u32 = 19;
pub const IMAGE_REL_PPC_SECRELHI: u32 = 20;
pub const IMAGE_REL_PPC_GPREL: u32 = 21;
pub const IMAGE_REL_PPC_TOKEN: u32 = 22;
pub const IMAGE_REL_PPC_TYPEMASK: u32 = 255;
pub const IMAGE_REL_PPC_NEG: u32 = 256;
pub const IMAGE_REL_PPC_BRTAKEN: u32 = 512;
pub const IMAGE_REL_PPC_BRNTAKEN: u32 = 1024;
pub const IMAGE_REL_PPC_TOCDEFN: u32 = 2048;
pub const IMAGE_REL_SH3_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_SH3_DIRECT16: u32 = 1;
pub const IMAGE_REL_SH3_DIRECT32: u32 = 2;
pub const IMAGE_REL_SH3_DIRECT8: u32 = 3;
pub const IMAGE_REL_SH3_DIRECT8_WORD: u32 = 4;
pub const IMAGE_REL_SH3_DIRECT8_LONG: u32 = 5;
pub const IMAGE_REL_SH3_DIRECT4: u32 = 6;
pub const IMAGE_REL_SH3_DIRECT4_WORD: u32 = 7;
pub const IMAGE_REL_SH3_DIRECT4_LONG: u32 = 8;
pub const IMAGE_REL_SH3_PCREL8_WORD: u32 = 9;
pub const IMAGE_REL_SH3_PCREL8_LONG: u32 = 10;
pub const IMAGE_REL_SH3_PCREL12_WORD: u32 = 11;
pub const IMAGE_REL_SH3_STARTOF_SECTION: u32 = 12;
pub const IMAGE_REL_SH3_SIZEOF_SECTION: u32 = 13;
pub const IMAGE_REL_SH3_SECTION: u32 = 14;
pub const IMAGE_REL_SH3_SECREL: u32 = 15;
pub const IMAGE_REL_SH3_DIRECT32_NB: u32 = 16;
pub const IMAGE_REL_SH3_GPREL4_LONG: u32 = 17;
pub const IMAGE_REL_SH3_TOKEN: u32 = 18;
pub const IMAGE_REL_SHM_PCRELPT: u32 = 19;
pub const IMAGE_REL_SHM_REFLO: u32 = 20;
pub const IMAGE_REL_SHM_REFHALF: u32 = 21;
pub const IMAGE_REL_SHM_RELLO: u32 = 22;
pub const IMAGE_REL_SHM_RELHALF: u32 = 23;
pub const IMAGE_REL_SHM_PAIR: u32 = 24;
pub const IMAGE_REL_SH_NOMODE: u32 = 32768;
pub const IMAGE_REL_ARM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM_BRANCH24: u32 = 3;
pub const IMAGE_REL_ARM_BRANCH11: u32 = 4;
pub const IMAGE_REL_ARM_TOKEN: u32 = 5;
pub const IMAGE_REL_ARM_GPREL12: u32 = 6;
pub const IMAGE_REL_ARM_GPREL7: u32 = 7;
pub const IMAGE_REL_ARM_BLX24: u32 = 8;
pub const IMAGE_REL_ARM_BLX11: u32 = 9;
pub const IMAGE_REL_ARM_SECTION: u32 = 14;
pub const IMAGE_REL_ARM_SECREL: u32 = 15;
pub const IMAGE_REL_ARM_MOV32A: u32 = 16;
pub const IMAGE_REL_ARM_MOV32: u32 = 16;
pub const IMAGE_REL_ARM_MOV32T: u32 = 17;
pub const IMAGE_REL_THUMB_MOV32: u32 = 17;
pub const IMAGE_REL_ARM_BRANCH20T: u32 = 18;
pub const IMAGE_REL_THUMB_BRANCH20: u32 = 18;
pub const IMAGE_REL_ARM_BRANCH24T: u32 = 20;
pub const IMAGE_REL_THUMB_BRANCH24: u32 = 20;
pub const IMAGE_REL_ARM_BLX23T: u32 = 21;
pub const IMAGE_REL_THUMB_BLX23: u32 = 21;
pub const IMAGE_REL_AM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AM_ADDR32: u32 = 1;
pub const IMAGE_REL_AM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_AM_CALL32: u32 = 3;
pub const IMAGE_REL_AM_FUNCINFO: u32 = 4;
pub const IMAGE_REL_AM_REL32_1: u32 = 5;
pub const IMAGE_REL_AM_REL32_2: u32 = 6;
pub const IMAGE_REL_AM_SECREL: u32 = 7;
pub const IMAGE_REL_AM_SECTION: u32 = 8;
pub const IMAGE_REL_AM_TOKEN: u32 = 9;
pub const IMAGE_REL_ARM64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM64_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM64_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM64_BRANCH26: u32 = 3;
pub const IMAGE_REL_ARM64_PAGEBASE_REL21: u32 = 4;
pub const IMAGE_REL_ARM64_REL21: u32 = 5;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12A: u32 = 6;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12L: u32 = 7;
pub const IMAGE_REL_ARM64_SECREL: u32 = 8;
pub const IMAGE_REL_ARM64_SECREL_LOW12A: u32 = 9;
pub const IMAGE_REL_ARM64_SECREL_HIGH12A: u32 = 10;
pub const IMAGE_REL_ARM64_SECREL_LOW12L: u32 = 11;
pub const IMAGE_REL_ARM64_TOKEN: u32 = 12;
pub const IMAGE_REL_ARM64_SECTION: u32 = 13;
pub const IMAGE_REL_ARM64_ADDR64: u32 = 14;
pub const IMAGE_REL_ARM64_BRANCH19: u32 = 15;
pub const IMAGE_REL_AMD64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AMD64_ADDR64: u32 = 1;
pub const IMAGE_REL_AMD64_ADDR32: u32 = 2;
pub const IMAGE_REL_AMD64_ADDR32NB: u32 = 3;
pub const IMAGE_REL_AMD64_REL32: u32 = 4;
pub const IMAGE_REL_AMD64_REL32_1: u32 = 5;
pub const IMAGE_REL_AMD64_REL32_2: u32 = 6;
pub const IMAGE_REL_AMD64_REL32_3: u32 = 7;
pub const IMAGE_REL_AMD64_REL32_4: u32 = 8;
pub const IMAGE_REL_AMD64_REL32_5: u32 = 9;
pub const IMAGE_REL_AMD64_SECTION: u32 = 10;
pub const IMAGE_REL_AMD64_SECREL: u32 = 11;
pub const IMAGE_REL_AMD64_SECREL7: u32 = 12;
pub const IMAGE_REL_AMD64_TOKEN: u32 = 13;
pub const IMAGE_REL_AMD64_SREL32: u32 = 14;
pub const IMAGE_REL_AMD64_PAIR: u32 = 15;
pub const IMAGE_REL_AMD64_SSPAN32: u32 = 16;
pub const IMAGE_REL_IA64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_IA64_IMM14: u32 = 1;
pub const IMAGE_REL_IA64_IMM22: u32 = 2;
pub const IMAGE_REL_IA64_IMM64: u32 = 3;
pub const IMAGE_REL_IA64_DIR32: u32 = 4;
pub const IMAGE_REL_IA64_DIR64: u32 = 5;
pub const IMAGE_REL_IA64_PCREL21B: u32 = 6;
pub const IMAGE_REL_IA64_PCREL21M: u32 = 7;
pub const IMAGE_REL_IA64_PCREL21F: u32 = 8;
pub const IMAGE_REL_IA64_GPREL22: u32 = 9;
pub const IMAGE_REL_IA64_LTOFF22: u32 = 10;
pub const IMAGE_REL_IA64_SECTION: u32 = 11;
pub const IMAGE_REL_IA64_SECREL22: u32 = 12;
pub const IMAGE_REL_IA64_SECREL64I: u32 = 13;
pub const IMAGE_REL_IA64_SECREL32: u32 = 14;
pub const IMAGE_REL_IA64_DIR32NB: u32 = 16;
pub const IMAGE_REL_IA64_SREL14: u32 = 17;
pub const IMAGE_REL_IA64_SREL22: u32 = 18;
pub const IMAGE_REL_IA64_SREL32: u32 = 19;
pub const IMAGE_REL_IA64_UREL32: u32 = 20;
pub const IMAGE_REL_IA64_PCREL60X: u32 = 21;
pub const IMAGE_REL_IA64_PCREL60B: u32 = 22;
pub const IMAGE_REL_IA64_PCREL60F: u32 = 23;
pub const IMAGE_REL_IA64_PCREL60I: u32 = 24;
pub const IMAGE_REL_IA64_PCREL60M: u32 = 25;
pub const IMAGE_REL_IA64_IMMGPREL64: u32 = 26;
pub const IMAGE_REL_IA64_TOKEN: u32 = 27;
pub const IMAGE_REL_IA64_GPREL32: u32 = 28;
pub const IMAGE_REL_IA64_ADDEND: u32 = 31;
pub const IMAGE_REL_CEF_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEF_ADDR32: u32 = 1;
pub const IMAGE_REL_CEF_ADDR64: u32 = 2;
pub const IMAGE_REL_CEF_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEF_SECTION: u32 = 4;
pub const IMAGE_REL_CEF_SECREL: u32 = 5;
pub const IMAGE_REL_CEF_TOKEN: u32 = 6;
pub const IMAGE_REL_CEE_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEE_ADDR32: u32 = 1;
pub const IMAGE_REL_CEE_ADDR64: u32 = 2;
pub const IMAGE_REL_CEE_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEE_SECTION: u32 = 4;
pub const IMAGE_REL_CEE_SECREL: u32 = 5;
pub const IMAGE_REL_CEE_TOKEN: u32 = 6;
pub const IMAGE_REL_M32R_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_M32R_ADDR32: u32 = 1;
pub const IMAGE_REL_M32R_ADDR32NB: u32 = 2;
pub const IMAGE_REL_M32R_ADDR24: u32 = 3;
pub const IMAGE_REL_M32R_GPREL16: u32 = 4;
pub const IMAGE_REL_M32R_PCREL24: u32 = 5;
pub const IMAGE_REL_M32R_PCREL16: u32 = 6;
pub const IMAGE_REL_M32R_PCREL8: u32 = 7;
pub const IMAGE_REL_M32R_REFHALF: u32 = 8;
pub const IMAGE_REL_M32R_REFHI: u32 = 9;
pub const IMAGE_REL_M32R_REFLO: u32 = 10;
pub const IMAGE_REL_M32R_PAIR: u32 = 11;
pub const IMAGE_REL_M32R_SECTION: u32 = 12;
pub const IMAGE_REL_M32R_SECREL32: u32 = 13;
pub const IMAGE_REL_M32R_TOKEN: u32 = 14;
pub const IMAGE_REL_EBC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_EBC_ADDR32NB: u32 = 1;
pub const IMAGE_REL_EBC_REL32: u32 = 2;
pub const IMAGE_REL_EBC_SECTION: u32 = 3;
pub const IMAGE_REL_EBC_SECREL: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM7B_SIZE_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM9D_SIZE_X: u32 = 9;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X: u32 = 18;
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM5C_SIZE_X: u32 = 5;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X: u32 = 13;
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X: u32 = 16;
pub const EMARCH_ENC_I17_IC_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IC_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X: u32 = 12;
pub const EMARCH_ENC_I17_IC_VAL_POS_X: u32 = 21;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41a_SIZE_X: u32 = 10;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X: u32 = 14;
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X: u32 = 22;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41b_SIZE_X: u32 = 8;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X: u32 = 24;
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X: u32 = 32;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X: u32 = 2;
pub const EMARCH_ENC_I17_IMM41c_SIZE_X: u32 = 23;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X: u32 = 40;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_SIGN_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X: u32 = 27;
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X: u32 = 63;
pub const X3_OPCODE_INST_WORD_X: u32 = 3;
pub const X3_OPCODE_SIZE_X: u32 = 4;
pub const X3_OPCODE_INST_WORD_POS_X: u32 = 28;
pub const X3_OPCODE_SIGN_VAL_POS_X: u32 = 0;
pub const X3_I_INST_WORD_X: u32 = 3;
pub const X3_I_SIZE_X: u32 = 1;
pub const X3_I_INST_WORD_POS_X: u32 = 27;
pub const X3_I_SIGN_VAL_POS_X: u32 = 59;
pub const X3_D_WH_INST_WORD_X: u32 = 3;
pub const X3_D_WH_SIZE_X: u32 = 3;
pub const X3_D_WH_INST_WORD_POS_X: u32 = 24;
pub const X3_D_WH_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM20_INST_WORD_X: u32 = 3;
pub const X3_IMM20_SIZE_X: u32 = 20;
pub const X3_IMM20_INST_WORD_POS_X: u32 = 4;
pub const X3_IMM20_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM39_1_INST_WORD_X: u32 = 2;
pub const X3_IMM39_1_SIZE_X: u32 = 23;
pub const X3_IMM39_1_INST_WORD_POS_X: u32 = 0;
pub const X3_IMM39_1_SIGN_VAL_POS_X: u32 = 36;
pub const X3_IMM39_2_INST_WORD_X: u32 = 1;
pub const X3_IMM39_2_SIZE_X: u32 = 16;
pub const X3_IMM39_2_INST_WORD_POS_X: u32 = 16;
pub const X3_IMM39_2_SIGN_VAL_POS_X: u32 = 20;
pub const X3_P_INST_WORD_X: u32 = 3;
pub const X3_P_SIZE_X: u32 = 4;
pub const X3_P_INST_WORD_POS_X: u32 = 0;
pub const X3_P_SIGN_VAL_POS_X: u32 = 0;
pub const X3_TMPLT_INST_WORD_X: u32 = 0;
pub const X3_TMPLT_SIZE_X: u32 = 4;
pub const X3_TMPLT_INST_WORD_POS_X: u32 = 0;
pub const X3_TMPLT_SIGN_VAL_POS_X: u32 = 0;
pub const X3_BTYPE_QP_INST_WORD_X: u32 = 2;
pub const X3_BTYPE_QP_SIZE_X: u32 = 9;
pub const X3_BTYPE_QP_INST_WORD_POS_X: u32 = 23;
pub const X3_BTYPE_QP_INST_VAL_POS_X: u32 = 0;
pub const X3_EMPTY_INST_WORD_X: u32 = 1;
pub const X3_EMPTY_SIZE_X: u32 = 2;
pub const X3_EMPTY_INST_WORD_POS_X: u32 = 14;
pub const X3_EMPTY_INST_VAL_POS_X: u32 = 0;
pub const IMAGE_REL_BASED_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_BASED_HIGH: u32 = 1;
pub const IMAGE_REL_BASED_LOW: u32 = 2;
pub const IMAGE_REL_BASED_HIGHLOW: u32 = 3;
pub const IMAGE_REL_BASED_HIGHADJ: u32 = 4;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_5: u32 = 5;
pub const IMAGE_REL_BASED_RESERVED: u32 = 6;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_7: u32 = 7;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_8: u32 = 8;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_9: u32 = 9;
pub const IMAGE_REL_BASED_DIR64: u32 = 10;
pub const IMAGE_REL_BASED_IA64_IMM64: u32 = 9;
pub const IMAGE_REL_BASED_MIPS_JMPADDR: u32 = 5;
pub const IMAGE_REL_BASED_MIPS_JMPADDR16: u32 = 9;
pub const IMAGE_REL_BASED_ARM_MOV32: u32 = 5;
pub const IMAGE_REL_BASED_THUMB_MOV32: u32 = 7;
pub const IMAGE_ARCHIVE_START_SIZE: u32 = 8;
pub const IMAGE_ARCHIVE_START: &'static [u8; 9usize] = b"!<arch>\n\0";
pub const IMAGE_ARCHIVE_END: &'static [u8; 3usize] = b"`\n\0";
pub const IMAGE_ARCHIVE_PAD: &'static [u8; 2usize] = b"\n\0";
pub const IMAGE_ARCHIVE_LINKER_MEMBER: &'static [u8; 17usize] = b"/               \0";
pub const IMAGE_ARCHIVE_LONGNAMES_MEMBER: &'static [u8; 17usize] = b"//              \0";
pub const IMAGE_ARCHIVE_HYBRIDMAP_MEMBER: &'static [u8; 17usize] = b"/<HYBRIDMAP>/   \0";
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR: u32 = 60;
pub const IMAGE_ORDINAL_FLAG64: i64 = -9223372036854775808;
pub const IMAGE_ORDINAL_FLAG32: u32 = 2147483648;
pub const IMAGE_ORDINAL_FLAG: i64 = -9223372036854775808;
pub const IMAGE_RESOURCE_NAME_IS_STRING: u32 = 2147483648;
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY: u32 = 2147483648;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE: u32 = 1;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE: u32 = 2;
pub const IMAGE_HOT_PATCH_BASE_OBLIGATORY: u32 = 1;
pub const IMAGE_HOT_PATCH_CHUNK_INVERSE: u32 = 2147483648;
pub const IMAGE_HOT_PATCH_CHUNK_OBLIGATORY: u32 = 1073741824;
pub const IMAGE_HOT_PATCH_CHUNK_RESERVED: u32 = 1072705536;
pub const IMAGE_HOT_PATCH_CHUNK_TYPE: u32 = 1032192;
pub const IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA: u32 = 32768;
pub const IMAGE_HOT_PATCH_CHUNK_TARGET_RVA: u32 = 16384;
pub const IMAGE_HOT_PATCH_CHUNK_SIZE: u32 = 4095;
pub const IMAGE_HOT_PATCH_NONE: u32 = 0;
pub const IMAGE_HOT_PATCH_FUNCTION: u32 = 114688;
pub const IMAGE_HOT_PATCH_ABSOLUTE: u32 = 180224;
pub const IMAGE_HOT_PATCH_REL32: u32 = 245760;
pub const IMAGE_HOT_PATCH_CALL_TARGET: u32 = 278528;
pub const IMAGE_HOT_PATCH_INDIRECT: u32 = 376832;
pub const IMAGE_HOT_PATCH_NO_CALL_TARGET: u32 = 409600;
pub const IMAGE_HOT_PATCH_DYNAMIC_VALUE: u32 = 491520;
pub const IMAGE_GUARD_CF_INSTRUMENTED: u32 = 256;
pub const IMAGE_GUARD_CFW_INSTRUMENTED: u32 = 512;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT: u32 = 1024;
pub const IMAGE_GUARD_SECURITY_COOKIE_UNUSED: u32 = 2048;
pub const IMAGE_GUARD_PROTECT_DELAYLOAD_IAT: u32 = 4096;
pub const IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION: u32 = 8192;
pub const IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT: u32 = 16384;
pub const IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION: u32 = 32768;
pub const IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT: u32 = 65536;
pub const IMAGE_GUARD_RF_INSTRUMENTED: u32 = 131072;
pub const IMAGE_GUARD_RF_ENABLE: u32 = 262144;
pub const IMAGE_GUARD_RF_STRICT: u32 = 524288;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK: u32 = 4026531840;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT: u32 = 28;
pub const IMAGE_GUARD_FLAG_FID_SUPPRESSED: u32 = 1;
pub const IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED: u32 = 2;
pub const IMAGE_ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const IMAGE_ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const IMAGE_ENCLAVE_POLICY_DEBUGGABLE: u32 = 1;
pub const IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE: u32 = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_NONE: u32 = 0;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID: u32 = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID: u32 = 2;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID: u32 = 3;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID: u32 = 4;
pub const IMAGE_DEBUG_TYPE_UNKNOWN: u32 = 0;
pub const IMAGE_DEBUG_TYPE_COFF: u32 = 1;
pub const IMAGE_DEBUG_TYPE_CODEVIEW: u32 = 2;
pub const IMAGE_DEBUG_TYPE_FPO: u32 = 3;
pub const IMAGE_DEBUG_TYPE_MISC: u32 = 4;
pub const IMAGE_DEBUG_TYPE_EXCEPTION: u32 = 5;
pub const IMAGE_DEBUG_TYPE_FIXUP: u32 = 6;
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC: u32 = 7;
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: u32 = 8;
pub const IMAGE_DEBUG_TYPE_BORLAND: u32 = 9;
pub const IMAGE_DEBUG_TYPE_RESERVED10: u32 = 10;
pub const IMAGE_DEBUG_TYPE_CLSID: u32 = 11;
pub const IMAGE_DEBUG_TYPE_VC_FEATURE: u32 = 12;
pub const IMAGE_DEBUG_TYPE_POGO: u32 = 13;
pub const IMAGE_DEBUG_TYPE_ILTCG: u32 = 14;
pub const IMAGE_DEBUG_TYPE_MPX: u32 = 15;
pub const IMAGE_DEBUG_TYPE_REPRO: u32 = 16;
pub const FRAME_FPO: u32 = 0;
pub const FRAME_TRAP: u32 = 1;
pub const FRAME_TSS: u32 = 2;
pub const FRAME_NONFPO: u32 = 3;
pub const SIZEOF_RFPO_DATA: u32 = 16;
pub const IMAGE_DEBUG_MISC_EXENAME: u32 = 1;
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE: u32 = 18756;
pub const NON_PAGED_DEBUG_SIGNATURE: u32 = 18766;
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK: u32 = 32768;
pub const IMAGE_SEPARATE_DEBUG_MISMATCH: u32 = 32768;
pub const IMPORT_OBJECT_HDR_SIG2: u32 = 65535;
pub const RTL_RUN_ONCE_CHECK_ONLY: u32 = 1;
pub const RTL_RUN_ONCE_ASYNC: u32 = 2;
pub const RTL_RUN_ONCE_INIT_FAILED: u32 = 4;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4;
pub const FAST_FAIL_INVALID_ARG: u32 = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: u32 = 10;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: u32 = 11;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: u32 = 12;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: u32 = 13;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: u32 = 14;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: u32 = 18;
pub const FAST_FAIL_MRDATA_MODIFIED: u32 = 19;
pub const FAST_FAIL_CERTIFICATION_FAILURE: u32 = 20;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: u32 = 21;
pub const FAST_FAIL_CRYPTO_LIBRARY: u32 = 22;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: u32 = 23;
pub const FAST_FAIL_INVALID_IMAGE_BASE: u32 = 24;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: u32 = 25;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: u32 = 26;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: u32 = 27;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: u32 = 28;
pub const FAST_FAIL_INVALID_BALANCED_TREE: u32 = 29;
pub const FAST_FAIL_INVALID_NEXT_THREAD: u32 = 30;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: u32 = 31;
pub const FAST_FAIL_APCS_DISABLED: u32 = 32;
pub const FAST_FAIL_INVALID_IDLE_STATE: u32 = 33;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: u32 = 34;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: u32 = 35;
pub const FAST_FAIL_INVALID_LOCK_STATE: u32 = 36;
pub const FAST_FAIL_GUARD_JUMPTABLE: u32 = 37;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: u32 = 38;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: u32 = 39;
pub const FAST_FAIL_INVALID_THREAD: u32 = 40;
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER: u32 = 41;
pub const FAST_FAIL_INVALID_FILE_OPERATION: u32 = 42;
pub const FAST_FAIL_LPAC_ACCESS_DENIED: u32 = 43;
pub const FAST_FAIL_GUARD_SS_FAILURE: u32 = 44;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE: u32 = 45;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE: u32 = 46;
pub const FAST_FAIL_INVALID_CONTROL_STACK: u32 = 47;
pub const FAST_FAIL_SET_CONTEXT_DENIED: u32 = 48;
pub const FAST_FAIL_INVALID_IAT: u32 = 49;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION: u32 = 50;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION: u32 = 51;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED: u32 = 52;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE: u32 = 53;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON: u32 = 54;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295;
pub const HEAP_NO_SERIALIZE: u32 = 1;
pub const HEAP_GROWABLE: u32 = 2;
pub const HEAP_GENERATE_EXCEPTIONS: u32 = 4;
pub const HEAP_ZERO_MEMORY: u32 = 8;
pub const HEAP_REALLOC_IN_PLACE_ONLY: u32 = 16;
pub const HEAP_TAIL_CHECKING_ENABLED: u32 = 32;
pub const HEAP_FREE_CHECKING_ENABLED: u32 = 64;
pub const HEAP_DISABLE_COALESCE_ON_FREE: u32 = 128;
pub const HEAP_CREATE_ALIGN_16: u32 = 65536;
pub const HEAP_CREATE_ENABLE_TRACING: u32 = 131072;
pub const HEAP_CREATE_ENABLE_EXECUTE: u32 = 262144;
pub const HEAP_MAXIMUM_TAG: u32 = 4095;
pub const HEAP_PSEUDO_TAG_FLAG: u32 = 32768;
pub const HEAP_TAG_SHIFT: u32 = 18;
pub const HEAP_CREATE_SEGMENT_HEAP: u32 = 256;
pub const HEAP_CREATE_HARDENED: u32 = 512;
pub const IS_TEXT_UNICODE_ASCII16: u32 = 1;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16: u32 = 16;
pub const IS_TEXT_UNICODE_STATISTICS: u32 = 2;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS: u32 = 32;
pub const IS_TEXT_UNICODE_CONTROLS: u32 = 4;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS: u32 = 64;
pub const IS_TEXT_UNICODE_SIGNATURE: u32 = 8;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE: u32 = 128;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS: u32 = 256;
pub const IS_TEXT_UNICODE_ODD_LENGTH: u32 = 512;
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE: u32 = 1024;
pub const IS_TEXT_UNICODE_NULL_BYTES: u32 = 4096;
pub const IS_TEXT_UNICODE_UNICODE_MASK: u32 = 15;
pub const IS_TEXT_UNICODE_REVERSE_MASK: u32 = 240;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK: u32 = 3840;
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK: u32 = 61440;
pub const COMPRESSION_FORMAT_NONE: u32 = 0;
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1;
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2;
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3;
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4;
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0;
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256;
pub const COMPRESSION_ENGINE_HIBER: u32 = 512;
pub const SEF_DACL_AUTO_INHERIT: u32 = 1;
pub const SEF_SACL_AUTO_INHERIT: u32 = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8;
pub const SEF_AVOID_OWNER_CHECK: u32 = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64;
pub const SEF_MACL_NO_WRITE_UP: u32 = 256;
pub const SEF_MACL_NO_READ_UP: u32 = 512;
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024;
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048;
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096;
pub const SEF_MACL_VALID_FLAGS: u32 = 1792;
pub const MESSAGE_RESOURCE_UNICODE: u32 = 1;
pub const VER_EQUAL: u32 = 1;
pub const VER_GREATER: u32 = 2;
pub const VER_GREATER_EQUAL: u32 = 3;
pub const VER_LESS: u32 = 4;
pub const VER_LESS_EQUAL: u32 = 5;
pub const VER_AND: u32 = 6;
pub const VER_OR: u32 = 7;
pub const VER_CONDITION_MASK: u32 = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3;
pub const VER_MINORVERSION: u32 = 1;
pub const VER_MAJORVERSION: u32 = 2;
pub const VER_BUILDNUMBER: u32 = 4;
pub const VER_PLATFORMID: u32 = 8;
pub const VER_SERVICEPACKMINOR: u32 = 16;
pub const VER_SERVICEPACKMAJOR: u32 = 32;
pub const VER_SUITENAME: u32 = 64;
pub const VER_PRODUCT_TYPE: u32 = 128;
pub const VER_NT_WORKSTATION: u32 = 1;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2;
pub const VER_NT_SERVER: u32 = 3;
pub const VER_PLATFORM_WIN32s: u32 = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: u32 = 1;
pub const VER_PLATFORM_WIN32_NT: u32 = 2;
pub const RTL_UMS_VERSION: u32 = 256;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256;
pub const VRL_CLASS_CONSISTENCY: u32 = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648;
pub const CTMF_INCLUDE_APPCONTAINER: u32 = 1;
pub const CTMF_INCLUDE_LPAC: u32 = 2;
pub const CTMF_VALID_FLAGS: u32 = 3;
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN: u32 = 1;
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH: u32 = 129;
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH: u32 = 16;
pub const RTL_CORRELATION_VECTOR_V1_LENGTH: u32 = 64;
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH: u32 = 22;
pub const RTL_CORRELATION_VECTOR_V2_LENGTH: u32 = 128;
pub const IMAGE_POLICY_METADATA_VERSION: u32 = 1;
pub const IMAGE_POLICY_SECTION_NAME: &'static [u8; 9usize] = b".tPolicy\0";
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO: u32 = 16777216;
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN: u32 = 33554432;
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT: u32 = 67108864;
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE: u32 = 134217728;
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO: u32 = 268435456;
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS: u32 = 4278190080;
pub const RTL_CRITICAL_SECTION_FLAG_RESERVED: u32 = 3758096384;
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT: u32 = 1;
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION: u32 = 1;
pub const WT_EXECUTEDEFAULT: u32 = 0;
pub const WT_EXECUTEINIOTHREAD: u32 = 1;
pub const WT_EXECUTEINUITHREAD: u32 = 2;
pub const WT_EXECUTEINWAITTHREAD: u32 = 4;
pub const WT_EXECUTEONLYONCE: u32 = 8;
pub const WT_EXECUTEINTIMERTHREAD: u32 = 32;
pub const WT_EXECUTELONGFUNCTION: u32 = 16;
pub const WT_EXECUTEINPERSISTENTIOTHREAD: u32 = 64;
pub const WT_EXECUTEINPERSISTENTTHREAD: u32 = 128;
pub const WT_TRANSFER_IMPERSONATION: u32 = 256;
pub const WT_EXECUTEINLONGTHREAD: u32 = 16;
pub const WT_EXECUTEDELETEWAIT: u32 = 8;
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE: u32 = 1;
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE: u32 = 2;
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL: u32 = 3;
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF: u32 = 4;
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1;
pub const PERFORMANCE_DATA_VERSION: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS: u32 = 2;
pub const UNIFIEDBUILDREVISION_KEY: &'static [u8; 63usize] =
  b"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\0";
pub const UNIFIEDBUILDREVISION_VALUE: &'static [u8; 4usize] = b"UBR\0";
pub const UNIFIEDBUILDREVISION_MIN: u32 = 0;
pub const DEVICEFAMILYDEVICEFORM_KEY: &'static [u8; 67usize] =
  b"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\OEM\0";
pub const DEVICEFAMILYDEVICEFORM_VALUE: &'static [u8; 11usize] = b"DeviceForm\0";
pub const DEVICEFAMILYINFOENUM_UAP: u32 = 0;
pub const DEVICEFAMILYINFOENUM_WINDOWS_8X: u32 = 1;
pub const DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X: u32 = 2;
pub const DEVICEFAMILYINFOENUM_DESKTOP: u32 = 3;
pub const DEVICEFAMILYINFOENUM_MOBILE: u32 = 4;
pub const DEVICEFAMILYINFOENUM_XBOX: u32 = 5;
pub const DEVICEFAMILYINFOENUM_TEAM: u32 = 6;
pub const DEVICEFAMILYINFOENUM_IOT: u32 = 7;
pub const DEVICEFAMILYINFOENUM_IOT_HEADLESS: u32 = 8;
pub const DEVICEFAMILYINFOENUM_SERVER: u32 = 9;
pub const DEVICEFAMILYINFOENUM_HOLOGRAPHIC: u32 = 10;
pub const DEVICEFAMILYINFOENUM_XBOXSRA: u32 = 11;
pub const DEVICEFAMILYINFOENUM_XBOXERA: u32 = 12;
pub const DEVICEFAMILYINFOENUM_SERVER_NANO: u32 = 13;
pub const DEVICEFAMILYINFOENUM_8828080: u32 = 14;
pub const DEVICEFAMILYINFOENUM_MAX: u32 = 14;
pub const DEVICEFAMILYDEVICEFORM_UNKNOWN: u32 = 0;
pub const DEVICEFAMILYDEVICEFORM_PHONE: u32 = 1;
pub const DEVICEFAMILYDEVICEFORM_TABLET: u32 = 2;
pub const DEVICEFAMILYDEVICEFORM_DESKTOP: u32 = 3;
pub const DEVICEFAMILYDEVICEFORM_NOTEBOOK: u32 = 4;
pub const DEVICEFAMILYDEVICEFORM_CONVERTIBLE: u32 = 5;
pub const DEVICEFAMILYDEVICEFORM_DETACHABLE: u32 = 6;
pub const DEVICEFAMILYDEVICEFORM_ALLINONE: u32 = 7;
pub const DEVICEFAMILYDEVICEFORM_STICKPC: u32 = 8;
pub const DEVICEFAMILYDEVICEFORM_PUCK: u32 = 9;
pub const DEVICEFAMILYDEVICEFORM_LARGESCREEN: u32 = 10;
pub const DEVICEFAMILYDEVICEFORM_HMD: u32 = 11;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD: u32 = 12;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET: u32 = 13;
pub const DEVICEFAMILYDEVICEFORM_BANKING: u32 = 14;
pub const DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION: u32 = 15;
pub const DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE: u32 = 16;
pub const DEVICEFAMILYDEVICEFORM_GAMING: u32 = 17;
pub const DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION: u32 = 18;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION: u32 = 19;
pub const DEVICEFAMILYDEVICEFORM_KIOSK: u32 = 20;
pub const DEVICEFAMILYDEVICEFORM_MAKER_BOARD: u32 = 21;
pub const DEVICEFAMILYDEVICEFORM_MEDICAL: u32 = 22;
pub const DEVICEFAMILYDEVICEFORM_NETWORKING: u32 = 23;
pub const DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE: u32 = 24;
pub const DEVICEFAMILYDEVICEFORM_PRINTING: u32 = 25;
pub const DEVICEFAMILYDEVICEFORM_THIN_CLIENT: u32 = 26;
pub const DEVICEFAMILYDEVICEFORM_TOY: u32 = 27;
pub const DEVICEFAMILYDEVICEFORM_VENDING: u32 = 28;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER: u32 = 29;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE: u32 = 30;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_S: u32 = 31;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X: u32 = 32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT: u32 = 33;
pub const DEVICEFAMILYDEVICEFORM_MAX: u32 = 33;
pub const DLL_PROCESS_ATTACH: u32 = 1;
pub const DLL_THREAD_ATTACH: u32 = 2;
pub const DLL_THREAD_DETACH: u32 = 3;
pub const DLL_PROCESS_DETACH: u32 = 0;
pub const EVENTLOG_SEQUENTIAL_READ: u32 = 1;
pub const EVENTLOG_SEEK_READ: u32 = 2;
pub const EVENTLOG_FORWARDS_READ: u32 = 4;
pub const EVENTLOG_BACKWARDS_READ: u32 = 8;
pub const EVENTLOG_SUCCESS: u32 = 0;
pub const EVENTLOG_ERROR_TYPE: u32 = 1;
pub const EVENTLOG_WARNING_TYPE: u32 = 2;
pub const EVENTLOG_INFORMATION_TYPE: u32 = 4;
pub const EVENTLOG_AUDIT_SUCCESS: u32 = 8;
pub const EVENTLOG_AUDIT_FAILURE: u32 = 16;
pub const EVENTLOG_START_PAIRED_EVENT: u32 = 1;
pub const EVENTLOG_END_PAIRED_EVENT: u32 = 2;
pub const EVENTLOG_END_ALL_PAIRED_EVENTS: u32 = 4;
pub const EVENTLOG_PAIRED_EVENT_ACTIVE: u32 = 8;
pub const EVENTLOG_PAIRED_EVENT_INACTIVE: u32 = 16;
pub const MAXLOGICALLOGNAMESIZE: u32 = 256;
pub const KEY_QUERY_VALUE: u32 = 1;
pub const KEY_SET_VALUE: u32 = 2;
pub const KEY_CREATE_SUB_KEY: u32 = 4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 8;
pub const KEY_NOTIFY: u32 = 16;
pub const KEY_CREATE_LINK: u32 = 32;
pub const KEY_WOW64_32KEY: u32 = 512;
pub const KEY_WOW64_64KEY: u32 = 256;
pub const KEY_WOW64_RES: u32 = 768;
pub const KEY_READ: u32 = 131097;
pub const KEY_WRITE: u32 = 131078;
pub const KEY_EXECUTE: u32 = 131097;
pub const KEY_ALL_ACCESS: u32 = 983103;
pub const REG_OPTION_RESERVED: u32 = 0;
pub const REG_OPTION_NON_VOLATILE: u32 = 0;
pub const REG_OPTION_VOLATILE: u32 = 1;
pub const REG_OPTION_CREATE_LINK: u32 = 2;
pub const REG_OPTION_BACKUP_RESTORE: u32 = 4;
pub const REG_OPTION_OPEN_LINK: u32 = 8;
pub const REG_OPTION_DONT_VIRTUALIZE: u32 = 16;
pub const REG_LEGAL_OPTION: u32 = 31;
pub const REG_OPEN_LEGAL_OPTION: u32 = 28;
pub const REG_CREATED_NEW_KEY: u32 = 1;
pub const REG_OPENED_EXISTING_KEY: u32 = 2;
pub const REG_STANDARD_FORMAT: u32 = 1;
pub const REG_LATEST_FORMAT: u32 = 2;
pub const REG_NO_COMPRESSION: u32 = 4;
pub const REG_WHOLE_HIVE_VOLATILE: u32 = 1;
pub const REG_REFRESH_HIVE: u32 = 2;
pub const REG_NO_LAZY_FLUSH: u32 = 4;
pub const REG_FORCE_RESTORE: u32 = 8;
pub const REG_APP_HIVE: u32 = 16;
pub const REG_PROCESS_PRIVATE: u32 = 32;
pub const REG_START_JOURNAL: u32 = 64;
pub const REG_HIVE_EXACT_FILE_GROWTH: u32 = 128;
pub const REG_HIVE_NO_RM: u32 = 256;
pub const REG_HIVE_SINGLE_LOG: u32 = 512;
pub const REG_BOOT_HIVE: u32 = 1024;
pub const REG_LOAD_HIVE_OPEN_HANDLE: u32 = 2048;
pub const REG_FLUSH_HIVE_FILE_GROWTH: u32 = 4096;
pub const REG_OPEN_READ_ONLY: u32 = 8192;
pub const REG_IMMUTABLE: u32 = 16384;
pub const REG_APP_HIVE_OPEN_READ_ONLY: u32 = 8192;
pub const REG_FORCE_UNLOAD: u32 = 1;
pub const REG_UNLOAD_LEGAL_FLAGS: u32 = 1;
pub const REG_NOTIFY_CHANGE_NAME: u32 = 1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: u32 = 2;
pub const REG_NOTIFY_CHANGE_LAST_SET: u32 = 4;
pub const REG_NOTIFY_CHANGE_SECURITY: u32 = 8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: u32 = 268435456;
pub const REG_LEGAL_CHANGE_FILTER: u32 = 268435471;
pub const REG_NONE: u32 = 0;
pub const REG_SZ: u32 = 1;
pub const REG_EXPAND_SZ: u32 = 2;
pub const REG_BINARY: u32 = 3;
pub const REG_DWORD: u32 = 4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 5;
pub const REG_LINK: u32 = 6;
pub const REG_MULTI_SZ: u32 = 7;
pub const REG_RESOURCE_LIST: u32 = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 10;
pub const REG_QWORD: u32 = 11;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 11;
pub const SERVICE_KERNEL_DRIVER: u32 = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: u32 = 2;
pub const SERVICE_ADAPTER: u32 = 4;
pub const SERVICE_RECOGNIZER_DRIVER: u32 = 8;
pub const SERVICE_DRIVER: u32 = 11;
pub const SERVICE_WIN32_OWN_PROCESS: u32 = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: u32 = 32;
pub const SERVICE_WIN32: u32 = 48;
pub const SERVICE_USER_SERVICE: u32 = 64;
pub const SERVICE_USERSERVICE_INSTANCE: u32 = 128;
pub const SERVICE_USER_SHARE_PROCESS: u32 = 96;
pub const SERVICE_USER_OWN_PROCESS: u32 = 80;
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256;
pub const SERVICE_PKG_SERVICE: u32 = 512;
pub const SERVICE_TYPE_ALL: u32 = 1023;
pub const SERVICE_BOOT_START: u32 = 0;
pub const SERVICE_SYSTEM_START: u32 = 1;
pub const SERVICE_AUTO_START: u32 = 2;
pub const SERVICE_DEMAND_START: u32 = 3;
pub const SERVICE_DISABLED: u32 = 4;
pub const SERVICE_ERROR_IGNORE: u32 = 0;
pub const SERVICE_ERROR_NORMAL: u32 = 1;
pub const SERVICE_ERROR_SEVERE: u32 = 2;
pub const SERVICE_ERROR_CRITICAL: u32 = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128;
pub const CM_SERVICE_VALID_PROMOTION_MASK: u32 = 255;
pub const TAPE_ERASE_SHORT: u32 = 0;
pub const TAPE_ERASE_LONG: u32 = 1;
pub const TAPE_LOAD: u32 = 0;
pub const TAPE_UNLOAD: u32 = 1;
pub const TAPE_TENSION: u32 = 2;
pub const TAPE_LOCK: u32 = 3;
pub const TAPE_UNLOCK: u32 = 4;
pub const TAPE_FORMAT: u32 = 5;
pub const TAPE_SETMARKS: u32 = 0;
pub const TAPE_FILEMARKS: u32 = 1;
pub const TAPE_SHORT_FILEMARKS: u32 = 2;
pub const TAPE_LONG_FILEMARKS: u32 = 3;
pub const TAPE_ABSOLUTE_POSITION: u32 = 0;
pub const TAPE_LOGICAL_POSITION: u32 = 1;
pub const TAPE_PSEUDO_LOGICAL_POSITION: u32 = 2;
pub const TAPE_REWIND: u32 = 0;
pub const TAPE_ABSOLUTE_BLOCK: u32 = 1;
pub const TAPE_LOGICAL_BLOCK: u32 = 2;
pub const TAPE_PSEUDO_LOGICAL_BLOCK: u32 = 3;
pub const TAPE_SPACE_END_OF_DATA: u32 = 4;
pub const TAPE_SPACE_RELATIVE_BLOCKS: u32 = 5;
pub const TAPE_SPACE_FILEMARKS: u32 = 6;
pub const TAPE_SPACE_SEQUENTIAL_FMKS: u32 = 7;
pub const TAPE_SPACE_SETMARKS: u32 = 8;
pub const TAPE_SPACE_SEQUENTIAL_SMKS: u32 = 9;
pub const TAPE_DRIVE_FIXED: u32 = 1;
pub const TAPE_DRIVE_SELECT: u32 = 2;
pub const TAPE_DRIVE_INITIATOR: u32 = 4;
pub const TAPE_DRIVE_ERASE_SHORT: u32 = 16;
pub const TAPE_DRIVE_ERASE_LONG: u32 = 32;
pub const TAPE_DRIVE_ERASE_BOP_ONLY: u32 = 64;
pub const TAPE_DRIVE_ERASE_IMMEDIATE: u32 = 128;
pub const TAPE_DRIVE_TAPE_CAPACITY: u32 = 256;
pub const TAPE_DRIVE_TAPE_REMAINING: u32 = 512;
pub const TAPE_DRIVE_FIXED_BLOCK: u32 = 1024;
pub const TAPE_DRIVE_VARIABLE_BLOCK: u32 = 2048;
pub const TAPE_DRIVE_WRITE_PROTECT: u32 = 4096;
pub const TAPE_DRIVE_EOT_WZ_SIZE: u32 = 8192;
pub const TAPE_DRIVE_ECC: u32 = 65536;
pub const TAPE_DRIVE_COMPRESSION: u32 = 131072;
pub const TAPE_DRIVE_PADDING: u32 = 262144;
pub const TAPE_DRIVE_REPORT_SMKS: u32 = 524288;
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK: u32 = 1048576;
pub const TAPE_DRIVE_GET_LOGICAL_BLK: u32 = 2097152;
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE: u32 = 4194304;
pub const TAPE_DRIVE_EJECT_MEDIA: u32 = 16777216;
pub const TAPE_DRIVE_CLEAN_REQUESTS: u32 = 33554432;
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY: u32 = 67108864;
pub const TAPE_DRIVE_RESERVED_BIT: u32 = 2147483648;
pub const TAPE_DRIVE_LOAD_UNLOAD: u32 = 2147483649;
pub const TAPE_DRIVE_TENSION: u32 = 2147483650;
pub const TAPE_DRIVE_LOCK_UNLOCK: u32 = 2147483652;
pub const TAPE_DRIVE_REWIND_IMMEDIATE: u32 = 2147483656;
pub const TAPE_DRIVE_SET_BLOCK_SIZE: u32 = 2147483664;
pub const TAPE_DRIVE_LOAD_UNLD_IMMED: u32 = 2147483680;
pub const TAPE_DRIVE_TENSION_IMMED: u32 = 2147483712;
pub const TAPE_DRIVE_LOCK_UNLK_IMMED: u32 = 2147483776;
pub const TAPE_DRIVE_SET_ECC: u32 = 2147483904;
pub const TAPE_DRIVE_SET_COMPRESSION: u32 = 2147484160;
pub const TAPE_DRIVE_SET_PADDING: u32 = 2147484672;
pub const TAPE_DRIVE_SET_REPORT_SMKS: u32 = 2147485696;
pub const TAPE_DRIVE_ABSOLUTE_BLK: u32 = 2147487744;
pub const TAPE_DRIVE_ABS_BLK_IMMED: u32 = 2147491840;
pub const TAPE_DRIVE_LOGICAL_BLK: u32 = 2147500032;
pub const TAPE_DRIVE_LOG_BLK_IMMED: u32 = 2147516416;
pub const TAPE_DRIVE_END_OF_DATA: u32 = 2147549184;
pub const TAPE_DRIVE_RELATIVE_BLKS: u32 = 2147614720;
pub const TAPE_DRIVE_FILEMARKS: u32 = 2147745792;
pub const TAPE_DRIVE_SEQUENTIAL_FMKS: u32 = 2148007936;
pub const TAPE_DRIVE_SETMARKS: u32 = 2148532224;
pub const TAPE_DRIVE_SEQUENTIAL_SMKS: u32 = 2149580800;
pub const TAPE_DRIVE_REVERSE_POSITION: u32 = 2151677952;
pub const TAPE_DRIVE_SPACE_IMMEDIATE: u32 = 2155872256;
pub const TAPE_DRIVE_WRITE_SETMARKS: u32 = 2164260864;
pub const TAPE_DRIVE_WRITE_FILEMARKS: u32 = 2181038080;
pub const TAPE_DRIVE_WRITE_SHORT_FMKS: u32 = 2214592512;
pub const TAPE_DRIVE_WRITE_LONG_FMKS: u32 = 2281701376;
pub const TAPE_DRIVE_WRITE_MARK_IMMED: u32 = 2415919104;
pub const TAPE_DRIVE_FORMAT: u32 = 2684354560;
pub const TAPE_DRIVE_FORMAT_IMMEDIATE: u32 = 3221225472;
pub const TAPE_DRIVE_HIGH_FEATURES: u32 = 2147483648;
pub const TAPE_FIXED_PARTITIONS: u32 = 0;
pub const TAPE_SELECT_PARTITIONS: u32 = 1;
pub const TAPE_INITIATOR_PARTITIONS: u32 = 2;
pub const TAPE_QUERY_DRIVE_PARAMETERS: u32 = 0;
pub const TAPE_QUERY_MEDIA_CAPACITY: u32 = 1;
pub const TAPE_CHECK_FOR_DRIVE_PROBLEM: u32 = 2;
pub const TAPE_QUERY_IO_ERROR_DATA: u32 = 3;
pub const TAPE_QUERY_DEVICE_ERROR_DATA: u32 = 4;
pub const TRANSACTION_MANAGER_VOLATILE: u32 = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: u32 = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: u32 = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: u32 = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: u32 = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: u32 = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: u32 = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: u32 = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: u32 = 1;
pub const TRANSACTION_MAXIMUM_OPTION: u32 = 1;
pub const RESOURCE_MANAGER_VOLATILE: u32 = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: u32 = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: u32 = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: u32 = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: u32 = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: u32 = 3;
pub const ENLISTMENT_SUPERIOR: u32 = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: u32 = 1;
pub const TRANSACTION_NOTIFY_MASK: u32 = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: u32 = 1;
pub const TRANSACTION_NOTIFY_PREPARE: u32 = 2;
pub const TRANSACTION_NOTIFY_COMMIT: u32 = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: u32 = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: u32 = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: u32 = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: u32 = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: u32 = 128;
pub const TRANSACTION_NOTIFY_RECOVER: u32 = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: u32 = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: u32 = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: u32 = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: u32 = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: u32 = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: u32 = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: u32 = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: u32 = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: u32 = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: u32 = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: u32 = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: u32 = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: u32 = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: u32 = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: u32 = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: u32 = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: u32 = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &'static [u8; 21usize] = b"\\TransactionManager\\\0";
pub const TRANSACTION_OBJECT_PATH: &'static [u8; 14usize] = b"\\Transaction\\\0";
pub const ENLISTMENT_OBJECT_PATH: &'static [u8; 13usize] = b"\\Enlistment\\\0";
pub const RESOURCE_MANAGER_OBJECT_PATH: &'static [u8; 18usize] = b"\\ResourceManager\\\0";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: u32 = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: u32 = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: u32 = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4;
pub const TRANSACTIONMANAGER_RENAME: u32 = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32;
pub const TRANSACTIONMANAGER_GENERIC_READ: u32 = 131073;
pub const TRANSACTIONMANAGER_GENERIC_WRITE: u32 = 131102;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE: u32 = 131072;
pub const TRANSACTIONMANAGER_ALL_ACCESS: u32 = 983103;
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTION_SET_INFORMATION: u32 = 2;
pub const TRANSACTION_ENLIST: u32 = 4;
pub const TRANSACTION_COMMIT: u32 = 8;
pub const TRANSACTION_ROLLBACK: u32 = 16;
pub const TRANSACTION_PROPAGATE: u32 = 32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64;
pub const TRANSACTION_GENERIC_READ: u32 = 1179649;
pub const TRANSACTION_GENERIC_WRITE: u32 = 1179710;
pub const TRANSACTION_GENERIC_EXECUTE: u32 = 1179672;
pub const TRANSACTION_ALL_ACCESS: u32 = 2031679;
pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS: u32 = 1179703;
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2;
pub const RESOURCEMANAGER_RECOVER: u32 = 4;
pub const RESOURCEMANAGER_ENLIST: u32 = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64;
pub const RESOURCEMANAGER_GENERIC_READ: u32 = 1179649;
pub const RESOURCEMANAGER_GENERIC_WRITE: u32 = 1179774;
pub const RESOURCEMANAGER_GENERIC_EXECUTE: u32 = 1179740;
pub const RESOURCEMANAGER_ALL_ACCESS: u32 = 2031743;
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2;
pub const ENLISTMENT_RECOVER: u32 = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16;
pub const ENLISTMENT_GENERIC_READ: u32 = 131073;
pub const ENLISTMENT_GENERIC_WRITE: u32 = 131102;
pub const ENLISTMENT_GENERIC_EXECUTE: u32 = 131100;
pub const ENLISTMENT_ALL_ACCESS: u32 = 983071;
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: u32 = 1;
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: u32 = 2;
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: u32 = 3;
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: u32 = 4;
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: u32 = 5;
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: u32 = 6;
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: u32 = 7;
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: u32 = 8;
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: u32 = 9;
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS: u32 = 10;
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO: u32 = 11;
pub const DM_UPDATE: u32 = 1;
pub const DM_COPY: u32 = 2;
pub const DM_PROMPT: u32 = 4;
pub const DM_MODIFY: u32 = 8;
pub const DM_IN_BUFFER: u32 = 8;
pub const DM_IN_PROMPT: u32 = 4;
pub const DM_OUT_BUFFER: u32 = 2;
pub const DM_OUT_DEFAULT: u32 = 1;
pub const DC_FIELDS: u32 = 1;
pub const DC_PAPERS: u32 = 2;
pub const DC_PAPERSIZE: u32 = 3;
pub const DC_MINEXTENT: u32 = 4;
pub const DC_MAXEXTENT: u32 = 5;
pub const DC_BINS: u32 = 6;
pub const DC_DUPLEX: u32 = 7;
pub const DC_SIZE: u32 = 8;
pub const DC_EXTRA: u32 = 9;
pub const DC_VERSION: u32 = 10;
pub const DC_DRIVER: u32 = 11;
pub const DC_BINNAMES: u32 = 12;
pub const DC_ENUMRESOLUTIONS: u32 = 13;
pub const DC_FILEDEPENDENCIES: u32 = 14;
pub const DC_TRUETYPE: u32 = 15;
pub const DC_PAPERNAMES: u32 = 16;
pub const DC_ORIENTATION: u32 = 17;
pub const DC_COPIES: u32 = 18;
pub const FIND_FIRST_EX_CASE_SENSITIVE: u32 = 1;
pub const FIND_FIRST_EX_LARGE_FETCH: u32 = 2;
pub const LOCKFILE_FAIL_IMMEDIATELY: u32 = 1;
pub const LOCKFILE_EXCLUSIVE_LOCK: u32 = 2;
pub const PROCESS_HEAP_REGION: u32 = 1;
pub const PROCESS_HEAP_UNCOMMITTED_RANGE: u32 = 2;
pub const PROCESS_HEAP_ENTRY_BUSY: u32 = 4;
pub const PROCESS_HEAP_SEG_ALLOC: u32 = 8;
pub const PROCESS_HEAP_ENTRY_MOVEABLE: u32 = 16;
pub const PROCESS_HEAP_ENTRY_DDESHARE: u32 = 32;
pub const EXCEPTION_DEBUG_EVENT: u32 = 1;
pub const CREATE_THREAD_DEBUG_EVENT: u32 = 2;
pub const CREATE_PROCESS_DEBUG_EVENT: u32 = 3;
pub const EXIT_THREAD_DEBUG_EVENT: u32 = 4;
pub const EXIT_PROCESS_DEBUG_EVENT: u32 = 5;
pub const LOAD_DLL_DEBUG_EVENT: u32 = 6;
pub const UNLOAD_DLL_DEBUG_EVENT: u32 = 7;
pub const OUTPUT_DEBUG_STRING_EVENT: u32 = 8;
pub const RIP_EVENT: u32 = 9;
pub const LMEM_FIXED: u32 = 0;
pub const LMEM_MOVEABLE: u32 = 2;
pub const LMEM_NOCOMPACT: u32 = 16;
pub const LMEM_NODISCARD: u32 = 32;
pub const LMEM_ZEROINIT: u32 = 64;
pub const LMEM_MODIFY: u32 = 128;
pub const LMEM_DISCARDABLE: u32 = 3840;
pub const LMEM_VALID_FLAGS: u32 = 3954;
pub const LMEM_INVALID_HANDLE: u32 = 32768;
pub const LHND: u32 = 66;
pub const LPTR: u32 = 64;
pub const NONZEROLHND: u32 = 2;
pub const NONZEROLPTR: u32 = 0;
pub const LMEM_DISCARDED: u32 = 16384;
pub const LMEM_LOCKCOUNT: u32 = 255;
pub const CREATE_NEW: u32 = 1;
pub const CREATE_ALWAYS: u32 = 2;
pub const OPEN_EXISTING: u32 = 3;
pub const OPEN_ALWAYS: u32 = 4;
pub const TRUNCATE_EXISTING: u32 = 5;
pub const INIT_ONCE_CHECK_ONLY: u32 = 1;
pub const INIT_ONCE_ASYNC: u32 = 2;
pub const INIT_ONCE_INIT_FAILED: u32 = 4;
pub const INIT_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const MUTEX_MODIFY_STATE: u32 = 1;
pub const MUTEX_ALL_ACCESS: u32 = 2031617;
pub const CREATE_MUTEX_INITIAL_OWNER: u32 = 1;
pub const CREATE_EVENT_MANUAL_RESET: u32 = 1;
pub const CREATE_EVENT_INITIAL_SET: u32 = 2;
pub const CREATE_WAITABLE_TIMER_MANUAL_RESET: u32 = 1;
pub const SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY: u32 = 1;
pub const SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY: u32 = 2;
pub const SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE: u32 = 4;
pub const PROCESS_AFFINITY_ENABLE_AUTO_UPDATE: u32 = 1;
pub const PROC_THREAD_ATTRIBUTE_REPLACE_VALUE: u32 = 1;
pub const THREAD_POWER_THROTTLING_CURRENT_VERSION: u32 = 1;
pub const THREAD_POWER_THROTTLING_EXECUTION_SPEED: u32 = 1;
pub const THREAD_POWER_THROTTLING_VALID_FLAGS: u32 = 1;
pub const PME_CURRENT_VERSION: u32 = 1;
pub const PME_FAILFAST_ON_COMMIT_FAIL_DISABLE: u32 = 0;
pub const PME_FAILFAST_ON_COMMIT_FAIL_ENABLE: u32 = 1;
pub const PROCESS_POWER_THROTTLING_CURRENT_VERSION: u32 = 1;
pub const PROCESS_POWER_THROTTLING_EXECUTION_SPEED: u32 = 1;
pub const PROCESS_POWER_THROTTLING_VALID_FLAGS: u32 = 1;
pub const SCEX2_ALT_NETBIOS_NAME: u32 = 1;
pub const FILE_MAP_WRITE: u32 = 2;
pub const FILE_MAP_READ: u32 = 4;
pub const FILE_MAP_ALL_ACCESS: u32 = 983071;
pub const FILE_MAP_EXECUTE: u32 = 32;
pub const FILE_MAP_COPY: u32 = 1;
pub const FILE_MAP_RESERVE: u32 = 2147483648;
pub const FILE_MAP_TARGETS_INVALID: u32 = 1073741824;
pub const FILE_MAP_LARGE_PAGES: u32 = 536870912;
pub const FILE_CACHE_MAX_HARD_ENABLE: u32 = 1;
pub const FILE_CACHE_MAX_HARD_DISABLE: u32 = 2;
pub const FILE_CACHE_MIN_HARD_ENABLE: u32 = 4;
pub const FILE_CACHE_MIN_HARD_DISABLE: u32 = 8;
pub const MEHC_PATROL_SCRUBBER_PRESENT: u32 = 1;
pub const FIND_RESOURCE_DIRECTORY_TYPES: u32 = 256;
pub const FIND_RESOURCE_DIRECTORY_NAMES: u32 = 512;
pub const FIND_RESOURCE_DIRECTORY_LANGUAGES: u32 = 1024;
pub const RESOURCE_ENUM_LN: u32 = 1;
pub const RESOURCE_ENUM_MUI: u32 = 2;
pub const RESOURCE_ENUM_MUI_SYSTEM: u32 = 4;
pub const RESOURCE_ENUM_VALIDATE: u32 = 8;
pub const RESOURCE_ENUM_MODULE_EXACT: u32 = 16;
pub const SUPPORT_LANG_NUMBER: u32 = 32;
pub const GET_MODULE_HANDLE_EX_FLAG_PIN: u32 = 1;
pub const GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT: u32 = 2;
pub const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: u32 = 4;
pub const DONT_RESOLVE_DLL_REFERENCES: u32 = 1;
pub const LOAD_LIBRARY_AS_DATAFILE: u32 = 2;
pub const LOAD_WITH_ALTERED_SEARCH_PATH: u32 = 8;
pub const LOAD_IGNORE_CODE_AUTHZ_LEVEL: u32 = 16;
pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE: u32 = 32;
pub const LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE: u32 = 64;
pub const LOAD_LIBRARY_REQUIRE_SIGNED_TARGET: u32 = 128;
pub const LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR: u32 = 256;
pub const LOAD_LIBRARY_SEARCH_APPLICATION_DIR: u32 = 512;
pub const LOAD_LIBRARY_SEARCH_USER_DIRS: u32 = 1024;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32: u32 = 2048;
pub const LOAD_LIBRARY_SEARCH_DEFAULT_DIRS: u32 = 4096;
pub const LOAD_LIBRARY_SAFE_CURRENT_DIRS: u32 = 8192;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER: u32 = 16384;
pub const LOAD_LIBRARY_OS_INTEGRITY_CONTINUITY: u32 = 32768;
pub const PRIVATE_NAMESPACE_FLAG_DESTROY: u32 = 1;
pub const FILE_BEGIN: u32 = 0;
pub const FILE_CURRENT: u32 = 1;
pub const FILE_END: u32 = 2;
pub const FILE_FLAG_WRITE_THROUGH: u32 = 2147483648;
pub const FILE_FLAG_OVERLAPPED: u32 = 1073741824;
pub const FILE_FLAG_NO_BUFFERING: u32 = 536870912;
pub const FILE_FLAG_RANDOM_ACCESS: u32 = 268435456;
pub const FILE_FLAG_SEQUENTIAL_SCAN: u32 = 134217728;
pub const FILE_FLAG_DELETE_ON_CLOSE: u32 = 67108864;
pub const FILE_FLAG_BACKUP_SEMANTICS: u32 = 33554432;
pub const FILE_FLAG_POSIX_SEMANTICS: u32 = 16777216;
pub const FILE_FLAG_SESSION_AWARE: u32 = 8388608;
pub const FILE_FLAG_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_FLAG_OPEN_NO_RECALL: u32 = 1048576;
pub const FILE_FLAG_FIRST_PIPE_INSTANCE: u32 = 524288;
pub const FILE_FLAG_OPEN_REQUIRING_OPLOCK: u32 = 262144;
pub const PROGRESS_CONTINUE: u32 = 0;
pub const PROGRESS_CANCEL: u32 = 1;
pub const PROGRESS_STOP: u32 = 2;
pub const PROGRESS_QUIET: u32 = 3;
pub const CALLBACK_CHUNK_FINISHED: u32 = 0;
pub const CALLBACK_STREAM_SWITCH: u32 = 1;
pub const COPY_FILE_FAIL_IF_EXISTS: u32 = 1;
pub const COPY_FILE_RESTARTABLE: u32 = 2;
pub const COPY_FILE_OPEN_SOURCE_FOR_WRITE: u32 = 4;
pub const COPY_FILE_ALLOW_DECRYPTED_DESTINATION: u32 = 8;
pub const COPY_FILE_COPY_SYMLINK: u32 = 2048;
pub const COPY_FILE_NO_BUFFERING: u32 = 4096;
pub const COPY_FILE_REQUEST_SECURITY_PRIVILEGES: u32 = 8192;
pub const COPY_FILE_RESUME_FROM_PAUSE: u32 = 16384;
pub const COPY_FILE_NO_OFFLOAD: u32 = 262144;
pub const COPY_FILE_IGNORE_EDP_BLOCK: u32 = 4194304;
pub const COPY_FILE_IGNORE_SOURCE_ENCRYPTION: u32 = 8388608;
pub const REPLACEFILE_WRITE_THROUGH: u32 = 1;
pub const REPLACEFILE_IGNORE_MERGE_ERRORS: u32 = 2;
pub const REPLACEFILE_IGNORE_ACL_ERRORS: u32 = 4;
pub const PIPE_ACCESS_INBOUND: u32 = 1;
pub const PIPE_ACCESS_OUTBOUND: u32 = 2;
pub const PIPE_ACCESS_DUPLEX: u32 = 3;
pub const PIPE_CLIENT_END: u32 = 0;
pub const PIPE_SERVER_END: u32 = 1;
pub const PIPE_WAIT: u32 = 0;
pub const PIPE_NOWAIT: u32 = 1;
pub const PIPE_READMODE_BYTE: u32 = 0;
pub const PIPE_READMODE_MESSAGE: u32 = 2;
pub const PIPE_TYPE_BYTE: u32 = 0;
pub const PIPE_TYPE_MESSAGE: u32 = 4;
pub const PIPE_ACCEPT_REMOTE_CLIENTS: u32 = 0;
pub const PIPE_REJECT_REMOTE_CLIENTS: u32 = 8;
pub const PIPE_UNLIMITED_INSTANCES: u32 = 255;
pub const SECURITY_CONTEXT_TRACKING: u32 = 262144;
pub const SECURITY_EFFECTIVE_ONLY: u32 = 524288;
pub const SECURITY_SQOS_PRESENT: u32 = 1048576;
pub const SECURITY_VALID_SQOS_FLAGS: u32 = 2031616;
pub const FAIL_FAST_GENERATE_EXCEPTION_ADDRESS: u32 = 1;
pub const FAIL_FAST_NO_HARD_ERROR_DLG: u32 = 2;
pub const DTR_CONTROL_DISABLE: u32 = 0;
pub const DTR_CONTROL_ENABLE: u32 = 1;
pub const DTR_CONTROL_HANDSHAKE: u32 = 2;
pub const RTS_CONTROL_DISABLE: u32 = 0;
pub const RTS_CONTROL_ENABLE: u32 = 1;
pub const RTS_CONTROL_HANDSHAKE: u32 = 2;
pub const RTS_CONTROL_TOGGLE: u32 = 3;
pub const GMEM_FIXED: u32 = 0;
pub const GMEM_MOVEABLE: u32 = 2;
pub const GMEM_NOCOMPACT: u32 = 16;
pub const GMEM_NODISCARD: u32 = 32;
pub const GMEM_ZEROINIT: u32 = 64;
pub const GMEM_MODIFY: u32 = 128;
pub const GMEM_DISCARDABLE: u32 = 256;
pub const GMEM_NOT_BANKED: u32 = 4096;
pub const GMEM_SHARE: u32 = 8192;
pub const GMEM_DDESHARE: u32 = 8192;
pub const GMEM_NOTIFY: u32 = 16384;
pub const GMEM_LOWER: u32 = 4096;
pub const GMEM_VALID_FLAGS: u32 = 32626;
pub const GMEM_INVALID_HANDLE: u32 = 32768;
pub const GHND: u32 = 66;
pub const GPTR: u32 = 64;
pub const GMEM_DISCARDED: u32 = 16384;
pub const GMEM_LOCKCOUNT: u32 = 255;
pub const DEBUG_PROCESS: u32 = 1;
pub const DEBUG_ONLY_THIS_PROCESS: u32 = 2;
pub const CREATE_SUSPENDED: u32 = 4;
pub const DETACHED_PROCESS: u32 = 8;
pub const CREATE_NEW_CONSOLE: u32 = 16;
pub const NORMAL_PRIORITY_CLASS: u32 = 32;
pub const IDLE_PRIORITY_CLASS: u32 = 64;
pub const HIGH_PRIORITY_CLASS: u32 = 128;
pub const REALTIME_PRIORITY_CLASS: u32 = 256;
pub const CREATE_NEW_PROCESS_GROUP: u32 = 512;
pub const CREATE_UNICODE_ENVIRONMENT: u32 = 1024;
pub const CREATE_SEPARATE_WOW_VDM: u32 = 2048;
pub const CREATE_SHARED_WOW_VDM: u32 = 4096;
pub const CREATE_FORCEDOS: u32 = 8192;
pub const BELOW_NORMAL_PRIORITY_CLASS: u32 = 16384;
pub const ABOVE_NORMAL_PRIORITY_CLASS: u32 = 32768;
pub const INHERIT_PARENT_AFFINITY: u32 = 65536;
pub const INHERIT_CALLER_PRIORITY: u32 = 131072;
pub const CREATE_PROTECTED_PROCESS: u32 = 262144;
pub const EXTENDED_STARTUPINFO_PRESENT: u32 = 524288;
pub const PROCESS_MODE_BACKGROUND_BEGIN: u32 = 1048576;
pub const PROCESS_MODE_BACKGROUND_END: u32 = 2097152;
pub const CREATE_BREAKAWAY_FROM_JOB: u32 = 16777216;
pub const CREATE_PRESERVE_CODE_AUTHZ_LEVEL: u32 = 33554432;
pub const CREATE_DEFAULT_ERROR_MODE: u32 = 67108864;
pub const CREATE_NO_WINDOW: u32 = 134217728;
pub const PROFILE_USER: u32 = 268435456;
pub const PROFILE_KERNEL: u32 = 536870912;
pub const PROFILE_SERVER: u32 = 1073741824;
pub const CREATE_IGNORE_SYSTEM_DEFAULT: u32 = 2147483648;
pub const STACK_SIZE_PARAM_IS_A_RESERVATION: u32 = 65536;
pub const THREAD_PRIORITY_LOWEST: i32 = -2;
pub const THREAD_PRIORITY_BELOW_NORMAL: i32 = -1;
pub const THREAD_PRIORITY_NORMAL: u32 = 0;
pub const THREAD_PRIORITY_HIGHEST: u32 = 2;
pub const THREAD_PRIORITY_ABOVE_NORMAL: u32 = 1;
pub const THREAD_PRIORITY_ERROR_RETURN: u32 = 2147483647;
pub const THREAD_PRIORITY_TIME_CRITICAL: u32 = 15;
pub const THREAD_PRIORITY_IDLE: i32 = -15;
pub const THREAD_MODE_BACKGROUND_BEGIN: u32 = 65536;
pub const THREAD_MODE_BACKGROUND_END: u32 = 131072;
pub const VOLUME_NAME_DOS: u32 = 0;
pub const VOLUME_NAME_GUID: u32 = 1;
pub const VOLUME_NAME_NT: u32 = 2;
pub const VOLUME_NAME_NONE: u32 = 4;
pub const FILE_NAME_NORMALIZED: u32 = 0;
pub const FILE_NAME_OPENED: u32 = 8;
pub const DRIVE_UNKNOWN: u32 = 0;
pub const DRIVE_NO_ROOT_DIR: u32 = 1;
pub const DRIVE_REMOVABLE: u32 = 2;
pub const DRIVE_FIXED: u32 = 3;
pub const DRIVE_REMOTE: u32 = 4;
pub const DRIVE_CDROM: u32 = 5;
pub const DRIVE_RAMDISK: u32 = 6;
pub const FILE_TYPE_UNKNOWN: u32 = 0;
pub const FILE_TYPE_DISK: u32 = 1;
pub const FILE_TYPE_CHAR: u32 = 2;
pub const FILE_TYPE_PIPE: u32 = 3;
pub const FILE_TYPE_REMOTE: u32 = 32768;
pub const NOPARITY: u32 = 0;
pub const ODDPARITY: u32 = 1;
pub const EVENPARITY: u32 = 2;
pub const MARKPARITY: u32 = 3;
pub const SPACEPARITY: u32 = 4;
pub const ONESTOPBIT: u32 = 0;
pub const ONE5STOPBITS: u32 = 1;
pub const TWOSTOPBITS: u32 = 2;
pub const IGNORE: u32 = 0;
pub const INFINITE: u32 = 4294967295;
pub const CBR_110: u32 = 110;
pub const CBR_300: u32 = 300;
pub const CBR_600: u32 = 600;
pub const CBR_1200: u32 = 1200;
pub const CBR_2400: u32 = 2400;
pub const CBR_4800: u32 = 4800;
pub const CBR_9600: u32 = 9600;
pub const CBR_14400: u32 = 14400;
pub const CBR_19200: u32 = 19200;
pub const CBR_38400: u32 = 38400;
pub const CBR_56000: u32 = 56000;
pub const CBR_57600: u32 = 57600;
pub const CBR_115200: u32 = 115200;
pub const CBR_128000: u32 = 128000;
pub const CBR_256000: u32 = 256000;
pub const CE_RXOVER: u32 = 1;
pub const CE_OVERRUN: u32 = 2;
pub const CE_RXPARITY: u32 = 4;
pub const CE_FRAME: u32 = 8;
pub const CE_BREAK: u32 = 16;
pub const CE_TXFULL: u32 = 256;
pub const CE_PTO: u32 = 512;
pub const CE_IOE: u32 = 1024;
pub const CE_DNS: u32 = 2048;
pub const CE_OOP: u32 = 4096;
pub const CE_MODE: u32 = 32768;
pub const IE_BADID: i32 = -1;
pub const IE_OPEN: i32 = -2;
pub const IE_NOPEN: i32 = -3;
pub const IE_MEMORY: i32 = -4;
pub const IE_DEFAULT: i32 = -5;
pub const IE_HARDWARE: i32 = -10;
pub const IE_BYTESIZE: i32 = -11;
pub const IE_BAUDRATE: i32 = -12;
pub const EV_RXCHAR: u32 = 1;
pub const EV_RXFLAG: u32 = 2;
pub const EV_TXEMPTY: u32 = 4;
pub const EV_CTS: u32 = 8;
pub const EV_DSR: u32 = 16;
pub const EV_RLSD: u32 = 32;
pub const EV_BREAK: u32 = 64;
pub const EV_ERR: u32 = 128;
pub const EV_RING: u32 = 256;
pub const EV_PERR: u32 = 512;
pub const EV_RX80FULL: u32 = 1024;
pub const EV_EVENT1: u32 = 2048;
pub const EV_EVENT2: u32 = 4096;
pub const SETXOFF: u32 = 1;
pub const SETXON: u32 = 2;
pub const SETRTS: u32 = 3;
pub const CLRRTS: u32 = 4;
pub const SETDTR: u32 = 5;
pub const CLRDTR: u32 = 6;
pub const RESETDEV: u32 = 7;
pub const SETBREAK: u32 = 8;
pub const CLRBREAK: u32 = 9;
pub const PURGE_TXABORT: u32 = 1;
pub const PURGE_RXABORT: u32 = 2;
pub const PURGE_TXCLEAR: u32 = 4;
pub const PURGE_RXCLEAR: u32 = 8;
pub const LPTx: u32 = 128;
pub const S_QUEUEEMPTY: u32 = 0;
pub const S_THRESHOLD: u32 = 1;
pub const S_ALLTHRESHOLD: u32 = 2;
pub const S_NORMAL: u32 = 0;
pub const S_LEGATO: u32 = 1;
pub const S_STACCATO: u32 = 2;
pub const S_PERIOD512: u32 = 0;
pub const S_PERIOD1024: u32 = 1;
pub const S_PERIOD2048: u32 = 2;
pub const S_PERIODVOICE: u32 = 3;
pub const S_WHITE512: u32 = 4;
pub const S_WHITE1024: u32 = 5;
pub const S_WHITE2048: u32 = 6;
pub const S_WHITEVOICE: u32 = 7;
pub const S_SERDVNA: i32 = -1;
pub const S_SEROFM: i32 = -2;
pub const S_SERMACT: i32 = -3;
pub const S_SERQFUL: i32 = -4;
pub const S_SERBDNT: i32 = -5;
pub const S_SERDLN: i32 = -6;
pub const S_SERDCC: i32 = -7;
pub const S_SERDTP: i32 = -8;
pub const S_SERDVL: i32 = -9;
pub const S_SERDMD: i32 = -10;
pub const S_SERDSH: i32 = -11;
pub const S_SERDPT: i32 = -12;
pub const S_SERDFQ: i32 = -13;
pub const S_SERDDR: i32 = -14;
pub const S_SERDSR: i32 = -15;
pub const S_SERDST: i32 = -16;
pub const NMPWAIT_WAIT_FOREVER: u32 = 4294967295;
pub const NMPWAIT_NOWAIT: u32 = 1;
pub const NMPWAIT_USE_DEFAULT_WAIT: u32 = 0;
pub const FS_CASE_IS_PRESERVED: u32 = 2;
pub const FS_CASE_SENSITIVE: u32 = 1;
pub const FS_UNICODE_STORED_ON_DISK: u32 = 4;
pub const FS_PERSISTENT_ACLS: u32 = 8;
pub const FS_VOL_IS_COMPRESSED: u32 = 32768;
pub const FS_FILE_COMPRESSION: u32 = 16;
pub const FS_FILE_ENCRYPTION: u32 = 131072;
pub const OF_READ: u32 = 0;
pub const OF_WRITE: u32 = 1;
pub const OF_READWRITE: u32 = 2;
pub const OF_SHARE_COMPAT: u32 = 0;
pub const OF_SHARE_EXCLUSIVE: u32 = 16;
pub const OF_SHARE_DENY_WRITE: u32 = 32;
pub const OF_SHARE_DENY_READ: u32 = 48;
pub const OF_SHARE_DENY_NONE: u32 = 64;
pub const OF_PARSE: u32 = 256;
pub const OF_DELETE: u32 = 512;
pub const OF_VERIFY: u32 = 1024;
pub const OF_CANCEL: u32 = 2048;
pub const OF_CREATE: u32 = 4096;
pub const OF_PROMPT: u32 = 8192;
pub const OF_EXIST: u32 = 16384;
pub const OF_REOPEN: u32 = 32768;
pub const OFS_MAXPATHNAME: u32 = 128;
pub const MAXINTATOM: u32 = 49152;
pub const SCS_32BIT_BINARY: u32 = 0;
pub const SCS_DOS_BINARY: u32 = 1;
pub const SCS_WOW_BINARY: u32 = 2;
pub const SCS_PIF_BINARY: u32 = 3;
pub const SCS_POSIX_BINARY: u32 = 4;
pub const SCS_OS216_BINARY: u32 = 5;
pub const SCS_64BIT_BINARY: u32 = 6;
pub const SCS_THIS_PLATFORM_BINARY: u32 = 6;
pub const FIBER_FLAG_FLOAT_SWITCH: u32 = 1;
pub const UMS_VERSION: u32 = 256;
pub const PROCESS_DEP_ENABLE: u32 = 1;
pub const PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION: u32 = 2;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS: u32 = 1;
pub const FILE_SKIP_SET_EVENT_ON_HANDLE: u32 = 2;
pub const SEM_FAILCRITICALERRORS: u32 = 1;
pub const SEM_NOGPFAULTERRORBOX: u32 = 2;
pub const SEM_NOALIGNMENTFAULTEXCEPT: u32 = 4;
pub const SEM_NOOPENFILEERRORBOX: u32 = 32768;
pub const CRITICAL_SECTION_NO_DEBUG_INFO: u32 = 16777216;
pub const HANDLE_FLAG_INHERIT: u32 = 1;
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE: u32 = 2;
pub const HINSTANCE_ERROR: u32 = 32;
pub const GET_TAPE_MEDIA_INFORMATION: u32 = 0;
pub const GET_TAPE_DRIVE_INFORMATION: u32 = 1;
pub const SET_TAPE_MEDIA_INFORMATION: u32 = 0;
pub const SET_TAPE_DRIVE_INFORMATION: u32 = 1;
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER: u32 = 256;
pub const FORMAT_MESSAGE_IGNORE_INSERTS: u32 = 512;
pub const FORMAT_MESSAGE_FROM_STRING: u32 = 1024;
pub const FORMAT_MESSAGE_FROM_HMODULE: u32 = 2048;
pub const FORMAT_MESSAGE_FROM_SYSTEM: u32 = 4096;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY: u32 = 8192;
pub const FORMAT_MESSAGE_MAX_WIDTH_MASK: u32 = 255;
pub const FILE_ENCRYPTABLE: u32 = 0;
pub const FILE_IS_ENCRYPTED: u32 = 1;
pub const FILE_SYSTEM_ATTR: u32 = 2;
pub const FILE_ROOT_DIR: u32 = 3;
pub const FILE_SYSTEM_DIR: u32 = 4;
pub const FILE_UNKNOWN: u32 = 5;
pub const FILE_SYSTEM_NOT_SUPPORT: u32 = 6;
pub const FILE_USER_DISALLOWED: u32 = 7;
pub const FILE_READ_ONLY: u32 = 8;
pub const FILE_DIR_DISALLOWED: u32 = 9;
pub const EFS_USE_RECOVERY_KEYS: u32 = 1;
pub const CREATE_FOR_IMPORT: u32 = 1;
pub const CREATE_FOR_DIR: u32 = 2;
pub const OVERWRITE_HIDDEN: u32 = 4;
pub const EFSRPC_SECURE_ONLY: u32 = 8;
pub const EFS_DROP_ALTERNATE_STREAMS: u32 = 16;
pub const BACKUP_INVALID: u32 = 0;
pub const BACKUP_DATA: u32 = 1;
pub const BACKUP_EA_DATA: u32 = 2;
pub const BACKUP_SECURITY_DATA: u32 = 3;
pub const BACKUP_ALTERNATE_DATA: u32 = 4;
pub const BACKUP_LINK: u32 = 5;
pub const BACKUP_PROPERTY_DATA: u32 = 6;
pub const BACKUP_OBJECT_ID: u32 = 7;
pub const BACKUP_REPARSE_DATA: u32 = 8;
pub const BACKUP_SPARSE_BLOCK: u32 = 9;
pub const BACKUP_TXFS_DATA: u32 = 10;
pub const BACKUP_GHOSTED_FILE_EXTENTS: u32 = 11;
pub const STREAM_NORMAL_ATTRIBUTE: u32 = 0;
pub const STREAM_MODIFIED_WHEN_READ: u32 = 1;
pub const STREAM_CONTAINS_SECURITY: u32 = 2;
pub const STREAM_CONTAINS_PROPERTIES: u32 = 4;
pub const STREAM_SPARSE_ATTRIBUTE: u32 = 8;
pub const STREAM_CONTAINS_GHOSTED_FILE_EXTENTS: u32 = 16;
pub const STARTF_USESHOWWINDOW: u32 = 1;
pub const STARTF_USESIZE: u32 = 2;
pub const STARTF_USEPOSITION: u32 = 4;
pub const STARTF_USECOUNTCHARS: u32 = 8;
pub const STARTF_USEFILLATTRIBUTE: u32 = 16;
pub const STARTF_RUNFULLSCREEN: u32 = 32;
pub const STARTF_FORCEONFEEDBACK: u32 = 64;
pub const STARTF_FORCEOFFFEEDBACK: u32 = 128;
pub const STARTF_USESTDHANDLES: u32 = 256;
pub const STARTF_USEHOTKEY: u32 = 512;
pub const STARTF_TITLEISLINKNAME: u32 = 2048;
pub const STARTF_TITLEISAPPID: u32 = 4096;
pub const STARTF_PREVENTPINNING: u32 = 8192;
pub const STARTF_UNTRUSTEDSOURCE: u32 = 32768;
pub const SHUTDOWN_NORETRY: u32 = 1;
pub const PROTECTION_LEVEL_WINTCB_LIGHT: u32 = 0;
pub const PROTECTION_LEVEL_WINDOWS: u32 = 1;
pub const PROTECTION_LEVEL_WINDOWS_LIGHT: u32 = 2;
pub const PROTECTION_LEVEL_ANTIMALWARE_LIGHT: u32 = 3;
pub const PROTECTION_LEVEL_LSA_LIGHT: u32 = 4;
pub const PROTECTION_LEVEL_WINTCB: u32 = 5;
pub const PROTECTION_LEVEL_CODEGEN_LIGHT: u32 = 6;
pub const PROTECTION_LEVEL_AUTHENTICODE: u32 = 7;
pub const PROTECTION_LEVEL_PPL_APP: u32 = 8;
pub const PROTECTION_LEVEL_SAME: u32 = 4294967295;
pub const PROTECTION_LEVEL_NONE: u32 = 4294967294;
pub const PROCESS_NAME_NATIVE: u32 = 1;
pub const PROC_THREAD_ATTRIBUTE_NUMBER: u32 = 65535;
pub const PROC_THREAD_ATTRIBUTE_THREAD: u32 = 65536;
pub const PROC_THREAD_ATTRIBUTE_INPUT: u32 = 131072;
pub const PROC_THREAD_ATTRIBUTE_ADDITIVE: u32 = 262144;
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE: u32 = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE: u32 = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE: u32 = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_MASK: u32 = 768;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON: u32 = 256;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF: u32 = 512;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS: u32 = 768;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_MASK: u32 = 12288;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON: u32 = 4096;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_OFF: u32 = 8192;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_RESERVED: u32 = 12288;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_MASK: u32 = 196608;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON: u32 = 65536;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF: u32 = 131072;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_RESERVED: u32 = 196608;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_MASK: u32 = 3145728;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON: u32 = 1048576;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_OFF: u32 = 2097152;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_RESERVED: u32 = 3145728;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_MASK: u32 = 50331648;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON: u32 = 16777216;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_OFF: u32 = 33554432;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_RESERVED: u32 = 50331648;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_MASK: u32 = 805306368;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON: u32 = 268435456;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_OFF: u32 = 536870912;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_RESERVED: u32 = 805306368;
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED: u32 = 1;
pub const PROCESS_CREATION_CHILD_PROCESS_OVERRIDE: u32 = 2;
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED_UNLESS_SECURE: u32 = 4;
pub const PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT: u32 = 1;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_ENABLE_PROCESS_TREE: u32 = 1;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_DISABLE_PROCESS_TREE: u32 = 2;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_OVERRIDE: u32 = 4;
pub const ATOM_FLAG_GLOBAL: u32 = 2;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A: &'static [u8; 25usize] =
  b"GetSystemWow64DirectoryA\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W: &'static [u8; 25usize] =
  b"GetSystemWow64DirectoryA\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A: &'static [u8; 25usize] =
  b"GetSystemWow64DirectoryW\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W: &'static [u8; 25usize] =
  b"GetSystemWow64DirectoryW\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A: &'static [u8; 25usize] =
  b"GetSystemWow64DirectoryA\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W: &'static [u8; 25usize] =
  b"GetSystemWow64DirectoryA\0";
pub const BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE: u32 = 1;
pub const BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE: u32 = 65536;
pub const BASE_SEARCH_PATH_PERMANENT: u32 = 32768;
pub const BASE_SEARCH_PATH_INVALID_FLAGS: i32 = -98306;
pub const DDD_RAW_TARGET_PATH: u32 = 1;
pub const DDD_REMOVE_DEFINITION: u32 = 2;
pub const DDD_EXACT_MATCH_ON_REMOVE: u32 = 4;
pub const DDD_NO_BROADCAST_SYSTEM: u32 = 8;
pub const DDD_LUID_BROADCAST_DRIVE: u32 = 16;
pub const COPYFILE2_MESSAGE_COPY_OFFLOAD: u32 = 1;
pub const MOVEFILE_REPLACE_EXISTING: u32 = 1;
pub const MOVEFILE_COPY_ALLOWED: u32 = 2;
pub const MOVEFILE_DELAY_UNTIL_REBOOT: u32 = 4;
pub const MOVEFILE_WRITE_THROUGH: u32 = 8;
pub const MOVEFILE_CREATE_HARDLINK: u32 = 16;
pub const MOVEFILE_FAIL_IF_NOT_TRACKABLE: u32 = 32;
pub const EVENTLOG_FULL_INFO: u32 = 0;
pub const OPERATION_API_VERSION: u32 = 1;
pub const OPERATION_START_TRACE_CURRENT_THREAD: u32 = 1;
pub const OPERATION_END_DISCARD: u32 = 1;
pub const MAX_COMPUTERNAME_LENGTH: u32 = 15;
pub const LOGON32_LOGON_INTERACTIVE: u32 = 2;
pub const LOGON32_LOGON_NETWORK: u32 = 3;
pub const LOGON32_LOGON_BATCH: u32 = 4;
pub const LOGON32_LOGON_SERVICE: u32 = 5;
pub const LOGON32_LOGON_UNLOCK: u32 = 7;
pub const LOGON32_LOGON_NETWORK_CLEARTEXT: u32 = 8;
pub const LOGON32_LOGON_NEW_CREDENTIALS: u32 = 9;
pub const LOGON32_PROVIDER_DEFAULT: u32 = 0;
pub const LOGON32_PROVIDER_WINNT35: u32 = 1;
pub const LOGON32_PROVIDER_WINNT40: u32 = 2;
pub const LOGON32_PROVIDER_WINNT50: u32 = 3;
pub const LOGON32_PROVIDER_VIRTUAL: u32 = 4;
pub const LOGON_WITH_PROFILE: u32 = 1;
pub const LOGON_NETCREDENTIALS_ONLY: u32 = 2;
pub const LOGON_ZERO_PASSWORD_BUFFER: u32 = 2147483648;
pub const HW_PROFILE_GUIDLEN: u32 = 39;
pub const MAX_PROFILE_LEN: u32 = 80;
pub const DOCKINFO_UNDOCKED: u32 = 1;
pub const DOCKINFO_DOCKED: u32 = 2;
pub const DOCKINFO_USER_SUPPLIED: u32 = 4;
pub const DOCKINFO_USER_UNDOCKED: u32 = 5;
pub const DOCKINFO_USER_DOCKED: u32 = 6;
pub const FACILITY_NULL: u32 = 0;
pub const FACILITY_RPC: u32 = 1;
pub const FACILITY_DISPATCH: u32 = 2;
pub const FACILITY_STORAGE: u32 = 3;
pub const FACILITY_ITF: u32 = 4;
pub const FACILITY_WIN32: u32 = 7;
pub const FACILITY_WINDOWS: u32 = 8;
pub const FACILITY_SSPI: u32 = 9;
pub const FACILITY_SECURITY: u32 = 9;
pub const FACILITY_CONTROL: u32 = 10;
pub const FACILITY_CERT: u32 = 11;
pub const FACILITY_INTERNET: u32 = 12;
pub const FACILITY_MEDIASERVER: u32 = 13;
pub const FACILITY_MSMQ: u32 = 14;
pub const FACILITY_SETUPAPI: u32 = 15;
pub const FACILITY_SCARD: u32 = 16;
pub const FACILITY_COMPLUS: u32 = 17;
pub const FACILITY_AAF: u32 = 18;
pub const FACILITY_URT: u32 = 19;
pub const FACILITY_ACS: u32 = 20;
pub const FACILITY_DPLAY: u32 = 21;
pub const FACILITY_UMI: u32 = 22;
pub const FACILITY_SXS: u32 = 23;
pub const FACILITY_WINDOWS_CE: u32 = 24;
pub const FACILITY_HTTP: u32 = 25;
pub const FACILITY_USERMODE_COMMONLOG: u32 = 26;
pub const FACILITY_WER: u32 = 27;
pub const FACILITY_USERMODE_FILTER_MANAGER: u32 = 31;
pub const FACILITY_BACKGROUNDCOPY: u32 = 32;
pub const FACILITY_CONFIGURATION: u32 = 33;
pub const FACILITY_WIA: u32 = 33;
pub const FACILITY_STATE_MANAGEMENT: u32 = 34;
pub const FACILITY_METADIRECTORY: u32 = 35;
pub const FACILITY_WINDOWSUPDATE: u32 = 36;
pub const FACILITY_DIRECTORYSERVICE: u32 = 37;
pub const FACILITY_GRAPHICS: u32 = 38;
pub const FACILITY_SHELL: u32 = 39;
pub const FACILITY_NAP: u32 = 39;
pub const FACILITY_TPM_SERVICES: u32 = 40;
pub const FACILITY_TPM_SOFTWARE: u32 = 41;
pub const FACILITY_UI: u32 = 42;
pub const FACILITY_XAML: u32 = 43;
pub const FACILITY_ACTION_QUEUE: u32 = 44;
pub const FACILITY_PLA: u32 = 48;
pub const FACILITY_WINDOWS_SETUP: u32 = 48;
pub const FACILITY_FVE: u32 = 49;
pub const FACILITY_FWP: u32 = 50;
pub const FACILITY_WINRM: u32 = 51;
pub const FACILITY_NDIS: u32 = 52;
pub const FACILITY_USERMODE_HYPERVISOR: u32 = 53;
pub const FACILITY_CMI: u32 = 54;
pub const FACILITY_USERMODE_VIRTUALIZATION: u32 = 55;
pub const FACILITY_USERMODE_VOLMGR: u32 = 56;
pub const FACILITY_BCD: u32 = 57;
pub const FACILITY_USERMODE_VHD: u32 = 58;
pub const FACILITY_USERMODE_HNS: u32 = 59;
pub const FACILITY_SDIAG: u32 = 60;
pub const FACILITY_WEBSERVICES: u32 = 61;
pub const FACILITY_WINPE: u32 = 61;
pub const FACILITY_WPN: u32 = 62;
pub const FACILITY_WINDOWS_STORE: u32 = 63;
pub const FACILITY_INPUT: u32 = 64;
pub const FACILITY_EAP: u32 = 66;
pub const FACILITY_WINDOWS_DEFENDER: u32 = 80;
pub const FACILITY_OPC: u32 = 81;
pub const FACILITY_XPS: u32 = 82;
pub const FACILITY_MBN: u32 = 84;
pub const FACILITY_POWERSHELL: u32 = 84;
pub const FACILITY_RAS: u32 = 83;
pub const FACILITY_P2P_INT: u32 = 98;
pub const FACILITY_P2P: u32 = 99;
pub const FACILITY_DAF: u32 = 100;
pub const FACILITY_BLUETOOTH_ATT: u32 = 101;
pub const FACILITY_AUDIO: u32 = 102;
pub const FACILITY_STATEREPOSITORY: u32 = 103;
pub const FACILITY_VISUALCPP: u32 = 109;
pub const FACILITY_SCRIPT: u32 = 112;
pub const FACILITY_PARSE: u32 = 113;
pub const FACILITY_BLB: u32 = 120;
pub const FACILITY_BLB_CLI: u32 = 121;
pub const FACILITY_WSBAPP: u32 = 122;
pub const FACILITY_BLBUI: u32 = 128;
pub const FACILITY_USN: u32 = 129;
pub const FACILITY_USERMODE_VOLSNAP: u32 = 130;
pub const FACILITY_TIERING: u32 = 131;
pub const FACILITY_WSB_ONLINE: u32 = 133;
pub const FACILITY_ONLINE_ID: u32 = 134;
pub const FACILITY_DEVICE_UPDATE_AGENT: u32 = 135;
pub const FACILITY_DLS: u32 = 153;
pub const FACILITY_DELIVERY_OPTIMIZATION: u32 = 208;
pub const FACILITY_USERMODE_SPACES: u32 = 231;
pub const FACILITY_USER_MODE_SECURITY_CORE: u32 = 232;
pub const FACILITY_USERMODE_LICENSING: u32 = 234;
pub const FACILITY_SOS: u32 = 160;
pub const FACILITY_DEBUGGERS: u32 = 176;
pub const FACILITY_SPP: u32 = 256;
pub const FACILITY_RESTORE: u32 = 256;
pub const FACILITY_DMSERVER: u32 = 256;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER: u32 = 257;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING: u32 = 258;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT: u32 = 259;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL: u32 = 260;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC: u32 = 261;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE: u32 = 263;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP: u32 = 264;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT: u32 = 272;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING: u32 = 278;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER: u32 = 289;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT: u32 = 290;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER: u32 = 293;
pub const FACILITY_LINGUISTIC_SERVICES: u32 = 305;
pub const FACILITY_AUDIOSTREAMING: u32 = 1094;
pub const FACILITY_ACCELERATOR: u32 = 1536;
pub const FACILITY_WMAAECMA: u32 = 1996;
pub const FACILITY_DIRECTMUSIC: u32 = 2168;
pub const FACILITY_DIRECT3D10: u32 = 2169;
pub const FACILITY_DXGI: u32 = 2170;
pub const FACILITY_DXGI_DDI: u32 = 2171;
pub const FACILITY_DIRECT3D11: u32 = 2172;
pub const FACILITY_DIRECT3D11_DEBUG: u32 = 2173;
pub const FACILITY_DIRECT3D12: u32 = 2174;
pub const FACILITY_DIRECT3D12_DEBUG: u32 = 2175;
pub const FACILITY_LEAP: u32 = 2184;
pub const FACILITY_AUDCLNT: u32 = 2185;
pub const FACILITY_WINCODEC_DWRITE_DWM: u32 = 2200;
pub const FACILITY_DIRECT2D: u32 = 2201;
pub const FACILITY_DEFRAG: u32 = 2304;
pub const FACILITY_USERMODE_SDBUS: u32 = 2305;
pub const FACILITY_JSCRIPT: u32 = 2306;
pub const FACILITY_PIDGENX: u32 = 2561;
pub const FACILITY_EAS: u32 = 85;
pub const FACILITY_WEB: u32 = 885;
pub const FACILITY_WEB_SOCKET: u32 = 886;
pub const FACILITY_MOBILE: u32 = 1793;
pub const FACILITY_SQLITE: u32 = 1967;
pub const FACILITY_UTC: u32 = 1989;
pub const FACILITY_WEP: u32 = 2049;
pub const FACILITY_SYNCENGINE: u32 = 2050;
pub const FACILITY_XBOX: u32 = 2339;
pub const FACILITY_PIX: u32 = 2748;
pub const ERROR_SUCCESS: u32 = 0;
pub const NO_ERROR: u32 = 0;
pub const ERROR_INVALID_FUNCTION: u32 = 1;
pub const ERROR_FILE_NOT_FOUND: u32 = 2;
pub const ERROR_PATH_NOT_FOUND: u32 = 3;
pub const ERROR_TOO_MANY_OPEN_FILES: u32 = 4;
pub const ERROR_ACCESS_DENIED: u32 = 5;
pub const ERROR_INVALID_HANDLE: u32 = 6;
pub const ERROR_ARENA_TRASHED: u32 = 7;
pub const ERROR_NOT_ENOUGH_MEMORY: u32 = 8;
pub const ERROR_INVALID_BLOCK: u32 = 9;
pub const ERROR_BAD_ENVIRONMENT: u32 = 10;
pub const ERROR_BAD_FORMAT: u32 = 11;
pub const ERROR_INVALID_ACCESS: u32 = 12;
pub const ERROR_INVALID_DATA: u32 = 13;
pub const ERROR_OUTOFMEMORY: u32 = 14;
pub const ERROR_INVALID_DRIVE: u32 = 15;
pub const ERROR_CURRENT_DIRECTORY: u32 = 16;
pub const ERROR_NOT_SAME_DEVICE: u32 = 17;
pub const ERROR_NO_MORE_FILES: u32 = 18;
pub const ERROR_WRITE_PROTECT: u32 = 19;
pub const ERROR_BAD_UNIT: u32 = 20;
pub const ERROR_NOT_READY: u32 = 21;
pub const ERROR_BAD_COMMAND: u32 = 22;
pub const ERROR_CRC: u32 = 23;
pub const ERROR_BAD_LENGTH: u32 = 24;
pub const ERROR_SEEK: u32 = 25;
pub const ERROR_NOT_DOS_DISK: u32 = 26;
pub const ERROR_SECTOR_NOT_FOUND: u32 = 27;
pub const ERROR_OUT_OF_PAPER: u32 = 28;
pub const ERROR_WRITE_FAULT: u32 = 29;
pub const ERROR_READ_FAULT: u32 = 30;
pub const ERROR_GEN_FAILURE: u32 = 31;
pub const ERROR_SHARING_VIOLATION: u32 = 32;
pub const ERROR_LOCK_VIOLATION: u32 = 33;
pub const ERROR_WRONG_DISK: u32 = 34;
pub const ERROR_SHARING_BUFFER_EXCEEDED: u32 = 36;
pub const ERROR_HANDLE_EOF: u32 = 38;
pub const ERROR_HANDLE_DISK_FULL: u32 = 39;
pub const ERROR_NOT_SUPPORTED: u32 = 50;
pub const ERROR_REM_NOT_LIST: u32 = 51;
pub const ERROR_DUP_NAME: u32 = 52;
pub const ERROR_BAD_NETPATH: u32 = 53;
pub const ERROR_NETWORK_BUSY: u32 = 54;
pub const ERROR_DEV_NOT_EXIST: u32 = 55;
pub const ERROR_TOO_MANY_CMDS: u32 = 56;
pub const ERROR_ADAP_HDW_ERR: u32 = 57;
pub const ERROR_BAD_NET_RESP: u32 = 58;
pub const ERROR_UNEXP_NET_ERR: u32 = 59;
pub const ERROR_BAD_REM_ADAP: u32 = 60;
pub const ERROR_PRINTQ_FULL: u32 = 61;
pub const ERROR_NO_SPOOL_SPACE: u32 = 62;
pub const ERROR_PRINT_CANCELLED: u32 = 63;
pub const ERROR_NETNAME_DELETED: u32 = 64;
pub const ERROR_NETWORK_ACCESS_DENIED: u32 = 65;
pub const ERROR_BAD_DEV_TYPE: u32 = 66;
pub const ERROR_BAD_NET_NAME: u32 = 67;
pub const ERROR_TOO_MANY_NAMES: u32 = 68;
pub const ERROR_TOO_MANY_SESS: u32 = 69;
pub const ERROR_SHARING_PAUSED: u32 = 70;
pub const ERROR_REQ_NOT_ACCEP: u32 = 71;
pub const ERROR_REDIR_PAUSED: u32 = 72;
pub const ERROR_FILE_EXISTS: u32 = 80;
pub const ERROR_CANNOT_MAKE: u32 = 82;
pub const ERROR_FAIL_I24: u32 = 83;
pub const ERROR_OUT_OF_STRUCTURES: u32 = 84;
pub const ERROR_ALREADY_ASSIGNED: u32 = 85;
pub const ERROR_INVALID_PASSWORD: u32 = 86;
pub const ERROR_INVALID_PARAMETER: u32 = 87;
pub const ERROR_NET_WRITE_FAULT: u32 = 88;
pub const ERROR_NO_PROC_SLOTS: u32 = 89;
pub const ERROR_TOO_MANY_SEMAPHORES: u32 = 100;
pub const ERROR_EXCL_SEM_ALREADY_OWNED: u32 = 101;
pub const ERROR_SEM_IS_SET: u32 = 102;
pub const ERROR_TOO_MANY_SEM_REQUESTS: u32 = 103;
pub const ERROR_INVALID_AT_INTERRUPT_TIME: u32 = 104;
pub const ERROR_SEM_OWNER_DIED: u32 = 105;
pub const ERROR_SEM_USER_LIMIT: u32 = 106;
pub const ERROR_DISK_CHANGE: u32 = 107;
pub const ERROR_DRIVE_LOCKED: u32 = 108;
pub const ERROR_BROKEN_PIPE: u32 = 109;
pub const ERROR_OPEN_FAILED: u32 = 110;
pub const ERROR_BUFFER_OVERFLOW: u32 = 111;
pub const ERROR_DISK_FULL: u32 = 112;
pub const ERROR_NO_MORE_SEARCH_HANDLES: u32 = 113;
pub const ERROR_INVALID_TARGET_HANDLE: u32 = 114;
pub const ERROR_INVALID_CATEGORY: u32 = 117;
pub const ERROR_INVALID_VERIFY_SWITCH: u32 = 118;
pub const ERROR_BAD_DRIVER_LEVEL: u32 = 119;
pub const ERROR_CALL_NOT_IMPLEMENTED: u32 = 120;
pub const ERROR_SEM_TIMEOUT: u32 = 121;
pub const ERROR_INSUFFICIENT_BUFFER: u32 = 122;
pub const ERROR_INVALID_NAME: u32 = 123;
pub const ERROR_INVALID_LEVEL: u32 = 124;
pub const ERROR_NO_VOLUME_LABEL: u32 = 125;
pub const ERROR_MOD_NOT_FOUND: u32 = 126;
pub const ERROR_PROC_NOT_FOUND: u32 = 127;
pub const ERROR_WAIT_NO_CHILDREN: u32 = 128;
pub const ERROR_CHILD_NOT_COMPLETE: u32 = 129;
pub const ERROR_DIRECT_ACCESS_HANDLE: u32 = 130;
pub const ERROR_NEGATIVE_SEEK: u32 = 131;
pub const ERROR_SEEK_ON_DEVICE: u32 = 132;
pub const ERROR_IS_JOIN_TARGET: u32 = 133;
pub const ERROR_IS_JOINED: u32 = 134;
pub const ERROR_IS_SUBSTED: u32 = 135;
pub const ERROR_NOT_JOINED: u32 = 136;
pub const ERROR_NOT_SUBSTED: u32 = 137;
pub const ERROR_JOIN_TO_JOIN: u32 = 138;
pub const ERROR_SUBST_TO_SUBST: u32 = 139;
pub const ERROR_JOIN_TO_SUBST: u32 = 140;
pub const ERROR_SUBST_TO_JOIN: u32 = 141;
pub const ERROR_BUSY_DRIVE: u32 = 142;
pub const ERROR_SAME_DRIVE: u32 = 143;
pub const ERROR_DIR_NOT_ROOT: u32 = 144;
pub const ERROR_DIR_NOT_EMPTY: u32 = 145;
pub const ERROR_IS_SUBST_PATH: u32 = 146;
pub const ERROR_IS_JOIN_PATH: u32 = 147;
pub const ERROR_PATH_BUSY: u32 = 148;
pub const ERROR_IS_SUBST_TARGET: u32 = 149;
pub const ERROR_SYSTEM_TRACE: u32 = 150;
pub const ERROR_INVALID_EVENT_COUNT: u32 = 151;
pub const ERROR_TOO_MANY_MUXWAITERS: u32 = 152;
pub const ERROR_INVALID_LIST_FORMAT: u32 = 153;
pub const ERROR_LABEL_TOO_LONG: u32 = 154;
pub const ERROR_TOO_MANY_TCBS: u32 = 155;
pub const ERROR_SIGNAL_REFUSED: u32 = 156;
pub const ERROR_DISCARDED: u32 = 157;
pub const ERROR_NOT_LOCKED: u32 = 158;
pub const ERROR_BAD_THREADID_ADDR: u32 = 159;
pub const ERROR_BAD_ARGUMENTS: u32 = 160;
pub const ERROR_BAD_PATHNAME: u32 = 161;
pub const ERROR_SIGNAL_PENDING: u32 = 162;
pub const ERROR_MAX_THRDS_REACHED: u32 = 164;
pub const ERROR_LOCK_FAILED: u32 = 167;
pub const ERROR_BUSY: u32 = 170;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS: u32 = 171;
pub const ERROR_CANCEL_VIOLATION: u32 = 173;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED: u32 = 174;
pub const ERROR_INVALID_SEGMENT_NUMBER: u32 = 180;
pub const ERROR_INVALID_ORDINAL: u32 = 182;
pub const ERROR_ALREADY_EXISTS: u32 = 183;
pub const ERROR_INVALID_FLAG_NUMBER: u32 = 186;
pub const ERROR_SEM_NOT_FOUND: u32 = 187;
pub const ERROR_INVALID_STARTING_CODESEG: u32 = 188;
pub const ERROR_INVALID_STACKSEG: u32 = 189;
pub const ERROR_INVALID_MODULETYPE: u32 = 190;
pub const ERROR_INVALID_EXE_SIGNATURE: u32 = 191;
pub const ERROR_EXE_MARKED_INVALID: u32 = 192;
pub const ERROR_BAD_EXE_FORMAT: u32 = 193;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k: u32 = 194;
pub const ERROR_INVALID_MINALLOCSIZE: u32 = 195;
pub const ERROR_DYNLINK_FROM_INVALID_RING: u32 = 196;
pub const ERROR_IOPL_NOT_ENABLED: u32 = 197;
pub const ERROR_INVALID_SEGDPL: u32 = 198;
pub const ERROR_AUTODATASEG_EXCEEDS_64k: u32 = 199;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE: u32 = 200;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM: u32 = 201;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN: u32 = 202;
pub const ERROR_ENVVAR_NOT_FOUND: u32 = 203;
pub const ERROR_NO_SIGNAL_SENT: u32 = 205;
pub const ERROR_FILENAME_EXCED_RANGE: u32 = 206;
pub const ERROR_RING2_STACK_IN_USE: u32 = 207;
pub const ERROR_META_EXPANSION_TOO_LONG: u32 = 208;
pub const ERROR_INVALID_SIGNAL_NUMBER: u32 = 209;
pub const ERROR_THREAD_1_INACTIVE: u32 = 210;
pub const ERROR_LOCKED: u32 = 212;
pub const ERROR_TOO_MANY_MODULES: u32 = 214;
pub const ERROR_NESTING_NOT_ALLOWED: u32 = 215;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH: u32 = 216;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY: u32 = 217;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY: u32 = 218;
pub const ERROR_FILE_CHECKED_OUT: u32 = 220;
pub const ERROR_CHECKOUT_REQUIRED: u32 = 221;
pub const ERROR_BAD_FILE_TYPE: u32 = 222;
pub const ERROR_FILE_TOO_LARGE: u32 = 223;
pub const ERROR_FORMS_AUTH_REQUIRED: u32 = 224;
pub const ERROR_VIRUS_INFECTED: u32 = 225;
pub const ERROR_VIRUS_DELETED: u32 = 226;
pub const ERROR_PIPE_LOCAL: u32 = 229;
pub const ERROR_BAD_PIPE: u32 = 230;
pub const ERROR_PIPE_BUSY: u32 = 231;
pub const ERROR_NO_DATA: u32 = 232;
pub const ERROR_PIPE_NOT_CONNECTED: u32 = 233;
pub const ERROR_MORE_DATA: u32 = 234;
pub const ERROR_NO_WORK_DONE: u32 = 235;
pub const ERROR_VC_DISCONNECTED: u32 = 240;
pub const ERROR_INVALID_EA_NAME: u32 = 254;
pub const ERROR_EA_LIST_INCONSISTENT: u32 = 255;
pub const WAIT_TIMEOUT: u32 = 258;
pub const ERROR_NO_MORE_ITEMS: u32 = 259;
pub const ERROR_CANNOT_COPY: u32 = 266;
pub const ERROR_DIRECTORY: u32 = 267;
pub const ERROR_EAS_DIDNT_FIT: u32 = 275;
pub const ERROR_EA_FILE_CORRUPT: u32 = 276;
pub const ERROR_EA_TABLE_FULL: u32 = 277;
pub const ERROR_INVALID_EA_HANDLE: u32 = 278;
pub const ERROR_EAS_NOT_SUPPORTED: u32 = 282;
pub const ERROR_NOT_OWNER: u32 = 288;
pub const ERROR_TOO_MANY_POSTS: u32 = 298;
pub const ERROR_PARTIAL_COPY: u32 = 299;
pub const ERROR_OPLOCK_NOT_GRANTED: u32 = 300;
pub const ERROR_INVALID_OPLOCK_PROTOCOL: u32 = 301;
pub const ERROR_DISK_TOO_FRAGMENTED: u32 = 302;
pub const ERROR_DELETE_PENDING: u32 = 303;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING: u32 = 304;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME: u32 = 305;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT: u32 = 306;
pub const ERROR_INVALID_LOCK_RANGE: u32 = 307;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT: u32 = 308;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED: u32 = 309;
pub const ERROR_INVALID_EXCEPTION_HANDLER: u32 = 310;
pub const ERROR_DUPLICATE_PRIVILEGES: u32 = 311;
pub const ERROR_NO_RANGES_PROCESSED: u32 = 312;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE: u32 = 313;
pub const ERROR_DISK_RESOURCES_EXHAUSTED: u32 = 314;
pub const ERROR_INVALID_TOKEN: u32 = 315;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED: u32 = 316;
pub const ERROR_MR_MID_NOT_FOUND: u32 = 317;
pub const ERROR_SCOPE_NOT_FOUND: u32 = 318;
pub const ERROR_UNDEFINED_SCOPE: u32 = 319;
pub const ERROR_INVALID_CAP: u32 = 320;
pub const ERROR_DEVICE_UNREACHABLE: u32 = 321;
pub const ERROR_DEVICE_NO_RESOURCES: u32 = 322;
pub const ERROR_DATA_CHECKSUM_ERROR: u32 = 323;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION: u32 = 324;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED: u32 = 326;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION: u32 = 327;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST: u32 = 328;
pub const ERROR_OPERATION_IN_PROGRESS: u32 = 329;
pub const ERROR_BAD_DEVICE_PATH: u32 = 330;
pub const ERROR_TOO_MANY_DESCRIPTORS: u32 = 331;
pub const ERROR_SCRUB_DATA_DISABLED: u32 = 332;
pub const ERROR_NOT_REDUNDANT_STORAGE: u32 = 333;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED: u32 = 334;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED: u32 = 335;
pub const ERROR_DIRECTORY_NOT_SUPPORTED: u32 = 336;
pub const ERROR_NOT_READ_FROM_COPY: u32 = 337;
pub const ERROR_FT_WRITE_FAILURE: u32 = 338;
pub const ERROR_FT_DI_SCAN_REQUIRED: u32 = 339;
pub const ERROR_INVALID_KERNEL_INFO_VERSION: u32 = 340;
pub const ERROR_INVALID_PEP_INFO_VERSION: u32 = 341;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED: u32 = 342;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN: u32 = 343;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL: u32 = 344;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH: u32 = 345;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS: u32 = 346;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES: u32 = 347;
pub const ERROR_MARKED_TO_DISALLOW_WRITES: u32 = 348;
pub const ERROR_ENCLAVE_FAILURE: u32 = 349;
pub const ERROR_FAIL_NOACTION_REBOOT: u32 = 350;
pub const ERROR_FAIL_SHUTDOWN: u32 = 351;
pub const ERROR_FAIL_RESTART: u32 = 352;
pub const ERROR_MAX_SESSIONS_REACHED: u32 = 353;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP: u32 = 354;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL: u32 = 355;
pub const ERROR_EDP_POLICY_DENIES_OPERATION: u32 = 356;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED: u32 = 357;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT: u32 = 358;
pub const ERROR_DEVICE_IN_MAINTENANCE: u32 = 359;
pub const ERROR_NOT_SUPPORTED_ON_DAX: u32 = 360;
pub const ERROR_DAX_MAPPING_EXISTS: u32 = 361;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING: u32 = 362;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT: u32 = 363;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE: u32 = 364;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE: u32 = 365;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH: u32 = 366;
pub const ERROR_CHILD_PROCESS_BLOCKED: u32 = 367;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE: u32 = 368;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE: u32 = 369;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT: u32 = 370;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY: u32 = 371;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN: u32 = 372;
pub const ERROR_GDI_HANDLE_LEAK: u32 = 373;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS: u32 = 374;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED: u32 = 375;
pub const ERROR_NOT_A_CLOUD_FILE: u32 = 376;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC: u32 = 377;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED: u32 = 378;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED: u32 = 379;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST: u32 = 380;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME: u32 = 381;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY: u32 = 382;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED: u32 = 383;
pub const ERROR_SMB1_NOT_AVAILABLE: u32 = 384;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION: u32 = 385;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED: u32 = 386;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES: u32 = 387;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE: u32 = 388;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL: u32 = 389;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT: u32 = 390;
pub const ERROR_CLOUD_FILE_IN_USE: u32 = 391;
pub const ERROR_CLOUD_FILE_PINNED: u32 = 392;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED: u32 = 393;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT: u32 = 394;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED: u32 = 395;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS: u32 = 396;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT: u32 = 397;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED: u32 = 398;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED: u32 = 399;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND: u32 = 400;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND: u32 = 401;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND: u32 = 402;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND: u32 = 403;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED: u32 = 450;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE: u32 = 451;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED: u32 = 452;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED: u32 = 453;
pub const ERROR_CAPAUTHZ_NO_POLICY: u32 = 454;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED: u32 = 455;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG: u32 = 456;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY: u32 = 457;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR: u32 = 458;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED: u32 = 459;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH: u32 = 460;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT: u32 = 480;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT: u32 = 481;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT: u32 = 482;
pub const ERROR_DEVICE_HARDWARE_ERROR: u32 = 483;
pub const ERROR_INVALID_ADDRESS: u32 = 487;
pub const ERROR_VRF_CFG_ENABLED: u32 = 1183;
pub const ERROR_PARTITION_TERMINATING: u32 = 1184;
pub const ERROR_USER_PROFILE_LOAD: u32 = 500;
pub const ERROR_ARITHMETIC_OVERFLOW: u32 = 534;
pub const ERROR_PIPE_CONNECTED: u32 = 535;
pub const ERROR_PIPE_LISTENING: u32 = 536;
pub const ERROR_VERIFIER_STOP: u32 = 537;
pub const ERROR_ABIOS_ERROR: u32 = 538;
pub const ERROR_WX86_WARNING: u32 = 539;
pub const ERROR_WX86_ERROR: u32 = 540;
pub const ERROR_TIMER_NOT_CANCELED: u32 = 541;
pub const ERROR_UNWIND: u32 = 542;
pub const ERROR_BAD_STACK: u32 = 543;
pub const ERROR_INVALID_UNWIND_TARGET: u32 = 544;
pub const ERROR_INVALID_PORT_ATTRIBUTES: u32 = 545;
pub const ERROR_PORT_MESSAGE_TOO_LONG: u32 = 546;
pub const ERROR_INVALID_QUOTA_LOWER: u32 = 547;
pub const ERROR_DEVICE_ALREADY_ATTACHED: u32 = 548;
pub const ERROR_INSTRUCTION_MISALIGNMENT: u32 = 549;
pub const ERROR_PROFILING_NOT_STARTED: u32 = 550;
pub const ERROR_PROFILING_NOT_STOPPED: u32 = 551;
pub const ERROR_COULD_NOT_INTERPRET: u32 = 552;
pub const ERROR_PROFILING_AT_LIMIT: u32 = 553;
pub const ERROR_CANT_WAIT: u32 = 554;
pub const ERROR_CANT_TERMINATE_SELF: u32 = 555;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR: u32 = 556;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR: u32 = 557;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR: u32 = 558;
pub const ERROR_BAD_FUNCTION_TABLE: u32 = 559;
pub const ERROR_NO_GUID_TRANSLATION: u32 = 560;
pub const ERROR_INVALID_LDT_SIZE: u32 = 561;
pub const ERROR_INVALID_LDT_OFFSET: u32 = 563;
pub const ERROR_INVALID_LDT_DESCRIPTOR: u32 = 564;
pub const ERROR_TOO_MANY_THREADS: u32 = 565;
pub const ERROR_THREAD_NOT_IN_PROCESS: u32 = 566;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED: u32 = 567;
pub const ERROR_LOGON_SERVER_CONFLICT: u32 = 568;
pub const ERROR_SYNCHRONIZATION_REQUIRED: u32 = 569;
pub const ERROR_NET_OPEN_FAILED: u32 = 570;
pub const ERROR_IO_PRIVILEGE_FAILED: u32 = 571;
pub const ERROR_CONTROL_C_EXIT: u32 = 572;
pub const ERROR_MISSING_SYSTEMFILE: u32 = 573;
pub const ERROR_UNHANDLED_EXCEPTION: u32 = 574;
pub const ERROR_APP_INIT_FAILURE: u32 = 575;
pub const ERROR_PAGEFILE_CREATE_FAILED: u32 = 576;
pub const ERROR_INVALID_IMAGE_HASH: u32 = 577;
pub const ERROR_NO_PAGEFILE: u32 = 578;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT: u32 = 579;
pub const ERROR_NO_EVENT_PAIR: u32 = 580;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR: u32 = 581;
pub const ERROR_ILLEGAL_CHARACTER: u32 = 582;
pub const ERROR_UNDEFINED_CHARACTER: u32 = 583;
pub const ERROR_FLOPPY_VOLUME: u32 = 584;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT: u32 = 585;
pub const ERROR_BACKUP_CONTROLLER: u32 = 586;
pub const ERROR_MUTANT_LIMIT_EXCEEDED: u32 = 587;
pub const ERROR_FS_DRIVER_REQUIRED: u32 = 588;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE: u32 = 589;
pub const ERROR_DEBUG_ATTACH_FAILED: u32 = 590;
pub const ERROR_SYSTEM_PROCESS_TERMINATED: u32 = 591;
pub const ERROR_DATA_NOT_ACCEPTED: u32 = 592;
pub const ERROR_VDM_HARD_ERROR: u32 = 593;
pub const ERROR_DRIVER_CANCEL_TIMEOUT: u32 = 594;
pub const ERROR_REPLY_MESSAGE_MISMATCH: u32 = 595;
pub const ERROR_LOST_WRITEBEHIND_DATA: u32 = 596;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID: u32 = 597;
pub const ERROR_NOT_TINY_STREAM: u32 = 598;
pub const ERROR_STACK_OVERFLOW_READ: u32 = 599;
pub const ERROR_CONVERT_TO_LARGE: u32 = 600;
pub const ERROR_FOUND_OUT_OF_SCOPE: u32 = 601;
pub const ERROR_ALLOCATE_BUCKET: u32 = 602;
pub const ERROR_MARSHALL_OVERFLOW: u32 = 603;
pub const ERROR_INVALID_VARIANT: u32 = 604;
pub const ERROR_BAD_COMPRESSION_BUFFER: u32 = 605;
pub const ERROR_AUDIT_FAILED: u32 = 606;
pub const ERROR_TIMER_RESOLUTION_NOT_SET: u32 = 607;
pub const ERROR_INSUFFICIENT_LOGON_INFO: u32 = 608;
pub const ERROR_BAD_DLL_ENTRYPOINT: u32 = 609;
pub const ERROR_BAD_SERVICE_ENTRYPOINT: u32 = 610;
pub const ERROR_IP_ADDRESS_CONFLICT1: u32 = 611;
pub const ERROR_IP_ADDRESS_CONFLICT2: u32 = 612;
pub const ERROR_REGISTRY_QUOTA_LIMIT: u32 = 613;
pub const ERROR_NO_CALLBACK_ACTIVE: u32 = 614;
pub const ERROR_PWD_TOO_SHORT: u32 = 615;
pub const ERROR_PWD_TOO_RECENT: u32 = 616;
pub const ERROR_PWD_HISTORY_CONFLICT: u32 = 617;
pub const ERROR_UNSUPPORTED_COMPRESSION: u32 = 618;
pub const ERROR_INVALID_HW_PROFILE: u32 = 619;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH: u32 = 620;
pub const ERROR_QUOTA_LIST_INCONSISTENT: u32 = 621;
pub const ERROR_EVALUATION_EXPIRATION: u32 = 622;
pub const ERROR_ILLEGAL_DLL_RELOCATION: u32 = 623;
pub const ERROR_DLL_INIT_FAILED_LOGOFF: u32 = 624;
pub const ERROR_VALIDATE_CONTINUE: u32 = 625;
pub const ERROR_NO_MORE_MATCHES: u32 = 626;
pub const ERROR_RANGE_LIST_CONFLICT: u32 = 627;
pub const ERROR_SERVER_SID_MISMATCH: u32 = 628;
pub const ERROR_CANT_ENABLE_DENY_ONLY: u32 = 629;
pub const ERROR_FLOAT_MULTIPLE_FAULTS: u32 = 630;
pub const ERROR_FLOAT_MULTIPLE_TRAPS: u32 = 631;
pub const ERROR_NOINTERFACE: u32 = 632;
pub const ERROR_DRIVER_FAILED_SLEEP: u32 = 633;
pub const ERROR_CORRUPT_SYSTEM_FILE: u32 = 634;
pub const ERROR_COMMITMENT_MINIMUM: u32 = 635;
pub const ERROR_PNP_RESTART_ENUMERATION: u32 = 636;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE: u32 = 637;
pub const ERROR_PNP_REBOOT_REQUIRED: u32 = 638;
pub const ERROR_INSUFFICIENT_POWER: u32 = 639;
pub const ERROR_MULTIPLE_FAULT_VIOLATION: u32 = 640;
pub const ERROR_SYSTEM_SHUTDOWN: u32 = 641;
pub const ERROR_PORT_NOT_SET: u32 = 642;
pub const ERROR_DS_VERSION_CHECK_FAILURE: u32 = 643;
pub const ERROR_RANGE_NOT_FOUND: u32 = 644;
pub const ERROR_NOT_SAFE_MODE_DRIVER: u32 = 646;
pub const ERROR_FAILED_DRIVER_ENTRY: u32 = 647;
pub const ERROR_DEVICE_ENUMERATION_ERROR: u32 = 648;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED: u32 = 649;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER: u32 = 650;
pub const ERROR_MCA_OCCURED: u32 = 651;
pub const ERROR_DRIVER_DATABASE_ERROR: u32 = 652;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE: u32 = 653;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD: u32 = 654;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE: u32 = 655;
pub const ERROR_HIBERNATION_FAILURE: u32 = 656;
pub const ERROR_PWD_TOO_LONG: u32 = 657;
pub const ERROR_FILE_SYSTEM_LIMITATION: u32 = 665;
pub const ERROR_ASSERTION_FAILURE: u32 = 668;
pub const ERROR_ACPI_ERROR: u32 = 669;
pub const ERROR_WOW_ASSERTION: u32 = 670;
pub const ERROR_PNP_BAD_MPS_TABLE: u32 = 671;
pub const ERROR_PNP_TRANSLATION_FAILED: u32 = 672;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED: u32 = 673;
pub const ERROR_PNP_INVALID_ID: u32 = 674;
pub const ERROR_WAKE_SYSTEM_DEBUGGER: u32 = 675;
pub const ERROR_HANDLES_CLOSED: u32 = 676;
pub const ERROR_EXTRANEOUS_INFORMATION: u32 = 677;
pub const ERROR_RXACT_COMMIT_NECESSARY: u32 = 678;
pub const ERROR_MEDIA_CHECK: u32 = 679;
pub const ERROR_GUID_SUBSTITUTION_MADE: u32 = 680;
pub const ERROR_STOPPED_ON_SYMLINK: u32 = 681;
pub const ERROR_LONGJUMP: u32 = 682;
pub const ERROR_PLUGPLAY_QUERY_VETOED: u32 = 683;
pub const ERROR_UNWIND_CONSOLIDATE: u32 = 684;
pub const ERROR_REGISTRY_HIVE_RECOVERED: u32 = 685;
pub const ERROR_DLL_MIGHT_BE_INSECURE: u32 = 686;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE: u32 = 687;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED: u32 = 688;
pub const ERROR_DBG_REPLY_LATER: u32 = 689;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE: u32 = 690;
pub const ERROR_DBG_TERMINATE_THREAD: u32 = 691;
pub const ERROR_DBG_TERMINATE_PROCESS: u32 = 692;
pub const ERROR_DBG_CONTROL_C: u32 = 693;
pub const ERROR_DBG_PRINTEXCEPTION_C: u32 = 694;
pub const ERROR_DBG_RIPEXCEPTION: u32 = 695;
pub const ERROR_DBG_CONTROL_BREAK: u32 = 696;
pub const ERROR_DBG_COMMAND_EXCEPTION: u32 = 697;
pub const ERROR_OBJECT_NAME_EXISTS: u32 = 698;
pub const ERROR_THREAD_WAS_SUSPENDED: u32 = 699;
pub const ERROR_IMAGE_NOT_AT_BASE: u32 = 700;
pub const ERROR_RXACT_STATE_CREATED: u32 = 701;
pub const ERROR_SEGMENT_NOTIFICATION: u32 = 702;
pub const ERROR_BAD_CURRENT_DIRECTORY: u32 = 703;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP: u32 = 704;
pub const ERROR_FT_WRITE_RECOVERY: u32 = 705;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH: u32 = 706;
pub const ERROR_RECEIVE_PARTIAL: u32 = 707;
pub const ERROR_RECEIVE_EXPEDITED: u32 = 708;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED: u32 = 709;
pub const ERROR_EVENT_DONE: u32 = 710;
pub const ERROR_EVENT_PENDING: u32 = 711;
pub const ERROR_CHECKING_FILE_SYSTEM: u32 = 712;
pub const ERROR_FATAL_APP_EXIT: u32 = 713;
pub const ERROR_PREDEFINED_HANDLE: u32 = 714;
pub const ERROR_WAS_UNLOCKED: u32 = 715;
pub const ERROR_SERVICE_NOTIFICATION: u32 = 716;
pub const ERROR_WAS_LOCKED: u32 = 717;
pub const ERROR_LOG_HARD_ERROR: u32 = 718;
pub const ERROR_ALREADY_WIN32: u32 = 719;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE: u32 = 720;
pub const ERROR_NO_YIELD_PERFORMED: u32 = 721;
pub const ERROR_TIMER_RESUME_IGNORED: u32 = 722;
pub const ERROR_ARBITRATION_UNHANDLED: u32 = 723;
pub const ERROR_CARDBUS_NOT_SUPPORTED: u32 = 724;
pub const ERROR_MP_PROCESSOR_MISMATCH: u32 = 725;
pub const ERROR_HIBERNATED: u32 = 726;
pub const ERROR_RESUME_HIBERNATION: u32 = 727;
pub const ERROR_FIRMWARE_UPDATED: u32 = 728;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES: u32 = 729;
pub const ERROR_WAKE_SYSTEM: u32 = 730;
pub const ERROR_WAIT_1: u32 = 731;
pub const ERROR_WAIT_2: u32 = 732;
pub const ERROR_WAIT_3: u32 = 733;
pub const ERROR_WAIT_63: u32 = 734;
pub const ERROR_ABANDONED_WAIT_0: u32 = 735;
pub const ERROR_ABANDONED_WAIT_63: u32 = 736;
pub const ERROR_USER_APC: u32 = 737;
pub const ERROR_KERNEL_APC: u32 = 738;
pub const ERROR_ALERTED: u32 = 739;
pub const ERROR_ELEVATION_REQUIRED: u32 = 740;
pub const ERROR_REPARSE: u32 = 741;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS: u32 = 742;
pub const ERROR_VOLUME_MOUNTED: u32 = 743;
pub const ERROR_RXACT_COMMITTED: u32 = 744;
pub const ERROR_NOTIFY_CLEANUP: u32 = 745;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED: u32 = 746;
pub const ERROR_PAGE_FAULT_TRANSITION: u32 = 747;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO: u32 = 748;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE: u32 = 749;
pub const ERROR_PAGE_FAULT_GUARD_PAGE: u32 = 750;
pub const ERROR_PAGE_FAULT_PAGING_FILE: u32 = 751;
pub const ERROR_CACHE_PAGE_LOCKED: u32 = 752;
pub const ERROR_CRASH_DUMP: u32 = 753;
pub const ERROR_BUFFER_ALL_ZEROS: u32 = 754;
pub const ERROR_REPARSE_OBJECT: u32 = 755;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED: u32 = 756;
pub const ERROR_TRANSLATION_COMPLETE: u32 = 757;
pub const ERROR_NOTHING_TO_TERMINATE: u32 = 758;
pub const ERROR_PROCESS_NOT_IN_JOB: u32 = 759;
pub const ERROR_PROCESS_IN_JOB: u32 = 760;
pub const ERROR_VOLSNAP_HIBERNATE_READY: u32 = 761;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY: u32 = 762;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED: u32 = 763;
pub const ERROR_INTERRUPT_STILL_CONNECTED: u32 = 764;
pub const ERROR_WAIT_FOR_OPLOCK: u32 = 765;
pub const ERROR_DBG_EXCEPTION_HANDLED: u32 = 766;
pub const ERROR_DBG_CONTINUE: u32 = 767;
pub const ERROR_CALLBACK_POP_STACK: u32 = 768;
pub const ERROR_COMPRESSION_DISABLED: u32 = 769;
pub const ERROR_CANTFETCHBACKWARDS: u32 = 770;
pub const ERROR_CANTSCROLLBACKWARDS: u32 = 771;
pub const ERROR_ROWSNOTRELEASED: u32 = 772;
pub const ERROR_BAD_ACCESSOR_FLAGS: u32 = 773;
pub const ERROR_ERRORS_ENCOUNTERED: u32 = 774;
pub const ERROR_NOT_CAPABLE: u32 = 775;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE: u32 = 776;
pub const ERROR_VERSION_PARSE_ERROR: u32 = 777;
pub const ERROR_BADSTARTPOSITION: u32 = 778;
pub const ERROR_MEMORY_HARDWARE: u32 = 779;
pub const ERROR_DISK_REPAIR_DISABLED: u32 = 780;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE: u32 = 781;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION: u32 = 782;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION: u32 = 783;
pub const ERROR_MCA_EXCEPTION: u32 = 784;
pub const ERROR_ACCESS_AUDIT_BY_POLICY: u32 = 785;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY: u32 = 786;
pub const ERROR_ABANDON_HIBERFILE: u32 = 787;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED: u32 = 788;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR: u32 = 789;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR: u32 = 790;
pub const ERROR_BAD_MCFG_TABLE: u32 = 791;
pub const ERROR_DISK_REPAIR_REDIRECTED: u32 = 792;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL: u32 = 793;
pub const ERROR_CORRUPT_LOG_OVERFULL: u32 = 794;
pub const ERROR_CORRUPT_LOG_CORRUPTED: u32 = 795;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE: u32 = 796;
pub const ERROR_CORRUPT_LOG_DELETED_FULL: u32 = 797;
pub const ERROR_CORRUPT_LOG_CLEARED: u32 = 798;
pub const ERROR_ORPHAN_NAME_EXHAUSTED: u32 = 799;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE: u32 = 800;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK: u32 = 801;
pub const ERROR_CANNOT_BREAK_OPLOCK: u32 = 802;
pub const ERROR_OPLOCK_HANDLE_CLOSED: u32 = 803;
pub const ERROR_NO_ACE_CONDITION: u32 = 804;
pub const ERROR_INVALID_ACE_CONDITION: u32 = 805;
pub const ERROR_FILE_HANDLE_REVOKED: u32 = 806;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE: u32 = 807;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE: u32 = 808;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS: u32 = 809;
pub const ERROR_QUOTA_ACTIVITY: u32 = 810;
pub const ERROR_HANDLE_REVOKED: u32 = 811;
pub const ERROR_CALLBACK_INVOKE_INLINE: u32 = 812;
pub const ERROR_CPU_SET_INVALID: u32 = 813;
pub const ERROR_ENCLAVE_NOT_TERMINATED: u32 = 814;
pub const ERROR_EA_ACCESS_DENIED: u32 = 994;
pub const ERROR_OPERATION_ABORTED: u32 = 995;
pub const ERROR_IO_INCOMPLETE: u32 = 996;
pub const ERROR_IO_PENDING: u32 = 997;
pub const ERROR_NOACCESS: u32 = 998;
pub const ERROR_SWAPERROR: u32 = 999;
pub const ERROR_STACK_OVERFLOW: u32 = 1001;
pub const ERROR_INVALID_MESSAGE: u32 = 1002;
pub const ERROR_CAN_NOT_COMPLETE: u32 = 1003;
pub const ERROR_INVALID_FLAGS: u32 = 1004;
pub const ERROR_UNRECOGNIZED_VOLUME: u32 = 1005;
pub const ERROR_FILE_INVALID: u32 = 1006;
pub const ERROR_FULLSCREEN_MODE: u32 = 1007;
pub const ERROR_NO_TOKEN: u32 = 1008;
pub const ERROR_BADDB: u32 = 1009;
pub const ERROR_BADKEY: u32 = 1010;
pub const ERROR_CANTOPEN: u32 = 1011;
pub const ERROR_CANTREAD: u32 = 1012;
pub const ERROR_CANTWRITE: u32 = 1013;
pub const ERROR_REGISTRY_RECOVERED: u32 = 1014;
pub const ERROR_REGISTRY_CORRUPT: u32 = 1015;
pub const ERROR_REGISTRY_IO_FAILED: u32 = 1016;
pub const ERROR_NOT_REGISTRY_FILE: u32 = 1017;
pub const ERROR_KEY_DELETED: u32 = 1018;
pub const ERROR_NO_LOG_SPACE: u32 = 1019;
pub const ERROR_KEY_HAS_CHILDREN: u32 = 1020;
pub const ERROR_CHILD_MUST_BE_VOLATILE: u32 = 1021;
pub const ERROR_NOTIFY_ENUM_DIR: u32 = 1022;
pub const ERROR_DEPENDENT_SERVICES_RUNNING: u32 = 1051;
pub const ERROR_INVALID_SERVICE_CONTROL: u32 = 1052;
pub const ERROR_SERVICE_REQUEST_TIMEOUT: u32 = 1053;
pub const ERROR_SERVICE_NO_THREAD: u32 = 1054;
pub const ERROR_SERVICE_DATABASE_LOCKED: u32 = 1055;
pub const ERROR_SERVICE_ALREADY_RUNNING: u32 = 1056;
pub const ERROR_INVALID_SERVICE_ACCOUNT: u32 = 1057;
pub const ERROR_SERVICE_DISABLED: u32 = 1058;
pub const ERROR_CIRCULAR_DEPENDENCY: u32 = 1059;
pub const ERROR_SERVICE_DOES_NOT_EXIST: u32 = 1060;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL: u32 = 1061;
pub const ERROR_SERVICE_NOT_ACTIVE: u32 = 1062;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: u32 = 1063;
pub const ERROR_EXCEPTION_IN_SERVICE: u32 = 1064;
pub const ERROR_DATABASE_DOES_NOT_EXIST: u32 = 1065;
pub const ERROR_SERVICE_SPECIFIC_ERROR: u32 = 1066;
pub const ERROR_PROCESS_ABORTED: u32 = 1067;
pub const ERROR_SERVICE_DEPENDENCY_FAIL: u32 = 1068;
pub const ERROR_SERVICE_LOGON_FAILED: u32 = 1069;
pub const ERROR_SERVICE_START_HANG: u32 = 1070;
pub const ERROR_INVALID_SERVICE_LOCK: u32 = 1071;
pub const ERROR_SERVICE_MARKED_FOR_DELETE: u32 = 1072;
pub const ERROR_SERVICE_EXISTS: u32 = 1073;
pub const ERROR_ALREADY_RUNNING_LKG: u32 = 1074;
pub const ERROR_SERVICE_DEPENDENCY_DELETED: u32 = 1075;
pub const ERROR_BOOT_ALREADY_ACCEPTED: u32 = 1076;
pub const ERROR_SERVICE_NEVER_STARTED: u32 = 1077;
pub const ERROR_DUPLICATE_SERVICE_NAME: u32 = 1078;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT: u32 = 1079;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE: u32 = 1080;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT: u32 = 1081;
pub const ERROR_NO_RECOVERY_PROGRAM: u32 = 1082;
pub const ERROR_SERVICE_NOT_IN_EXE: u32 = 1083;
pub const ERROR_NOT_SAFEBOOT_SERVICE: u32 = 1084;
pub const ERROR_END_OF_MEDIA: u32 = 1100;
pub const ERROR_FILEMARK_DETECTED: u32 = 1101;
pub const ERROR_BEGINNING_OF_MEDIA: u32 = 1102;
pub const ERROR_SETMARK_DETECTED: u32 = 1103;
pub const ERROR_NO_DATA_DETECTED: u32 = 1104;
pub const ERROR_PARTITION_FAILURE: u32 = 1105;
pub const ERROR_INVALID_BLOCK_LENGTH: u32 = 1106;
pub const ERROR_DEVICE_NOT_PARTITIONED: u32 = 1107;
pub const ERROR_UNABLE_TO_LOCK_MEDIA: u32 = 1108;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA: u32 = 1109;
pub const ERROR_MEDIA_CHANGED: u32 = 1110;
pub const ERROR_BUS_RESET: u32 = 1111;
pub const ERROR_NO_MEDIA_IN_DRIVE: u32 = 1112;
pub const ERROR_NO_UNICODE_TRANSLATION: u32 = 1113;
pub const ERROR_DLL_INIT_FAILED: u32 = 1114;
pub const ERROR_SHUTDOWN_IN_PROGRESS: u32 = 1115;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS: u32 = 1116;
pub const ERROR_IO_DEVICE: u32 = 1117;
pub const ERROR_SERIAL_NO_DEVICE: u32 = 1118;
pub const ERROR_IRQ_BUSY: u32 = 1119;
pub const ERROR_MORE_WRITES: u32 = 1120;
pub const ERROR_COUNTER_TIMEOUT: u32 = 1121;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND: u32 = 1122;
pub const ERROR_FLOPPY_WRONG_CYLINDER: u32 = 1123;
pub const ERROR_FLOPPY_UNKNOWN_ERROR: u32 = 1124;
pub const ERROR_FLOPPY_BAD_REGISTERS: u32 = 1125;
pub const ERROR_DISK_RECALIBRATE_FAILED: u32 = 1126;
pub const ERROR_DISK_OPERATION_FAILED: u32 = 1127;
pub const ERROR_DISK_RESET_FAILED: u32 = 1128;
pub const ERROR_EOM_OVERFLOW: u32 = 1129;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY: u32 = 1130;
pub const ERROR_POSSIBLE_DEADLOCK: u32 = 1131;
pub const ERROR_MAPPED_ALIGNMENT: u32 = 1132;
pub const ERROR_SET_POWER_STATE_VETOED: u32 = 1140;
pub const ERROR_SET_POWER_STATE_FAILED: u32 = 1141;
pub const ERROR_TOO_MANY_LINKS: u32 = 1142;
pub const ERROR_OLD_WIN_VERSION: u32 = 1150;
pub const ERROR_APP_WRONG_OS: u32 = 1151;
pub const ERROR_SINGLE_INSTANCE_APP: u32 = 1152;
pub const ERROR_RMODE_APP: u32 = 1153;
pub const ERROR_INVALID_DLL: u32 = 1154;
pub const ERROR_NO_ASSOCIATION: u32 = 1155;
pub const ERROR_DDE_FAIL: u32 = 1156;
pub const ERROR_DLL_NOT_FOUND: u32 = 1157;
pub const ERROR_NO_MORE_USER_HANDLES: u32 = 1158;
pub const ERROR_MESSAGE_SYNC_ONLY: u32 = 1159;
pub const ERROR_SOURCE_ELEMENT_EMPTY: u32 = 1160;
pub const ERROR_DESTINATION_ELEMENT_FULL: u32 = 1161;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS: u32 = 1162;
pub const ERROR_MAGAZINE_NOT_PRESENT: u32 = 1163;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED: u32 = 1164;
pub const ERROR_DEVICE_REQUIRES_CLEANING: u32 = 1165;
pub const ERROR_DEVICE_DOOR_OPEN: u32 = 1166;
pub const ERROR_DEVICE_NOT_CONNECTED: u32 = 1167;
pub const ERROR_NOT_FOUND: u32 = 1168;
pub const ERROR_NO_MATCH: u32 = 1169;
pub const ERROR_SET_NOT_FOUND: u32 = 1170;
pub const ERROR_POINT_NOT_FOUND: u32 = 1171;
pub const ERROR_NO_TRACKING_SERVICE: u32 = 1172;
pub const ERROR_NO_VOLUME_ID: u32 = 1173;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED: u32 = 1175;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT: u32 = 1176;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2: u32 = 1177;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS: u32 = 1178;
pub const ERROR_JOURNAL_NOT_ACTIVE: u32 = 1179;
pub const ERROR_POTENTIAL_FILE_FOUND: u32 = 1180;
pub const ERROR_JOURNAL_ENTRY_DELETED: u32 = 1181;
pub const ERROR_SHUTDOWN_IS_SCHEDULED: u32 = 1190;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON: u32 = 1191;
pub const ERROR_BAD_DEVICE: u32 = 1200;
pub const ERROR_CONNECTION_UNAVAIL: u32 = 1201;
pub const ERROR_DEVICE_ALREADY_REMEMBERED: u32 = 1202;
pub const ERROR_NO_NET_OR_BAD_PATH: u32 = 1203;
pub const ERROR_BAD_PROVIDER: u32 = 1204;
pub const ERROR_CANNOT_OPEN_PROFILE: u32 = 1205;
pub const ERROR_BAD_PROFILE: u32 = 1206;
pub const ERROR_NOT_CONTAINER: u32 = 1207;
pub const ERROR_EXTENDED_ERROR: u32 = 1208;
pub const ERROR_INVALID_GROUPNAME: u32 = 1209;
pub const ERROR_INVALID_COMPUTERNAME: u32 = 1210;
pub const ERROR_INVALID_EVENTNAME: u32 = 1211;
pub const ERROR_INVALID_DOMAINNAME: u32 = 1212;
pub const ERROR_INVALID_SERVICENAME: u32 = 1213;
pub const ERROR_INVALID_NETNAME: u32 = 1214;
pub const ERROR_INVALID_SHARENAME: u32 = 1215;
pub const ERROR_INVALID_PASSWORDNAME: u32 = 1216;
pub const ERROR_INVALID_MESSAGENAME: u32 = 1217;
pub const ERROR_INVALID_MESSAGEDEST: u32 = 1218;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT: u32 = 1219;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED: u32 = 1220;
pub const ERROR_DUP_DOMAINNAME: u32 = 1221;
pub const ERROR_NO_NETWORK: u32 = 1222;
pub const ERROR_CANCELLED: u32 = 1223;
pub const ERROR_USER_MAPPED_FILE: u32 = 1224;
pub const ERROR_CONNECTION_REFUSED: u32 = 1225;
pub const ERROR_GRACEFUL_DISCONNECT: u32 = 1226;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED: u32 = 1227;
pub const ERROR_ADDRESS_NOT_ASSOCIATED: u32 = 1228;
pub const ERROR_CONNECTION_INVALID: u32 = 1229;
pub const ERROR_CONNECTION_ACTIVE: u32 = 1230;
pub const ERROR_NETWORK_UNREACHABLE: u32 = 1231;
pub const ERROR_HOST_UNREACHABLE: u32 = 1232;
pub const ERROR_PROTOCOL_UNREACHABLE: u32 = 1233;
pub const ERROR_PORT_UNREACHABLE: u32 = 1234;
pub const ERROR_REQUEST_ABORTED: u32 = 1235;
pub const ERROR_CONNECTION_ABORTED: u32 = 1236;
pub const ERROR_RETRY: u32 = 1237;
pub const ERROR_CONNECTION_COUNT_LIMIT: u32 = 1238;
pub const ERROR_LOGIN_TIME_RESTRICTION: u32 = 1239;
pub const ERROR_LOGIN_WKSTA_RESTRICTION: u32 = 1240;
pub const ERROR_INCORRECT_ADDRESS: u32 = 1241;
pub const ERROR_ALREADY_REGISTERED: u32 = 1242;
pub const ERROR_SERVICE_NOT_FOUND: u32 = 1243;
pub const ERROR_NOT_AUTHENTICATED: u32 = 1244;
pub const ERROR_NOT_LOGGED_ON: u32 = 1245;
pub const ERROR_CONTINUE: u32 = 1246;
pub const ERROR_ALREADY_INITIALIZED: u32 = 1247;
pub const ERROR_NO_MORE_DEVICES: u32 = 1248;
pub const ERROR_NO_SUCH_SITE: u32 = 1249;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS: u32 = 1250;
pub const ERROR_ONLY_IF_CONNECTED: u32 = 1251;
pub const ERROR_OVERRIDE_NOCHANGES: u32 = 1252;
pub const ERROR_BAD_USER_PROFILE: u32 = 1253;
pub const ERROR_NOT_SUPPORTED_ON_SBS: u32 = 1254;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS: u32 = 1255;
pub const ERROR_HOST_DOWN: u32 = 1256;
pub const ERROR_NON_ACCOUNT_SID: u32 = 1257;
pub const ERROR_NON_DOMAIN_SID: u32 = 1258;
pub const ERROR_APPHELP_BLOCK: u32 = 1259;
pub const ERROR_ACCESS_DISABLED_BY_POLICY: u32 = 1260;
pub const ERROR_REG_NAT_CONSUMPTION: u32 = 1261;
pub const ERROR_CSCSHARE_OFFLINE: u32 = 1262;
pub const ERROR_PKINIT_FAILURE: u32 = 1263;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE: u32 = 1264;
pub const ERROR_DOWNGRADE_DETECTED: u32 = 1265;
pub const ERROR_MACHINE_LOCKED: u32 = 1271;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED: u32 = 1272;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA: u32 = 1273;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED: u32 = 1274;
pub const ERROR_DRIVER_BLOCKED: u32 = 1275;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL: u32 = 1276;
pub const ERROR_ACCESS_DISABLED_WEBBLADE: u32 = 1277;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER: u32 = 1278;
pub const ERROR_RECOVERY_FAILURE: u32 = 1279;
pub const ERROR_ALREADY_FIBER: u32 = 1280;
pub const ERROR_ALREADY_THREAD: u32 = 1281;
pub const ERROR_STACK_BUFFER_OVERRUN: u32 = 1282;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED: u32 = 1283;
pub const ERROR_DEBUGGER_INACTIVE: u32 = 1284;
pub const ERROR_DELAY_LOAD_FAILED: u32 = 1285;
pub const ERROR_VDM_DISALLOWED: u32 = 1286;
pub const ERROR_UNIDENTIFIED_ERROR: u32 = 1287;
pub const ERROR_INVALID_CRUNTIME_PARAMETER: u32 = 1288;
pub const ERROR_BEYOND_VDL: u32 = 1289;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE: u32 = 1290;
pub const ERROR_DRIVER_PROCESS_TERMINATED: u32 = 1291;
pub const ERROR_IMPLEMENTATION_LIMIT: u32 = 1292;
pub const ERROR_PROCESS_IS_PROTECTED: u32 = 1293;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING: u32 = 1294;
pub const ERROR_DISK_QUOTA_EXCEEDED: u32 = 1295;
pub const ERROR_CONTENT_BLOCKED: u32 = 1296;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE: u32 = 1297;
pub const ERROR_APP_HANG: u32 = 1298;
pub const ERROR_INVALID_LABEL: u32 = 1299;
pub const ERROR_NOT_ALL_ASSIGNED: u32 = 1300;
pub const ERROR_SOME_NOT_MAPPED: u32 = 1301;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT: u32 = 1302;
pub const ERROR_LOCAL_USER_SESSION_KEY: u32 = 1303;
pub const ERROR_NULL_LM_PASSWORD: u32 = 1304;
pub const ERROR_UNKNOWN_REVISION: u32 = 1305;
pub const ERROR_REVISION_MISMATCH: u32 = 1306;
pub const ERROR_INVALID_OWNER: u32 = 1307;
pub const ERROR_INVALID_PRIMARY_GROUP: u32 = 1308;
pub const ERROR_NO_IMPERSONATION_TOKEN: u32 = 1309;
pub const ERROR_CANT_DISABLE_MANDATORY: u32 = 1310;
pub const ERROR_NO_LOGON_SERVERS: u32 = 1311;
pub const ERROR_NO_SUCH_LOGON_SESSION: u32 = 1312;
pub const ERROR_NO_SUCH_PRIVILEGE: u32 = 1313;
pub const ERROR_PRIVILEGE_NOT_HELD: u32 = 1314;
pub const ERROR_INVALID_ACCOUNT_NAME: u32 = 1315;
pub const ERROR_USER_EXISTS: u32 = 1316;
pub const ERROR_NO_SUCH_USER: u32 = 1317;
pub const ERROR_GROUP_EXISTS: u32 = 1318;
pub const ERROR_NO_SUCH_GROUP: u32 = 1319;
pub const ERROR_MEMBER_IN_GROUP: u32 = 1320;
pub const ERROR_MEMBER_NOT_IN_GROUP: u32 = 1321;
pub const ERROR_LAST_ADMIN: u32 = 1322;
pub const ERROR_WRONG_PASSWORD: u32 = 1323;
pub const ERROR_ILL_FORMED_PASSWORD: u32 = 1324;
pub const ERROR_PASSWORD_RESTRICTION: u32 = 1325;
pub const ERROR_LOGON_FAILURE: u32 = 1326;
pub const ERROR_ACCOUNT_RESTRICTION: u32 = 1327;
pub const ERROR_INVALID_LOGON_HOURS: u32 = 1328;
pub const ERROR_INVALID_WORKSTATION: u32 = 1329;
pub const ERROR_PASSWORD_EXPIRED: u32 = 1330;
pub const ERROR_ACCOUNT_DISABLED: u32 = 1331;
pub const ERROR_NONE_MAPPED: u32 = 1332;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED: u32 = 1333;
pub const ERROR_LUIDS_EXHAUSTED: u32 = 1334;
pub const ERROR_INVALID_SUB_AUTHORITY: u32 = 1335;
pub const ERROR_INVALID_ACL: u32 = 1336;
pub const ERROR_INVALID_SID: u32 = 1337;
pub const ERROR_INVALID_SECURITY_DESCR: u32 = 1338;
pub const ERROR_BAD_INHERITANCE_ACL: u32 = 1340;
pub const ERROR_SERVER_DISABLED: u32 = 1341;
pub const ERROR_SERVER_NOT_DISABLED: u32 = 1342;
pub const ERROR_INVALID_ID_AUTHORITY: u32 = 1343;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED: u32 = 1344;
pub const ERROR_INVALID_GROUP_ATTRIBUTES: u32 = 1345;
pub const ERROR_BAD_IMPERSONATION_LEVEL: u32 = 1346;
pub const ERROR_CANT_OPEN_ANONYMOUS: u32 = 1347;
pub const ERROR_BAD_VALIDATION_CLASS: u32 = 1348;
pub const ERROR_BAD_TOKEN_TYPE: u32 = 1349;
pub const ERROR_NO_SECURITY_ON_OBJECT: u32 = 1350;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO: u32 = 1351;
pub const ERROR_INVALID_SERVER_STATE: u32 = 1352;
pub const ERROR_INVALID_DOMAIN_STATE: u32 = 1353;
pub const ERROR_INVALID_DOMAIN_ROLE: u32 = 1354;
pub const ERROR_NO_SUCH_DOMAIN: u32 = 1355;
pub const ERROR_DOMAIN_EXISTS: u32 = 1356;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED: u32 = 1357;
pub const ERROR_INTERNAL_DB_CORRUPTION: u32 = 1358;
pub const ERROR_INTERNAL_ERROR: u32 = 1359;
pub const ERROR_GENERIC_NOT_MAPPED: u32 = 1360;
pub const ERROR_BAD_DESCRIPTOR_FORMAT: u32 = 1361;
pub const ERROR_NOT_LOGON_PROCESS: u32 = 1362;
pub const ERROR_LOGON_SESSION_EXISTS: u32 = 1363;
pub const ERROR_NO_SUCH_PACKAGE: u32 = 1364;
pub const ERROR_BAD_LOGON_SESSION_STATE: u32 = 1365;
pub const ERROR_LOGON_SESSION_COLLISION: u32 = 1366;
pub const ERROR_INVALID_LOGON_TYPE: u32 = 1367;
pub const ERROR_CANNOT_IMPERSONATE: u32 = 1368;
pub const ERROR_RXACT_INVALID_STATE: u32 = 1369;
pub const ERROR_RXACT_COMMIT_FAILURE: u32 = 1370;
pub const ERROR_SPECIAL_ACCOUNT: u32 = 1371;
pub const ERROR_SPECIAL_GROUP: u32 = 1372;
pub const ERROR_SPECIAL_USER: u32 = 1373;
pub const ERROR_MEMBERS_PRIMARY_GROUP: u32 = 1374;
pub const ERROR_TOKEN_ALREADY_IN_USE: u32 = 1375;
pub const ERROR_NO_SUCH_ALIAS: u32 = 1376;
pub const ERROR_MEMBER_NOT_IN_ALIAS: u32 = 1377;
pub const ERROR_MEMBER_IN_ALIAS: u32 = 1378;
pub const ERROR_ALIAS_EXISTS: u32 = 1379;
pub const ERROR_LOGON_NOT_GRANTED: u32 = 1380;
pub const ERROR_TOO_MANY_SECRETS: u32 = 1381;
pub const ERROR_SECRET_TOO_LONG: u32 = 1382;
pub const ERROR_INTERNAL_DB_ERROR: u32 = 1383;
pub const ERROR_TOO_MANY_CONTEXT_IDS: u32 = 1384;
pub const ERROR_LOGON_TYPE_NOT_GRANTED: u32 = 1385;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED: u32 = 1386;
pub const ERROR_NO_SUCH_MEMBER: u32 = 1387;
pub const ERROR_INVALID_MEMBER: u32 = 1388;
pub const ERROR_TOO_MANY_SIDS: u32 = 1389;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED: u32 = 1390;
pub const ERROR_NO_INHERITANCE: u32 = 1391;
pub const ERROR_FILE_CORRUPT: u32 = 1392;
pub const ERROR_DISK_CORRUPT: u32 = 1393;
pub const ERROR_NO_USER_SESSION_KEY: u32 = 1394;
pub const ERROR_LICENSE_QUOTA_EXCEEDED: u32 = 1395;
pub const ERROR_WRONG_TARGET_NAME: u32 = 1396;
pub const ERROR_MUTUAL_AUTH_FAILED: u32 = 1397;
pub const ERROR_TIME_SKEW: u32 = 1398;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED: u32 = 1399;
pub const ERROR_INVALID_WINDOW_HANDLE: u32 = 1400;
pub const ERROR_INVALID_MENU_HANDLE: u32 = 1401;
pub const ERROR_INVALID_CURSOR_HANDLE: u32 = 1402;
pub const ERROR_INVALID_ACCEL_HANDLE: u32 = 1403;
pub const ERROR_INVALID_HOOK_HANDLE: u32 = 1404;
pub const ERROR_INVALID_DWP_HANDLE: u32 = 1405;
pub const ERROR_TLW_WITH_WSCHILD: u32 = 1406;
pub const ERROR_CANNOT_FIND_WND_CLASS: u32 = 1407;
pub const ERROR_WINDOW_OF_OTHER_THREAD: u32 = 1408;
pub const ERROR_HOTKEY_ALREADY_REGISTERED: u32 = 1409;
pub const ERROR_CLASS_ALREADY_EXISTS: u32 = 1410;
pub const ERROR_CLASS_DOES_NOT_EXIST: u32 = 1411;
pub const ERROR_CLASS_HAS_WINDOWS: u32 = 1412;
pub const ERROR_INVALID_INDEX: u32 = 1413;
pub const ERROR_INVALID_ICON_HANDLE: u32 = 1414;
pub const ERROR_PRIVATE_DIALOG_INDEX: u32 = 1415;
pub const ERROR_LISTBOX_ID_NOT_FOUND: u32 = 1416;
pub const ERROR_NO_WILDCARD_CHARACTERS: u32 = 1417;
pub const ERROR_CLIPBOARD_NOT_OPEN: u32 = 1418;
pub const ERROR_HOTKEY_NOT_REGISTERED: u32 = 1419;
pub const ERROR_WINDOW_NOT_DIALOG: u32 = 1420;
pub const ERROR_CONTROL_ID_NOT_FOUND: u32 = 1421;
pub const ERROR_INVALID_COMBOBOX_MESSAGE: u32 = 1422;
pub const ERROR_WINDOW_NOT_COMBOBOX: u32 = 1423;
pub const ERROR_INVALID_EDIT_HEIGHT: u32 = 1424;
pub const ERROR_DC_NOT_FOUND: u32 = 1425;
pub const ERROR_INVALID_HOOK_FILTER: u32 = 1426;
pub const ERROR_INVALID_FILTER_PROC: u32 = 1427;
pub const ERROR_HOOK_NEEDS_HMOD: u32 = 1428;
pub const ERROR_GLOBAL_ONLY_HOOK: u32 = 1429;
pub const ERROR_JOURNAL_HOOK_SET: u32 = 1430;
pub const ERROR_HOOK_NOT_INSTALLED: u32 = 1431;
pub const ERROR_INVALID_LB_MESSAGE: u32 = 1432;
pub const ERROR_SETCOUNT_ON_BAD_LB: u32 = 1433;
pub const ERROR_LB_WITHOUT_TABSTOPS: u32 = 1434;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD: u32 = 1435;
pub const ERROR_CHILD_WINDOW_MENU: u32 = 1436;
pub const ERROR_NO_SYSTEM_MENU: u32 = 1437;
pub const ERROR_INVALID_MSGBOX_STYLE: u32 = 1438;
pub const ERROR_INVALID_SPI_VALUE: u32 = 1439;
pub const ERROR_SCREEN_ALREADY_LOCKED: u32 = 1440;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT: u32 = 1441;
pub const ERROR_NOT_CHILD_WINDOW: u32 = 1442;
pub const ERROR_INVALID_GW_COMMAND: u32 = 1443;
pub const ERROR_INVALID_THREAD_ID: u32 = 1444;
pub const ERROR_NON_MDICHILD_WINDOW: u32 = 1445;
pub const ERROR_POPUP_ALREADY_ACTIVE: u32 = 1446;
pub const ERROR_NO_SCROLLBARS: u32 = 1447;
pub const ERROR_INVALID_SCROLLBAR_RANGE: u32 = 1448;
pub const ERROR_INVALID_SHOWWIN_COMMAND: u32 = 1449;
pub const ERROR_NO_SYSTEM_RESOURCES: u32 = 1450;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES: u32 = 1451;
pub const ERROR_PAGED_SYSTEM_RESOURCES: u32 = 1452;
pub const ERROR_WORKING_SET_QUOTA: u32 = 1453;
pub const ERROR_PAGEFILE_QUOTA: u32 = 1454;
pub const ERROR_COMMITMENT_LIMIT: u32 = 1455;
pub const ERROR_MENU_ITEM_NOT_FOUND: u32 = 1456;
pub const ERROR_INVALID_KEYBOARD_HANDLE: u32 = 1457;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED: u32 = 1458;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION: u32 = 1459;
pub const ERROR_TIMEOUT: u32 = 1460;
pub const ERROR_INVALID_MONITOR_HANDLE: u32 = 1461;
pub const ERROR_INCORRECT_SIZE: u32 = 1462;
pub const ERROR_SYMLINK_CLASS_DISABLED: u32 = 1463;
pub const ERROR_SYMLINK_NOT_SUPPORTED: u32 = 1464;
pub const ERROR_XML_PARSE_ERROR: u32 = 1465;
pub const ERROR_XMLDSIG_ERROR: u32 = 1466;
pub const ERROR_RESTART_APPLICATION: u32 = 1467;
pub const ERROR_WRONG_COMPARTMENT: u32 = 1468;
pub const ERROR_AUTHIP_FAILURE: u32 = 1469;
pub const ERROR_NO_NVRAM_RESOURCES: u32 = 1470;
pub const ERROR_NOT_GUI_PROCESS: u32 = 1471;
pub const ERROR_EVENTLOG_FILE_CORRUPT: u32 = 1500;
pub const ERROR_EVENTLOG_CANT_START: u32 = 1501;
pub const ERROR_LOG_FILE_FULL: u32 = 1502;
pub const ERROR_EVENTLOG_FILE_CHANGED: u32 = 1503;
pub const ERROR_CONTAINER_ASSIGNED: u32 = 1504;
pub const ERROR_JOB_NO_CONTAINER: u32 = 1505;
pub const ERROR_INVALID_TASK_NAME: u32 = 1550;
pub const ERROR_INVALID_TASK_INDEX: u32 = 1551;
pub const ERROR_THREAD_ALREADY_IN_TASK: u32 = 1552;
pub const ERROR_INSTALL_SERVICE_FAILURE: u32 = 1601;
pub const ERROR_INSTALL_USEREXIT: u32 = 1602;
pub const ERROR_INSTALL_FAILURE: u32 = 1603;
pub const ERROR_INSTALL_SUSPEND: u32 = 1604;
pub const ERROR_UNKNOWN_PRODUCT: u32 = 1605;
pub const ERROR_UNKNOWN_FEATURE: u32 = 1606;
pub const ERROR_UNKNOWN_COMPONENT: u32 = 1607;
pub const ERROR_UNKNOWN_PROPERTY: u32 = 1608;
pub const ERROR_INVALID_HANDLE_STATE: u32 = 1609;
pub const ERROR_BAD_CONFIGURATION: u32 = 1610;
pub const ERROR_INDEX_ABSENT: u32 = 1611;
pub const ERROR_INSTALL_SOURCE_ABSENT: u32 = 1612;
pub const ERROR_INSTALL_PACKAGE_VERSION: u32 = 1613;
pub const ERROR_PRODUCT_UNINSTALLED: u32 = 1614;
pub const ERROR_BAD_QUERY_SYNTAX: u32 = 1615;
pub const ERROR_INVALID_FIELD: u32 = 1616;
pub const ERROR_DEVICE_REMOVED: u32 = 1617;
pub const ERROR_INSTALL_ALREADY_RUNNING: u32 = 1618;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED: u32 = 1619;
pub const ERROR_INSTALL_PACKAGE_INVALID: u32 = 1620;
pub const ERROR_INSTALL_UI_FAILURE: u32 = 1621;
pub const ERROR_INSTALL_LOG_FAILURE: u32 = 1622;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED: u32 = 1623;
pub const ERROR_INSTALL_TRANSFORM_FAILURE: u32 = 1624;
pub const ERROR_INSTALL_PACKAGE_REJECTED: u32 = 1625;
pub const ERROR_FUNCTION_NOT_CALLED: u32 = 1626;
pub const ERROR_FUNCTION_FAILED: u32 = 1627;
pub const ERROR_INVALID_TABLE: u32 = 1628;
pub const ERROR_DATATYPE_MISMATCH: u32 = 1629;
pub const ERROR_UNSUPPORTED_TYPE: u32 = 1630;
pub const ERROR_CREATE_FAILED: u32 = 1631;
pub const ERROR_INSTALL_TEMP_UNWRITABLE: u32 = 1632;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED: u32 = 1633;
pub const ERROR_INSTALL_NOTUSED: u32 = 1634;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED: u32 = 1635;
pub const ERROR_PATCH_PACKAGE_INVALID: u32 = 1636;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED: u32 = 1637;
pub const ERROR_PRODUCT_VERSION: u32 = 1638;
pub const ERROR_INVALID_COMMAND_LINE: u32 = 1639;
pub const ERROR_INSTALL_REMOTE_DISALLOWED: u32 = 1640;
pub const ERROR_SUCCESS_REBOOT_INITIATED: u32 = 1641;
pub const ERROR_PATCH_TARGET_NOT_FOUND: u32 = 1642;
pub const ERROR_PATCH_PACKAGE_REJECTED: u32 = 1643;
pub const ERROR_INSTALL_TRANSFORM_REJECTED: u32 = 1644;
pub const ERROR_INSTALL_REMOTE_PROHIBITED: u32 = 1645;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED: u32 = 1646;
pub const ERROR_UNKNOWN_PATCH: u32 = 1647;
pub const ERROR_PATCH_NO_SEQUENCE: u32 = 1648;
pub const ERROR_PATCH_REMOVAL_DISALLOWED: u32 = 1649;
pub const ERROR_INVALID_PATCH_XML: u32 = 1650;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT: u32 = 1651;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT: u32 = 1652;
pub const ERROR_FAIL_FAST_EXCEPTION: u32 = 1653;
pub const ERROR_INSTALL_REJECTED: u32 = 1654;
pub const ERROR_DYNAMIC_CODE_BLOCKED: u32 = 1655;
pub const ERROR_NOT_SAME_OBJECT: u32 = 1656;
pub const ERROR_STRICT_CFG_VIOLATION: u32 = 1657;
pub const ERROR_SET_CONTEXT_DENIED: u32 = 1660;
pub const ERROR_CROSS_PARTITION_VIOLATION: u32 = 1661;
pub const RPC_S_INVALID_STRING_BINDING: u32 = 1700;
pub const RPC_S_WRONG_KIND_OF_BINDING: u32 = 1701;
pub const RPC_S_INVALID_BINDING: u32 = 1702;
pub const RPC_S_PROTSEQ_NOT_SUPPORTED: u32 = 1703;
pub const RPC_S_INVALID_RPC_PROTSEQ: u32 = 1704;
pub const RPC_S_INVALID_STRING_UUID: u32 = 1705;
pub const RPC_S_INVALID_ENDPOINT_FORMAT: u32 = 1706;
pub const RPC_S_INVALID_NET_ADDR: u32 = 1707;
pub const RPC_S_NO_ENDPOINT_FOUND: u32 = 1708;
pub const RPC_S_INVALID_TIMEOUT: u32 = 1709;
pub const RPC_S_OBJECT_NOT_FOUND: u32 = 1710;
pub const RPC_S_ALREADY_REGISTERED: u32 = 1711;
pub const RPC_S_TYPE_ALREADY_REGISTERED: u32 = 1712;
pub const RPC_S_ALREADY_LISTENING: u32 = 1713;
pub const RPC_S_NO_PROTSEQS_REGISTERED: u32 = 1714;
pub const RPC_S_NOT_LISTENING: u32 = 1715;
pub const RPC_S_UNKNOWN_MGR_TYPE: u32 = 1716;
pub const RPC_S_UNKNOWN_IF: u32 = 1717;
pub const RPC_S_NO_BINDINGS: u32 = 1718;
pub const RPC_S_NO_PROTSEQS: u32 = 1719;
pub const RPC_S_CANT_CREATE_ENDPOINT: u32 = 1720;
pub const RPC_S_OUT_OF_RESOURCES: u32 = 1721;
pub const RPC_S_SERVER_UNAVAILABLE: u32 = 1722;
pub const RPC_S_SERVER_TOO_BUSY: u32 = 1723;
pub const RPC_S_INVALID_NETWORK_OPTIONS: u32 = 1724;
pub const RPC_S_NO_CALL_ACTIVE: u32 = 1725;
pub const RPC_S_CALL_FAILED: u32 = 1726;
pub const RPC_S_CALL_FAILED_DNE: u32 = 1727;
pub const RPC_S_PROTOCOL_ERROR: u32 = 1728;
pub const RPC_S_PROXY_ACCESS_DENIED: u32 = 1729;
pub const RPC_S_UNSUPPORTED_TRANS_SYN: u32 = 1730;
pub const RPC_S_UNSUPPORTED_TYPE: u32 = 1732;
pub const RPC_S_INVALID_TAG: u32 = 1733;
pub const RPC_S_INVALID_BOUND: u32 = 1734;
pub const RPC_S_NO_ENTRY_NAME: u32 = 1735;
pub const RPC_S_INVALID_NAME_SYNTAX: u32 = 1736;
pub const RPC_S_UNSUPPORTED_NAME_SYNTAX: u32 = 1737;
pub const RPC_S_UUID_NO_ADDRESS: u32 = 1739;
pub const RPC_S_DUPLICATE_ENDPOINT: u32 = 1740;
pub const RPC_S_UNKNOWN_AUTHN_TYPE: u32 = 1741;
pub const RPC_S_MAX_CALLS_TOO_SMALL: u32 = 1742;
pub const RPC_S_STRING_TOO_LONG: u32 = 1743;
pub const RPC_S_PROTSEQ_NOT_FOUND: u32 = 1744;
pub const RPC_S_PROCNUM_OUT_OF_RANGE: u32 = 1745;
pub const RPC_S_BINDING_HAS_NO_AUTH: u32 = 1746;
pub const RPC_S_UNKNOWN_AUTHN_SERVICE: u32 = 1747;
pub const RPC_S_UNKNOWN_AUTHN_LEVEL: u32 = 1748;
pub const RPC_S_INVALID_AUTH_IDENTITY: u32 = 1749;
pub const RPC_S_UNKNOWN_AUTHZ_SERVICE: u32 = 1750;
pub const EPT_S_INVALID_ENTRY: u32 = 1751;
pub const EPT_S_CANT_PERFORM_OP: u32 = 1752;
pub const EPT_S_NOT_REGISTERED: u32 = 1753;
pub const RPC_S_NOTHING_TO_EXPORT: u32 = 1754;
pub const RPC_S_INCOMPLETE_NAME: u32 = 1755;
pub const RPC_S_INVALID_VERS_OPTION: u32 = 1756;
pub const RPC_S_NO_MORE_MEMBERS: u32 = 1757;
pub const RPC_S_NOT_ALL_OBJS_UNEXPORTED: u32 = 1758;
pub const RPC_S_INTERFACE_NOT_FOUND: u32 = 1759;
pub const RPC_S_ENTRY_ALREADY_EXISTS: u32 = 1760;
pub const RPC_S_ENTRY_NOT_FOUND: u32 = 1761;
pub const RPC_S_NAME_SERVICE_UNAVAILABLE: u32 = 1762;
pub const RPC_S_INVALID_NAF_ID: u32 = 1763;
pub const RPC_S_CANNOT_SUPPORT: u32 = 1764;
pub const RPC_S_NO_CONTEXT_AVAILABLE: u32 = 1765;
pub const RPC_S_INTERNAL_ERROR: u32 = 1766;
pub const RPC_S_ZERO_DIVIDE: u32 = 1767;
pub const RPC_S_ADDRESS_ERROR: u32 = 1768;
pub const RPC_S_FP_DIV_ZERO: u32 = 1769;
pub const RPC_S_FP_UNDERFLOW: u32 = 1770;
pub const RPC_S_FP_OVERFLOW: u32 = 1771;
pub const RPC_X_NO_MORE_ENTRIES: u32 = 1772;
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL: u32 = 1773;
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE: u32 = 1774;
pub const RPC_X_SS_IN_NULL_CONTEXT: u32 = 1775;
pub const RPC_X_SS_CONTEXT_DAMAGED: u32 = 1777;
pub const RPC_X_SS_HANDLES_MISMATCH: u32 = 1778;
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE: u32 = 1779;
pub const RPC_X_NULL_REF_POINTER: u32 = 1780;
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE: u32 = 1781;
pub const RPC_X_BYTE_COUNT_TOO_SMALL: u32 = 1782;
pub const RPC_X_BAD_STUB_DATA: u32 = 1783;
pub const ERROR_INVALID_USER_BUFFER: u32 = 1784;
pub const ERROR_UNRECOGNIZED_MEDIA: u32 = 1785;
pub const ERROR_NO_TRUST_LSA_SECRET: u32 = 1786;
pub const ERROR_NO_TRUST_SAM_ACCOUNT: u32 = 1787;
pub const ERROR_TRUSTED_DOMAIN_FAILURE: u32 = 1788;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE: u32 = 1789;
pub const ERROR_TRUST_FAILURE: u32 = 1790;
pub const RPC_S_CALL_IN_PROGRESS: u32 = 1791;
pub const ERROR_NETLOGON_NOT_STARTED: u32 = 1792;
pub const ERROR_ACCOUNT_EXPIRED: u32 = 1793;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES: u32 = 1794;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED: u32 = 1795;
pub const ERROR_UNKNOWN_PORT: u32 = 1796;
pub const ERROR_UNKNOWN_PRINTER_DRIVER: u32 = 1797;
pub const ERROR_UNKNOWN_PRINTPROCESSOR: u32 = 1798;
pub const ERROR_INVALID_SEPARATOR_FILE: u32 = 1799;
pub const ERROR_INVALID_PRIORITY: u32 = 1800;
pub const ERROR_INVALID_PRINTER_NAME: u32 = 1801;
pub const ERROR_PRINTER_ALREADY_EXISTS: u32 = 1802;
pub const ERROR_INVALID_PRINTER_COMMAND: u32 = 1803;
pub const ERROR_INVALID_DATATYPE: u32 = 1804;
pub const ERROR_INVALID_ENVIRONMENT: u32 = 1805;
pub const RPC_S_NO_MORE_BINDINGS: u32 = 1806;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: u32 = 1807;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT: u32 = 1808;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT: u32 = 1809;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT: u32 = 1810;
pub const ERROR_SERVER_HAS_OPEN_HANDLES: u32 = 1811;
pub const ERROR_RESOURCE_DATA_NOT_FOUND: u32 = 1812;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND: u32 = 1813;
pub const ERROR_RESOURCE_NAME_NOT_FOUND: u32 = 1814;
pub const ERROR_RESOURCE_LANG_NOT_FOUND: u32 = 1815;
pub const ERROR_NOT_ENOUGH_QUOTA: u32 = 1816;
pub const RPC_S_NO_INTERFACES: u32 = 1817;
pub const RPC_S_CALL_CANCELLED: u32 = 1818;
pub const RPC_S_BINDING_INCOMPLETE: u32 = 1819;
pub const RPC_S_COMM_FAILURE: u32 = 1820;
pub const RPC_S_UNSUPPORTED_AUTHN_LEVEL: u32 = 1821;
pub const RPC_S_NO_PRINC_NAME: u32 = 1822;
pub const RPC_S_NOT_RPC_ERROR: u32 = 1823;
pub const RPC_S_UUID_LOCAL_ONLY: u32 = 1824;
pub const RPC_S_SEC_PKG_ERROR: u32 = 1825;
pub const RPC_S_NOT_CANCELLED: u32 = 1826;
pub const RPC_X_INVALID_ES_ACTION: u32 = 1827;
pub const RPC_X_WRONG_ES_VERSION: u32 = 1828;
pub const RPC_X_WRONG_STUB_VERSION: u32 = 1829;
pub const RPC_X_INVALID_PIPE_OBJECT: u32 = 1830;
pub const RPC_X_WRONG_PIPE_ORDER: u32 = 1831;
pub const RPC_X_WRONG_PIPE_VERSION: u32 = 1832;
pub const RPC_S_COOKIE_AUTH_FAILED: u32 = 1833;
pub const RPC_S_DO_NOT_DISTURB: u32 = 1834;
pub const RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED: u32 = 1835;
pub const RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH: u32 = 1836;
pub const RPC_S_GROUP_MEMBER_NOT_FOUND: u32 = 1898;
pub const EPT_S_CANT_CREATE: u32 = 1899;
pub const RPC_S_INVALID_OBJECT: u32 = 1900;
pub const ERROR_INVALID_TIME: u32 = 1901;
pub const ERROR_INVALID_FORM_NAME: u32 = 1902;
pub const ERROR_INVALID_FORM_SIZE: u32 = 1903;
pub const ERROR_ALREADY_WAITING: u32 = 1904;
pub const ERROR_PRINTER_DELETED: u32 = 1905;
pub const ERROR_INVALID_PRINTER_STATE: u32 = 1906;
pub const ERROR_PASSWORD_MUST_CHANGE: u32 = 1907;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND: u32 = 1908;
pub const ERROR_ACCOUNT_LOCKED_OUT: u32 = 1909;
pub const OR_INVALID_OXID: u32 = 1910;
pub const OR_INVALID_OID: u32 = 1911;
pub const OR_INVALID_SET: u32 = 1912;
pub const RPC_S_SEND_INCOMPLETE: u32 = 1913;
pub const RPC_S_INVALID_ASYNC_HANDLE: u32 = 1914;
pub const RPC_S_INVALID_ASYNC_CALL: u32 = 1915;
pub const RPC_X_PIPE_CLOSED: u32 = 1916;
pub const RPC_X_PIPE_DISCIPLINE_ERROR: u32 = 1917;
pub const RPC_X_PIPE_EMPTY: u32 = 1918;
pub const ERROR_NO_SITENAME: u32 = 1919;
pub const ERROR_CANT_ACCESS_FILE: u32 = 1920;
pub const ERROR_CANT_RESOLVE_FILENAME: u32 = 1921;
pub const RPC_S_ENTRY_TYPE_MISMATCH: u32 = 1922;
pub const RPC_S_NOT_ALL_OBJS_EXPORTED: u32 = 1923;
pub const RPC_S_INTERFACE_NOT_EXPORTED: u32 = 1924;
pub const RPC_S_PROFILE_NOT_ADDED: u32 = 1925;
pub const RPC_S_PRF_ELT_NOT_ADDED: u32 = 1926;
pub const RPC_S_PRF_ELT_NOT_REMOVED: u32 = 1927;
pub const RPC_S_GRP_ELT_NOT_ADDED: u32 = 1928;
pub const RPC_S_GRP_ELT_NOT_REMOVED: u32 = 1929;
pub const ERROR_KM_DRIVER_BLOCKED: u32 = 1930;
pub const ERROR_CONTEXT_EXPIRED: u32 = 1931;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED: u32 = 1932;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED: u32 = 1933;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED: u32 = 1934;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED: u32 = 1935;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED: u32 = 1936;
pub const ERROR_NTLM_BLOCKED: u32 = 1937;
pub const ERROR_PASSWORD_CHANGE_REQUIRED: u32 = 1938;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION: u32 = 1939;
pub const ERROR_INVALID_PIXEL_FORMAT: u32 = 2000;
pub const ERROR_BAD_DRIVER: u32 = 2001;
pub const ERROR_INVALID_WINDOW_STYLE: u32 = 2002;
pub const ERROR_METAFILE_NOT_SUPPORTED: u32 = 2003;
pub const ERROR_TRANSFORM_NOT_SUPPORTED: u32 = 2004;
pub const ERROR_CLIPPING_NOT_SUPPORTED: u32 = 2005;
pub const ERROR_INVALID_CMM: u32 = 2010;
pub const ERROR_INVALID_PROFILE: u32 = 2011;
pub const ERROR_TAG_NOT_FOUND: u32 = 2012;
pub const ERROR_TAG_NOT_PRESENT: u32 = 2013;
pub const ERROR_DUPLICATE_TAG: u32 = 2014;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE: u32 = 2015;
pub const ERROR_PROFILE_NOT_FOUND: u32 = 2016;
pub const ERROR_INVALID_COLORSPACE: u32 = 2017;
pub const ERROR_ICM_NOT_ENABLED: u32 = 2018;
pub const ERROR_DELETING_ICM_XFORM: u32 = 2019;
pub const ERROR_INVALID_TRANSFORM: u32 = 2020;
pub const ERROR_COLORSPACE_MISMATCH: u32 = 2021;
pub const ERROR_INVALID_COLORINDEX: u32 = 2022;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE: u32 = 2023;
pub const ERROR_CONNECTED_OTHER_PASSWORD: u32 = 2108;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 2109;
pub const ERROR_BAD_USERNAME: u32 = 2202;
pub const ERROR_NOT_CONNECTED: u32 = 2250;
pub const ERROR_OPEN_FILES: u32 = 2401;
pub const ERROR_ACTIVE_CONNECTIONS: u32 = 2402;
pub const ERROR_DEVICE_IN_USE: u32 = 2404;
pub const ERROR_UNKNOWN_PRINT_MONITOR: u32 = 3000;
pub const ERROR_PRINTER_DRIVER_IN_USE: u32 = 3001;
pub const ERROR_SPOOL_FILE_NOT_FOUND: u32 = 3002;
pub const ERROR_SPL_NO_STARTDOC: u32 = 3003;
pub const ERROR_SPL_NO_ADDJOB: u32 = 3004;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED: u32 = 3005;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED: u32 = 3006;
pub const ERROR_INVALID_PRINT_MONITOR: u32 = 3007;
pub const ERROR_PRINT_MONITOR_IN_USE: u32 = 3008;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED: u32 = 3009;
pub const ERROR_SUCCESS_REBOOT_REQUIRED: u32 = 3010;
pub const ERROR_SUCCESS_RESTART_REQUIRED: u32 = 3011;
pub const ERROR_PRINTER_NOT_FOUND: u32 = 3012;
pub const ERROR_PRINTER_DRIVER_WARNED: u32 = 3013;
pub const ERROR_PRINTER_DRIVER_BLOCKED: u32 = 3014;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE: u32 = 3015;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND: u32 = 3016;
pub const ERROR_FAIL_REBOOT_REQUIRED: u32 = 3017;
pub const ERROR_FAIL_REBOOT_INITIATED: u32 = 3018;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED: u32 = 3019;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED: u32 = 3020;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST: u32 = 3021;
pub const ERROR_PRINTER_NOT_SHAREABLE: u32 = 3022;
pub const ERROR_REQUEST_PAUSED: u32 = 3050;
pub const ERROR_IO_REISSUE_AS_CACHED: u32 = 3950;
pub const ERROR_WINS_INTERNAL: u32 = 4000;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS: u32 = 4001;
pub const ERROR_STATIC_INIT: u32 = 4002;
pub const ERROR_INC_BACKUP: u32 = 4003;
pub const ERROR_FULL_BACKUP: u32 = 4004;
pub const ERROR_REC_NON_EXISTENT: u32 = 4005;
pub const ERROR_RPL_NOT_ALLOWED: u32 = 4006;
pub const PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED: u32 = 4050;
pub const PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO: u32 = 4051;
pub const PEERDIST_ERROR_MISSING_DATA: u32 = 4052;
pub const PEERDIST_ERROR_NO_MORE: u32 = 4053;
pub const PEERDIST_ERROR_NOT_INITIALIZED: u32 = 4054;
pub const PEERDIST_ERROR_ALREADY_INITIALIZED: u32 = 4055;
pub const PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS: u32 = 4056;
pub const PEERDIST_ERROR_INVALIDATED: u32 = 4057;
pub const PEERDIST_ERROR_ALREADY_EXISTS: u32 = 4058;
pub const PEERDIST_ERROR_OPERATION_NOTFOUND: u32 = 4059;
pub const PEERDIST_ERROR_ALREADY_COMPLETED: u32 = 4060;
pub const PEERDIST_ERROR_OUT_OF_BOUNDS: u32 = 4061;
pub const PEERDIST_ERROR_VERSION_UNSUPPORTED: u32 = 4062;
pub const PEERDIST_ERROR_INVALID_CONFIGURATION: u32 = 4063;
pub const PEERDIST_ERROR_NOT_LICENSED: u32 = 4064;
pub const PEERDIST_ERROR_SERVICE_UNAVAILABLE: u32 = 4065;
pub const PEERDIST_ERROR_TRUST_FAILURE: u32 = 4066;
pub const ERROR_DHCP_ADDRESS_CONFLICT: u32 = 4100;
pub const ERROR_WMI_GUID_NOT_FOUND: u32 = 4200;
pub const ERROR_WMI_INSTANCE_NOT_FOUND: u32 = 4201;
pub const ERROR_WMI_ITEMID_NOT_FOUND: u32 = 4202;
pub const ERROR_WMI_TRY_AGAIN: u32 = 4203;
pub const ERROR_WMI_DP_NOT_FOUND: u32 = 4204;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF: u32 = 4205;
pub const ERROR_WMI_ALREADY_ENABLED: u32 = 4206;
pub const ERROR_WMI_GUID_DISCONNECTED: u32 = 4207;
pub const ERROR_WMI_SERVER_UNAVAILABLE: u32 = 4208;
pub const ERROR_WMI_DP_FAILED: u32 = 4209;
pub const ERROR_WMI_INVALID_MOF: u32 = 4210;
pub const ERROR_WMI_INVALID_REGINFO: u32 = 4211;
pub const ERROR_WMI_ALREADY_DISABLED: u32 = 4212;
pub const ERROR_WMI_READ_ONLY: u32 = 4213;
pub const ERROR_WMI_SET_FAILURE: u32 = 4214;
pub const ERROR_NOT_APPCONTAINER: u32 = 4250;
pub const ERROR_APPCONTAINER_REQUIRED: u32 = 4251;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER: u32 = 4252;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH: u32 = 4253;
pub const ERROR_INVALID_MEDIA: u32 = 4300;
pub const ERROR_INVALID_LIBRARY: u32 = 4301;
pub const ERROR_INVALID_MEDIA_POOL: u32 = 4302;
pub const ERROR_DRIVE_MEDIA_MISMATCH: u32 = 4303;
pub const ERROR_MEDIA_OFFLINE: u32 = 4304;
pub const ERROR_LIBRARY_OFFLINE: u32 = 4305;
pub const ERROR_EMPTY: u32 = 4306;
pub const ERROR_NOT_EMPTY: u32 = 4307;
pub const ERROR_MEDIA_UNAVAILABLE: u32 = 4308;
pub const ERROR_RESOURCE_DISABLED: u32 = 4309;
pub const ERROR_INVALID_CLEANER: u32 = 4310;
pub const ERROR_UNABLE_TO_CLEAN: u32 = 4311;
pub const ERROR_OBJECT_NOT_FOUND: u32 = 4312;
pub const ERROR_DATABASE_FAILURE: u32 = 4313;
pub const ERROR_DATABASE_FULL: u32 = 4314;
pub const ERROR_MEDIA_INCOMPATIBLE: u32 = 4315;
pub const ERROR_RESOURCE_NOT_PRESENT: u32 = 4316;
pub const ERROR_INVALID_OPERATION: u32 = 4317;
pub const ERROR_MEDIA_NOT_AVAILABLE: u32 = 4318;
pub const ERROR_DEVICE_NOT_AVAILABLE: u32 = 4319;
pub const ERROR_REQUEST_REFUSED: u32 = 4320;
pub const ERROR_INVALID_DRIVE_OBJECT: u32 = 4321;
pub const ERROR_LIBRARY_FULL: u32 = 4322;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE: u32 = 4323;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM: u32 = 4324;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE: u32 = 4325;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT: u32 = 4326;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT: u32 = 4327;
pub const ERROR_TRANSPORT_FULL: u32 = 4328;
pub const ERROR_CONTROLLING_IEPORT: u32 = 4329;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA: u32 = 4330;
pub const ERROR_CLEANER_SLOT_SET: u32 = 4331;
pub const ERROR_CLEANER_SLOT_NOT_SET: u32 = 4332;
pub const ERROR_CLEANER_CARTRIDGE_SPENT: u32 = 4333;
pub const ERROR_UNEXPECTED_OMID: u32 = 4334;
pub const ERROR_CANT_DELETE_LAST_ITEM: u32 = 4335;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE: u32 = 4336;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES: u32 = 4337;
pub const ERROR_INDIGENOUS_TYPE: u32 = 4338;
pub const ERROR_NO_SUPPORTING_DRIVES: u32 = 4339;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED: u32 = 4340;
pub const ERROR_IEPORT_FULL: u32 = 4341;
pub const ERROR_FILE_OFFLINE: u32 = 4350;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE: u32 = 4351;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR: u32 = 4352;
pub const ERROR_NOT_A_REPARSE_POINT: u32 = 4390;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT: u32 = 4391;
pub const ERROR_INVALID_REPARSE_DATA: u32 = 4392;
pub const ERROR_REPARSE_TAG_INVALID: u32 = 4393;
pub const ERROR_REPARSE_TAG_MISMATCH: u32 = 4394;
pub const ERROR_REPARSE_POINT_ENCOUNTERED: u32 = 4395;
pub const ERROR_APP_DATA_NOT_FOUND: u32 = 4400;
pub const ERROR_APP_DATA_EXPIRED: u32 = 4401;
pub const ERROR_APP_DATA_CORRUPT: u32 = 4402;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED: u32 = 4403;
pub const ERROR_APP_DATA_REBOOT_REQUIRED: u32 = 4404;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED: u32 = 4420;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION: u32 = 4421;
pub const ERROR_SECUREBOOT_INVALID_POLICY: u32 = 4422;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND: u32 = 4423;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED: u32 = 4424;
pub const ERROR_SECUREBOOT_NOT_ENABLED: u32 = 4425;
pub const ERROR_SECUREBOOT_FILE_REPLACED: u32 = 4426;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED: u32 = 4427;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN: u32 = 4428;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION: u32 = 4429;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH: u32 = 4430;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED: u32 = 4431;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH: u32 = 4432;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING: u32 = 4433;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY: u32 = 4434;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY: u32 = 4435;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED: u32 = 4440;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED: u32 = 4441;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED: u32 = 4442;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED: u32 = 4443;
pub const ERROR_ALREADY_HAS_STREAM_ID: u32 = 4444;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED: u32 = 4445;
pub const ERROR_VOLUME_NOT_SIS_ENABLED: u32 = 4500;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED: u32 = 4550;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION: u32 = 4551;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY: u32 = 4552;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED: u32 = 4553;
pub const ERROR_VSM_NOT_INITIALIZED: u32 = 4560;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE: u32 = 4561;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED: u32 = 4570;
pub const ERROR_PLATFORM_MANIFEST_INVALID: u32 = 4571;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED: u32 = 4572;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED: u32 = 4573;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND: u32 = 4574;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE: u32 = 4575;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED: u32 = 4576;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS: u32 = 5001;
pub const ERROR_DEPENDENCY_NOT_FOUND: u32 = 5002;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS: u32 = 5003;
pub const ERROR_RESOURCE_NOT_ONLINE: u32 = 5004;
pub const ERROR_HOST_NODE_NOT_AVAILABLE: u32 = 5005;
pub const ERROR_RESOURCE_NOT_AVAILABLE: u32 = 5006;
pub const ERROR_RESOURCE_NOT_FOUND: u32 = 5007;
pub const ERROR_SHUTDOWN_CLUSTER: u32 = 5008;
pub const ERROR_CANT_EVICT_ACTIVE_NODE: u32 = 5009;
pub const ERROR_OBJECT_ALREADY_EXISTS: u32 = 5010;
pub const ERROR_OBJECT_IN_LIST: u32 = 5011;
pub const ERROR_GROUP_NOT_AVAILABLE: u32 = 5012;
pub const ERROR_GROUP_NOT_FOUND: u32 = 5013;
pub const ERROR_GROUP_NOT_ONLINE: u32 = 5014;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER: u32 = 5015;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER: u32 = 5016;
pub const ERROR_RESMON_CREATE_FAILED: u32 = 5017;
pub const ERROR_RESMON_ONLINE_FAILED: u32 = 5018;
pub const ERROR_RESOURCE_ONLINE: u32 = 5019;
pub const ERROR_QUORUM_RESOURCE: u32 = 5020;
pub const ERROR_NOT_QUORUM_CAPABLE: u32 = 5021;
pub const ERROR_CLUSTER_SHUTTING_DOWN: u32 = 5022;
pub const ERROR_INVALID_STATE: u32 = 5023;
pub const ERROR_RESOURCE_PROPERTIES_STORED: u32 = 5024;
pub const ERROR_NOT_QUORUM_CLASS: u32 = 5025;
pub const ERROR_CORE_RESOURCE: u32 = 5026;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED: u32 = 5027;
pub const ERROR_QUORUMLOG_OPEN_FAILED: u32 = 5028;
pub const ERROR_CLUSTERLOG_CORRUPT: u32 = 5029;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE: u32 = 5030;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE: u32 = 5031;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND: u32 = 5032;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE: u32 = 5033;
pub const ERROR_QUORUM_OWNER_ALIVE: u32 = 5034;
pub const ERROR_NETWORK_NOT_AVAILABLE: u32 = 5035;
pub const ERROR_NODE_NOT_AVAILABLE: u32 = 5036;
pub const ERROR_ALL_NODES_NOT_AVAILABLE: u32 = 5037;
pub const ERROR_RESOURCE_FAILED: u32 = 5038;
pub const ERROR_CLUSTER_INVALID_NODE: u32 = 5039;
pub const ERROR_CLUSTER_NODE_EXISTS: u32 = 5040;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS: u32 = 5041;
pub const ERROR_CLUSTER_NODE_NOT_FOUND: u32 = 5042;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND: u32 = 5043;
pub const ERROR_CLUSTER_NETWORK_EXISTS: u32 = 5044;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND: u32 = 5045;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS: u32 = 5046;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND: u32 = 5047;
pub const ERROR_CLUSTER_INVALID_REQUEST: u32 = 5048;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER: u32 = 5049;
pub const ERROR_CLUSTER_NODE_DOWN: u32 = 5050;
pub const ERROR_CLUSTER_NODE_UNREACHABLE: u32 = 5051;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER: u32 = 5052;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS: u32 = 5053;
pub const ERROR_CLUSTER_INVALID_NETWORK: u32 = 5054;
pub const ERROR_CLUSTER_NODE_UP: u32 = 5056;
pub const ERROR_CLUSTER_IPADDR_IN_USE: u32 = 5057;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED: u32 = 5058;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT: u32 = 5059;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL: u32 = 5060;
pub const ERROR_CLUSTER_NODE_ALREADY_UP: u32 = 5061;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN: u32 = 5062;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE: u32 = 5063;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE: u32 = 5064;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER: u32 = 5065;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK: u32 = 5066;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS: u32 = 5067;
pub const ERROR_INVALID_OPERATION_ON_QUORUM: u32 = 5068;
pub const ERROR_DEPENDENCY_NOT_ALLOWED: u32 = 5069;
pub const ERROR_CLUSTER_NODE_PAUSED: u32 = 5070;
pub const ERROR_NODE_CANT_HOST_RESOURCE: u32 = 5071;
pub const ERROR_CLUSTER_NODE_NOT_READY: u32 = 5072;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN: u32 = 5073;
pub const ERROR_CLUSTER_JOIN_ABORTED: u32 = 5074;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS: u32 = 5075;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED: u32 = 5076;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED: u32 = 5077;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: u32 = 5078;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED: u32 = 5079;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND: u32 = 5080;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED: u32 = 5081;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST: u32 = 5082;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH: u32 = 5083;
pub const ERROR_RESMON_INVALID_STATE: u32 = 5084;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER: u32 = 5085;
pub const ERROR_QUORUM_DISK_NOT_FOUND: u32 = 5086;
pub const ERROR_DATABASE_BACKUP_CORRUPT: u32 = 5087;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT: u32 = 5088;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE: u32 = 5089;
pub const ERROR_NO_ADMIN_ACCESS_POINT: u32 = 5090;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE: u32 = 5890;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND: u32 = 5891;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT: u32 = 5892;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH: u32 = 5893;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP: u32 = 5894;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH: u32 = 5895;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP: u32 = 5896;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH: u32 = 5897;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED: u32 = 5898;
pub const ERROR_CLUSTER_WRONG_OS_VERSION: u32 = 5899;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME: u32 = 5900;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED: u32 = 5901;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED: u32 = 5902;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT: u32 = 5903;
pub const ERROR_CLUSTER_OLD_VERSION: u32 = 5904;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME: u32 = 5905;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS: u32 = 5906;
pub const ERROR_CLUSTER_POISONED: u32 = 5907;
pub const ERROR_CLUSTER_GROUP_MOVING: u32 = 5908;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY: u32 = 5909;
pub const ERROR_RESOURCE_CALL_TIMED_OUT: u32 = 5910;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS: u32 = 5911;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION: u32 = 5912;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS: u32 = 5913;
pub const ERROR_CLUSTER_PARTIAL_SEND: u32 = 5914;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION: u32 = 5915;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION: u32 = 5916;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT: u32 = 5917;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS: u32 = 5918;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS: u32 = 5919;
pub const ERROR_CLUSTER_NULL_DATA: u32 = 5920;
pub const ERROR_CLUSTER_PARTIAL_READ: u32 = 5921;
pub const ERROR_CLUSTER_PARTIAL_WRITE: u32 = 5922;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA: u32 = 5923;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT: u32 = 5924;
pub const ERROR_CLUSTER_NO_QUORUM: u32 = 5925;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK: u32 = 5926;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK: u32 = 5927;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP: u32 = 5928;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX: u32 = 5929;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL: u32 = 5930;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION: u32 = 5931;
pub const ERROR_CLUSTER_NOT_INSTALLED: u32 = 5932;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE: u32 = 5933;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER: u32 = 5934;
pub const ERROR_CLUSTER_TOO_MANY_NODES: u32 = 5935;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED: u32 = 5936;
pub const ERROR_NONCORE_GROUPS_FOUND: u32 = 5937;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT: u32 = 5938;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST: u32 = 5939;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE: u32 = 5940;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE: u32 = 5941;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED: u32 = 5942;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR: u32 = 5943;
pub const ERROR_CLUSTER_GROUP_BUSY: u32 = 5944;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME: u32 = 5945;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR: u32 = 5946;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE: u32 = 5947;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API: u32 = 5948;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS: u32 = 5949;
pub const ERROR_NON_CSV_PATH: u32 = 5950;
pub const ERROR_CSV_VOLUME_NOT_LOCAL: u32 = 5951;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING: u32 = 5952;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES: u32 = 5953;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT: u32 = 5954;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL: u32 = 5955;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING: u32 = 5956;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION: u32 = 5957;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE: u32 = 5958;
pub const ERROR_CLUSTER_GROUP_QUEUED: u32 = 5959;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS: u32 = 5960;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED: u32 = 5961;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS: u32 = 5962;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED: u32 = 5963;
pub const ERROR_DISK_NOT_CSV_CAPABLE: u32 = 5964;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE: u32 = 5965;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED: u32 = 5966;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED: u32 = 5967;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES: u32 = 5968;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES: u32 = 5969;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE: u32 = 5970;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT: u32 = 5971;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE: u32 = 5972;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS: u32 = 5973;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED: u32 = 5974;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED: u32 = 5975;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS: u32 = 5976;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE: u32 = 5977;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD: u32 = 5978;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT: u32 = 5979;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER: u32 = 5980;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED: u32 = 5981;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED: u32 = 5982;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED: u32 = 5983;
pub const ERROR_CLUSTER_NODE_ISOLATED: u32 = 5984;
pub const ERROR_CLUSTER_NODE_QUARANTINED: u32 = 5985;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED: u32 = 5986;
pub const ERROR_CLUSTER_SPACE_DEGRADED: u32 = 5987;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED: u32 = 5988;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE: u32 = 5989;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR: u32 = 5990;
pub const ERROR_GROUPSET_NOT_AVAILABLE: u32 = 5991;
pub const ERROR_GROUPSET_NOT_FOUND: u32 = 5992;
pub const ERROR_GROUPSET_CANT_PROVIDE: u32 = 5993;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND: u32 = 5994;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY: u32 = 5995;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION: u32 = 5996;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS: u32 = 5997;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME: u32 = 5998;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE: u32 = 5999;
pub const ERROR_ENCRYPTION_FAILED: u32 = 6000;
pub const ERROR_DECRYPTION_FAILED: u32 = 6001;
pub const ERROR_FILE_ENCRYPTED: u32 = 6002;
pub const ERROR_NO_RECOVERY_POLICY: u32 = 6003;
pub const ERROR_NO_EFS: u32 = 6004;
pub const ERROR_WRONG_EFS: u32 = 6005;
pub const ERROR_NO_USER_KEYS: u32 = 6006;
pub const ERROR_FILE_NOT_ENCRYPTED: u32 = 6007;
pub const ERROR_NOT_EXPORT_FORMAT: u32 = 6008;
pub const ERROR_FILE_READ_ONLY: u32 = 6009;
pub const ERROR_DIR_EFS_DISALLOWED: u32 = 6010;
pub const ERROR_EFS_SERVER_NOT_TRUSTED: u32 = 6011;
pub const ERROR_BAD_RECOVERY_POLICY: u32 = 6012;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG: u32 = 6013;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS: u32 = 6014;
pub const ERROR_EFS_DISABLED: u32 = 6015;
pub const ERROR_EFS_VERSION_NOT_SUPPORT: u32 = 6016;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE: u32 = 6017;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER: u32 = 6018;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE: u32 = 6019;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE: u32 = 6020;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE: u32 = 6021;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION: u32 = 6022;
pub const ERROR_NO_BROWSER_SERVERS_FOUND: u32 = 6118;
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM: u32 = 6200;
pub const ERROR_LOG_SECTOR_INVALID: u32 = 6600;
pub const ERROR_LOG_SECTOR_PARITY_INVALID: u32 = 6601;
pub const ERROR_LOG_SECTOR_REMAPPED: u32 = 6602;
pub const ERROR_LOG_BLOCK_INCOMPLETE: u32 = 6603;
pub const ERROR_LOG_INVALID_RANGE: u32 = 6604;
pub const ERROR_LOG_BLOCKS_EXHAUSTED: u32 = 6605;
pub const ERROR_LOG_READ_CONTEXT_INVALID: u32 = 6606;
pub const ERROR_LOG_RESTART_INVALID: u32 = 6607;
pub const ERROR_LOG_BLOCK_VERSION: u32 = 6608;
pub const ERROR_LOG_BLOCK_INVALID: u32 = 6609;
pub const ERROR_LOG_READ_MODE_INVALID: u32 = 6610;
pub const ERROR_LOG_NO_RESTART: u32 = 6611;
pub const ERROR_LOG_METADATA_CORRUPT: u32 = 6612;
pub const ERROR_LOG_METADATA_INVALID: u32 = 6613;
pub const ERROR_LOG_METADATA_INCONSISTENT: u32 = 6614;
pub const ERROR_LOG_RESERVATION_INVALID: u32 = 6615;
pub const ERROR_LOG_CANT_DELETE: u32 = 6616;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED: u32 = 6617;
pub const ERROR_LOG_START_OF_LOG: u32 = 6618;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED: u32 = 6619;
pub const ERROR_LOG_POLICY_NOT_INSTALLED: u32 = 6620;
pub const ERROR_LOG_POLICY_INVALID: u32 = 6621;
pub const ERROR_LOG_POLICY_CONFLICT: u32 = 6622;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL: u32 = 6623;
pub const ERROR_LOG_RECORD_NONEXISTENT: u32 = 6624;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID: u32 = 6625;
pub const ERROR_LOG_SPACE_RESERVED_INVALID: u32 = 6626;
pub const ERROR_LOG_TAIL_INVALID: u32 = 6627;
pub const ERROR_LOG_FULL: u32 = 6628;
pub const ERROR_COULD_NOT_RESIZE_LOG: u32 = 6629;
pub const ERROR_LOG_MULTIPLEXED: u32 = 6630;
pub const ERROR_LOG_DEDICATED: u32 = 6631;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS: u32 = 6632;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS: u32 = 6633;
pub const ERROR_LOG_EPHEMERAL: u32 = 6634;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS: u32 = 6635;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED: u32 = 6636;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED: u32 = 6637;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS: u32 = 6638;
pub const ERROR_LOG_CONTAINER_READ_FAILED: u32 = 6639;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED: u32 = 6640;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED: u32 = 6641;
pub const ERROR_LOG_CONTAINER_STATE_INVALID: u32 = 6642;
pub const ERROR_LOG_STATE_INVALID: u32 = 6643;
pub const ERROR_LOG_PINNED: u32 = 6644;
pub const ERROR_LOG_METADATA_FLUSH_FAILED: u32 = 6645;
pub const ERROR_LOG_INCONSISTENT_SECURITY: u32 = 6646;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED: u32 = 6647;
pub const ERROR_LOG_PINNED_RESERVATION: u32 = 6648;
pub const ERROR_INVALID_TRANSACTION: u32 = 6700;
pub const ERROR_TRANSACTION_NOT_ACTIVE: u32 = 6701;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID: u32 = 6702;
pub const ERROR_TRANSACTION_NOT_REQUESTED: u32 = 6703;
pub const ERROR_TRANSACTION_ALREADY_ABORTED: u32 = 6704;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED: u32 = 6705;
pub const ERROR_TM_INITIALIZATION_FAILED: u32 = 6706;
pub const ERROR_RESOURCEMANAGER_READ_ONLY: u32 = 6707;
pub const ERROR_TRANSACTION_NOT_JOINED: u32 = 6708;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS: u32 = 6709;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS: u32 = 6710;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED: u32 = 6711;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND: u32 = 6712;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER: u32 = 6713;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID: u32 = 6714;
pub const ERROR_TRANSACTION_NOT_FOUND: u32 = 6715;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND: u32 = 6716;
pub const ERROR_ENLISTMENT_NOT_FOUND: u32 = 6717;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND: u32 = 6718;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE: u32 = 6719;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION: u32 = 6720;
pub const ERROR_TRANSACTION_NOT_ROOT: u32 = 6721;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED: u32 = 6722;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED: u32 = 6723;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG: u32 = 6724;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED: u32 = 6725;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED: u32 = 6726;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH: u32 = 6727;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT: u32 = 6728;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH: u32 = 6729;
pub const ERROR_TRANSACTION_NO_SUPERIOR: u32 = 6730;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE: u32 = 6731;
pub const ERROR_TRANSACTIONAL_CONFLICT: u32 = 6800;
pub const ERROR_RM_NOT_ACTIVE: u32 = 6801;
pub const ERROR_RM_METADATA_CORRUPT: u32 = 6802;
pub const ERROR_DIRECTORY_NOT_RM: u32 = 6803;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE: u32 = 6805;
pub const ERROR_LOG_RESIZE_INVALID_SIZE: u32 = 6806;
pub const ERROR_OBJECT_NO_LONGER_EXISTS: u32 = 6807;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND: u32 = 6808;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID: u32 = 6809;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION: u32 = 6810;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT: u32 = 6811;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS: u32 = 6812;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH: u32 = 6814;
pub const ERROR_HANDLE_NO_LONGER_VALID: u32 = 6815;
pub const ERROR_NO_TXF_METADATA: u32 = 6816;
pub const ERROR_LOG_CORRUPTION_DETECTED: u32 = 6817;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN: u32 = 6818;
pub const ERROR_RM_DISCONNECTED: u32 = 6819;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR: u32 = 6820;
pub const ERROR_RECOVERY_NOT_NEEDED: u32 = 6821;
pub const ERROR_RM_ALREADY_STARTED: u32 = 6822;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT: u32 = 6823;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY: u32 = 6824;
pub const ERROR_CANT_CROSS_RM_BOUNDARY: u32 = 6825;
pub const ERROR_TXF_DIR_NOT_EMPTY: u32 = 6826;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST: u32 = 6827;
pub const ERROR_TM_VOLATILE: u32 = 6828;
pub const ERROR_ROLLBACK_TIMER_EXPIRED: u32 = 6829;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT: u32 = 6830;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION: u32 = 6831;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED: u32 = 6832;
pub const ERROR_LOG_GROWTH_FAILED: u32 = 6833;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE: u32 = 6834;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT: u32 = 6835;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET: u32 = 6836;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION: u32 = 6837;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION: u32 = 6838;
pub const ERROR_TRANSACTIONS_NOT_FROZEN: u32 = 6839;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS: u32 = 6840;
pub const ERROR_NOT_SNAPSHOT_VOLUME: u32 = 6841;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES: u32 = 6842;
pub const ERROR_DATA_LOST_REPAIR: u32 = 6843;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION: u32 = 6844;
pub const ERROR_TM_IDENTITY_MISMATCH: u32 = 6845;
pub const ERROR_FLOATED_SECTION: u32 = 6846;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK: u32 = 6847;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS: u32 = 6848;
pub const ERROR_BAD_CLUSTERS: u32 = 6849;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION: u32 = 6850;
pub const ERROR_VOLUME_DIRTY: u32 = 6851;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION: u32 = 6852;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION: u32 = 6853;
pub const ERROR_EXPIRED_HANDLE: u32 = 6854;
pub const ERROR_TRANSACTION_NOT_ENLISTED: u32 = 6855;
pub const ERROR_CTX_WINSTATION_NAME_INVALID: u32 = 7001;
pub const ERROR_CTX_INVALID_PD: u32 = 7002;
pub const ERROR_CTX_PD_NOT_FOUND: u32 = 7003;
pub const ERROR_CTX_WD_NOT_FOUND: u32 = 7004;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY: u32 = 7005;
pub const ERROR_CTX_SERVICE_NAME_COLLISION: u32 = 7006;
pub const ERROR_CTX_CLOSE_PENDING: u32 = 7007;
pub const ERROR_CTX_NO_OUTBUF: u32 = 7008;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND: u32 = 7009;
pub const ERROR_CTX_INVALID_MODEMNAME: u32 = 7010;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR: u32 = 7011;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: u32 = 7012;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER: u32 = 7013;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE: u32 = 7014;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY: u32 = 7015;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE: u32 = 7016;
pub const ERROR_CTX_TD_ERROR: u32 = 7017;
pub const ERROR_CTX_WINSTATION_NOT_FOUND: u32 = 7022;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS: u32 = 7023;
pub const ERROR_CTX_WINSTATION_BUSY: u32 = 7024;
pub const ERROR_CTX_BAD_VIDEO_MODE: u32 = 7025;
pub const ERROR_CTX_GRAPHICS_INVALID: u32 = 7035;
pub const ERROR_CTX_LOGON_DISABLED: u32 = 7037;
pub const ERROR_CTX_NOT_CONSOLE: u32 = 7038;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: u32 = 7040;
pub const ERROR_CTX_CONSOLE_DISCONNECT: u32 = 7041;
pub const ERROR_CTX_CONSOLE_CONNECT: u32 = 7042;
pub const ERROR_CTX_SHADOW_DENIED: u32 = 7044;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED: u32 = 7045;
pub const ERROR_CTX_INVALID_WD: u32 = 7049;
pub const ERROR_CTX_SHADOW_INVALID: u32 = 7050;
pub const ERROR_CTX_SHADOW_DISABLED: u32 = 7051;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE: u32 = 7052;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET: u32 = 7053;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE: u32 = 7054;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID: u32 = 7055;
pub const ERROR_CTX_LICENSE_EXPIRED: u32 = 7056;
pub const ERROR_CTX_SHADOW_NOT_RUNNING: u32 = 7057;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE: u32 = 7058;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED: u32 = 7059;
pub const ERROR_CTX_WINSTATIONS_DISABLED: u32 = 7060;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED: u32 = 7061;
pub const ERROR_CTX_SESSION_IN_USE: u32 = 7062;
pub const ERROR_CTX_NO_FORCE_LOGOFF: u32 = 7063;
pub const ERROR_CTX_ACCOUNT_RESTRICTION: u32 = 7064;
pub const ERROR_RDP_PROTOCOL_ERROR: u32 = 7065;
pub const ERROR_CTX_CDM_CONNECT: u32 = 7066;
pub const ERROR_CTX_CDM_DISCONNECT: u32 = 7067;
pub const ERROR_CTX_SECURITY_LAYER_ERROR: u32 = 7068;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS: u32 = 7069;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR: u32 = 7070;
pub const FRS_ERR_INVALID_API_SEQUENCE: u32 = 8001;
pub const FRS_ERR_STARTING_SERVICE: u32 = 8002;
pub const FRS_ERR_STOPPING_SERVICE: u32 = 8003;
pub const FRS_ERR_INTERNAL_API: u32 = 8004;
pub const FRS_ERR_INTERNAL: u32 = 8005;
pub const FRS_ERR_SERVICE_COMM: u32 = 8006;
pub const FRS_ERR_INSUFFICIENT_PRIV: u32 = 8007;
pub const FRS_ERR_AUTHENTICATION: u32 = 8008;
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV: u32 = 8009;
pub const FRS_ERR_PARENT_AUTHENTICATION: u32 = 8010;
pub const FRS_ERR_CHILD_TO_PARENT_COMM: u32 = 8011;
pub const FRS_ERR_PARENT_TO_CHILD_COMM: u32 = 8012;
pub const FRS_ERR_SYSVOL_POPULATE: u32 = 8013;
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: u32 = 8014;
pub const FRS_ERR_SYSVOL_IS_BUSY: u32 = 8015;
pub const FRS_ERR_SYSVOL_DEMOTE: u32 = 8016;
pub const FRS_ERR_INVALID_SERVICE_PARAMETER: u32 = 8017;
pub const DS_S_SUCCESS: u32 = 0;
pub const ERROR_DS_NOT_INSTALLED: u32 = 8200;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY: u32 = 8201;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE: u32 = 8202;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX: u32 = 8203;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED: u32 = 8204;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS: u32 = 8205;
pub const ERROR_DS_BUSY: u32 = 8206;
pub const ERROR_DS_UNAVAILABLE: u32 = 8207;
pub const ERROR_DS_NO_RIDS_ALLOCATED: u32 = 8208;
pub const ERROR_DS_NO_MORE_RIDS: u32 = 8209;
pub const ERROR_DS_INCORRECT_ROLE_OWNER: u32 = 8210;
pub const ERROR_DS_RIDMGR_INIT_ERROR: u32 = 8211;
pub const ERROR_DS_OBJ_CLASS_VIOLATION: u32 = 8212;
pub const ERROR_DS_CANT_ON_NON_LEAF: u32 = 8213;
pub const ERROR_DS_CANT_ON_RDN: u32 = 8214;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS: u32 = 8215;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR: u32 = 8216;
pub const ERROR_DS_GC_NOT_AVAILABLE: u32 = 8217;
pub const ERROR_SHARED_POLICY: u32 = 8218;
pub const ERROR_POLICY_OBJECT_NOT_FOUND: u32 = 8219;
pub const ERROR_POLICY_ONLY_IN_DS: u32 = 8220;
pub const ERROR_PROMOTION_ACTIVE: u32 = 8221;
pub const ERROR_NO_PROMOTION_ACTIVE: u32 = 8222;
pub const ERROR_DS_OPERATIONS_ERROR: u32 = 8224;
pub const ERROR_DS_PROTOCOL_ERROR: u32 = 8225;
pub const ERROR_DS_TIMELIMIT_EXCEEDED: u32 = 8226;
pub const ERROR_DS_SIZELIMIT_EXCEEDED: u32 = 8227;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED: u32 = 8228;
pub const ERROR_DS_COMPARE_FALSE: u32 = 8229;
pub const ERROR_DS_COMPARE_TRUE: u32 = 8230;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED: u32 = 8231;
pub const ERROR_DS_STRONG_AUTH_REQUIRED: u32 = 8232;
pub const ERROR_DS_INAPPROPRIATE_AUTH: u32 = 8233;
pub const ERROR_DS_AUTH_UNKNOWN: u32 = 8234;
pub const ERROR_DS_REFERRAL: u32 = 8235;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION: u32 = 8236;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED: u32 = 8237;
pub const ERROR_DS_INAPPROPRIATE_MATCHING: u32 = 8238;
pub const ERROR_DS_CONSTRAINT_VIOLATION: u32 = 8239;
pub const ERROR_DS_NO_SUCH_OBJECT: u32 = 8240;
pub const ERROR_DS_ALIAS_PROBLEM: u32 = 8241;
pub const ERROR_DS_INVALID_DN_SYNTAX: u32 = 8242;
pub const ERROR_DS_IS_LEAF: u32 = 8243;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM: u32 = 8244;
pub const ERROR_DS_UNWILLING_TO_PERFORM: u32 = 8245;
pub const ERROR_DS_LOOP_DETECT: u32 = 8246;
pub const ERROR_DS_NAMING_VIOLATION: u32 = 8247;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE: u32 = 8248;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS: u32 = 8249;
pub const ERROR_DS_SERVER_DOWN: u32 = 8250;
pub const ERROR_DS_LOCAL_ERROR: u32 = 8251;
pub const ERROR_DS_ENCODING_ERROR: u32 = 8252;
pub const ERROR_DS_DECODING_ERROR: u32 = 8253;
pub const ERROR_DS_FILTER_UNKNOWN: u32 = 8254;
pub const ERROR_DS_PARAM_ERROR: u32 = 8255;
pub const ERROR_DS_NOT_SUPPORTED: u32 = 8256;
pub const ERROR_DS_NO_RESULTS_RETURNED: u32 = 8257;
pub const ERROR_DS_CONTROL_NOT_FOUND: u32 = 8258;
pub const ERROR_DS_CLIENT_LOOP: u32 = 8259;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED: u32 = 8260;
pub const ERROR_DS_SORT_CONTROL_MISSING: u32 = 8261;
pub const ERROR_DS_OFFSET_RANGE_ERROR: u32 = 8262;
pub const ERROR_DS_RIDMGR_DISABLED: u32 = 8263;
pub const ERROR_DS_ROOT_MUST_BE_NC: u32 = 8301;
pub const ERROR_DS_ADD_REPLICA_INHIBITED: u32 = 8302;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA: u32 = 8303;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED: u32 = 8304;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS: u32 = 8305;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA: u32 = 8306;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA: u32 = 8307;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND: u32 = 8308;
pub const ERROR_DS_USER_BUFFER_TO_SMALL: u32 = 8309;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ: u32 = 8310;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION: u32 = 8311;
pub const ERROR_DS_OBJ_TOO_LARGE: u32 = 8312;
pub const ERROR_DS_BAD_INSTANCE_TYPE: u32 = 8313;
pub const ERROR_DS_MASTERDSA_REQUIRED: u32 = 8314;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED: u32 = 8315;
pub const ERROR_DS_MISSING_REQUIRED_ATT: u32 = 8316;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS: u32 = 8317;
pub const ERROR_DS_ATT_ALREADY_EXISTS: u32 = 8318;
pub const ERROR_DS_CANT_ADD_ATT_VALUES: u32 = 8320;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT: u32 = 8321;
pub const ERROR_DS_RANGE_CONSTRAINT: u32 = 8322;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS: u32 = 8323;
pub const ERROR_DS_CANT_REM_MISSING_ATT: u32 = 8324;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL: u32 = 8325;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF: u32 = 8326;
pub const ERROR_DS_NO_CHAINING: u32 = 8327;
pub const ERROR_DS_NO_CHAINED_EVAL: u32 = 8328;
pub const ERROR_DS_NO_PARENT_OBJECT: u32 = 8329;
pub const ERROR_DS_PARENT_IS_AN_ALIAS: u32 = 8330;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS: u32 = 8331;
pub const ERROR_DS_CHILDREN_EXIST: u32 = 8332;
pub const ERROR_DS_OBJ_NOT_FOUND: u32 = 8333;
pub const ERROR_DS_ALIASED_OBJ_MISSING: u32 = 8334;
pub const ERROR_DS_BAD_NAME_SYNTAX: u32 = 8335;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS: u32 = 8336;
pub const ERROR_DS_CANT_DEREF_ALIAS: u32 = 8337;
pub const ERROR_DS_OUT_OF_SCOPE: u32 = 8338;
pub const ERROR_DS_OBJECT_BEING_REMOVED: u32 = 8339;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ: u32 = 8340;
pub const ERROR_DS_GENERIC_ERROR: u32 = 8341;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER: u32 = 8342;
pub const ERROR_DS_CLASS_NOT_DSA: u32 = 8343;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS: u32 = 8344;
pub const ERROR_DS_ILLEGAL_SUPERIOR: u32 = 8345;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM: u32 = 8346;
pub const ERROR_DS_NAME_TOO_MANY_PARTS: u32 = 8347;
pub const ERROR_DS_NAME_TOO_LONG: u32 = 8348;
pub const ERROR_DS_NAME_VALUE_TOO_LONG: u32 = 8349;
pub const ERROR_DS_NAME_UNPARSEABLE: u32 = 8350;
pub const ERROR_DS_NAME_TYPE_UNKNOWN: u32 = 8351;
pub const ERROR_DS_NOT_AN_OBJECT: u32 = 8352;
pub const ERROR_DS_SEC_DESC_TOO_SHORT: u32 = 8353;
pub const ERROR_DS_SEC_DESC_INVALID: u32 = 8354;
pub const ERROR_DS_NO_DELETED_NAME: u32 = 8355;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT: u32 = 8356;
pub const ERROR_DS_NCNAME_MUST_BE_NC: u32 = 8357;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY: u32 = 8358;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE: u32 = 8359;
pub const ERROR_DS_INVALID_DMD: u32 = 8360;
pub const ERROR_DS_OBJ_GUID_EXISTS: u32 = 8361;
pub const ERROR_DS_NOT_ON_BACKLINK: u32 = 8362;
pub const ERROR_DS_NO_CROSSREF_FOR_NC: u32 = 8363;
pub const ERROR_DS_SHUTTING_DOWN: u32 = 8364;
pub const ERROR_DS_UNKNOWN_OPERATION: u32 = 8365;
pub const ERROR_DS_INVALID_ROLE_OWNER: u32 = 8366;
pub const ERROR_DS_COULDNT_CONTACT_FSMO: u32 = 8367;
pub const ERROR_DS_CROSS_NC_DN_RENAME: u32 = 8368;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY: u32 = 8369;
pub const ERROR_DS_REPLICATOR_ONLY: u32 = 8370;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED: u32 = 8371;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS: u32 = 8372;
pub const ERROR_DS_NAME_REFERENCE_INVALID: u32 = 8373;
pub const ERROR_DS_CROSS_REF_EXISTS: u32 = 8374;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF: u32 = 8375;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD: u32 = 8376;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX: u32 = 8377;
pub const ERROR_DS_DUP_RDN: u32 = 8378;
pub const ERROR_DS_DUP_OID: u32 = 8379;
pub const ERROR_DS_DUP_MAPI_ID: u32 = 8380;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID: u32 = 8381;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME: u32 = 8382;
pub const ERROR_DS_SEMANTIC_ATT_TEST: u32 = 8383;
pub const ERROR_DS_SYNTAX_MISMATCH: u32 = 8384;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE: u32 = 8385;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE: u32 = 8386;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE: u32 = 8387;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE: u32 = 8388;
pub const ERROR_DS_AUX_CLS_TEST_FAIL: u32 = 8389;
pub const ERROR_DS_NONEXISTENT_POSS_SUP: u32 = 8390;
pub const ERROR_DS_SUB_CLS_TEST_FAIL: u32 = 8391;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX: u32 = 8392;
pub const ERROR_DS_EXISTS_IN_AUX_CLS: u32 = 8393;
pub const ERROR_DS_EXISTS_IN_SUB_CLS: u32 = 8394;
pub const ERROR_DS_EXISTS_IN_POSS_SUP: u32 = 8395;
pub const ERROR_DS_RECALCSCHEMA_FAILED: u32 = 8396;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED: u32 = 8397;
pub const ERROR_DS_CANT_DELETE: u32 = 8398;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID: u32 = 8399;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX: u32 = 8400;
pub const ERROR_DS_CANT_CACHE_ATT: u32 = 8401;
pub const ERROR_DS_CANT_CACHE_CLASS: u32 = 8402;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE: u32 = 8403;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE: u32 = 8404;
pub const ERROR_DS_CANT_RETRIEVE_DN: u32 = 8405;
pub const ERROR_DS_MISSING_SUPREF: u32 = 8406;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE: u32 = 8407;
pub const ERROR_DS_CODE_INCONSISTENCY: u32 = 8408;
pub const ERROR_DS_DATABASE_ERROR: u32 = 8409;
pub const ERROR_DS_GOVERNSID_MISSING: u32 = 8410;
pub const ERROR_DS_MISSING_EXPECTED_ATT: u32 = 8411;
pub const ERROR_DS_NCNAME_MISSING_CR_REF: u32 = 8412;
pub const ERROR_DS_SECURITY_CHECKING_ERROR: u32 = 8413;
pub const ERROR_DS_SCHEMA_NOT_LOADED: u32 = 8414;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED: u32 = 8415;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX: u32 = 8416;
pub const ERROR_DS_GCVERIFY_ERROR: u32 = 8417;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH: u32 = 8418;
pub const ERROR_DS_CANT_FIND_DSA_OBJ: u32 = 8419;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC: u32 = 8420;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE: u32 = 8421;
pub const ERROR_DS_CANT_RETRIEVE_CHILD: u32 = 8422;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY: u32 = 8423;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC: u32 = 8424;
pub const ERROR_DS_BAD_HIERARCHY_FILE: u32 = 8425;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED: u32 = 8426;
pub const ERROR_DS_CONFIG_PARAM_MISSING: u32 = 8427;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED: u32 = 8428;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED: u32 = 8429;
pub const ERROR_DS_INTERNAL_FAILURE: u32 = 8430;
pub const ERROR_DS_UNKNOWN_ERROR: u32 = 8431;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP: u32 = 8432;
pub const ERROR_DS_REFUSING_FSMO_ROLES: u32 = 8433;
pub const ERROR_DS_MISSING_FSMO_SETTINGS: u32 = 8434;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES: u32 = 8435;
pub const ERROR_DS_DRA_GENERIC: u32 = 8436;
pub const ERROR_DS_DRA_INVALID_PARAMETER: u32 = 8437;
pub const ERROR_DS_DRA_BUSY: u32 = 8438;
pub const ERROR_DS_DRA_BAD_DN: u32 = 8439;
pub const ERROR_DS_DRA_BAD_NC: u32 = 8440;
pub const ERROR_DS_DRA_DN_EXISTS: u32 = 8441;
pub const ERROR_DS_DRA_INTERNAL_ERROR: u32 = 8442;
pub const ERROR_DS_DRA_INCONSISTENT_DIT: u32 = 8443;
pub const ERROR_DS_DRA_CONNECTION_FAILED: u32 = 8444;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE: u32 = 8445;
pub const ERROR_DS_DRA_OUT_OF_MEM: u32 = 8446;
pub const ERROR_DS_DRA_MAIL_PROBLEM: u32 = 8447;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS: u32 = 8448;
pub const ERROR_DS_DRA_REF_NOT_FOUND: u32 = 8449;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE: u32 = 8450;
pub const ERROR_DS_DRA_DB_ERROR: u32 = 8451;
pub const ERROR_DS_DRA_NO_REPLICA: u32 = 8452;
pub const ERROR_DS_DRA_ACCESS_DENIED: u32 = 8453;
pub const ERROR_DS_DRA_NOT_SUPPORTED: u32 = 8454;
pub const ERROR_DS_DRA_RPC_CANCELLED: u32 = 8455;
pub const ERROR_DS_DRA_SOURCE_DISABLED: u32 = 8456;
pub const ERROR_DS_DRA_SINK_DISABLED: u32 = 8457;
pub const ERROR_DS_DRA_NAME_COLLISION: u32 = 8458;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED: u32 = 8459;
pub const ERROR_DS_DRA_MISSING_PARENT: u32 = 8460;
pub const ERROR_DS_DRA_PREEMPTED: u32 = 8461;
pub const ERROR_DS_DRA_ABANDON_SYNC: u32 = 8462;
pub const ERROR_DS_DRA_SHUTDOWN: u32 = 8463;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET: u32 = 8464;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA: u32 = 8465;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED: u32 = 8466;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH: u32 = 8467;
pub const ERROR_DS_DUP_LINK_ID: u32 = 8468;
pub const ERROR_DS_NAME_ERROR_RESOLVING: u32 = 8469;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND: u32 = 8470;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE: u32 = 8471;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING: u32 = 8472;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY: u32 = 8473;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING: u32 = 8474;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD: u32 = 8475;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS: u32 = 8476;
pub const ERROR_DS_DRA_REPL_PENDING: u32 = 8477;
pub const ERROR_DS_DS_REQUIRED: u32 = 8478;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME: u32 = 8479;
pub const ERROR_DS_NON_BASE_SEARCH: u32 = 8480;
pub const ERROR_DS_CANT_RETRIEVE_ATTS: u32 = 8481;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK: u32 = 8482;
pub const ERROR_DS_EPOCH_MISMATCH: u32 = 8483;
pub const ERROR_DS_SRC_NAME_MISMATCH: u32 = 8484;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL: u32 = 8485;
pub const ERROR_DS_DST_NC_MISMATCH: u32 = 8486;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC: u32 = 8487;
pub const ERROR_DS_SRC_GUID_MISMATCH: u32 = 8488;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT: u32 = 8489;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS: u32 = 8490;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD: u32 = 8491;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION: u32 = 8492;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS: u32 = 8493;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT: u32 = 8494;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE: u32 = 8495;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE: u32 = 8496;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER: u32 = 8497;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP: u32 = 8498;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP: u32 = 8499;
pub const ERROR_DS_INVALID_SEARCH_FLAG: u32 = 8500;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC: u32 = 8501;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE: u32 = 8502;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE: u32 = 8503;
pub const ERROR_DS_SAM_INIT_FAILURE: u32 = 8504;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION: u32 = 8505;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID: u32 = 8506;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD: u32 = 8507;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE: u32 = 8508;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED: u32 = 8509;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA: u32 = 8510;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION: u32 = 8511;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE: u32 = 8512;
pub const ERROR_DS_INVALID_GROUP_TYPE: u32 = 8513;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: u32 = 8514;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: u32 = 8515;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8516;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8517;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8518;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: u32 = 8519;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: u32 = 8520;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS: u32 = 8521;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED: u32 = 8522;
pub const ERROR_DS_NAMING_MASTER_GC: u32 = 8523;
pub const ERROR_DS_DNS_LOOKUP_FAILURE: u32 = 8524;
pub const ERROR_DS_COULDNT_UPDATE_SPNS: u32 = 8525;
pub const ERROR_DS_CANT_RETRIEVE_SD: u32 = 8526;
pub const ERROR_DS_KEY_NOT_UNIQUE: u32 = 8527;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX: u32 = 8528;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD: u32 = 8529;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY: u32 = 8530;
pub const ERROR_DS_CANT_START: u32 = 8531;
pub const ERROR_DS_INIT_FAILURE: u32 = 8532;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION: u32 = 8533;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST: u32 = 8534;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST: u32 = 8535;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED: u32 = 8536;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN: u32 = 8537;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER: u32 = 8538;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST: u32 = 8539;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH: u32 = 8540;
pub const ERROR_SAM_INIT_FAILURE: u32 = 8541;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP: u32 = 8542;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT: u32 = 8543;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT: u32 = 8544;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH: u32 = 8545;
pub const ERROR_DS_NC_STILL_HAS_DSAS: u32 = 8546;
pub const ERROR_DS_GC_REQUIRED: u32 = 8547;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: u32 = 8548;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS: u32 = 8549;
pub const ERROR_DS_CANT_ADD_TO_GC: u32 = 8550;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC: u32 = 8551;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED: u32 = 8552;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC: u32 = 8553;
pub const ERROR_DS_INVALID_NAME_FOR_SPN: u32 = 8554;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: u32 = 8555;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES: u32 = 8556;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: u32 = 8557;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC: u32 = 8558;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER: u32 = 8559;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ: u32 = 8560;
pub const ERROR_DS_INIT_FAILURE_CONSOLE: u32 = 8561;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE: u32 = 8562;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH: u32 = 8563;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH: u32 = 8564;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW: u32 = 8565;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW: u32 = 8566;
pub const ERROR_DS_INCOMPATIBLE_VERSION: u32 = 8567;
pub const ERROR_DS_LOW_DSA_VERSION: u32 = 8568;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN: u32 = 8569;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER: u32 = 8570;
pub const ERROR_DS_NAME_NOT_UNIQUE: u32 = 8571;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4: u32 = 8572;
pub const ERROR_DS_OUT_OF_VERSION_STORE: u32 = 8573;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED: u32 = 8574;
pub const ERROR_DS_NO_REF_DOMAIN: u32 = 8575;
pub const ERROR_DS_RESERVED_LINK_ID: u32 = 8576;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE: u32 = 8577;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8578;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE: u32 = 8579;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC: u32 = 8580;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG: u32 = 8581;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT: u32 = 8582;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL: u32 = 8583;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER: u32 = 8584;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD: u32 = 8585;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2: u32 = 8586;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED: u32 = 8587;
pub const ERROR_DS_NOT_CLOSEST: u32 = 8588;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF: u32 = 8589;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED: u32 = 8590;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR: u32 = 8591;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR: u32 = 8592;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS: u32 = 8593;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED: u32 = 8594;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR: u32 = 8595;
pub const ERROR_DS_NO_MSDS_INTID: u32 = 8596;
pub const ERROR_DS_DUP_MSDS_INTID: u32 = 8597;
pub const ERROR_DS_EXISTS_IN_RDNATTID: u32 = 8598;
pub const ERROR_DS_AUTHORIZATION_FAILED: u32 = 8599;
pub const ERROR_DS_INVALID_SCRIPT: u32 = 8600;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED: u32 = 8601;
pub const ERROR_DS_CROSS_REF_BUSY: u32 = 8602;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN: u32 = 8603;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC: u32 = 8604;
pub const ERROR_DS_DUPLICATE_ID_FOUND: u32 = 8605;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT: u32 = 8606;
pub const ERROR_DS_GROUP_CONVERSION_ERROR: u32 = 8607;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP: u32 = 8608;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP: u32 = 8609;
pub const ERROR_DS_ROLE_NOT_VERIFIED: u32 = 8610;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL: u32 = 8611;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS: u32 = 8612;
pub const ERROR_DS_EXISTING_AD_CHILD_NC: u32 = 8613;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED: u32 = 8614;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER: u32 = 8615;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL: u32 = 8616;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW: u32 = 8617;
pub const ERROR_DS_POLICY_NOT_KNOWN: u32 = 8618;
pub const ERROR_NO_SITE_SETTINGS_OBJECT: u32 = 8619;
pub const ERROR_NO_SECRETS: u32 = 8620;
pub const ERROR_NO_WRITABLE_DC_FOUND: u32 = 8621;
pub const ERROR_DS_NO_SERVER_OBJECT: u32 = 8622;
pub const ERROR_DS_NO_NTDSA_OBJECT: u32 = 8623;
pub const ERROR_DS_NON_ASQ_SEARCH: u32 = 8624;
pub const ERROR_DS_AUDIT_FAILURE: u32 = 8625;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE: u32 = 8626;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE: u32 = 8627;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP: u32 = 8628;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR: u32 = 8629;
pub const ERROR_DS_DRA_SECRETS_DENIED: u32 = 8630;
pub const ERROR_DS_RESERVED_MAPI_ID: u32 = 8631;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE: u32 = 8632;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET: u32 = 8633;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST: u32 = 8634;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST: u32 = 8635;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME: u32 = 8636;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS: u32 = 8637;
pub const ERROR_DS_OID_NOT_FOUND: u32 = 8638;
pub const ERROR_DS_DRA_RECYCLED_TARGET: u32 = 8639;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT: u32 = 8640;
pub const ERROR_DS_HIGH_ADLDS_FFL: u32 = 8641;
pub const ERROR_DS_HIGH_DSA_VERSION: u32 = 8642;
pub const ERROR_DS_LOW_ADLDS_FFL: u32 = 8643;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION: u32 = 8644;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED: u32 = 8645;
pub const ERROR_INCORRECT_ACCOUNT_TYPE: u32 = 8646;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 8647;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 8648;
pub const ERROR_DS_MISSING_FOREST_TRUST: u32 = 8649;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE: u32 = 8650;
pub const DNS_ERROR_RESPONSE_CODES_BASE: u32 = 9000;
pub const DNS_ERROR_RCODE_NO_ERROR: u32 = 0;
pub const DNS_ERROR_MASK: u32 = 9000;
pub const DNS_ERROR_RCODE_FORMAT_ERROR: u32 = 9001;
pub const DNS_ERROR_RCODE_SERVER_FAILURE: u32 = 9002;
pub const DNS_ERROR_RCODE_NAME_ERROR: u32 = 9003;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED: u32 = 9004;
pub const DNS_ERROR_RCODE_REFUSED: u32 = 9005;
pub const DNS_ERROR_RCODE_YXDOMAIN: u32 = 9006;
pub const DNS_ERROR_RCODE_YXRRSET: u32 = 9007;
pub const DNS_ERROR_RCODE_NXRRSET: u32 = 9008;
pub const DNS_ERROR_RCODE_NOTAUTH: u32 = 9009;
pub const DNS_ERROR_RCODE_NOTZONE: u32 = 9010;
pub const DNS_ERROR_RCODE_BADSIG: u32 = 9016;
pub const DNS_ERROR_RCODE_BADKEY: u32 = 9017;
pub const DNS_ERROR_RCODE_BADTIME: u32 = 9018;
pub const DNS_ERROR_RCODE_LAST: u32 = 9018;
pub const DNS_ERROR_DNSSEC_BASE: u32 = 9100;
pub const DNS_ERROR_KEYMASTER_REQUIRED: u32 = 9101;
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE: u32 = 9102;
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1: u32 = 9103;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS: u32 = 9104;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM: u32 = 9105;
pub const DNS_ERROR_INVALID_KEY_SIZE: u32 = 9106;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE: u32 = 9107;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION: u32 = 9108;
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR: u32 = 9109;
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR: u32 = 9110;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION: u32 = 9111;
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE: u32 = 9112;
pub const DNS_ERROR_TOO_MANY_SKDS: u32 = 9113;
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD: u32 = 9114;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET: u32 = 9115;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS: u32 = 9116;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT: u32 = 9117;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK: u32 = 9118;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD: u32 = 9119;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED: u32 = 9120;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE: u32 = 9121;
pub const DNS_ERROR_BAD_KEYMASTER: u32 = 9122;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD: u32 = 9123;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT: u32 = 9124;
pub const DNS_ERROR_DNSSEC_IS_DISABLED: u32 = 9125;
pub const DNS_ERROR_INVALID_XML: u32 = 9126;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS: u32 = 9127;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE: u32 = 9128;
pub const DNS_ERROR_NSEC3_NAME_COLLISION: u32 = 9129;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1: u32 = 9130;
pub const DNS_ERROR_PACKET_FMT_BASE: u32 = 9500;
pub const DNS_INFO_NO_RECORDS: u32 = 9501;
pub const DNS_ERROR_BAD_PACKET: u32 = 9502;
pub const DNS_ERROR_NO_PACKET: u32 = 9503;
pub const DNS_ERROR_RCODE: u32 = 9504;
pub const DNS_ERROR_UNSECURE_PACKET: u32 = 9505;
pub const DNS_STATUS_PACKET_UNSECURE: u32 = 9505;
pub const DNS_REQUEST_PENDING: u32 = 9506;
pub const DNS_ERROR_NO_MEMORY: u32 = 14;
pub const DNS_ERROR_INVALID_NAME: u32 = 123;
pub const DNS_ERROR_INVALID_DATA: u32 = 13;
pub const DNS_ERROR_GENERAL_API_BASE: u32 = 9550;
pub const DNS_ERROR_INVALID_TYPE: u32 = 9551;
pub const DNS_ERROR_INVALID_IP_ADDRESS: u32 = 9552;
pub const DNS_ERROR_INVALID_PROPERTY: u32 = 9553;
pub const DNS_ERROR_TRY_AGAIN_LATER: u32 = 9554;
pub const DNS_ERROR_NOT_UNIQUE: u32 = 9555;
pub const DNS_ERROR_NON_RFC_NAME: u32 = 9556;
pub const DNS_STATUS_FQDN: u32 = 9557;
pub const DNS_STATUS_DOTTED_NAME: u32 = 9558;
pub const DNS_STATUS_SINGLE_PART_NAME: u32 = 9559;
pub const DNS_ERROR_INVALID_NAME_CHAR: u32 = 9560;
pub const DNS_ERROR_NUMERIC_NAME: u32 = 9561;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER: u32 = 9562;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION: u32 = 9563;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS: u32 = 9564;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS: u32 = 9565;
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL: u32 = 9566;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE: u32 = 9567;
pub const DNS_ERROR_BACKGROUND_LOADING: u32 = 9568;
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC: u32 = 9569;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME: u32 = 9570;
pub const DNS_ERROR_DELEGATION_REQUIRED: u32 = 9571;
pub const DNS_ERROR_INVALID_POLICY_TABLE: u32 = 9572;
pub const DNS_ERROR_ADDRESS_REQUIRED: u32 = 9573;
pub const DNS_ERROR_ZONE_BASE: u32 = 9600;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST: u32 = 9601;
pub const DNS_ERROR_NO_ZONE_INFO: u32 = 9602;
pub const DNS_ERROR_INVALID_ZONE_OPERATION: u32 = 9603;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR: u32 = 9604;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD: u32 = 9605;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS: u32 = 9606;
pub const DNS_ERROR_ZONE_LOCKED: u32 = 9607;
pub const DNS_ERROR_ZONE_CREATION_FAILED: u32 = 9608;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS: u32 = 9609;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS: u32 = 9610;
pub const DNS_ERROR_INVALID_ZONE_TYPE: u32 = 9611;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP: u32 = 9612;
pub const DNS_ERROR_ZONE_NOT_SECONDARY: u32 = 9613;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES: u32 = 9614;
pub const DNS_ERROR_WINS_INIT_FAILED: u32 = 9615;
pub const DNS_ERROR_NEED_WINS_SERVERS: u32 = 9616;
pub const DNS_ERROR_NBSTAT_INIT_FAILED: u32 = 9617;
pub const DNS_ERROR_SOA_DELETE_INVALID: u32 = 9618;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS: u32 = 9619;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP: u32 = 9620;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN: u32 = 9621;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING: u32 = 9622;
pub const DNS_ERROR_DATAFILE_BASE: u32 = 9650;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE: u32 = 9651;
pub const DNS_ERROR_INVALID_DATAFILE_NAME: u32 = 9652;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE: u32 = 9653;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED: u32 = 9654;
pub const DNS_ERROR_DATAFILE_PARSING: u32 = 9655;
pub const DNS_ERROR_DATABASE_BASE: u32 = 9700;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST: u32 = 9701;
pub const DNS_ERROR_RECORD_FORMAT: u32 = 9702;
pub const DNS_ERROR_NODE_CREATION_FAILED: u32 = 9703;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE: u32 = 9704;
pub const DNS_ERROR_RECORD_TIMED_OUT: u32 = 9705;
pub const DNS_ERROR_NAME_NOT_IN_ZONE: u32 = 9706;
pub const DNS_ERROR_CNAME_LOOP: u32 = 9707;
pub const DNS_ERROR_NODE_IS_CNAME: u32 = 9708;
pub const DNS_ERROR_CNAME_COLLISION: u32 = 9709;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT: u32 = 9710;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS: u32 = 9711;
pub const DNS_ERROR_SECONDARY_DATA: u32 = 9712;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA: u32 = 9713;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST: u32 = 9714;
pub const DNS_WARNING_PTR_CREATE_FAILED: u32 = 9715;
pub const DNS_WARNING_DOMAIN_UNDELETED: u32 = 9716;
pub const DNS_ERROR_DS_UNAVAILABLE: u32 = 9717;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS: u32 = 9718;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE: u32 = 9719;
pub const DNS_ERROR_NODE_IS_DNAME: u32 = 9720;
pub const DNS_ERROR_DNAME_COLLISION: u32 = 9721;
pub const DNS_ERROR_ALIAS_LOOP: u32 = 9722;
pub const DNS_ERROR_OPERATION_BASE: u32 = 9750;
pub const DNS_INFO_AXFR_COMPLETE: u32 = 9751;
pub const DNS_ERROR_AXFR: u32 = 9752;
pub const DNS_INFO_ADDED_LOCAL_WINS: u32 = 9753;
pub const DNS_ERROR_SECURE_BASE: u32 = 9800;
pub const DNS_STATUS_CONTINUE_NEEDED: u32 = 9801;
pub const DNS_ERROR_SETUP_BASE: u32 = 9850;
pub const DNS_ERROR_NO_TCPIP: u32 = 9851;
pub const DNS_ERROR_NO_DNS_SERVERS: u32 = 9852;
pub const DNS_ERROR_DP_BASE: u32 = 9900;
pub const DNS_ERROR_DP_DOES_NOT_EXIST: u32 = 9901;
pub const DNS_ERROR_DP_ALREADY_EXISTS: u32 = 9902;
pub const DNS_ERROR_DP_NOT_ENLISTED: u32 = 9903;
pub const DNS_ERROR_DP_ALREADY_ENLISTED: u32 = 9904;
pub const DNS_ERROR_DP_NOT_AVAILABLE: u32 = 9905;
pub const DNS_ERROR_DP_FSMO_ERROR: u32 = 9906;
pub const DNS_ERROR_RRL_NOT_ENABLED: u32 = 9911;
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE: u32 = 9912;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX: u32 = 9913;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX: u32 = 9914;
pub const DNS_ERROR_RRL_INVALID_TC_RATE: u32 = 9915;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE: u32 = 9916;
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE: u32 = 9917;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS: u32 = 9921;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST: u32 = 9922;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED: u32 = 9923;
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME: u32 = 9924;
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE: u32 = 9925;
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS: u32 = 9951;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST: u32 = 9952;
pub const DNS_ERROR_DEFAULT_ZONESCOPE: u32 = 9953;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME: u32 = 9954;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES: u32 = 9955;
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED: u32 = 9956;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED: u32 = 9957;
pub const DNS_ERROR_INVALID_SCOPE_NAME: u32 = 9958;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST: u32 = 9959;
pub const DNS_ERROR_DEFAULT_SCOPE: u32 = 9960;
pub const DNS_ERROR_INVALID_SCOPE_OPERATION: u32 = 9961;
pub const DNS_ERROR_SCOPE_LOCKED: u32 = 9962;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS: u32 = 9963;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS: u32 = 9971;
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST: u32 = 9972;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA: u32 = 9973;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS: u32 = 9974;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED: u32 = 9975;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST: u32 = 9976;
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS: u32 = 9977;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST: u32 = 9978;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS: u32 = 9979;
pub const DNS_ERROR_POLICY_LOCKED: u32 = 9980;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT: u32 = 9981;
pub const DNS_ERROR_POLICY_INVALID_NAME: u32 = 9982;
pub const DNS_ERROR_POLICY_MISSING_CRITERIA: u32 = 9983;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME: u32 = 9984;
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID: u32 = 9985;
pub const DNS_ERROR_POLICY_SCOPE_MISSING: u32 = 9986;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED: u32 = 9987;
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED: u32 = 9988;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED: u32 = 9989;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET: u32 = 9990;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL: u32 = 9991;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL: u32 = 9992;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE: u32 = 9993;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN: u32 = 9994;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE: u32 = 9995;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY: u32 = 9996;
pub const WSABASEERR: u32 = 10000;
pub const WSAEINTR: u32 = 10004;
pub const WSAEBADF: u32 = 10009;
pub const WSAEACCES: u32 = 10013;
pub const WSAEFAULT: u32 = 10014;
pub const WSAEINVAL: u32 = 10022;
pub const WSAEMFILE: u32 = 10024;
pub const WSAEWOULDBLOCK: u32 = 10035;
pub const WSAEINPROGRESS: u32 = 10036;
pub const WSAEALREADY: u32 = 10037;
pub const WSAENOTSOCK: u32 = 10038;
pub const WSAEDESTADDRREQ: u32 = 10039;
pub const WSAEMSGSIZE: u32 = 10040;
pub const WSAEPROTOTYPE: u32 = 10041;
pub const WSAENOPROTOOPT: u32 = 10042;
pub const WSAEPROTONOSUPPORT: u32 = 10043;
pub const WSAESOCKTNOSUPPORT: u32 = 10044;
pub const WSAEOPNOTSUPP: u32 = 10045;
pub const WSAEPFNOSUPPORT: u32 = 10046;
pub const WSAEAFNOSUPPORT: u32 = 10047;
pub const WSAEADDRINUSE: u32 = 10048;
pub const WSAEADDRNOTAVAIL: u32 = 10049;
pub const WSAENETDOWN: u32 = 10050;
pub const WSAENETUNREACH: u32 = 10051;
pub const WSAENETRESET: u32 = 10052;
pub const WSAECONNABORTED: u32 = 10053;
pub const WSAECONNRESET: u32 = 10054;
pub const WSAENOBUFS: u32 = 10055;
pub const WSAEISCONN: u32 = 10056;
pub const WSAENOTCONN: u32 = 10057;
pub const WSAESHUTDOWN: u32 = 10058;
pub const WSAETOOMANYREFS: u32 = 10059;
pub const WSAETIMEDOUT: u32 = 10060;
pub const WSAECONNREFUSED: u32 = 10061;
pub const WSAELOOP: u32 = 10062;
pub const WSAENAMETOOLONG: u32 = 10063;
pub const WSAEHOSTDOWN: u32 = 10064;
pub const WSAEHOSTUNREACH: u32 = 10065;
pub const WSAENOTEMPTY: u32 = 10066;
pub const WSAEPROCLIM: u32 = 10067;
pub const WSAEUSERS: u32 = 10068;
pub const WSAEDQUOT: u32 = 10069;
pub const WSAESTALE: u32 = 10070;
pub const WSAEREMOTE: u32 = 10071;
pub const WSASYSNOTREADY: u32 = 10091;
pub const WSAVERNOTSUPPORTED: u32 = 10092;
pub const WSANOTINITIALISED: u32 = 10093;
pub const WSAEDISCON: u32 = 10101;
pub const WSAENOMORE: u32 = 10102;
pub const WSAECANCELLED: u32 = 10103;
pub const WSAEINVALIDPROCTABLE: u32 = 10104;
pub const WSAEINVALIDPROVIDER: u32 = 10105;
pub const WSAEPROVIDERFAILEDINIT: u32 = 10106;
pub const WSASYSCALLFAILURE: u32 = 10107;
pub const WSASERVICE_NOT_FOUND: u32 = 10108;
pub const WSATYPE_NOT_FOUND: u32 = 10109;
pub const WSA_E_NO_MORE: u32 = 10110;
pub const WSA_E_CANCELLED: u32 = 10111;
pub const WSAEREFUSED: u32 = 10112;
pub const WSAHOST_NOT_FOUND: u32 = 11001;
pub const WSATRY_AGAIN: u32 = 11002;
pub const WSANO_RECOVERY: u32 = 11003;
pub const WSANO_DATA: u32 = 11004;
pub const WSA_QOS_RECEIVERS: u32 = 11005;
pub const WSA_QOS_SENDERS: u32 = 11006;
pub const WSA_QOS_NO_SENDERS: u32 = 11007;
pub const WSA_QOS_NO_RECEIVERS: u32 = 11008;
pub const WSA_QOS_REQUEST_CONFIRMED: u32 = 11009;
pub const WSA_QOS_ADMISSION_FAILURE: u32 = 11010;
pub const WSA_QOS_POLICY_FAILURE: u32 = 11011;
pub const WSA_QOS_BAD_STYLE: u32 = 11012;
pub const WSA_QOS_BAD_OBJECT: u32 = 11013;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR: u32 = 11014;
pub const WSA_QOS_GENERIC_ERROR: u32 = 11015;
pub const WSA_QOS_ESERVICETYPE: u32 = 11016;
pub const WSA_QOS_EFLOWSPEC: u32 = 11017;
pub const WSA_QOS_EPROVSPECBUF: u32 = 11018;
pub const WSA_QOS_EFILTERSTYLE: u32 = 11019;
pub const WSA_QOS_EFILTERTYPE: u32 = 11020;
pub const WSA_QOS_EFILTERCOUNT: u32 = 11021;
pub const WSA_QOS_EOBJLENGTH: u32 = 11022;
pub const WSA_QOS_EFLOWCOUNT: u32 = 11023;
pub const WSA_QOS_EUNKOWNPSOBJ: u32 = 11024;
pub const WSA_QOS_EPOLICYOBJ: u32 = 11025;
pub const WSA_QOS_EFLOWDESC: u32 = 11026;
pub const WSA_QOS_EPSFLOWSPEC: u32 = 11027;
pub const WSA_QOS_EPSFILTERSPEC: u32 = 11028;
pub const WSA_QOS_ESDMODEOBJ: u32 = 11029;
pub const WSA_QOS_ESHAPERATEOBJ: u32 = 11030;
pub const WSA_QOS_RESERVED_PETYPE: u32 = 11031;
pub const WSA_SECURE_HOST_NOT_FOUND: u32 = 11032;
pub const WSA_IPSEC_NAME_POLICY_ERROR: u32 = 11033;
pub const ERROR_IPSEC_QM_POLICY_EXISTS: u32 = 13000;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND: u32 = 13001;
pub const ERROR_IPSEC_QM_POLICY_IN_USE: u32 = 13002;
pub const ERROR_IPSEC_MM_POLICY_EXISTS: u32 = 13003;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND: u32 = 13004;
pub const ERROR_IPSEC_MM_POLICY_IN_USE: u32 = 13005;
pub const ERROR_IPSEC_MM_FILTER_EXISTS: u32 = 13006;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND: u32 = 13007;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS: u32 = 13008;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND: u32 = 13009;
pub const ERROR_IPSEC_MM_AUTH_EXISTS: u32 = 13010;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND: u32 = 13011;
pub const ERROR_IPSEC_MM_AUTH_IN_USE: u32 = 13012;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND: u32 = 13013;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND: u32 = 13014;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND: u32 = 13015;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS: u32 = 13016;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND: u32 = 13017;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION: u32 = 13018;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION: u32 = 13019;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION: u32 = 13020;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION: u32 = 13021;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION: u32 = 13022;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION: u32 = 13023;
pub const WARNING_IPSEC_MM_POLICY_PRUNED: u32 = 13024;
pub const WARNING_IPSEC_QM_POLICY_PRUNED: u32 = 13025;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN: u32 = 13800;
pub const ERROR_IPSEC_IKE_AUTH_FAIL: u32 = 13801;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL: u32 = 13802;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING: u32 = 13803;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR: u32 = 13804;
pub const ERROR_IPSEC_IKE_TIMED_OUT: u32 = 13805;
pub const ERROR_IPSEC_IKE_NO_CERT: u32 = 13806;
pub const ERROR_IPSEC_IKE_SA_DELETED: u32 = 13807;
pub const ERROR_IPSEC_IKE_SA_REAPED: u32 = 13808;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP: u32 = 13809;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP: u32 = 13810;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM: u32 = 13811;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM: u32 = 13812;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE: u32 = 13813;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP: u32 = 13814;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP: u32 = 13815;
pub const ERROR_IPSEC_IKE_ERROR: u32 = 13816;
pub const ERROR_IPSEC_IKE_CRL_FAILED: u32 = 13817;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE: u32 = 13818;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE: u32 = 13819;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY: u32 = 13820;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY: u32 = 13821;
pub const ERROR_IPSEC_IKE_DH_FAIL: u32 = 13822;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED: u32 = 13823;
pub const ERROR_IPSEC_IKE_INVALID_HEADER: u32 = 13824;
pub const ERROR_IPSEC_IKE_NO_POLICY: u32 = 13825;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE: u32 = 13826;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR: u32 = 13827;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY: u32 = 13828;
pub const ERROR_IPSEC_IKE_PROCESS_ERR: u32 = 13829;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA: u32 = 13830;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP: u32 = 13831;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS: u32 = 13832;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE: u32 = 13833;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID: u32 = 13834;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT: u32 = 13835;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ: u32 = 13836;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH: u32 = 13837;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG: u32 = 13838;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE: u32 = 13839;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY: u32 = 13840;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE: u32 = 13841;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR: u32 = 13842;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD: u32 = 13843;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA: u32 = 13844;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN: u32 = 13845;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE: u32 = 13846;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT: u32 = 13847;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED: u32 = 13848;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE: u32 = 13849;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY: u32 = 13850;
pub const ERROR_IPSEC_IKE_NOTCBPRIV: u32 = 13851;
pub const ERROR_IPSEC_IKE_SECLOADFAIL: u32 = 13852;
pub const ERROR_IPSEC_IKE_FAILSSPINIT: u32 = 13853;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP: u32 = 13854;
pub const ERROR_IPSEC_IKE_SRVACQFAIL: u32 = 13855;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED: u32 = 13856;
pub const ERROR_IPSEC_IKE_GETSPIFAIL: u32 = 13857;
pub const ERROR_IPSEC_IKE_INVALID_FILTER: u32 = 13858;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY: u32 = 13859;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED: u32 = 13860;
pub const ERROR_IPSEC_IKE_INVALID_POLICY: u32 = 13861;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI: u32 = 13862;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION: u32 = 13863;
pub const ERROR_IPSEC_IKE_DH_FAILURE: u32 = 13864;
pub const ERROR_IPSEC_IKE_INVALID_GROUP: u32 = 13865;
pub const ERROR_IPSEC_IKE_ENCRYPT: u32 = 13866;
pub const ERROR_IPSEC_IKE_DECRYPT: u32 = 13867;
pub const ERROR_IPSEC_IKE_POLICY_MATCH: u32 = 13868;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID: u32 = 13869;
pub const ERROR_IPSEC_IKE_INVALID_HASH: u32 = 13870;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG: u32 = 13871;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE: u32 = 13872;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG: u32 = 13873;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG: u32 = 13874;
pub const ERROR_IPSEC_IKE_INVALID_SIG: u32 = 13875;
pub const ERROR_IPSEC_IKE_LOAD_FAILED: u32 = 13876;
pub const ERROR_IPSEC_IKE_RPC_DELETE: u32 = 13877;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT: u32 = 13878;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY: u32 = 13879;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION: u32 = 13880;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN: u32 = 13881;
pub const ERROR_IPSEC_IKE_MM_LIMIT: u32 = 13882;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED: u32 = 13883;
pub const ERROR_IPSEC_IKE_QM_LIMIT: u32 = 13884;
pub const ERROR_IPSEC_IKE_MM_EXPIRED: u32 = 13885;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID: u32 = 13886;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH: u32 = 13887;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID: u32 = 13888;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD: u32 = 13889;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT: u32 = 13890;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN: u32 = 13891;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED: u32 = 13892;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA: u32 = 13893;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM: u32 = 13894;
pub const ERROR_IPSEC_IKE_QM_EXPIRED: u32 = 13895;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS: u32 = 13896;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END: u32 = 13897;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL: u32 = 13898;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE: u32 = 13899;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING: u32 = 13900;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING: u32 = 13901;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS: u32 = 13902;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP: u32 = 13903;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE: u32 = 13904;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE: u32 = 13905;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE: u32 = 13906;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY: u32 = 13907;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE: u32 = 13908;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END: u32 = 13909;
pub const ERROR_IPSEC_BAD_SPI: u32 = 13910;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED: u32 = 13911;
pub const ERROR_IPSEC_WRONG_SA: u32 = 13912;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED: u32 = 13913;
pub const ERROR_IPSEC_INVALID_PACKET: u32 = 13914;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED: u32 = 13915;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP: u32 = 13916;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP: u32 = 13917;
pub const ERROR_IPSEC_THROTTLE_DROP: u32 = 13918;
pub const ERROR_IPSEC_DOSP_BLOCK: u32 = 13925;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST: u32 = 13926;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET: u32 = 13927;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED: u32 = 13928;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES: u32 = 13929;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED: u32 = 13930;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED: u32 = 13931;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES: u32 = 13932;
pub const ERROR_SXS_SECTION_NOT_FOUND: u32 = 14000;
pub const ERROR_SXS_CANT_GEN_ACTCTX: u32 = 14001;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT: u32 = 14002;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND: u32 = 14003;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR: u32 = 14004;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR: u32 = 14005;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED: u32 = 14006;
pub const ERROR_SXS_KEY_NOT_FOUND: u32 = 14007;
pub const ERROR_SXS_VERSION_CONFLICT: u32 = 14008;
pub const ERROR_SXS_WRONG_SECTION_TYPE: u32 = 14009;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED: u32 = 14010;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET: u32 = 14011;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP: u32 = 14012;
pub const ERROR_SXS_UNKNOWN_ENCODING: u32 = 14013;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI: u32 = 14014;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14015;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14016;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14017;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE: u32 = 14018;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE: u32 = 14019;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT: u32 = 14020;
pub const ERROR_SXS_DUPLICATE_DLL_NAME: u32 = 14021;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME: u32 = 14022;
pub const ERROR_SXS_DUPLICATE_CLSID: u32 = 14023;
pub const ERROR_SXS_DUPLICATE_IID: u32 = 14024;
pub const ERROR_SXS_DUPLICATE_TLBID: u32 = 14025;
pub const ERROR_SXS_DUPLICATE_PROGID: u32 = 14026;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME: u32 = 14027;
pub const ERROR_SXS_FILE_HASH_MISMATCH: u32 = 14028;
pub const ERROR_SXS_POLICY_PARSE_ERROR: u32 = 14029;
pub const ERROR_SXS_XML_E_MISSINGQUOTE: u32 = 14030;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX: u32 = 14031;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR: u32 = 14032;
pub const ERROR_SXS_XML_E_BADNAMECHAR: u32 = 14033;
pub const ERROR_SXS_XML_E_BADCHARINSTRING: u32 = 14034;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX: u32 = 14035;
pub const ERROR_SXS_XML_E_BADCHARDATA: u32 = 14036;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE: u32 = 14037;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND: u32 = 14038;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON: u32 = 14039;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN: u32 = 14040;
pub const ERROR_SXS_XML_E_INTERNALERROR: u32 = 14041;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE: u32 = 14042;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING: u32 = 14043;
pub const ERROR_SXS_XML_E_MISSING_PAREN: u32 = 14044;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE: u32 = 14045;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS: u32 = 14046;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL: u32 = 14047;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL: u32 = 14048;
pub const ERROR_SXS_XML_E_INVALID_UNICODE: u32 = 14049;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK: u32 = 14050;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG: u32 = 14051;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG: u32 = 14052;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE: u32 = 14053;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS: u32 = 14054;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL: u32 = 14055;
pub const ERROR_SXS_XML_E_BADXMLDECL: u32 = 14056;
pub const ERROR_SXS_XML_E_MISSINGROOT: u32 = 14057;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF: u32 = 14058;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET: u32 = 14059;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG: u32 = 14060;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG: u32 = 14061;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING: u32 = 14062;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT: u32 = 14063;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL: u32 = 14064;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA: u32 = 14065;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE: u32 = 14066;
pub const ERROR_SXS_XML_E_INVALIDENCODING: u32 = 14067;
pub const ERROR_SXS_XML_E_INVALIDSWITCH: u32 = 14068;
pub const ERROR_SXS_XML_E_BADXMLCASE: u32 = 14069;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE: u32 = 14070;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE: u32 = 14071;
pub const ERROR_SXS_XML_E_INVALID_VERSION: u32 = 14072;
pub const ERROR_SXS_XML_E_MISSINGEQUALS: u32 = 14073;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED: u32 = 14074;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT: u32 = 14075;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID: u32 = 14076;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT: u32 = 14077;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING: u32 = 14078;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14079;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME: u32 = 14080;
pub const ERROR_SXS_ASSEMBLY_MISSING: u32 = 14081;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK: u32 = 14082;
pub const ERROR_SXS_CORRUPTION: u32 = 14083;
pub const ERROR_SXS_EARLY_DEACTIVATION: u32 = 14084;
pub const ERROR_SXS_INVALID_DEACTIVATION: u32 = 14085;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION: u32 = 14086;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED: u32 = 14087;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT: u32 = 14088;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY: u32 = 14089;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE: u32 = 14090;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME: u32 = 14091;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE: u32 = 14092;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR: u32 = 14093;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING: u32 = 14094;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN: u32 = 14095;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING: u32 = 14096;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED: u32 = 14097;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT: u32 = 14098;
pub const ERROR_ADVANCED_INSTALLER_FAILED: u32 = 14099;
pub const ERROR_XML_ENCODING_MISMATCH: u32 = 14100;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT: u32 = 14101;
pub const ERROR_SXS_IDENTITIES_DIFFERENT: u32 = 14102;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT: u32 = 14103;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY: u32 = 14104;
pub const ERROR_SXS_MANIFEST_TOO_BIG: u32 = 14105;
pub const ERROR_SXS_SETTING_NOT_REGISTERED: u32 = 14106;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE: u32 = 14107;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED: u32 = 14108;
pub const ERROR_GENERIC_COMMAND_FAILED: u32 = 14109;
pub const ERROR_SXS_FILE_HASH_MISSING: u32 = 14110;
pub const ERROR_EVT_INVALID_CHANNEL_PATH: u32 = 15000;
pub const ERROR_EVT_INVALID_QUERY: u32 = 15001;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND: u32 = 15002;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND: u32 = 15003;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME: u32 = 15004;
pub const ERROR_EVT_INVALID_EVENT_DATA: u32 = 15005;
pub const ERROR_EVT_CHANNEL_NOT_FOUND: u32 = 15007;
pub const ERROR_EVT_MALFORMED_XML_TEXT: u32 = 15008;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL: u32 = 15009;
pub const ERROR_EVT_CONFIGURATION_ERROR: u32 = 15010;
pub const ERROR_EVT_QUERY_RESULT_STALE: u32 = 15011;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION: u32 = 15012;
pub const ERROR_EVT_NON_VALIDATING_MSXML: u32 = 15013;
pub const ERROR_EVT_FILTER_ALREADYSCOPED: u32 = 15014;
pub const ERROR_EVT_FILTER_NOTELTSET: u32 = 15015;
pub const ERROR_EVT_FILTER_INVARG: u32 = 15016;
pub const ERROR_EVT_FILTER_INVTEST: u32 = 15017;
pub const ERROR_EVT_FILTER_INVTYPE: u32 = 15018;
pub const ERROR_EVT_FILTER_PARSEERR: u32 = 15019;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP: u32 = 15020;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN: u32 = 15021;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL: u32 = 15022;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE: u32 = 15023;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE: u32 = 15024;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE: u32 = 15025;
pub const ERROR_EVT_FILTER_TOO_COMPLEX: u32 = 15026;
pub const ERROR_EVT_MESSAGE_NOT_FOUND: u32 = 15027;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND: u32 = 15028;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT: u32 = 15029;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT: u32 = 15030;
pub const ERROR_EVT_MAX_INSERTS_REACHED: u32 = 15031;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND: u32 = 15032;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND: u32 = 15033;
pub const ERROR_EVT_VERSION_TOO_OLD: u32 = 15034;
pub const ERROR_EVT_VERSION_TOO_NEW: u32 = 15035;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY: u32 = 15036;
pub const ERROR_EVT_PUBLISHER_DISABLED: u32 = 15037;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE: u32 = 15038;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE: u32 = 15080;
pub const ERROR_EC_LOG_DISABLED: u32 = 15081;
pub const ERROR_EC_CIRCULAR_FORWARDING: u32 = 15082;
pub const ERROR_EC_CREDSTORE_FULL: u32 = 15083;
pub const ERROR_EC_CRED_NOT_FOUND: u32 = 15084;
pub const ERROR_EC_NO_ACTIVE_CHANNEL: u32 = 15085;
pub const ERROR_MUI_FILE_NOT_FOUND: u32 = 15100;
pub const ERROR_MUI_INVALID_FILE: u32 = 15101;
pub const ERROR_MUI_INVALID_RC_CONFIG: u32 = 15102;
pub const ERROR_MUI_INVALID_LOCALE_NAME: u32 = 15103;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME: u32 = 15104;
pub const ERROR_MUI_FILE_NOT_LOADED: u32 = 15105;
pub const ERROR_RESOURCE_ENUM_USER_STOP: u32 = 15106;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED: u32 = 15107;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME: u32 = 15108;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE: u32 = 15110;
pub const ERROR_MRM_INVALID_PRICONFIG: u32 = 15111;
pub const ERROR_MRM_INVALID_FILE_TYPE: u32 = 15112;
pub const ERROR_MRM_UNKNOWN_QUALIFIER: u32 = 15113;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE: u32 = 15114;
pub const ERROR_MRM_NO_CANDIDATE: u32 = 15115;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE: u32 = 15116;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH: u32 = 15117;
pub const ERROR_MRM_DUPLICATE_MAP_NAME: u32 = 15118;
pub const ERROR_MRM_DUPLICATE_ENTRY: u32 = 15119;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER: u32 = 15120;
pub const ERROR_MRM_FILEPATH_TOO_LONG: u32 = 15121;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE: u32 = 15122;
pub const ERROR_MRM_INVALID_PRI_FILE: u32 = 15126;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND: u32 = 15127;
pub const ERROR_MRM_MAP_NOT_FOUND: u32 = 15135;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE: u32 = 15136;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR: u32 = 15137;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE: u32 = 15138;
pub const ERROR_MRM_AUTOMERGE_ENABLED: u32 = 15139;
pub const ERROR_MRM_TOO_MANY_RESOURCES: u32 = 15140;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE: u32 = 15141;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE: u32 = 15142;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD: u32 = 15143;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST: u32 = 15144;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT: u32 = 15145;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE: u32 = 15146;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH: u32 = 15147;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH: u32 = 15148;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA: u32 = 15149;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED: u32 = 15150;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED: u32 = 15151;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED: u32 = 15152;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED: u32 = 15153;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED: u32 = 15154;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED: u32 = 15155;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED: u32 = 15156;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED: u32 = 15157;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME: u32 = 15158;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING: u32 = 15200;
pub const ERROR_MCA_INVALID_VCP_VERSION: u32 = 15201;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION: u32 = 15202;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH: u32 = 15203;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION: u32 = 15204;
pub const ERROR_MCA_INTERNAL_ERROR: u32 = 15205;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED: u32 = 15206;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE: u32 = 15207;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE: u32 = 15250;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND: u32 = 15299;
pub const ERROR_HASH_NOT_SUPPORTED: u32 = 15300;
pub const ERROR_HASH_NOT_PRESENT: u32 = 15301;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED: u32 = 15321;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID: u32 = 15322;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED: u32 = 15323;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET: u32 = 15324;
pub const ERROR_GPIO_OPERATION_DENIED: u32 = 15325;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE: u32 = 15326;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED: u32 = 15327;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL: u32 = 15400;
pub const ERROR_INVALID_RUNLEVEL_SETTING: u32 = 15401;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT: u32 = 15402;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT: u32 = 15403;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS: u32 = 15404;
pub const ERROR_SERVICES_FAILED_AUTOSTART: u32 = 15405;
pub const ERROR_COM_TASK_STOP_PENDING: u32 = 15501;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED: u32 = 15600;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND: u32 = 15601;
pub const ERROR_INSTALL_INVALID_PACKAGE: u32 = 15602;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED: u32 = 15603;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE: u32 = 15604;
pub const ERROR_INSTALL_NETWORK_FAILURE: u32 = 15605;
pub const ERROR_INSTALL_REGISTRATION_FAILURE: u32 = 15606;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE: u32 = 15607;
pub const ERROR_INSTALL_CANCEL: u32 = 15608;
pub const ERROR_INSTALL_FAILED: u32 = 15609;
pub const ERROR_REMOVE_FAILED: u32 = 15610;
pub const ERROR_PACKAGE_ALREADY_EXISTS: u32 = 15611;
pub const ERROR_NEEDS_REMEDIATION: u32 = 15612;
pub const ERROR_INSTALL_PREREQUISITE_FAILED: u32 = 15613;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED: u32 = 15614;
pub const ERROR_INSTALL_POLICY_FAILURE: u32 = 15615;
pub const ERROR_PACKAGE_UPDATING: u32 = 15616;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY: u32 = 15617;
pub const ERROR_PACKAGES_IN_USE: u32 = 15618;
pub const ERROR_RECOVERY_FILE_CORRUPT: u32 = 15619;
pub const ERROR_INVALID_STAGED_SIGNATURE: u32 = 15620;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED: u32 = 15621;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE: u32 = 15622;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION: u32 = 15623;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN: u32 = 15624;
pub const ERROR_RESILIENCY_FILE_CORRUPT: u32 = 15625;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING: u32 = 15626;
pub const ERROR_PACKAGE_MOVE_FAILED: u32 = 15627;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY: u32 = 15628;
pub const ERROR_INSTALL_VOLUME_OFFLINE: u32 = 15629;
pub const ERROR_INSTALL_VOLUME_CORRUPT: u32 = 15630;
pub const ERROR_NEEDS_REGISTRATION: u32 = 15631;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE: u32 = 15632;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED: u32 = 15633;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE: u32 = 15634;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM: u32 = 15635;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING: u32 = 15636;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE: u32 = 15637;
pub const ERROR_PACKAGE_STAGING_ONHOLD: u32 = 15638;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE: u32 = 15639;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY: u32 = 15640;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF: u32 = 15641;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED: u32 = 15642;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED: u32 = 15643;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT: u32 = 15644;
pub const APPMODEL_ERROR_NO_PACKAGE: u32 = 15700;
pub const APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT: u32 = 15701;
pub const APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT: u32 = 15702;
pub const APPMODEL_ERROR_NO_APPLICATION: u32 = 15703;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED: u32 = 15704;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID: u32 = 15705;
pub const APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE: u32 = 15706;
pub const ERROR_STATE_LOAD_STORE_FAILED: u32 = 15800;
pub const ERROR_STATE_GET_VERSION_FAILED: u32 = 15801;
pub const ERROR_STATE_SET_VERSION_FAILED: u32 = 15802;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED: u32 = 15803;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED: u32 = 15804;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED: u32 = 15805;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED: u32 = 15806;
pub const ERROR_STATE_READ_SETTING_FAILED: u32 = 15807;
pub const ERROR_STATE_WRITE_SETTING_FAILED: u32 = 15808;
pub const ERROR_STATE_DELETE_SETTING_FAILED: u32 = 15809;
pub const ERROR_STATE_QUERY_SETTING_FAILED: u32 = 15810;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED: u32 = 15811;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED: u32 = 15812;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED: u32 = 15813;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED: u32 = 15814;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 15815;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 15816;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED: u32 = 15817;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED: u32 = 15818;
pub const ERROR_API_UNAVAILABLE: u32 = 15841;
pub const STORE_ERROR_UNLICENSED: u32 = 15861;
pub const STORE_ERROR_UNLICENSED_USER: u32 = 15862;
pub const STORE_ERROR_PENDING_COM_TRANSACTION: u32 = 15863;
pub const STORE_ERROR_LICENSE_REVOKED: u32 = 15864;
pub const SEVERITY_SUCCESS: u32 = 0;
pub const SEVERITY_ERROR: u32 = 1;
pub const FACILITY_NT_BIT: u32 = 268435456;
pub const NOERROR: u32 = 0;
pub const DRAGDROP_E_FIRST: u32 = 2147746048;
pub const DRAGDROP_E_LAST: u32 = 2147746063;
pub const DRAGDROP_S_FIRST: u32 = 262400;
pub const DRAGDROP_S_LAST: u32 = 262415;
pub const CLASSFACTORY_E_FIRST: u32 = 2147746064;
pub const CLASSFACTORY_E_LAST: u32 = 2147746079;
pub const CLASSFACTORY_S_FIRST: u32 = 262416;
pub const CLASSFACTORY_S_LAST: u32 = 262431;
pub const MARSHAL_E_FIRST: u32 = 2147746080;
pub const MARSHAL_E_LAST: u32 = 2147746095;
pub const MARSHAL_S_FIRST: u32 = 262432;
pub const MARSHAL_S_LAST: u32 = 262447;
pub const DATA_E_FIRST: u32 = 2147746096;
pub const DATA_E_LAST: u32 = 2147746111;
pub const DATA_S_FIRST: u32 = 262448;
pub const DATA_S_LAST: u32 = 262463;
pub const VIEW_E_FIRST: u32 = 2147746112;
pub const VIEW_E_LAST: u32 = 2147746127;
pub const VIEW_S_FIRST: u32 = 262464;
pub const VIEW_S_LAST: u32 = 262479;
pub const REGDB_E_FIRST: u32 = 2147746128;
pub const REGDB_E_LAST: u32 = 2147746143;
pub const REGDB_S_FIRST: u32 = 262480;
pub const REGDB_S_LAST: u32 = 262495;
pub const CAT_E_FIRST: u32 = 2147746144;
pub const CAT_E_LAST: u32 = 2147746145;
pub const CS_E_FIRST: u32 = 2147746148;
pub const CS_E_LAST: u32 = 2147746159;
pub const CACHE_E_FIRST: u32 = 2147746160;
pub const CACHE_E_LAST: u32 = 2147746175;
pub const CACHE_S_FIRST: u32 = 262512;
pub const CACHE_S_LAST: u32 = 262527;
pub const OLEOBJ_E_FIRST: u32 = 2147746176;
pub const OLEOBJ_E_LAST: u32 = 2147746191;
pub const OLEOBJ_S_FIRST: u32 = 262528;
pub const OLEOBJ_S_LAST: u32 = 262543;
pub const CLIENTSITE_E_FIRST: u32 = 2147746192;
pub const CLIENTSITE_E_LAST: u32 = 2147746207;
pub const CLIENTSITE_S_FIRST: u32 = 262544;
pub const CLIENTSITE_S_LAST: u32 = 262559;
pub const INPLACE_E_FIRST: u32 = 2147746208;
pub const INPLACE_E_LAST: u32 = 2147746223;
pub const INPLACE_S_FIRST: u32 = 262560;
pub const INPLACE_S_LAST: u32 = 262575;
pub const ENUM_E_FIRST: u32 = 2147746224;
pub const ENUM_E_LAST: u32 = 2147746239;
pub const ENUM_S_FIRST: u32 = 262576;
pub const ENUM_S_LAST: u32 = 262591;
pub const CONVERT10_E_FIRST: u32 = 2147746240;
pub const CONVERT10_E_LAST: u32 = 2147746255;
pub const CONVERT10_S_FIRST: u32 = 262592;
pub const CONVERT10_S_LAST: u32 = 262607;
pub const CLIPBRD_E_FIRST: u32 = 2147746256;
pub const CLIPBRD_E_LAST: u32 = 2147746271;
pub const CLIPBRD_S_FIRST: u32 = 262608;
pub const CLIPBRD_S_LAST: u32 = 262623;
pub const MK_E_FIRST: u32 = 2147746272;
pub const MK_E_LAST: u32 = 2147746287;
pub const MK_S_FIRST: u32 = 262624;
pub const MK_S_LAST: u32 = 262639;
pub const CO_E_FIRST: u32 = 2147746288;
pub const CO_E_LAST: u32 = 2147746303;
pub const CO_S_FIRST: u32 = 262640;
pub const CO_S_LAST: u32 = 262655;
pub const EVENT_E_FIRST: u32 = 2147746304;
pub const EVENT_E_LAST: u32 = 2147746335;
pub const EVENT_S_FIRST: u32 = 262656;
pub const EVENT_S_LAST: u32 = 262687;
pub const XACT_E_FIRST: u32 = 2147799040;
pub const XACT_E_LAST: u32 = 2147799083;
pub const XACT_S_FIRST: u32 = 315392;
pub const XACT_S_LAST: u32 = 315408;
pub const CONTEXT_E_FIRST: u32 = 2147803136;
pub const CONTEXT_E_LAST: u32 = 2147803183;
pub const CONTEXT_S_FIRST: u32 = 319488;
pub const CONTEXT_S_LAST: u32 = 319535;
pub const NTE_OP_OK: u32 = 0;
pub const SCARD_S_SUCCESS: u32 = 0;
pub const TC_NORMAL: u32 = 0;
pub const TC_HARDERR: u32 = 1;
pub const TC_GP_TRAP: u32 = 2;
pub const TC_SIGNAL: u32 = 3;
pub const AC_LINE_OFFLINE: u32 = 0;
pub const AC_LINE_ONLINE: u32 = 1;
pub const AC_LINE_BACKUP_POWER: u32 = 2;
pub const AC_LINE_UNKNOWN: u32 = 255;
pub const BATTERY_FLAG_HIGH: u32 = 1;
pub const BATTERY_FLAG_LOW: u32 = 2;
pub const BATTERY_FLAG_CRITICAL: u32 = 4;
pub const BATTERY_FLAG_CHARGING: u32 = 8;
pub const BATTERY_FLAG_NO_BATTERY: u32 = 128;
pub const BATTERY_FLAG_UNKNOWN: u32 = 255;
pub const BATTERY_PERCENTAGE_UNKNOWN: u32 = 255;
pub const SYSTEM_STATUS_FLAG_POWER_SAVING_ON: u32 = 1;
pub const BATTERY_LIFE_UNKNOWN: u32 = 4294967295;
pub const ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID: u32 = 1;
pub const ACTCTX_FLAG_LANGID_VALID: u32 = 2;
pub const ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID: u32 = 4;
pub const ACTCTX_FLAG_RESOURCE_NAME_VALID: u32 = 8;
pub const ACTCTX_FLAG_SET_PROCESS_DEFAULT: u32 = 16;
pub const ACTCTX_FLAG_APPLICATION_NAME_VALID: u32 = 32;
pub const ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF: u32 = 64;
pub const ACTCTX_FLAG_HMODULE_VALID: u32 = 128;
pub const DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION: u32 = 1;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX: u32 = 1;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS: u32 = 2;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA: u32 = 4;
pub const ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED: u32 = 1;
pub const QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX: u32 = 4;
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE: u32 = 8;
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS: u32 = 16;
pub const QUERY_ACTCTX_FLAG_NO_ADDREF: u32 = 2147483648;
pub const RESTART_MAX_CMD_LINE: u32 = 1024;
pub const RESTART_NO_CRASH: u32 = 1;
pub const RESTART_NO_HANG: u32 = 2;
pub const RESTART_NO_PATCH: u32 = 4;
pub const RESTART_NO_REBOOT: u32 = 8;
pub const RECOVERY_DEFAULT_PING_INTERVAL: u32 = 5000;
pub const RECOVERY_MAX_PING_INTERVAL: u32 = 300000;
pub const FILE_RENAME_FLAG_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_RENAME_FLAG_POSIX_SEMANTICS: u32 = 2;
pub const FILE_RENAME_FLAG_SUPPRESS_PIN_STATE_INHERITANCE: u32 = 4;
pub const FILE_DISPOSITION_FLAG_DO_NOT_DELETE: u32 = 0;
pub const FILE_DISPOSITION_FLAG_DELETE: u32 = 1;
pub const FILE_DISPOSITION_FLAG_POSIX_SEMANTICS: u32 = 2;
pub const FILE_DISPOSITION_FLAG_FORCE_IMAGE_SECTION_CHECK: u32 = 4;
pub const FILE_DISPOSITION_FLAG_ON_CLOSE: u32 = 8;
pub const STORAGE_INFO_FLAGS_ALIGNED_DEVICE: u32 = 1;
pub const STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: u32 = 2;
pub const STORAGE_INFO_OFFSET_UNKNOWN: u32 = 4294967295;
pub const REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK: u32 = 1;
pub const REMOTE_PROTOCOL_INFO_FLAG_OFFLINE: u32 = 2;
pub const REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE: u32 = 4;
pub const RPI_FLAG_SMB2_SHARECAP_TIMEWARP: u32 = 2;
pub const RPI_FLAG_SMB2_SHARECAP_DFS: u32 = 8;
pub const RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY: u32 = 16;
pub const RPI_FLAG_SMB2_SHARECAP_SCALEOUT: u32 = 32;
pub const RPI_FLAG_SMB2_SHARECAP_CLUSTER: u32 = 64;
pub const RPI_SMB2_FLAG_SERVERCAP_DFS: u32 = 1;
pub const RPI_SMB2_FLAG_SERVERCAP_LEASING: u32 = 2;
pub const RPI_SMB2_FLAG_SERVERCAP_LARGEMTU: u32 = 4;
pub const RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL: u32 = 8;
pub const RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES: u32 = 16;
pub const RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING: u32 = 32;
pub const SYMBOLIC_LINK_FLAG_DIRECTORY: u32 = 1;
pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE: u32 = 2;
pub const MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS: u32 = 0;
pub const R2_BLACK: u32 = 1;
pub const R2_NOTMERGEPEN: u32 = 2;
pub const R2_MASKNOTPEN: u32 = 3;
pub const R2_NOTCOPYPEN: u32 = 4;
pub const R2_MASKPENNOT: u32 = 5;
pub const R2_NOT: u32 = 6;
pub const R2_XORPEN: u32 = 7;
pub const R2_NOTMASKPEN: u32 = 8;
pub const R2_MASKPEN: u32 = 9;
pub const R2_NOTXORPEN: u32 = 10;
pub const R2_NOP: u32 = 11;
pub const R2_MERGENOTPEN: u32 = 12;
pub const R2_COPYPEN: u32 = 13;
pub const R2_MERGEPENNOT: u32 = 14;
pub const R2_MERGEPEN: u32 = 15;
pub const R2_WHITE: u32 = 16;
pub const R2_LAST: u32 = 16;
pub const GDI_ERROR: u32 = 4294967295;
pub const ERROR: u32 = 0;
pub const NULLREGION: u32 = 1;
pub const SIMPLEREGION: u32 = 2;
pub const COMPLEXREGION: u32 = 3;
pub const RGN_ERROR: u32 = 0;
pub const RGN_AND: u32 = 1;
pub const RGN_OR: u32 = 2;
pub const RGN_XOR: u32 = 3;
pub const RGN_DIFF: u32 = 4;
pub const RGN_COPY: u32 = 5;
pub const RGN_MIN: u32 = 1;
pub const RGN_MAX: u32 = 5;
pub const BLACKONWHITE: u32 = 1;
pub const WHITEONBLACK: u32 = 2;
pub const COLORONCOLOR: u32 = 3;
pub const HALFTONE: u32 = 4;
pub const MAXSTRETCHBLTMODE: u32 = 4;
pub const STRETCH_ANDSCANS: u32 = 1;
pub const STRETCH_ORSCANS: u32 = 2;
pub const STRETCH_DELETESCANS: u32 = 3;
pub const STRETCH_HALFTONE: u32 = 4;
pub const ALTERNATE: u32 = 1;
pub const WINDING: u32 = 2;
pub const POLYFILL_LAST: u32 = 2;
pub const LAYOUT_RTL: u32 = 1;
pub const LAYOUT_BTT: u32 = 2;
pub const LAYOUT_VBH: u32 = 4;
pub const LAYOUT_ORIENTATIONMASK: u32 = 7;
pub const LAYOUT_BITMAPORIENTATIONPRESERVED: u32 = 8;
pub const TA_NOUPDATECP: u32 = 0;
pub const TA_UPDATECP: u32 = 1;
pub const TA_LEFT: u32 = 0;
pub const TA_RIGHT: u32 = 2;
pub const TA_CENTER: u32 = 6;
pub const TA_TOP: u32 = 0;
pub const TA_BOTTOM: u32 = 8;
pub const TA_BASELINE: u32 = 24;
pub const TA_RTLREADING: u32 = 256;
pub const TA_MASK: u32 = 287;
pub const VTA_BASELINE: u32 = 24;
pub const VTA_LEFT: u32 = 8;
pub const VTA_RIGHT: u32 = 0;
pub const VTA_CENTER: u32 = 6;
pub const VTA_BOTTOM: u32 = 2;
pub const VTA_TOP: u32 = 0;
pub const ETO_OPAQUE: u32 = 2;
pub const ETO_CLIPPED: u32 = 4;
pub const ETO_GLYPH_INDEX: u32 = 16;
pub const ETO_RTLREADING: u32 = 128;
pub const ETO_NUMERICSLOCAL: u32 = 1024;
pub const ETO_NUMERICSLATIN: u32 = 2048;
pub const ETO_IGNORELANGUAGE: u32 = 4096;
pub const ETO_PDY: u32 = 8192;
pub const ETO_REVERSE_INDEX_MAP: u32 = 65536;
pub const ASPECT_FILTERING: u32 = 1;
pub const DCB_RESET: u32 = 1;
pub const DCB_ACCUMULATE: u32 = 2;
pub const DCB_DIRTY: u32 = 2;
pub const DCB_SET: u32 = 3;
pub const DCB_ENABLE: u32 = 4;
pub const DCB_DISABLE: u32 = 8;
pub const META_SETBKCOLOR: u32 = 513;
pub const META_SETBKMODE: u32 = 258;
pub const META_SETMAPMODE: u32 = 259;
pub const META_SETROP2: u32 = 260;
pub const META_SETRELABS: u32 = 261;
pub const META_SETPOLYFILLMODE: u32 = 262;
pub const META_SETSTRETCHBLTMODE: u32 = 263;
pub const META_SETTEXTCHAREXTRA: u32 = 264;
pub const META_SETTEXTCOLOR: u32 = 521;
pub const META_SETTEXTJUSTIFICATION: u32 = 522;
pub const META_SETWINDOWORG: u32 = 523;
pub const META_SETWINDOWEXT: u32 = 524;
pub const META_SETVIEWPORTORG: u32 = 525;
pub const META_SETVIEWPORTEXT: u32 = 526;
pub const META_OFFSETWINDOWORG: u32 = 527;
pub const META_SCALEWINDOWEXT: u32 = 1040;
pub const META_OFFSETVIEWPORTORG: u32 = 529;
pub const META_SCALEVIEWPORTEXT: u32 = 1042;
pub const META_LINETO: u32 = 531;
pub const META_MOVETO: u32 = 532;
pub const META_EXCLUDECLIPRECT: u32 = 1045;
pub const META_INTERSECTCLIPRECT: u32 = 1046;
pub const META_ARC: u32 = 2071;
pub const META_ELLIPSE: u32 = 1048;
pub const META_FLOODFILL: u32 = 1049;
pub const META_PIE: u32 = 2074;
pub const META_RECTANGLE: u32 = 1051;
pub const META_ROUNDRECT: u32 = 1564;
pub const META_PATBLT: u32 = 1565;
pub const META_SAVEDC: u32 = 30;
pub const META_SETPIXEL: u32 = 1055;
pub const META_OFFSETCLIPRGN: u32 = 544;
pub const META_TEXTOUT: u32 = 1313;
pub const META_BITBLT: u32 = 2338;
pub const META_STRETCHBLT: u32 = 2851;
pub const META_POLYGON: u32 = 804;
pub const META_POLYLINE: u32 = 805;
pub const META_ESCAPE: u32 = 1574;
pub const META_RESTOREDC: u32 = 295;
pub const META_FILLREGION: u32 = 552;
pub const META_FRAMEREGION: u32 = 1065;
pub const META_INVERTREGION: u32 = 298;
pub const META_PAINTREGION: u32 = 299;
pub const META_SELECTCLIPREGION: u32 = 300;
pub const META_SELECTOBJECT: u32 = 301;
pub const META_SETTEXTALIGN: u32 = 302;
pub const META_CHORD: u32 = 2096;
pub const META_SETMAPPERFLAGS: u32 = 561;
pub const META_EXTTEXTOUT: u32 = 2610;
pub const META_SETDIBTODEV: u32 = 3379;
pub const META_SELECTPALETTE: u32 = 564;
pub const META_REALIZEPALETTE: u32 = 53;
pub const META_ANIMATEPALETTE: u32 = 1078;
pub const META_SETPALENTRIES: u32 = 55;
pub const META_POLYPOLYGON: u32 = 1336;
pub const META_RESIZEPALETTE: u32 = 313;
pub const META_DIBBITBLT: u32 = 2368;
pub const META_DIBSTRETCHBLT: u32 = 2881;
pub const META_DIBCREATEPATTERNBRUSH: u32 = 322;
pub const META_STRETCHDIB: u32 = 3907;
pub const META_EXTFLOODFILL: u32 = 1352;
pub const META_SETLAYOUT: u32 = 329;
pub const META_DELETEOBJECT: u32 = 496;
pub const META_CREATEPALETTE: u32 = 247;
pub const META_CREATEPATTERNBRUSH: u32 = 505;
pub const META_CREATEPENINDIRECT: u32 = 762;
pub const META_CREATEFONTINDIRECT: u32 = 763;
pub const META_CREATEBRUSHINDIRECT: u32 = 764;
pub const META_CREATEREGION: u32 = 1791;
pub const NEWFRAME: u32 = 1;
pub const ABORTDOC: u32 = 2;
pub const NEXTBAND: u32 = 3;
pub const SETCOLORTABLE: u32 = 4;
pub const GETCOLORTABLE: u32 = 5;
pub const FLUSHOUTPUT: u32 = 6;
pub const DRAFTMODE: u32 = 7;
pub const QUERYESCSUPPORT: u32 = 8;
pub const SETABORTPROC: u32 = 9;
pub const STARTDOC: u32 = 10;
pub const ENDDOC: u32 = 11;
pub const GETPHYSPAGESIZE: u32 = 12;
pub const GETPRINTINGOFFSET: u32 = 13;
pub const GETSCALINGFACTOR: u32 = 14;
pub const MFCOMMENT: u32 = 15;
pub const GETPENWIDTH: u32 = 16;
pub const SETCOPYCOUNT: u32 = 17;
pub const SELECTPAPERSOURCE: u32 = 18;
pub const DEVICEDATA: u32 = 19;
pub const PASSTHROUGH: u32 = 19;
pub const GETTECHNOLGY: u32 = 20;
pub const GETTECHNOLOGY: u32 = 20;
pub const SETLINECAP: u32 = 21;
pub const SETLINEJOIN: u32 = 22;
pub const SETMITERLIMIT: u32 = 23;
pub const BANDINFO: u32 = 24;
pub const DRAWPATTERNRECT: u32 = 25;
pub const GETVECTORPENSIZE: u32 = 26;
pub const GETVECTORBRUSHSIZE: u32 = 27;
pub const ENABLEDUPLEX: u32 = 28;
pub const GETSETPAPERBINS: u32 = 29;
pub const GETSETPRINTORIENT: u32 = 30;
pub const ENUMPAPERBINS: u32 = 31;
pub const SETDIBSCALING: u32 = 32;
pub const EPSPRINTING: u32 = 33;
pub const ENUMPAPERMETRICS: u32 = 34;
pub const GETSETPAPERMETRICS: u32 = 35;
pub const POSTSCRIPT_DATA: u32 = 37;
pub const POSTSCRIPT_IGNORE: u32 = 38;
pub const MOUSETRAILS: u32 = 39;
pub const GETDEVICEUNITS: u32 = 42;
pub const GETEXTENDEDTEXTMETRICS: u32 = 256;
pub const GETEXTENTTABLE: u32 = 257;
pub const GETPAIRKERNTABLE: u32 = 258;
pub const GETTRACKKERNTABLE: u32 = 259;
pub const EXTTEXTOUT: u32 = 512;
pub const GETFACENAME: u32 = 513;
pub const DOWNLOADFACE: u32 = 514;
pub const ENABLERELATIVEWIDTHS: u32 = 768;
pub const ENABLEPAIRKERNING: u32 = 769;
pub const SETKERNTRACK: u32 = 770;
pub const SETALLJUSTVALUES: u32 = 771;
pub const SETCHARSET: u32 = 772;
pub const STRETCHBLT: u32 = 2048;
pub const METAFILE_DRIVER: u32 = 2049;
pub const GETSETSCREENPARAMS: u32 = 3072;
pub const QUERYDIBSUPPORT: u32 = 3073;
pub const BEGIN_PATH: u32 = 4096;
pub const CLIP_TO_PATH: u32 = 4097;
pub const END_PATH: u32 = 4098;
pub const EXT_DEVICE_CAPS: u32 = 4099;
pub const RESTORE_CTM: u32 = 4100;
pub const SAVE_CTM: u32 = 4101;
pub const SET_ARC_DIRECTION: u32 = 4102;
pub const SET_BACKGROUND_COLOR: u32 = 4103;
pub const SET_POLY_MODE: u32 = 4104;
pub const SET_SCREEN_ANGLE: u32 = 4105;
pub const SET_SPREAD: u32 = 4106;
pub const TRANSFORM_CTM: u32 = 4107;
pub const SET_CLIP_BOX: u32 = 4108;
pub const SET_BOUNDS: u32 = 4109;
pub const SET_MIRROR_MODE: u32 = 4110;
pub const OPENCHANNEL: u32 = 4110;
pub const DOWNLOADHEADER: u32 = 4111;
pub const CLOSECHANNEL: u32 = 4112;
pub const POSTSCRIPT_PASSTHROUGH: u32 = 4115;
pub const ENCAPSULATED_POSTSCRIPT: u32 = 4116;
pub const POSTSCRIPT_IDENTIFY: u32 = 4117;
pub const POSTSCRIPT_INJECTION: u32 = 4118;
pub const CHECKJPEGFORMAT: u32 = 4119;
pub const CHECKPNGFORMAT: u32 = 4120;
pub const GET_PS_FEATURESETTING: u32 = 4121;
pub const GDIPLUS_TS_QUERYVER: u32 = 4122;
pub const GDIPLUS_TS_RECORD: u32 = 4123;
pub const MILCORE_TS_QUERYVER_RESULT_FALSE: u32 = 0;
pub const MILCORE_TS_QUERYVER_RESULT_TRUE: u32 = 2147483647;
pub const SPCLPASSTHROUGH2: u32 = 4568;
pub const PSIDENT_GDICENTRIC: u32 = 0;
pub const PSIDENT_PSCENTRIC: u32 = 1;
pub const PSINJECT_BEGINSTREAM: u32 = 1;
pub const PSINJECT_PSADOBE: u32 = 2;
pub const PSINJECT_PAGESATEND: u32 = 3;
pub const PSINJECT_PAGES: u32 = 4;
pub const PSINJECT_DOCNEEDEDRES: u32 = 5;
pub const PSINJECT_DOCSUPPLIEDRES: u32 = 6;
pub const PSINJECT_PAGEORDER: u32 = 7;
pub const PSINJECT_ORIENTATION: u32 = 8;
pub const PSINJECT_BOUNDINGBOX: u32 = 9;
pub const PSINJECT_DOCUMENTPROCESSCOLORS: u32 = 10;
pub const PSINJECT_COMMENTS: u32 = 11;
pub const PSINJECT_BEGINDEFAULTS: u32 = 12;
pub const PSINJECT_ENDDEFAULTS: u32 = 13;
pub const PSINJECT_BEGINPROLOG: u32 = 14;
pub const PSINJECT_ENDPROLOG: u32 = 15;
pub const PSINJECT_BEGINSETUP: u32 = 16;
pub const PSINJECT_ENDSETUP: u32 = 17;
pub const PSINJECT_TRAILER: u32 = 18;
pub const PSINJECT_EOF: u32 = 19;
pub const PSINJECT_ENDSTREAM: u32 = 20;
pub const PSINJECT_DOCUMENTPROCESSCOLORSATEND: u32 = 21;
pub const PSINJECT_PAGENUMBER: u32 = 100;
pub const PSINJECT_BEGINPAGESETUP: u32 = 101;
pub const PSINJECT_ENDPAGESETUP: u32 = 102;
pub const PSINJECT_PAGETRAILER: u32 = 103;
pub const PSINJECT_PLATECOLOR: u32 = 104;
pub const PSINJECT_SHOWPAGE: u32 = 105;
pub const PSINJECT_PAGEBBOX: u32 = 106;
pub const PSINJECT_ENDPAGECOMMENTS: u32 = 107;
pub const PSINJECT_VMSAVE: u32 = 200;
pub const PSINJECT_VMRESTORE: u32 = 201;
pub const PSINJECT_DLFONT: u32 = 3722304989;
pub const FEATURESETTING_NUP: u32 = 0;
pub const FEATURESETTING_OUTPUT: u32 = 1;
pub const FEATURESETTING_PSLEVEL: u32 = 2;
pub const FEATURESETTING_CUSTPAPER: u32 = 3;
pub const FEATURESETTING_MIRROR: u32 = 4;
pub const FEATURESETTING_NEGATIVE: u32 = 5;
pub const FEATURESETTING_PROTOCOL: u32 = 6;
pub const FEATURESETTING_PRIVATE_BEGIN: u32 = 4096;
pub const FEATURESETTING_PRIVATE_END: u32 = 8191;
pub const PSPROTOCOL_ASCII: u32 = 0;
pub const PSPROTOCOL_BCP: u32 = 1;
pub const PSPROTOCOL_TBCP: u32 = 2;
pub const PSPROTOCOL_BINARY: u32 = 3;
pub const QDI_SETDIBITS: u32 = 1;
pub const QDI_GETDIBITS: u32 = 2;
pub const QDI_DIBTOSCREEN: u32 = 4;
pub const QDI_STRETCHDIB: u32 = 8;
pub const SP_NOTREPORTED: u32 = 16384;
pub const SP_ERROR: i32 = -1;
pub const SP_APPABORT: i32 = -2;
pub const SP_USERABORT: i32 = -3;
pub const SP_OUTOFDISK: i32 = -4;
pub const SP_OUTOFMEMORY: i32 = -5;
pub const PR_JOBSTATUS: u32 = 0;
pub const OBJ_PEN: u32 = 1;
pub const OBJ_BRUSH: u32 = 2;
pub const OBJ_DC: u32 = 3;
pub const OBJ_METADC: u32 = 4;
pub const OBJ_PAL: u32 = 5;
pub const OBJ_FONT: u32 = 6;
pub const OBJ_BITMAP: u32 = 7;
pub const OBJ_REGION: u32 = 8;
pub const OBJ_METAFILE: u32 = 9;
pub const OBJ_MEMDC: u32 = 10;
pub const OBJ_EXTPEN: u32 = 11;
pub const OBJ_ENHMETADC: u32 = 12;
pub const OBJ_ENHMETAFILE: u32 = 13;
pub const OBJ_COLORSPACE: u32 = 14;
pub const GDI_OBJ_LAST: u32 = 14;
pub const MWT_IDENTITY: u32 = 1;
pub const MWT_LEFTMULTIPLY: u32 = 2;
pub const MWT_RIGHTMULTIPLY: u32 = 3;
pub const MWT_MIN: u32 = 1;
pub const MWT_MAX: u32 = 3;
pub const CS_ENABLE: u32 = 1;
pub const CS_DISABLE: u32 = 2;
pub const CS_DELETE_TRANSFORM: u32 = 3;
pub const LCS_CALIBRATED_RGB: u32 = 0;
pub const LCS_GM_BUSINESS: u32 = 1;
pub const LCS_GM_GRAPHICS: u32 = 2;
pub const LCS_GM_IMAGES: u32 = 4;
pub const LCS_GM_ABS_COLORIMETRIC: u32 = 8;
pub const CM_OUT_OF_GAMUT: u32 = 255;
pub const CM_IN_GAMUT: u32 = 0;
pub const ICM_ADDPROFILE: u32 = 1;
pub const ICM_DELETEPROFILE: u32 = 2;
pub const ICM_QUERYPROFILE: u32 = 3;
pub const ICM_SETDEFAULTPROFILE: u32 = 4;
pub const ICM_REGISTERICMATCHER: u32 = 5;
pub const ICM_UNREGISTERICMATCHER: u32 = 6;
pub const ICM_QUERYMATCH: u32 = 7;
pub const BI_RGB: u32 = 0;
pub const BI_RLE8: u32 = 1;
pub const BI_RLE4: u32 = 2;
pub const BI_BITFIELDS: u32 = 3;
pub const BI_JPEG: u32 = 4;
pub const BI_PNG: u32 = 5;
pub const TCI_SRCCHARSET: u32 = 1;
pub const TCI_SRCCODEPAGE: u32 = 2;
pub const TCI_SRCFONTSIG: u32 = 3;
pub const TCI_SRCLOCALE: u32 = 4096;
pub const TMPF_FIXED_PITCH: u32 = 1;
pub const TMPF_VECTOR: u32 = 2;
pub const TMPF_DEVICE: u32 = 8;
pub const TMPF_TRUETYPE: u32 = 4;
pub const NTM_REGULAR: u32 = 64;
pub const NTM_BOLD: u32 = 32;
pub const NTM_ITALIC: u32 = 1;
pub const NTM_NONNEGATIVE_AC: u32 = 65536;
pub const NTM_PS_OPENTYPE: u32 = 131072;
pub const NTM_TT_OPENTYPE: u32 = 262144;
pub const NTM_MULTIPLEMASTER: u32 = 524288;
pub const NTM_TYPE1: u32 = 1048576;
pub const NTM_DSIG: u32 = 2097152;
pub const LF_FACESIZE: u32 = 32;
pub const LF_FULLFACESIZE: u32 = 64;
pub const OUT_DEFAULT_PRECIS: u32 = 0;
pub const OUT_STRING_PRECIS: u32 = 1;
pub const OUT_CHARACTER_PRECIS: u32 = 2;
pub const OUT_STROKE_PRECIS: u32 = 3;
pub const OUT_TT_PRECIS: u32 = 4;
pub const OUT_DEVICE_PRECIS: u32 = 5;
pub const OUT_RASTER_PRECIS: u32 = 6;
pub const OUT_TT_ONLY_PRECIS: u32 = 7;
pub const OUT_OUTLINE_PRECIS: u32 = 8;
pub const OUT_SCREEN_OUTLINE_PRECIS: u32 = 9;
pub const OUT_PS_ONLY_PRECIS: u32 = 10;
pub const CLIP_DEFAULT_PRECIS: u32 = 0;
pub const CLIP_CHARACTER_PRECIS: u32 = 1;
pub const CLIP_STROKE_PRECIS: u32 = 2;
pub const CLIP_MASK: u32 = 15;
pub const CLIP_LH_ANGLES: u32 = 16;
pub const CLIP_TT_ALWAYS: u32 = 32;
pub const CLIP_DFA_DISABLE: u32 = 64;
pub const CLIP_EMBEDDED: u32 = 128;
pub const DEFAULT_QUALITY: u32 = 0;
pub const DRAFT_QUALITY: u32 = 1;
pub const PROOF_QUALITY: u32 = 2;
pub const NONANTIALIASED_QUALITY: u32 = 3;
pub const ANTIALIASED_QUALITY: u32 = 4;
pub const CLEARTYPE_QUALITY: u32 = 5;
pub const CLEARTYPE_NATURAL_QUALITY: u32 = 6;
pub const DEFAULT_PITCH: u32 = 0;
pub const FIXED_PITCH: u32 = 1;
pub const VARIABLE_PITCH: u32 = 2;
pub const MONO_FONT: u32 = 8;
pub const ANSI_CHARSET: u32 = 0;
pub const DEFAULT_CHARSET: u32 = 1;
pub const SYMBOL_CHARSET: u32 = 2;
pub const SHIFTJIS_CHARSET: u32 = 128;
pub const HANGEUL_CHARSET: u32 = 129;
pub const HANGUL_CHARSET: u32 = 129;
pub const GB2312_CHARSET: u32 = 134;
pub const CHINESEBIG5_CHARSET: u32 = 136;
pub const OEM_CHARSET: u32 = 255;
pub const JOHAB_CHARSET: u32 = 130;
pub const HEBREW_CHARSET: u32 = 177;
pub const ARABIC_CHARSET: u32 = 178;
pub const GREEK_CHARSET: u32 = 161;
pub const TURKISH_CHARSET: u32 = 162;
pub const VIETNAMESE_CHARSET: u32 = 163;
pub const THAI_CHARSET: u32 = 222;
pub const EASTEUROPE_CHARSET: u32 = 238;
pub const RUSSIAN_CHARSET: u32 = 204;
pub const MAC_CHARSET: u32 = 77;
pub const BALTIC_CHARSET: u32 = 186;
pub const FS_LATIN1: u32 = 1;
pub const FS_LATIN2: u32 = 2;
pub const FS_CYRILLIC: u32 = 4;
pub const FS_GREEK: u32 = 8;
pub const FS_TURKISH: u32 = 16;
pub const FS_HEBREW: u32 = 32;
pub const FS_ARABIC: u32 = 64;
pub const FS_BALTIC: u32 = 128;
pub const FS_VIETNAMESE: u32 = 256;
pub const FS_THAI: u32 = 65536;
pub const FS_JISJAPAN: u32 = 131072;
pub const FS_CHINESESIMP: u32 = 262144;
pub const FS_WANSUNG: u32 = 524288;
pub const FS_CHINESETRAD: u32 = 1048576;
pub const FS_JOHAB: u32 = 2097152;
pub const FS_SYMBOL: u32 = 2147483648;
pub const FF_DONTCARE: u32 = 0;
pub const FF_ROMAN: u32 = 16;
pub const FF_SWISS: u32 = 32;
pub const FF_MODERN: u32 = 48;
pub const FF_SCRIPT: u32 = 64;
pub const FF_DECORATIVE: u32 = 80;
pub const FW_DONTCARE: u32 = 0;
pub const FW_THIN: u32 = 100;
pub const FW_EXTRALIGHT: u32 = 200;
pub const FW_LIGHT: u32 = 300;
pub const FW_NORMAL: u32 = 400;
pub const FW_MEDIUM: u32 = 500;
pub const FW_SEMIBOLD: u32 = 600;
pub const FW_BOLD: u32 = 700;
pub const FW_EXTRABOLD: u32 = 800;
pub const FW_HEAVY: u32 = 900;
pub const FW_ULTRALIGHT: u32 = 200;
pub const FW_REGULAR: u32 = 400;
pub const FW_DEMIBOLD: u32 = 600;
pub const FW_ULTRABOLD: u32 = 800;
pub const FW_BLACK: u32 = 900;
pub const PANOSE_COUNT: u32 = 10;
pub const PAN_FAMILYTYPE_INDEX: u32 = 0;
pub const PAN_SERIFSTYLE_INDEX: u32 = 1;
pub const PAN_WEIGHT_INDEX: u32 = 2;
pub const PAN_PROPORTION_INDEX: u32 = 3;
pub const PAN_CONTRAST_INDEX: u32 = 4;
pub const PAN_STROKEVARIATION_INDEX: u32 = 5;
pub const PAN_ARMSTYLE_INDEX: u32 = 6;
pub const PAN_LETTERFORM_INDEX: u32 = 7;
pub const PAN_MIDLINE_INDEX: u32 = 8;
pub const PAN_XHEIGHT_INDEX: u32 = 9;
pub const PAN_CULTURE_LATIN: u32 = 0;
pub const PAN_ANY: u32 = 0;
pub const PAN_NO_FIT: u32 = 1;
pub const PAN_FAMILY_TEXT_DISPLAY: u32 = 2;
pub const PAN_FAMILY_SCRIPT: u32 = 3;
pub const PAN_FAMILY_DECORATIVE: u32 = 4;
pub const PAN_FAMILY_PICTORIAL: u32 = 5;
pub const PAN_SERIF_COVE: u32 = 2;
pub const PAN_SERIF_OBTUSE_COVE: u32 = 3;
pub const PAN_SERIF_SQUARE_COVE: u32 = 4;
pub const PAN_SERIF_OBTUSE_SQUARE_COVE: u32 = 5;
pub const PAN_SERIF_SQUARE: u32 = 6;
pub const PAN_SERIF_THIN: u32 = 7;
pub const PAN_SERIF_BONE: u32 = 8;
pub const PAN_SERIF_EXAGGERATED: u32 = 9;
pub const PAN_SERIF_TRIANGLE: u32 = 10;
pub const PAN_SERIF_NORMAL_SANS: u32 = 11;
pub const PAN_SERIF_OBTUSE_SANS: u32 = 12;
pub const PAN_SERIF_PERP_SANS: u32 = 13;
pub const PAN_SERIF_FLARED: u32 = 14;
pub const PAN_SERIF_ROUNDED: u32 = 15;
pub const PAN_WEIGHT_VERY_LIGHT: u32 = 2;
pub const PAN_WEIGHT_LIGHT: u32 = 3;
pub const PAN_WEIGHT_THIN: u32 = 4;
pub const PAN_WEIGHT_BOOK: u32 = 5;
pub const PAN_WEIGHT_MEDIUM: u32 = 6;
pub const PAN_WEIGHT_DEMI: u32 = 7;
pub const PAN_WEIGHT_BOLD: u32 = 8;
pub const PAN_WEIGHT_HEAVY: u32 = 9;
pub const PAN_WEIGHT_BLACK: u32 = 10;
pub const PAN_WEIGHT_NORD: u32 = 11;
pub const PAN_PROP_OLD_STYLE: u32 = 2;
pub const PAN_PROP_MODERN: u32 = 3;
pub const PAN_PROP_EVEN_WIDTH: u32 = 4;
pub const PAN_PROP_EXPANDED: u32 = 5;
pub const PAN_PROP_CONDENSED: u32 = 6;
pub const PAN_PROP_VERY_EXPANDED: u32 = 7;
pub const PAN_PROP_VERY_CONDENSED: u32 = 8;
pub const PAN_PROP_MONOSPACED: u32 = 9;
pub const PAN_CONTRAST_NONE: u32 = 2;
pub const PAN_CONTRAST_VERY_LOW: u32 = 3;
pub const PAN_CONTRAST_LOW: u32 = 4;
pub const PAN_CONTRAST_MEDIUM_LOW: u32 = 5;
pub const PAN_CONTRAST_MEDIUM: u32 = 6;
pub const PAN_CONTRAST_MEDIUM_HIGH: u32 = 7;
pub const PAN_CONTRAST_HIGH: u32 = 8;
pub const PAN_CONTRAST_VERY_HIGH: u32 = 9;
pub const PAN_STROKE_GRADUAL_DIAG: u32 = 2;
pub const PAN_STROKE_GRADUAL_TRAN: u32 = 3;
pub const PAN_STROKE_GRADUAL_VERT: u32 = 4;
pub const PAN_STROKE_GRADUAL_HORZ: u32 = 5;
pub const PAN_STROKE_RAPID_VERT: u32 = 6;
pub const PAN_STROKE_RAPID_HORZ: u32 = 7;
pub const PAN_STROKE_INSTANT_VERT: u32 = 8;
pub const PAN_STRAIGHT_ARMS_HORZ: u32 = 2;
pub const PAN_STRAIGHT_ARMS_WEDGE: u32 = 3;
pub const PAN_STRAIGHT_ARMS_VERT: u32 = 4;
pub const PAN_STRAIGHT_ARMS_SINGLE_SERIF: u32 = 5;
pub const PAN_STRAIGHT_ARMS_DOUBLE_SERIF: u32 = 6;
pub const PAN_BENT_ARMS_HORZ: u32 = 7;
pub const PAN_BENT_ARMS_WEDGE: u32 = 8;
pub const PAN_BENT_ARMS_VERT: u32 = 9;
pub const PAN_BENT_ARMS_SINGLE_SERIF: u32 = 10;
pub const PAN_BENT_ARMS_DOUBLE_SERIF: u32 = 11;
pub const PAN_LETT_NORMAL_CONTACT: u32 = 2;
pub const PAN_LETT_NORMAL_WEIGHTED: u32 = 3;
pub const PAN_LETT_NORMAL_BOXED: u32 = 4;
pub const PAN_LETT_NORMAL_FLATTENED: u32 = 5;
pub const PAN_LETT_NORMAL_ROUNDED: u32 = 6;
pub const PAN_LETT_NORMAL_OFF_CENTER: u32 = 7;
pub const PAN_LETT_NORMAL_SQUARE: u32 = 8;
pub const PAN_LETT_OBLIQUE_CONTACT: u32 = 9;
pub const PAN_LETT_OBLIQUE_WEIGHTED: u32 = 10;
pub const PAN_LETT_OBLIQUE_BOXED: u32 = 11;
pub const PAN_LETT_OBLIQUE_FLATTENED: u32 = 12;
pub const PAN_LETT_OBLIQUE_ROUNDED: u32 = 13;
pub const PAN_LETT_OBLIQUE_OFF_CENTER: u32 = 14;
pub const PAN_LETT_OBLIQUE_SQUARE: u32 = 15;
pub const PAN_MIDLINE_STANDARD_TRIMMED: u32 = 2;
pub const PAN_MIDLINE_STANDARD_POINTED: u32 = 3;
pub const PAN_MIDLINE_STANDARD_SERIFED: u32 = 4;
pub const PAN_MIDLINE_HIGH_TRIMMED: u32 = 5;
pub const PAN_MIDLINE_HIGH_POINTED: u32 = 6;
pub const PAN_MIDLINE_HIGH_SERIFED: u32 = 7;
pub const PAN_MIDLINE_CONSTANT_TRIMMED: u32 = 8;
pub const PAN_MIDLINE_CONSTANT_POINTED: u32 = 9;
pub const PAN_MIDLINE_CONSTANT_SERIFED: u32 = 10;
pub const PAN_MIDLINE_LOW_TRIMMED: u32 = 11;
pub const PAN_MIDLINE_LOW_POINTED: u32 = 12;
pub const PAN_MIDLINE_LOW_SERIFED: u32 = 13;
pub const PAN_XHEIGHT_CONSTANT_SMALL: u32 = 2;
pub const PAN_XHEIGHT_CONSTANT_STD: u32 = 3;
pub const PAN_XHEIGHT_CONSTANT_LARGE: u32 = 4;
pub const PAN_XHEIGHT_DUCKING_SMALL: u32 = 5;
pub const PAN_XHEIGHT_DUCKING_STD: u32 = 6;
pub const PAN_XHEIGHT_DUCKING_LARGE: u32 = 7;
pub const ELF_VENDOR_SIZE: u32 = 4;
pub const ELF_VERSION: u32 = 0;
pub const ELF_CULTURE_LATIN: u32 = 0;
pub const RASTER_FONTTYPE: u32 = 1;
pub const DEVICE_FONTTYPE: u32 = 2;
pub const TRUETYPE_FONTTYPE: u32 = 4;
pub const PC_RESERVED: u32 = 1;
pub const PC_EXPLICIT: u32 = 2;
pub const PC_NOCOLLAPSE: u32 = 4;
pub const TRANSPARENT: u32 = 1;
pub const OPAQUE: u32 = 2;
pub const BKMODE_LAST: u32 = 2;
pub const GM_COMPATIBLE: u32 = 1;
pub const GM_ADVANCED: u32 = 2;
pub const GM_LAST: u32 = 2;
pub const PT_CLOSEFIGURE: u32 = 1;
pub const PT_LINETO: u32 = 2;
pub const PT_BEZIERTO: u32 = 4;
pub const PT_MOVETO: u32 = 6;
pub const MM_TEXT: u32 = 1;
pub const MM_LOMETRIC: u32 = 2;
pub const MM_HIMETRIC: u32 = 3;
pub const MM_LOENGLISH: u32 = 4;
pub const MM_HIENGLISH: u32 = 5;
pub const MM_TWIPS: u32 = 6;
pub const MM_ISOTROPIC: u32 = 7;
pub const MM_ANISOTROPIC: u32 = 8;
pub const MM_MIN: u32 = 1;
pub const MM_MAX: u32 = 8;
pub const MM_MAX_FIXEDSCALE: u32 = 6;
pub const ABSOLUTE: u32 = 1;
pub const RELATIVE: u32 = 2;
pub const WHITE_BRUSH: u32 = 0;
pub const LTGRAY_BRUSH: u32 = 1;
pub const GRAY_BRUSH: u32 = 2;
pub const DKGRAY_BRUSH: u32 = 3;
pub const BLACK_BRUSH: u32 = 4;
pub const NULL_BRUSH: u32 = 5;
pub const HOLLOW_BRUSH: u32 = 5;
pub const WHITE_PEN: u32 = 6;
pub const BLACK_PEN: u32 = 7;
pub const NULL_PEN: u32 = 8;
pub const OEM_FIXED_FONT: u32 = 10;
pub const ANSI_FIXED_FONT: u32 = 11;
pub const ANSI_VAR_FONT: u32 = 12;
pub const SYSTEM_FONT: u32 = 13;
pub const DEVICE_DEFAULT_FONT: u32 = 14;
pub const DEFAULT_PALETTE: u32 = 15;
pub const SYSTEM_FIXED_FONT: u32 = 16;
pub const DEFAULT_GUI_FONT: u32 = 17;
pub const DC_BRUSH: u32 = 18;
pub const DC_PEN: u32 = 19;
pub const STOCK_LAST: u32 = 19;
pub const CLR_INVALID: u32 = 4294967295;
pub const BS_SOLID: u32 = 0;
pub const BS_NULL: u32 = 1;
pub const BS_HOLLOW: u32 = 1;
pub const BS_HATCHED: u32 = 2;
pub const BS_PATTERN: u32 = 3;
pub const BS_INDEXED: u32 = 4;
pub const BS_DIBPATTERN: u32 = 5;
pub const BS_DIBPATTERNPT: u32 = 6;
pub const BS_PATTERN8X8: u32 = 7;
pub const BS_DIBPATTERN8X8: u32 = 8;
pub const BS_MONOPATTERN: u32 = 9;
pub const HS_HORIZONTAL: u32 = 0;
pub const HS_VERTICAL: u32 = 1;
pub const HS_FDIAGONAL: u32 = 2;
pub const HS_BDIAGONAL: u32 = 3;
pub const HS_CROSS: u32 = 4;
pub const HS_DIAGCROSS: u32 = 5;
pub const HS_API_MAX: u32 = 12;
pub const PS_SOLID: u32 = 0;
pub const PS_DASH: u32 = 1;
pub const PS_DOT: u32 = 2;
pub const PS_DASHDOT: u32 = 3;
pub const PS_DASHDOTDOT: u32 = 4;
pub const PS_NULL: u32 = 5;
pub const PS_INSIDEFRAME: u32 = 6;
pub const PS_USERSTYLE: u32 = 7;
pub const PS_ALTERNATE: u32 = 8;
pub const PS_STYLE_MASK: u32 = 15;
pub const PS_ENDCAP_ROUND: u32 = 0;
pub const PS_ENDCAP_SQUARE: u32 = 256;
pub const PS_ENDCAP_FLAT: u32 = 512;
pub const PS_ENDCAP_MASK: u32 = 3840;
pub const PS_JOIN_ROUND: u32 = 0;
pub const PS_JOIN_BEVEL: u32 = 4096;
pub const PS_JOIN_MITER: u32 = 8192;
pub const PS_JOIN_MASK: u32 = 61440;
pub const PS_COSMETIC: u32 = 0;
pub const PS_GEOMETRIC: u32 = 65536;
pub const PS_TYPE_MASK: u32 = 983040;
pub const AD_COUNTERCLOCKWISE: u32 = 1;
pub const AD_CLOCKWISE: u32 = 2;
pub const DRIVERVERSION: u32 = 0;
pub const TECHNOLOGY: u32 = 2;
pub const HORZSIZE: u32 = 4;
pub const VERTSIZE: u32 = 6;
pub const HORZRES: u32 = 8;
pub const VERTRES: u32 = 10;
pub const BITSPIXEL: u32 = 12;
pub const PLANES: u32 = 14;
pub const NUMBRUSHES: u32 = 16;
pub const NUMPENS: u32 = 18;
pub const NUMMARKERS: u32 = 20;
pub const NUMFONTS: u32 = 22;
pub const NUMCOLORS: u32 = 24;
pub const PDEVICESIZE: u32 = 26;
pub const CURVECAPS: u32 = 28;
pub const LINECAPS: u32 = 30;
pub const POLYGONALCAPS: u32 = 32;
pub const TEXTCAPS: u32 = 34;
pub const CLIPCAPS: u32 = 36;
pub const RASTERCAPS: u32 = 38;
pub const ASPECTX: u32 = 40;
pub const ASPECTY: u32 = 42;
pub const ASPECTXY: u32 = 44;
pub const LOGPIXELSX: u32 = 88;
pub const LOGPIXELSY: u32 = 90;
pub const SIZEPALETTE: u32 = 104;
pub const NUMRESERVED: u32 = 106;
pub const COLORRES: u32 = 108;
pub const PHYSICALWIDTH: u32 = 110;
pub const PHYSICALHEIGHT: u32 = 111;
pub const PHYSICALOFFSETX: u32 = 112;
pub const PHYSICALOFFSETY: u32 = 113;
pub const SCALINGFACTORX: u32 = 114;
pub const SCALINGFACTORY: u32 = 115;
pub const VREFRESH: u32 = 116;
pub const DESKTOPVERTRES: u32 = 117;
pub const DESKTOPHORZRES: u32 = 118;
pub const BLTALIGNMENT: u32 = 119;
pub const SHADEBLENDCAPS: u32 = 120;
pub const COLORMGMTCAPS: u32 = 121;
pub const DT_PLOTTER: u32 = 0;
pub const DT_RASDISPLAY: u32 = 1;
pub const DT_RASPRINTER: u32 = 2;
pub const DT_RASCAMERA: u32 = 3;
pub const DT_CHARSTREAM: u32 = 4;
pub const DT_METAFILE: u32 = 5;
pub const DT_DISPFILE: u32 = 6;
pub const CC_NONE: u32 = 0;
pub const CC_CIRCLES: u32 = 1;
pub const CC_PIE: u32 = 2;
pub const CC_CHORD: u32 = 4;
pub const CC_ELLIPSES: u32 = 8;
pub const CC_WIDE: u32 = 16;
pub const CC_STYLED: u32 = 32;
pub const CC_WIDESTYLED: u32 = 64;
pub const CC_INTERIORS: u32 = 128;
pub const CC_ROUNDRECT: u32 = 256;
pub const LC_NONE: u32 = 0;
pub const LC_POLYLINE: u32 = 2;
pub const LC_MARKER: u32 = 4;
pub const LC_POLYMARKER: u32 = 8;
pub const LC_WIDE: u32 = 16;
pub const LC_STYLED: u32 = 32;
pub const LC_WIDESTYLED: u32 = 64;
pub const LC_INTERIORS: u32 = 128;
pub const PC_NONE: u32 = 0;
pub const PC_POLYGON: u32 = 1;
pub const PC_RECTANGLE: u32 = 2;
pub const PC_WINDPOLYGON: u32 = 4;
pub const PC_TRAPEZOID: u32 = 4;
pub const PC_SCANLINE: u32 = 8;
pub const PC_WIDE: u32 = 16;
pub const PC_STYLED: u32 = 32;
pub const PC_WIDESTYLED: u32 = 64;
pub const PC_INTERIORS: u32 = 128;
pub const PC_POLYPOLYGON: u32 = 256;
pub const PC_PATHS: u32 = 512;
pub const CP_NONE: u32 = 0;
pub const CP_RECTANGLE: u32 = 1;
pub const CP_REGION: u32 = 2;
pub const TC_OP_CHARACTER: u32 = 1;
pub const TC_OP_STROKE: u32 = 2;
pub const TC_CP_STROKE: u32 = 4;
pub const TC_CR_90: u32 = 8;
pub const TC_CR_ANY: u32 = 16;
pub const TC_SF_X_YINDEP: u32 = 32;
pub const TC_SA_DOUBLE: u32 = 64;
pub const TC_SA_INTEGER: u32 = 128;
pub const TC_SA_CONTIN: u32 = 256;
pub const TC_EA_DOUBLE: u32 = 512;
pub const TC_IA_ABLE: u32 = 1024;
pub const TC_UA_ABLE: u32 = 2048;
pub const TC_SO_ABLE: u32 = 4096;
pub const TC_RA_ABLE: u32 = 8192;
pub const TC_VA_ABLE: u32 = 16384;
pub const TC_RESERVED: u32 = 32768;
pub const TC_SCROLLBLT: u32 = 65536;
pub const RC_BITBLT: u32 = 1;
pub const RC_BANDING: u32 = 2;
pub const RC_SCALING: u32 = 4;
pub const RC_BITMAP64: u32 = 8;
pub const RC_GDI20_OUTPUT: u32 = 16;
pub const RC_GDI20_STATE: u32 = 32;
pub const RC_SAVEBITMAP: u32 = 64;
pub const RC_DI_BITMAP: u32 = 128;
pub const RC_PALETTE: u32 = 256;
pub const RC_DIBTODEV: u32 = 512;
pub const RC_BIGFONT: u32 = 1024;
pub const RC_STRETCHBLT: u32 = 2048;
pub const RC_FLOODFILL: u32 = 4096;
pub const RC_STRETCHDIB: u32 = 8192;
pub const RC_OP_DX_OUTPUT: u32 = 16384;
pub const RC_DEVBITS: u32 = 32768;
pub const SB_NONE: u32 = 0;
pub const SB_CONST_ALPHA: u32 = 1;
pub const SB_PIXEL_ALPHA: u32 = 2;
pub const SB_PREMULT_ALPHA: u32 = 4;
pub const SB_GRAD_RECT: u32 = 16;
pub const SB_GRAD_TRI: u32 = 32;
pub const CM_NONE: u32 = 0;
pub const CM_DEVICE_ICM: u32 = 1;
pub const CM_GAMMA_RAMP: u32 = 2;
pub const CM_CMYK_COLOR: u32 = 4;
pub const DIB_RGB_COLORS: u32 = 0;
pub const DIB_PAL_COLORS: u32 = 1;
pub const SYSPAL_ERROR: u32 = 0;
pub const SYSPAL_STATIC: u32 = 1;
pub const SYSPAL_NOSTATIC: u32 = 2;
pub const SYSPAL_NOSTATIC256: u32 = 3;
pub const CBM_INIT: u32 = 4;
pub const FLOODFILLBORDER: u32 = 0;
pub const FLOODFILLSURFACE: u32 = 1;
pub const CCHDEVICENAME: u32 = 32;
pub const CCHFORMNAME: u32 = 32;
pub const DM_SPECVERSION: u32 = 1025;
pub const DM_ORIENTATION: u32 = 1;
pub const DM_PAPERSIZE: u32 = 2;
pub const DM_PAPERLENGTH: u32 = 4;
pub const DM_PAPERWIDTH: u32 = 8;
pub const DM_SCALE: u32 = 16;
pub const DM_POSITION: u32 = 32;
pub const DM_NUP: u32 = 64;
pub const DM_DISPLAYORIENTATION: u32 = 128;
pub const DM_COPIES: u32 = 256;
pub const DM_DEFAULTSOURCE: u32 = 512;
pub const DM_PRINTQUALITY: u32 = 1024;
pub const DM_COLOR: u32 = 2048;
pub const DM_DUPLEX: u32 = 4096;
pub const DM_YRESOLUTION: u32 = 8192;
pub const DM_TTOPTION: u32 = 16384;
pub const DM_COLLATE: u32 = 32768;
pub const DM_FORMNAME: u32 = 65536;
pub const DM_LOGPIXELS: u32 = 131072;
pub const DM_BITSPERPEL: u32 = 262144;
pub const DM_PELSWIDTH: u32 = 524288;
pub const DM_PELSHEIGHT: u32 = 1048576;
pub const DM_DISPLAYFLAGS: u32 = 2097152;
pub const DM_DISPLAYFREQUENCY: u32 = 4194304;
pub const DM_ICMMETHOD: u32 = 8388608;
pub const DM_ICMINTENT: u32 = 16777216;
pub const DM_MEDIATYPE: u32 = 33554432;
pub const DM_DITHERTYPE: u32 = 67108864;
pub const DM_PANNINGWIDTH: u32 = 134217728;
pub const DM_PANNINGHEIGHT: u32 = 268435456;
pub const DM_DISPLAYFIXEDOUTPUT: u32 = 536870912;
pub const DMORIENT_PORTRAIT: u32 = 1;
pub const DMORIENT_LANDSCAPE: u32 = 2;
pub const DMPAPER_LETTER: u32 = 1;
pub const DMPAPER_LETTERSMALL: u32 = 2;
pub const DMPAPER_TABLOID: u32 = 3;
pub const DMPAPER_LEDGER: u32 = 4;
pub const DMPAPER_LEGAL: u32 = 5;
pub const DMPAPER_STATEMENT: u32 = 6;
pub const DMPAPER_EXECUTIVE: u32 = 7;
pub const DMPAPER_A3: u32 = 8;
pub const DMPAPER_A4: u32 = 9;
pub const DMPAPER_A4SMALL: u32 = 10;
pub const DMPAPER_A5: u32 = 11;
pub const DMPAPER_B4: u32 = 12;
pub const DMPAPER_B5: u32 = 13;
pub const DMPAPER_FOLIO: u32 = 14;
pub const DMPAPER_QUARTO: u32 = 15;
pub const DMPAPER_10X14: u32 = 16;
pub const DMPAPER_11X17: u32 = 17;
pub const DMPAPER_NOTE: u32 = 18;
pub const DMPAPER_ENV_9: u32 = 19;
pub const DMPAPER_ENV_10: u32 = 20;
pub const DMPAPER_ENV_11: u32 = 21;
pub const DMPAPER_ENV_12: u32 = 22;
pub const DMPAPER_ENV_14: u32 = 23;
pub const DMPAPER_CSHEET: u32 = 24;
pub const DMPAPER_DSHEET: u32 = 25;
pub const DMPAPER_ESHEET: u32 = 26;
pub const DMPAPER_ENV_DL: u32 = 27;
pub const DMPAPER_ENV_C5: u32 = 28;
pub const DMPAPER_ENV_C3: u32 = 29;
pub const DMPAPER_ENV_C4: u32 = 30;
pub const DMPAPER_ENV_C6: u32 = 31;
pub const DMPAPER_ENV_C65: u32 = 32;
pub const DMPAPER_ENV_B4: u32 = 33;
pub const DMPAPER_ENV_B5: u32 = 34;
pub const DMPAPER_ENV_B6: u32 = 35;
pub const DMPAPER_ENV_ITALY: u32 = 36;
pub const DMPAPER_ENV_MONARCH: u32 = 37;
pub const DMPAPER_ENV_PERSONAL: u32 = 38;
pub const DMPAPER_FANFOLD_US: u32 = 39;
pub const DMPAPER_FANFOLD_STD_GERMAN: u32 = 40;
pub const DMPAPER_FANFOLD_LGL_GERMAN: u32 = 41;
pub const DMPAPER_ISO_B4: u32 = 42;
pub const DMPAPER_JAPANESE_POSTCARD: u32 = 43;
pub const DMPAPER_9X11: u32 = 44;
pub const DMPAPER_10X11: u32 = 45;
pub const DMPAPER_15X11: u32 = 46;
pub const DMPAPER_ENV_INVITE: u32 = 47;
pub const DMPAPER_RESERVED_48: u32 = 48;
pub const DMPAPER_RESERVED_49: u32 = 49;
pub const DMPAPER_LETTER_EXTRA: u32 = 50;
pub const DMPAPER_LEGAL_EXTRA: u32 = 51;
pub const DMPAPER_TABLOID_EXTRA: u32 = 52;
pub const DMPAPER_A4_EXTRA: u32 = 53;
pub const DMPAPER_LETTER_TRANSVERSE: u32 = 54;
pub const DMPAPER_A4_TRANSVERSE: u32 = 55;
pub const DMPAPER_LETTER_EXTRA_TRANSVERSE: u32 = 56;
pub const DMPAPER_A_PLUS: u32 = 57;
pub const DMPAPER_B_PLUS: u32 = 58;
pub const DMPAPER_LETTER_PLUS: u32 = 59;
pub const DMPAPER_A4_PLUS: u32 = 60;
pub const DMPAPER_A5_TRANSVERSE: u32 = 61;
pub const DMPAPER_B5_TRANSVERSE: u32 = 62;
pub const DMPAPER_A3_EXTRA: u32 = 63;
pub const DMPAPER_A5_EXTRA: u32 = 64;
pub const DMPAPER_B5_EXTRA: u32 = 65;
pub const DMPAPER_A2: u32 = 66;
pub const DMPAPER_A3_TRANSVERSE: u32 = 67;
pub const DMPAPER_A3_EXTRA_TRANSVERSE: u32 = 68;
pub const DMPAPER_DBL_JAPANESE_POSTCARD: u32 = 69;
pub const DMPAPER_A6: u32 = 70;
pub const DMPAPER_JENV_KAKU2: u32 = 71;
pub const DMPAPER_JENV_KAKU3: u32 = 72;
pub const DMPAPER_JENV_CHOU3: u32 = 73;
pub const DMPAPER_JENV_CHOU4: u32 = 74;
pub const DMPAPER_LETTER_ROTATED: u32 = 75;
pub const DMPAPER_A3_ROTATED: u32 = 76;
pub const DMPAPER_A4_ROTATED: u32 = 77;
pub const DMPAPER_A5_ROTATED: u32 = 78;
pub const DMPAPER_B4_JIS_ROTATED: u32 = 79;
pub const DMPAPER_B5_JIS_ROTATED: u32 = 80;
pub const DMPAPER_JAPANESE_POSTCARD_ROTATED: u32 = 81;
pub const DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED: u32 = 82;
pub const DMPAPER_A6_ROTATED: u32 = 83;
pub const DMPAPER_JENV_KAKU2_ROTATED: u32 = 84;
pub const DMPAPER_JENV_KAKU3_ROTATED: u32 = 85;
pub const DMPAPER_JENV_CHOU3_ROTATED: u32 = 86;
pub const DMPAPER_JENV_CHOU4_ROTATED: u32 = 87;
pub const DMPAPER_B6_JIS: u32 = 88;
pub const DMPAPER_B6_JIS_ROTATED: u32 = 89;
pub const DMPAPER_12X11: u32 = 90;
pub const DMPAPER_JENV_YOU4: u32 = 91;
pub const DMPAPER_JENV_YOU4_ROTATED: u32 = 92;
pub const DMPAPER_P16K: u32 = 93;
pub const DMPAPER_P32K: u32 = 94;
pub const DMPAPER_P32KBIG: u32 = 95;
pub const DMPAPER_PENV_1: u32 = 96;
pub const DMPAPER_PENV_2: u32 = 97;
pub const DMPAPER_PENV_3: u32 = 98;
pub const DMPAPER_PENV_4: u32 = 99;
pub const DMPAPER_PENV_5: u32 = 100;
pub const DMPAPER_PENV_6: u32 = 101;
pub const DMPAPER_PENV_7: u32 = 102;
pub const DMPAPER_PENV_8: u32 = 103;
pub const DMPAPER_PENV_9: u32 = 104;
pub const DMPAPER_PENV_10: u32 = 105;
pub const DMPAPER_P16K_ROTATED: u32 = 106;
pub const DMPAPER_P32K_ROTATED: u32 = 107;
pub const DMPAPER_P32KBIG_ROTATED: u32 = 108;
pub const DMPAPER_PENV_1_ROTATED: u32 = 109;
pub const DMPAPER_PENV_2_ROTATED: u32 = 110;
pub const DMPAPER_PENV_3_ROTATED: u32 = 111;
pub const DMPAPER_PENV_4_ROTATED: u32 = 112;
pub const DMPAPER_PENV_5_ROTATED: u32 = 113;
pub const DMPAPER_PENV_6_ROTATED: u32 = 114;
pub const DMPAPER_PENV_7_ROTATED: u32 = 115;
pub const DMPAPER_PENV_8_ROTATED: u32 = 116;
pub const DMPAPER_PENV_9_ROTATED: u32 = 117;
pub const DMPAPER_PENV_10_ROTATED: u32 = 118;
pub const DMPAPER_LAST: u32 = 118;
pub const DMPAPER_USER: u32 = 256;
pub const DMBIN_UPPER: u32 = 1;
pub const DMBIN_ONLYONE: u32 = 1;
pub const DMBIN_LOWER: u32 = 2;
pub const DMBIN_MIDDLE: u32 = 3;
pub const DMBIN_MANUAL: u32 = 4;
pub const DMBIN_ENVELOPE: u32 = 5;
pub const DMBIN_ENVMANUAL: u32 = 6;
pub const DMBIN_AUTO: u32 = 7;
pub const DMBIN_TRACTOR: u32 = 8;
pub const DMBIN_SMALLFMT: u32 = 9;
pub const DMBIN_LARGEFMT: u32 = 10;
pub const DMBIN_LARGECAPACITY: u32 = 11;
pub const DMBIN_CASSETTE: u32 = 14;
pub const DMBIN_FORMSOURCE: u32 = 15;
pub const DMBIN_LAST: u32 = 15;
pub const DMBIN_USER: u32 = 256;
pub const DMRES_DRAFT: i32 = -1;
pub const DMRES_LOW: i32 = -2;
pub const DMRES_MEDIUM: i32 = -3;
pub const DMRES_HIGH: i32 = -4;
pub const DMCOLOR_MONOCHROME: u32 = 1;
pub const DMCOLOR_COLOR: u32 = 2;
pub const DMDUP_SIMPLEX: u32 = 1;
pub const DMDUP_VERTICAL: u32 = 2;
pub const DMDUP_HORIZONTAL: u32 = 3;
pub const DMTT_BITMAP: u32 = 1;
pub const DMTT_DOWNLOAD: u32 = 2;
pub const DMTT_SUBDEV: u32 = 3;
pub const DMTT_DOWNLOAD_OUTLINE: u32 = 4;
pub const DMCOLLATE_FALSE: u32 = 0;
pub const DMCOLLATE_TRUE: u32 = 1;
pub const DMDO_DEFAULT: u32 = 0;
pub const DMDO_90: u32 = 1;
pub const DMDO_180: u32 = 2;
pub const DMDO_270: u32 = 3;
pub const DMDFO_DEFAULT: u32 = 0;
pub const DMDFO_STRETCH: u32 = 1;
pub const DMDFO_CENTER: u32 = 2;
pub const DM_INTERLACED: u32 = 2;
pub const DMDISPLAYFLAGS_TEXTMODE: u32 = 4;
pub const DMNUP_SYSTEM: u32 = 1;
pub const DMNUP_ONEUP: u32 = 2;
pub const DMICMMETHOD_NONE: u32 = 1;
pub const DMICMMETHOD_SYSTEM: u32 = 2;
pub const DMICMMETHOD_DRIVER: u32 = 3;
pub const DMICMMETHOD_DEVICE: u32 = 4;
pub const DMICMMETHOD_USER: u32 = 256;
pub const DMICM_SATURATE: u32 = 1;
pub const DMICM_CONTRAST: u32 = 2;
pub const DMICM_COLORIMETRIC: u32 = 3;
pub const DMICM_ABS_COLORIMETRIC: u32 = 4;
pub const DMICM_USER: u32 = 256;
pub const DMMEDIA_STANDARD: u32 = 1;
pub const DMMEDIA_TRANSPARENCY: u32 = 2;
pub const DMMEDIA_GLOSSY: u32 = 3;
pub const DMMEDIA_USER: u32 = 256;
pub const DMDITHER_NONE: u32 = 1;
pub const DMDITHER_COARSE: u32 = 2;
pub const DMDITHER_FINE: u32 = 3;
pub const DMDITHER_LINEART: u32 = 4;
pub const DMDITHER_ERRORDIFFUSION: u32 = 5;
pub const DMDITHER_RESERVED6: u32 = 6;
pub const DMDITHER_RESERVED7: u32 = 7;
pub const DMDITHER_RESERVED8: u32 = 8;
pub const DMDITHER_RESERVED9: u32 = 9;
pub const DMDITHER_GRAYSCALE: u32 = 10;
pub const DMDITHER_USER: u32 = 256;
pub const DISPLAY_DEVICE_ATTACHED_TO_DESKTOP: u32 = 1;
pub const DISPLAY_DEVICE_MULTI_DRIVER: u32 = 2;
pub const DISPLAY_DEVICE_PRIMARY_DEVICE: u32 = 4;
pub const DISPLAY_DEVICE_MIRRORING_DRIVER: u32 = 8;
pub const DISPLAY_DEVICE_VGA_COMPATIBLE: u32 = 16;
pub const DISPLAY_DEVICE_REMOVABLE: u32 = 32;
pub const DISPLAY_DEVICE_ACC_DRIVER: u32 = 64;
pub const DISPLAY_DEVICE_MODESPRUNED: u32 = 134217728;
pub const DISPLAY_DEVICE_RDPUDD: u32 = 16777216;
pub const DISPLAY_DEVICE_REMOTE: u32 = 67108864;
pub const DISPLAY_DEVICE_DISCONNECT: u32 = 33554432;
pub const DISPLAY_DEVICE_TS_COMPATIBLE: u32 = 2097152;
pub const DISPLAY_DEVICE_UNSAFE_MODES_ON: u32 = 524288;
pub const DISPLAY_DEVICE_ACTIVE: u32 = 1;
pub const DISPLAY_DEVICE_ATTACHED: u32 = 2;
pub const DISPLAYCONFIG_MAXPATH: u32 = 1024;
pub const DISPLAYCONFIG_PATH_MODE_IDX_INVALID: u32 = 4294967295;
pub const DISPLAYCONFIG_PATH_TARGET_MODE_IDX_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_PATH_DESKTOP_IMAGE_IDX_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_PATH_SOURCE_MODE_IDX_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_PATH_CLONE_GROUP_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_SOURCE_IN_USE: u32 = 1;
pub const DISPLAYCONFIG_TARGET_IN_USE: u32 = 1;
pub const DISPLAYCONFIG_TARGET_FORCIBLE: u32 = 2;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_BOOT: u32 = 4;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_PATH: u32 = 8;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_SYSTEM: u32 = 16;
pub const DISPLAYCONFIG_TARGET_IS_HMD: u32 = 32;
pub const DISPLAYCONFIG_PATH_ACTIVE: u32 = 1;
pub const DISPLAYCONFIG_PATH_PREFERRED_UNSCALED: u32 = 4;
pub const DISPLAYCONFIG_PATH_SUPPORT_VIRTUAL_MODE: u32 = 8;
pub const DISPLAYCONFIG_PATH_VALID_FLAGS: u32 = 13;
pub const QDC_ALL_PATHS: u32 = 1;
pub const QDC_ONLY_ACTIVE_PATHS: u32 = 2;
pub const QDC_DATABASE_CURRENT: u32 = 4;
pub const QDC_VIRTUAL_MODE_AWARE: u32 = 16;
pub const QDC_INCLUDE_HMD: u32 = 32;
pub const SDC_TOPOLOGY_INTERNAL: u32 = 1;
pub const SDC_TOPOLOGY_CLONE: u32 = 2;
pub const SDC_TOPOLOGY_EXTEND: u32 = 4;
pub const SDC_TOPOLOGY_EXTERNAL: u32 = 8;
pub const SDC_TOPOLOGY_SUPPLIED: u32 = 16;
pub const SDC_USE_DATABASE_CURRENT: u32 = 15;
pub const SDC_USE_SUPPLIED_DISPLAY_CONFIG: u32 = 32;
pub const SDC_VALIDATE: u32 = 64;
pub const SDC_APPLY: u32 = 128;
pub const SDC_NO_OPTIMIZATION: u32 = 256;
pub const SDC_SAVE_TO_DATABASE: u32 = 512;
pub const SDC_ALLOW_CHANGES: u32 = 1024;
pub const SDC_PATH_PERSIST_IF_REQUIRED: u32 = 2048;
pub const SDC_FORCE_MODE_ENUMERATION: u32 = 4096;
pub const SDC_ALLOW_PATH_ORDER_CHANGES: u32 = 8192;
pub const SDC_VIRTUAL_MODE_AWARE: u32 = 32768;
pub const RDH_RECTANGLES: u32 = 1;
pub const SYSRGN: u32 = 4;
pub const GGO_METRICS: u32 = 0;
pub const GGO_BITMAP: u32 = 1;
pub const GGO_NATIVE: u32 = 2;
pub const GGO_BEZIER: u32 = 3;
pub const GGO_GRAY2_BITMAP: u32 = 4;
pub const GGO_GRAY4_BITMAP: u32 = 5;
pub const GGO_GRAY8_BITMAP: u32 = 6;
pub const GGO_GLYPH_INDEX: u32 = 128;
pub const GGO_UNHINTED: u32 = 256;
pub const TT_POLYGON_TYPE: u32 = 24;
pub const TT_PRIM_LINE: u32 = 1;
pub const TT_PRIM_QSPLINE: u32 = 2;
pub const TT_PRIM_CSPLINE: u32 = 3;
pub const GCP_DBCS: u32 = 1;
pub const GCP_REORDER: u32 = 2;
pub const GCP_USEKERNING: u32 = 8;
pub const GCP_GLYPHSHAPE: u32 = 16;
pub const GCP_LIGATE: u32 = 32;
pub const GCP_DIACRITIC: u32 = 256;
pub const GCP_KASHIDA: u32 = 1024;
pub const GCP_ERROR: u32 = 32768;
pub const FLI_MASK: u32 = 4155;
pub const GCP_JUSTIFY: u32 = 65536;
pub const FLI_GLYPHS: u32 = 262144;
pub const GCP_CLASSIN: u32 = 524288;
pub const GCP_MAXEXTENT: u32 = 1048576;
pub const GCP_JUSTIFYIN: u32 = 2097152;
pub const GCP_DISPLAYZWG: u32 = 4194304;
pub const GCP_SYMSWAPOFF: u32 = 8388608;
pub const GCP_NUMERICOVERRIDE: u32 = 16777216;
pub const GCP_NEUTRALOVERRIDE: u32 = 33554432;
pub const GCP_NUMERICSLATIN: u32 = 67108864;
pub const GCP_NUMERICSLOCAL: u32 = 134217728;
pub const GCPCLASS_LATIN: u32 = 1;
pub const GCPCLASS_HEBREW: u32 = 2;
pub const GCPCLASS_ARABIC: u32 = 2;
pub const GCPCLASS_NEUTRAL: u32 = 3;
pub const GCPCLASS_LOCALNUMBER: u32 = 4;
pub const GCPCLASS_LATINNUMBER: u32 = 5;
pub const GCPCLASS_LATINNUMERICTERMINATOR: u32 = 6;
pub const GCPCLASS_LATINNUMERICSEPARATOR: u32 = 7;
pub const GCPCLASS_NUMERICSEPARATOR: u32 = 8;
pub const GCPCLASS_PREBOUNDLTR: u32 = 128;
pub const GCPCLASS_PREBOUNDRTL: u32 = 64;
pub const GCPCLASS_POSTBOUNDLTR: u32 = 32;
pub const GCPCLASS_POSTBOUNDRTL: u32 = 16;
pub const GCPGLYPH_LINKBEFORE: u32 = 32768;
pub const GCPGLYPH_LINKAFTER: u32 = 16384;
pub const TT_AVAILABLE: u32 = 1;
pub const TT_ENABLED: u32 = 2;
pub const PFD_TYPE_RGBA: u32 = 0;
pub const PFD_TYPE_COLORINDEX: u32 = 1;
pub const PFD_MAIN_PLANE: u32 = 0;
pub const PFD_OVERLAY_PLANE: u32 = 1;
pub const PFD_UNDERLAY_PLANE: i32 = -1;
pub const PFD_DOUBLEBUFFER: u32 = 1;
pub const PFD_STEREO: u32 = 2;
pub const PFD_DRAW_TO_WINDOW: u32 = 4;
pub const PFD_DRAW_TO_BITMAP: u32 = 8;
pub const PFD_SUPPORT_GDI: u32 = 16;
pub const PFD_SUPPORT_OPENGL: u32 = 32;
pub const PFD_GENERIC_FORMAT: u32 = 64;
pub const PFD_NEED_PALETTE: u32 = 128;
pub const PFD_NEED_SYSTEM_PALETTE: u32 = 256;
pub const PFD_SWAP_EXCHANGE: u32 = 512;
pub const PFD_SWAP_COPY: u32 = 1024;
pub const PFD_SWAP_LAYER_BUFFERS: u32 = 2048;
pub const PFD_GENERIC_ACCELERATED: u32 = 4096;
pub const PFD_SUPPORT_DIRECTDRAW: u32 = 8192;
pub const PFD_DIRECT3D_ACCELERATED: u32 = 16384;
pub const PFD_SUPPORT_COMPOSITION: u32 = 32768;
pub const PFD_DEPTH_DONTCARE: u32 = 536870912;
pub const PFD_DOUBLEBUFFER_DONTCARE: u32 = 1073741824;
pub const PFD_STEREO_DONTCARE: u32 = 2147483648;
pub const DC_BINADJUST: u32 = 19;
pub const DC_EMF_COMPLIANT: u32 = 20;
pub const DC_DATATYPE_PRODUCED: u32 = 21;
pub const DC_COLLATE: u32 = 22;
pub const DC_MANUFACTURER: u32 = 23;
pub const DC_MODEL: u32 = 24;
pub const DC_PERSONALITY: u32 = 25;
pub const DC_PRINTRATE: u32 = 26;
pub const DC_PRINTRATEUNIT: u32 = 27;
pub const PRINTRATEUNIT_PPM: u32 = 1;
pub const PRINTRATEUNIT_CPS: u32 = 2;
pub const PRINTRATEUNIT_LPM: u32 = 3;
pub const PRINTRATEUNIT_IPM: u32 = 4;
pub const DC_PRINTERMEM: u32 = 28;
pub const DC_MEDIAREADY: u32 = 29;
pub const DC_STAPLE: u32 = 30;
pub const DC_PRINTRATEPPM: u32 = 31;
pub const DC_COLORDEVICE: u32 = 32;
pub const DC_NUP: u32 = 33;
pub const DC_MEDIATYPENAMES: u32 = 34;
pub const DC_MEDIATYPES: u32 = 35;
pub const DCTT_BITMAP: u32 = 1;
pub const DCTT_DOWNLOAD: u32 = 2;
pub const DCTT_SUBDEV: u32 = 4;
pub const DCTT_DOWNLOAD_OUTLINE: u32 = 8;
pub const DCBA_FACEUPNONE: u32 = 0;
pub const DCBA_FACEUPCENTER: u32 = 1;
pub const DCBA_FACEUPLEFT: u32 = 2;
pub const DCBA_FACEUPRIGHT: u32 = 3;
pub const DCBA_FACEDOWNNONE: u32 = 256;
pub const DCBA_FACEDOWNCENTER: u32 = 257;
pub const DCBA_FACEDOWNLEFT: u32 = 258;
pub const DCBA_FACEDOWNRIGHT: u32 = 259;
pub const GS_8BIT_INDICES: u32 = 1;
pub const MM_MAX_NUMAXES: u32 = 16;
pub const FR_PRIVATE: u32 = 16;
pub const FR_NOT_ENUM: u32 = 32;
pub const MM_MAX_AXES_NAMELEN: u32 = 16;
pub const AC_SRC_OVER: u32 = 0;
pub const AC_SRC_ALPHA: u32 = 1;
pub const GRADIENT_FILL_RECT_H: u32 = 0;
pub const GRADIENT_FILL_RECT_V: u32 = 1;
pub const GRADIENT_FILL_TRIANGLE: u32 = 2;
pub const GRADIENT_FILL_OP_FLAG: u32 = 255;
pub const CA_NEGATIVE: u32 = 1;
pub const CA_LOG_FILTER: u32 = 2;
pub const ILLUMINANT_DEVICE_DEFAULT: u32 = 0;
pub const ILLUMINANT_A: u32 = 1;
pub const ILLUMINANT_B: u32 = 2;
pub const ILLUMINANT_C: u32 = 3;
pub const ILLUMINANT_D50: u32 = 4;
pub const ILLUMINANT_D55: u32 = 5;
pub const ILLUMINANT_D65: u32 = 6;
pub const ILLUMINANT_D75: u32 = 7;
pub const ILLUMINANT_F2: u32 = 8;
pub const ILLUMINANT_MAX_INDEX: u32 = 8;
pub const ILLUMINANT_TUNGSTEN: u32 = 1;
pub const ILLUMINANT_DAYLIGHT: u32 = 3;
pub const ILLUMINANT_FLUORESCENT: u32 = 8;
pub const ILLUMINANT_NTSC: u32 = 3;
pub const DI_APPBANDING: u32 = 1;
pub const DI_ROPS_READ_DESTINATION: u32 = 2;
pub const FONTMAPPER_MAX: u32 = 10;
pub const ICM_OFF: u32 = 1;
pub const ICM_ON: u32 = 2;
pub const ICM_QUERY: u32 = 3;
pub const ICM_DONE_OUTSIDEDC: u32 = 4;
pub const ENHMETA_SIGNATURE: u32 = 1179469088;
pub const ENHMETA_STOCK_OBJECT: u32 = 2147483648;
pub const EMR_HEADER: u32 = 1;
pub const EMR_POLYBEZIER: u32 = 2;
pub const EMR_POLYGON: u32 = 3;
pub const EMR_POLYLINE: u32 = 4;
pub const EMR_POLYBEZIERTO: u32 = 5;
pub const EMR_POLYLINETO: u32 = 6;
pub const EMR_POLYPOLYLINE: u32 = 7;
pub const EMR_POLYPOLYGON: u32 = 8;
pub const EMR_SETWINDOWEXTEX: u32 = 9;
pub const EMR_SETWINDOWORGEX: u32 = 10;
pub const EMR_SETVIEWPORTEXTEX: u32 = 11;
pub const EMR_SETVIEWPORTORGEX: u32 = 12;
pub const EMR_SETBRUSHORGEX: u32 = 13;
pub const EMR_EOF: u32 = 14;
pub const EMR_SETPIXELV: u32 = 15;
pub const EMR_SETMAPPERFLAGS: u32 = 16;
pub const EMR_SETMAPMODE: u32 = 17;
pub const EMR_SETBKMODE: u32 = 18;
pub const EMR_SETPOLYFILLMODE: u32 = 19;
pub const EMR_SETROP2: u32 = 20;
pub const EMR_SETSTRETCHBLTMODE: u32 = 21;
pub const EMR_SETTEXTALIGN: u32 = 22;
pub const EMR_SETCOLORADJUSTMENT: u32 = 23;
pub const EMR_SETTEXTCOLOR: u32 = 24;
pub const EMR_SETBKCOLOR: u32 = 25;
pub const EMR_OFFSETCLIPRGN: u32 = 26;
pub const EMR_MOVETOEX: u32 = 27;
pub const EMR_SETMETARGN: u32 = 28;
pub const EMR_EXCLUDECLIPRECT: u32 = 29;
pub const EMR_INTERSECTCLIPRECT: u32 = 30;
pub const EMR_SCALEVIEWPORTEXTEX: u32 = 31;
pub const EMR_SCALEWINDOWEXTEX: u32 = 32;
pub const EMR_SAVEDC: u32 = 33;
pub const EMR_RESTOREDC: u32 = 34;
pub const EMR_SETWORLDTRANSFORM: u32 = 35;
pub const EMR_MODIFYWORLDTRANSFORM: u32 = 36;
pub const EMR_SELECTOBJECT: u32 = 37;
pub const EMR_CREATEPEN: u32 = 38;
pub const EMR_CREATEBRUSHINDIRECT: u32 = 39;
pub const EMR_DELETEOBJECT: u32 = 40;
pub const EMR_ANGLEARC: u32 = 41;
pub const EMR_ELLIPSE: u32 = 42;
pub const EMR_RECTANGLE: u32 = 43;
pub const EMR_ROUNDRECT: u32 = 44;
pub const EMR_ARC: u32 = 45;
pub const EMR_CHORD: u32 = 46;
pub const EMR_PIE: u32 = 47;
pub const EMR_SELECTPALETTE: u32 = 48;
pub const EMR_CREATEPALETTE: u32 = 49;
pub const EMR_SETPALETTEENTRIES: u32 = 50;
pub const EMR_RESIZEPALETTE: u32 = 51;
pub const EMR_REALIZEPALETTE: u32 = 52;
pub const EMR_EXTFLOODFILL: u32 = 53;
pub const EMR_LINETO: u32 = 54;
pub const EMR_ARCTO: u32 = 55;
pub const EMR_POLYDRAW: u32 = 56;
pub const EMR_SETARCDIRECTION: u32 = 57;
pub const EMR_SETMITERLIMIT: u32 = 58;
pub const EMR_BEGINPATH: u32 = 59;
pub const EMR_ENDPATH: u32 = 60;
pub const EMR_CLOSEFIGURE: u32 = 61;
pub const EMR_FILLPATH: u32 = 62;
pub const EMR_STROKEANDFILLPATH: u32 = 63;
pub const EMR_STROKEPATH: u32 = 64;
pub const EMR_FLATTENPATH: u32 = 65;
pub const EMR_WIDENPATH: u32 = 66;
pub const EMR_SELECTCLIPPATH: u32 = 67;
pub const EMR_ABORTPATH: u32 = 68;
pub const EMR_GDICOMMENT: u32 = 70;
pub const EMR_FILLRGN: u32 = 71;
pub const EMR_FRAMERGN: u32 = 72;
pub const EMR_INVERTRGN: u32 = 73;
pub const EMR_PAINTRGN: u32 = 74;
pub const EMR_EXTSELECTCLIPRGN: u32 = 75;
pub const EMR_BITBLT: u32 = 76;
pub const EMR_STRETCHBLT: u32 = 77;
pub const EMR_MASKBLT: u32 = 78;
pub const EMR_PLGBLT: u32 = 79;
pub const EMR_SETDIBITSTODEVICE: u32 = 80;
pub const EMR_STRETCHDIBITS: u32 = 81;
pub const EMR_EXTCREATEFONTINDIRECTW: u32 = 82;
pub const EMR_EXTTEXTOUTA: u32 = 83;
pub const EMR_EXTTEXTOUTW: u32 = 84;
pub const EMR_POLYBEZIER16: u32 = 85;
pub const EMR_POLYGON16: u32 = 86;
pub const EMR_POLYLINE16: u32 = 87;
pub const EMR_POLYBEZIERTO16: u32 = 88;
pub const EMR_POLYLINETO16: u32 = 89;
pub const EMR_POLYPOLYLINE16: u32 = 90;
pub const EMR_POLYPOLYGON16: u32 = 91;
pub const EMR_POLYDRAW16: u32 = 92;
pub const EMR_CREATEMONOBRUSH: u32 = 93;
pub const EMR_CREATEDIBPATTERNBRUSHPT: u32 = 94;
pub const EMR_EXTCREATEPEN: u32 = 95;
pub const EMR_POLYTEXTOUTA: u32 = 96;
pub const EMR_POLYTEXTOUTW: u32 = 97;
pub const EMR_SETICMMODE: u32 = 98;
pub const EMR_CREATECOLORSPACE: u32 = 99;
pub const EMR_SETCOLORSPACE: u32 = 100;
pub const EMR_DELETECOLORSPACE: u32 = 101;
pub const EMR_GLSRECORD: u32 = 102;
pub const EMR_GLSBOUNDEDRECORD: u32 = 103;
pub const EMR_PIXELFORMAT: u32 = 104;
pub const EMR_RESERVED_105: u32 = 105;
pub const EMR_RESERVED_106: u32 = 106;
pub const EMR_RESERVED_107: u32 = 107;
pub const EMR_RESERVED_108: u32 = 108;
pub const EMR_RESERVED_109: u32 = 109;
pub const EMR_RESERVED_110: u32 = 110;
pub const EMR_COLORCORRECTPALETTE: u32 = 111;
pub const EMR_SETICMPROFILEA: u32 = 112;
pub const EMR_SETICMPROFILEW: u32 = 113;
pub const EMR_ALPHABLEND: u32 = 114;
pub const EMR_SETLAYOUT: u32 = 115;
pub const EMR_TRANSPARENTBLT: u32 = 116;
pub const EMR_RESERVED_117: u32 = 117;
pub const EMR_GRADIENTFILL: u32 = 118;
pub const EMR_RESERVED_119: u32 = 119;
pub const EMR_RESERVED_120: u32 = 120;
pub const EMR_COLORMATCHTOTARGETW: u32 = 121;
pub const EMR_CREATECOLORSPACEW: u32 = 122;
pub const EMR_MIN: u32 = 1;
pub const EMR_MAX: u32 = 122;
pub const SETICMPROFILE_EMBEDED: u32 = 1;
pub const CREATECOLORSPACE_EMBEDED: u32 = 1;
pub const COLORMATCHTOTARGET_EMBEDED: u32 = 1;
pub const GDICOMMENT_IDENTIFIER: u32 = 1128875079;
pub const GDICOMMENT_WINDOWS_METAFILE: u32 = 2147483649;
pub const GDICOMMENT_BEGINGROUP: u32 = 2;
pub const GDICOMMENT_ENDGROUP: u32 = 3;
pub const GDICOMMENT_MULTIFORMATS: u32 = 1073741828;
pub const EPS_SIGNATURE: u32 = 1179865157;
pub const GDICOMMENT_UNICODE_STRING: u32 = 64;
pub const GDICOMMENT_UNICODE_END: u32 = 128;
pub const WGL_FONT_LINES: u32 = 0;
pub const WGL_FONT_POLYGONS: u32 = 1;
pub const LPD_DOUBLEBUFFER: u32 = 1;
pub const LPD_STEREO: u32 = 2;
pub const LPD_SUPPORT_GDI: u32 = 16;
pub const LPD_SUPPORT_OPENGL: u32 = 32;
pub const LPD_SHARE_DEPTH: u32 = 64;
pub const LPD_SHARE_STENCIL: u32 = 128;
pub const LPD_SHARE_ACCUM: u32 = 256;
pub const LPD_SWAP_EXCHANGE: u32 = 512;
pub const LPD_SWAP_COPY: u32 = 1024;
pub const LPD_TRANSPARENT: u32 = 4096;
pub const LPD_TYPE_RGBA: u32 = 0;
pub const LPD_TYPE_COLORINDEX: u32 = 1;
pub const WGL_SWAP_MAIN_PLANE: u32 = 1;
pub const WGL_SWAP_OVERLAY1: u32 = 2;
pub const WGL_SWAP_OVERLAY2: u32 = 4;
pub const WGL_SWAP_OVERLAY3: u32 = 8;
pub const WGL_SWAP_OVERLAY4: u32 = 16;
pub const WGL_SWAP_OVERLAY5: u32 = 32;
pub const WGL_SWAP_OVERLAY6: u32 = 64;
pub const WGL_SWAP_OVERLAY7: u32 = 128;
pub const WGL_SWAP_OVERLAY8: u32 = 256;
pub const WGL_SWAP_OVERLAY9: u32 = 512;
pub const WGL_SWAP_OVERLAY10: u32 = 1024;
pub const WGL_SWAP_OVERLAY11: u32 = 2048;
pub const WGL_SWAP_OVERLAY12: u32 = 4096;
pub const WGL_SWAP_OVERLAY13: u32 = 8192;
pub const WGL_SWAP_OVERLAY14: u32 = 16384;
pub const WGL_SWAP_OVERLAY15: u32 = 32768;
pub const WGL_SWAP_UNDERLAY1: u32 = 65536;
pub const WGL_SWAP_UNDERLAY2: u32 = 131072;
pub const WGL_SWAP_UNDERLAY3: u32 = 262144;
pub const WGL_SWAP_UNDERLAY4: u32 = 524288;
pub const WGL_SWAP_UNDERLAY5: u32 = 1048576;
pub const WGL_SWAP_UNDERLAY6: u32 = 2097152;
pub const WGL_SWAP_UNDERLAY7: u32 = 4194304;
pub const WGL_SWAP_UNDERLAY8: u32 = 8388608;
pub const WGL_SWAP_UNDERLAY9: u32 = 16777216;
pub const WGL_SWAP_UNDERLAY10: u32 = 33554432;
pub const WGL_SWAP_UNDERLAY11: u32 = 67108864;
pub const WGL_SWAP_UNDERLAY12: u32 = 134217728;
pub const WGL_SWAP_UNDERLAY13: u32 = 268435456;
pub const WGL_SWAP_UNDERLAY14: u32 = 536870912;
pub const WGL_SWAP_UNDERLAY15: u32 = 1073741824;
pub const WGL_SWAPMULTIPLE_MAX: u32 = 16;
pub const DIFFERENCE: u32 = 11;
pub const SB_HORZ: u32 = 0;
pub const SB_VERT: u32 = 1;
pub const SB_CTL: u32 = 2;
pub const SB_BOTH: u32 = 3;
pub const SB_LINEUP: u32 = 0;
pub const SB_LINELEFT: u32 = 0;
pub const SB_LINEDOWN: u32 = 1;
pub const SB_LINERIGHT: u32 = 1;
pub const SB_PAGEUP: u32 = 2;
pub const SB_PAGELEFT: u32 = 2;
pub const SB_PAGEDOWN: u32 = 3;
pub const SB_PAGERIGHT: u32 = 3;
pub const SB_THUMBPOSITION: u32 = 4;
pub const SB_THUMBTRACK: u32 = 5;
pub const SB_TOP: u32 = 6;
pub const SB_LEFT: u32 = 6;
pub const SB_BOTTOM: u32 = 7;
pub const SB_RIGHT: u32 = 7;
pub const SB_ENDSCROLL: u32 = 8;
pub const SW_HIDE: u32 = 0;
pub const SW_SHOWNORMAL: u32 = 1;
pub const SW_NORMAL: u32 = 1;
pub const SW_SHOWMINIMIZED: u32 = 2;
pub const SW_SHOWMAXIMIZED: u32 = 3;
pub const SW_MAXIMIZE: u32 = 3;
pub const SW_SHOWNOACTIVATE: u32 = 4;
pub const SW_SHOW: u32 = 5;
pub const SW_MINIMIZE: u32 = 6;
pub const SW_SHOWMINNOACTIVE: u32 = 7;
pub const SW_SHOWNA: u32 = 8;
pub const SW_RESTORE: u32 = 9;
pub const SW_SHOWDEFAULT: u32 = 10;
pub const SW_FORCEMINIMIZE: u32 = 11;
pub const SW_MAX: u32 = 11;
pub const HIDE_WINDOW: u32 = 0;
pub const SHOW_OPENWINDOW: u32 = 1;
pub const SHOW_ICONWINDOW: u32 = 2;
pub const SHOW_FULLSCREEN: u32 = 3;
pub const SHOW_OPENNOACTIVATE: u32 = 4;
pub const SW_PARENTCLOSING: u32 = 1;
pub const SW_OTHERZOOM: u32 = 2;
pub const SW_PARENTOPENING: u32 = 3;
pub const SW_OTHERUNZOOM: u32 = 4;
pub const AW_HOR_POSITIVE: u32 = 1;
pub const AW_HOR_NEGATIVE: u32 = 2;
pub const AW_VER_POSITIVE: u32 = 4;
pub const AW_VER_NEGATIVE: u32 = 8;
pub const AW_CENTER: u32 = 16;
pub const AW_HIDE: u32 = 65536;
pub const AW_ACTIVATE: u32 = 131072;
pub const AW_SLIDE: u32 = 262144;
pub const AW_BLEND: u32 = 524288;
pub const KF_EXTENDED: u32 = 256;
pub const KF_DLGMODE: u32 = 2048;
pub const KF_MENUMODE: u32 = 4096;
pub const KF_ALTDOWN: u32 = 8192;
pub const KF_REPEAT: u32 = 16384;
pub const KF_UP: u32 = 32768;
pub const VK_LBUTTON: u32 = 1;
pub const VK_RBUTTON: u32 = 2;
pub const VK_CANCEL: u32 = 3;
pub const VK_MBUTTON: u32 = 4;
pub const VK_XBUTTON1: u32 = 5;
pub const VK_XBUTTON2: u32 = 6;
pub const VK_BACK: u32 = 8;
pub const VK_TAB: u32 = 9;
pub const VK_CLEAR: u32 = 12;
pub const VK_RETURN: u32 = 13;
pub const VK_SHIFT: u32 = 16;
pub const VK_CONTROL: u32 = 17;
pub const VK_MENU: u32 = 18;
pub const VK_PAUSE: u32 = 19;
pub const VK_CAPITAL: u32 = 20;
pub const VK_KANA: u32 = 21;
pub const VK_HANGEUL: u32 = 21;
pub const VK_HANGUL: u32 = 21;
pub const VK_JUNJA: u32 = 23;
pub const VK_FINAL: u32 = 24;
pub const VK_HANJA: u32 = 25;
pub const VK_KANJI: u32 = 25;
pub const VK_ESCAPE: u32 = 27;
pub const VK_CONVERT: u32 = 28;
pub const VK_NONCONVERT: u32 = 29;
pub const VK_ACCEPT: u32 = 30;
pub const VK_MODECHANGE: u32 = 31;
pub const VK_SPACE: u32 = 32;
pub const VK_PRIOR: u32 = 33;
pub const VK_NEXT: u32 = 34;
pub const VK_END: u32 = 35;
pub const VK_HOME: u32 = 36;
pub const VK_LEFT: u32 = 37;
pub const VK_UP: u32 = 38;
pub const VK_RIGHT: u32 = 39;
pub const VK_DOWN: u32 = 40;
pub const VK_SELECT: u32 = 41;
pub const VK_PRINT: u32 = 42;
pub const VK_EXECUTE: u32 = 43;
pub const VK_SNAPSHOT: u32 = 44;
pub const VK_INSERT: u32 = 45;
pub const VK_DELETE: u32 = 46;
pub const VK_HELP: u32 = 47;
pub const VK_LWIN: u32 = 91;
pub const VK_RWIN: u32 = 92;
pub const VK_APPS: u32 = 93;
pub const VK_SLEEP: u32 = 95;
pub const VK_NUMPAD0: u32 = 96;
pub const VK_NUMPAD1: u32 = 97;
pub const VK_NUMPAD2: u32 = 98;
pub const VK_NUMPAD3: u32 = 99;
pub const VK_NUMPAD4: u32 = 100;
pub const VK_NUMPAD5: u32 = 101;
pub const VK_NUMPAD6: u32 = 102;
pub const VK_NUMPAD7: u32 = 103;
pub const VK_NUMPAD8: u32 = 104;
pub const VK_NUMPAD9: u32 = 105;
pub const VK_MULTIPLY: u32 = 106;
pub const VK_ADD: u32 = 107;
pub const VK_SEPARATOR: u32 = 108;
pub const VK_SUBTRACT: u32 = 109;
pub const VK_DECIMAL: u32 = 110;
pub const VK_DIVIDE: u32 = 111;
pub const VK_F1: u32 = 112;
pub const VK_F2: u32 = 113;
pub const VK_F3: u32 = 114;
pub const VK_F4: u32 = 115;
pub const VK_F5: u32 = 116;
pub const VK_F6: u32 = 117;
pub const VK_F7: u32 = 118;
pub const VK_F8: u32 = 119;
pub const VK_F9: u32 = 120;
pub const VK_F10: u32 = 121;
pub const VK_F11: u32 = 122;
pub const VK_F12: u32 = 123;
pub const VK_F13: u32 = 124;
pub const VK_F14: u32 = 125;
pub const VK_F15: u32 = 126;
pub const VK_F16: u32 = 127;
pub const VK_F17: u32 = 128;
pub const VK_F18: u32 = 129;
pub const VK_F19: u32 = 130;
pub const VK_F20: u32 = 131;
pub const VK_F21: u32 = 132;
pub const VK_F22: u32 = 133;
pub const VK_F23: u32 = 134;
pub const VK_F24: u32 = 135;
pub const VK_NAVIGATION_VIEW: u32 = 136;
pub const VK_NAVIGATION_MENU: u32 = 137;
pub const VK_NAVIGATION_UP: u32 = 138;
pub const VK_NAVIGATION_DOWN: u32 = 139;
pub const VK_NAVIGATION_LEFT: u32 = 140;
pub const VK_NAVIGATION_RIGHT: u32 = 141;
pub const VK_NAVIGATION_ACCEPT: u32 = 142;
pub const VK_NAVIGATION_CANCEL: u32 = 143;
pub const VK_NUMLOCK: u32 = 144;
pub const VK_SCROLL: u32 = 145;
pub const VK_OEM_NEC_EQUAL: u32 = 146;
pub const VK_OEM_FJ_JISHO: u32 = 146;
pub const VK_OEM_FJ_MASSHOU: u32 = 147;
pub const VK_OEM_FJ_TOUROKU: u32 = 148;
pub const VK_OEM_FJ_LOYA: u32 = 149;
pub const VK_OEM_FJ_ROYA: u32 = 150;
pub const VK_LSHIFT: u32 = 160;
pub const VK_RSHIFT: u32 = 161;
pub const VK_LCONTROL: u32 = 162;
pub const VK_RCONTROL: u32 = 163;
pub const VK_LMENU: u32 = 164;
pub const VK_RMENU: u32 = 165;
pub const VK_BROWSER_BACK: u32 = 166;
pub const VK_BROWSER_FORWARD: u32 = 167;
pub const VK_BROWSER_REFRESH: u32 = 168;
pub const VK_BROWSER_STOP: u32 = 169;
pub const VK_BROWSER_SEARCH: u32 = 170;
pub const VK_BROWSER_FAVORITES: u32 = 171;
pub const VK_BROWSER_HOME: u32 = 172;
pub const VK_VOLUME_MUTE: u32 = 173;
pub const VK_VOLUME_DOWN: u32 = 174;
pub const VK_VOLUME_UP: u32 = 175;
pub const VK_MEDIA_NEXT_TRACK: u32 = 176;
pub const VK_MEDIA_PREV_TRACK: u32 = 177;
pub const VK_MEDIA_STOP: u32 = 178;
pub const VK_MEDIA_PLAY_PAUSE: u32 = 179;
pub const VK_LAUNCH_MAIL: u32 = 180;
pub const VK_LAUNCH_MEDIA_SELECT: u32 = 181;
pub const VK_LAUNCH_APP1: u32 = 182;
pub const VK_LAUNCH_APP2: u32 = 183;
pub const VK_OEM_1: u32 = 186;
pub const VK_OEM_PLUS: u32 = 187;
pub const VK_OEM_COMMA: u32 = 188;
pub const VK_OEM_MINUS: u32 = 189;
pub const VK_OEM_PERIOD: u32 = 190;
pub const VK_OEM_2: u32 = 191;
pub const VK_OEM_3: u32 = 192;
pub const VK_GAMEPAD_A: u32 = 195;
pub const VK_GAMEPAD_B: u32 = 196;
pub const VK_GAMEPAD_X: u32 = 197;
pub const VK_GAMEPAD_Y: u32 = 198;
pub const VK_GAMEPAD_RIGHT_SHOULDER: u32 = 199;
pub const VK_GAMEPAD_LEFT_SHOULDER: u32 = 200;
pub const VK_GAMEPAD_LEFT_TRIGGER: u32 = 201;
pub const VK_GAMEPAD_RIGHT_TRIGGER: u32 = 202;
pub const VK_GAMEPAD_DPAD_UP: u32 = 203;
pub const VK_GAMEPAD_DPAD_DOWN: u32 = 204;
pub const VK_GAMEPAD_DPAD_LEFT: u32 = 205;
pub const VK_GAMEPAD_DPAD_RIGHT: u32 = 206;
pub const VK_GAMEPAD_MENU: u32 = 207;
pub const VK_GAMEPAD_VIEW: u32 = 208;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON: u32 = 209;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON: u32 = 210;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_UP: u32 = 211;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_DOWN: u32 = 212;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT: u32 = 213;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_LEFT: u32 = 214;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_UP: u32 = 215;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN: u32 = 216;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT: u32 = 217;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT: u32 = 218;
pub const VK_OEM_4: u32 = 219;
pub const VK_OEM_5: u32 = 220;
pub const VK_OEM_6: u32 = 221;
pub const VK_OEM_7: u32 = 222;
pub const VK_OEM_8: u32 = 223;
pub const VK_OEM_AX: u32 = 225;
pub const VK_OEM_102: u32 = 226;
pub const VK_ICO_HELP: u32 = 227;
pub const VK_ICO_00: u32 = 228;
pub const VK_PROCESSKEY: u32 = 229;
pub const VK_ICO_CLEAR: u32 = 230;
pub const VK_PACKET: u32 = 231;
pub const VK_OEM_RESET: u32 = 233;
pub const VK_OEM_JUMP: u32 = 234;
pub const VK_OEM_PA1: u32 = 235;
pub const VK_OEM_PA2: u32 = 236;
pub const VK_OEM_PA3: u32 = 237;
pub const VK_OEM_WSCTRL: u32 = 238;
pub const VK_OEM_CUSEL: u32 = 239;
pub const VK_OEM_ATTN: u32 = 240;
pub const VK_OEM_FINISH: u32 = 241;
pub const VK_OEM_COPY: u32 = 242;
pub const VK_OEM_AUTO: u32 = 243;
pub const VK_OEM_ENLW: u32 = 244;
pub const VK_OEM_BACKTAB: u32 = 245;
pub const VK_ATTN: u32 = 246;
pub const VK_CRSEL: u32 = 247;
pub const VK_EXSEL: u32 = 248;
pub const VK_EREOF: u32 = 249;
pub const VK_PLAY: u32 = 250;
pub const VK_ZOOM: u32 = 251;
pub const VK_NONAME: u32 = 252;
pub const VK_PA1: u32 = 253;
pub const VK_OEM_CLEAR: u32 = 254;
pub const WH_MIN: i32 = -1;
pub const WH_MSGFILTER: i32 = -1;
pub const WH_JOURNALRECORD: u32 = 0;
pub const WH_JOURNALPLAYBACK: u32 = 1;
pub const WH_KEYBOARD: u32 = 2;
pub const WH_GETMESSAGE: u32 = 3;
pub const WH_CALLWNDPROC: u32 = 4;
pub const WH_CBT: u32 = 5;
pub const WH_SYSMSGFILTER: u32 = 6;
pub const WH_MOUSE: u32 = 7;
pub const WH_DEBUG: u32 = 9;
pub const WH_SHELL: u32 = 10;
pub const WH_FOREGROUNDIDLE: u32 = 11;
pub const WH_CALLWNDPROCRET: u32 = 12;
pub const WH_KEYBOARD_LL: u32 = 13;
pub const WH_MOUSE_LL: u32 = 14;
pub const WH_MAX: u32 = 14;
pub const WH_MINHOOK: i32 = -1;
pub const WH_MAXHOOK: u32 = 14;
pub const HC_ACTION: u32 = 0;
pub const HC_GETNEXT: u32 = 1;
pub const HC_SKIP: u32 = 2;
pub const HC_NOREMOVE: u32 = 3;
pub const HC_NOREM: u32 = 3;
pub const HC_SYSMODALON: u32 = 4;
pub const HC_SYSMODALOFF: u32 = 5;
pub const HCBT_MOVESIZE: u32 = 0;
pub const HCBT_MINMAX: u32 = 1;
pub const HCBT_QS: u32 = 2;
pub const HCBT_CREATEWND: u32 = 3;
pub const HCBT_DESTROYWND: u32 = 4;
pub const HCBT_ACTIVATE: u32 = 5;
pub const HCBT_CLICKSKIPPED: u32 = 6;
pub const HCBT_KEYSKIPPED: u32 = 7;
pub const HCBT_SYSCOMMAND: u32 = 8;
pub const HCBT_SETFOCUS: u32 = 9;
pub const WTS_CONSOLE_CONNECT: u32 = 1;
pub const WTS_CONSOLE_DISCONNECT: u32 = 2;
pub const WTS_REMOTE_CONNECT: u32 = 3;
pub const WTS_REMOTE_DISCONNECT: u32 = 4;
pub const WTS_SESSION_LOGON: u32 = 5;
pub const WTS_SESSION_LOGOFF: u32 = 6;
pub const WTS_SESSION_LOCK: u32 = 7;
pub const WTS_SESSION_UNLOCK: u32 = 8;
pub const WTS_SESSION_REMOTE_CONTROL: u32 = 9;
pub const WTS_SESSION_CREATE: u32 = 10;
pub const WTS_SESSION_TERMINATE: u32 = 11;
pub const MSGF_DIALOGBOX: u32 = 0;
pub const MSGF_MESSAGEBOX: u32 = 1;
pub const MSGF_MENU: u32 = 2;
pub const MSGF_SCROLLBAR: u32 = 5;
pub const MSGF_NEXTWINDOW: u32 = 6;
pub const MSGF_MAX: u32 = 8;
pub const MSGF_USER: u32 = 4096;
pub const HSHELL_WINDOWCREATED: u32 = 1;
pub const HSHELL_WINDOWDESTROYED: u32 = 2;
pub const HSHELL_ACTIVATESHELLWINDOW: u32 = 3;
pub const HSHELL_WINDOWACTIVATED: u32 = 4;
pub const HSHELL_GETMINRECT: u32 = 5;
pub const HSHELL_REDRAW: u32 = 6;
pub const HSHELL_TASKMAN: u32 = 7;
pub const HSHELL_LANGUAGE: u32 = 8;
pub const HSHELL_SYSMENU: u32 = 9;
pub const HSHELL_ENDTASK: u32 = 10;
pub const HSHELL_ACCESSIBILITYSTATE: u32 = 11;
pub const HSHELL_APPCOMMAND: u32 = 12;
pub const HSHELL_WINDOWREPLACED: u32 = 13;
pub const HSHELL_WINDOWREPLACING: u32 = 14;
pub const HSHELL_MONITORCHANGED: u32 = 16;
pub const HSHELL_HIGHBIT: u32 = 32768;
pub const HSHELL_FLASH: u32 = 32774;
pub const HSHELL_RUDEAPPACTIVATED: u32 = 32772;
pub const APPCOMMAND_BROWSER_BACKWARD: u32 = 1;
pub const APPCOMMAND_BROWSER_FORWARD: u32 = 2;
pub const APPCOMMAND_BROWSER_REFRESH: u32 = 3;
pub const APPCOMMAND_BROWSER_STOP: u32 = 4;
pub const APPCOMMAND_BROWSER_SEARCH: u32 = 5;
pub const APPCOMMAND_BROWSER_FAVORITES: u32 = 6;
pub const APPCOMMAND_BROWSER_HOME: u32 = 7;
pub const APPCOMMAND_VOLUME_MUTE: u32 = 8;
pub const APPCOMMAND_VOLUME_DOWN: u32 = 9;
pub const APPCOMMAND_VOLUME_UP: u32 = 10;
pub const APPCOMMAND_MEDIA_NEXTTRACK: u32 = 11;
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK: u32 = 12;
pub const APPCOMMAND_MEDIA_STOP: u32 = 13;
pub const APPCOMMAND_MEDIA_PLAY_PAUSE: u32 = 14;
pub const APPCOMMAND_LAUNCH_MAIL: u32 = 15;
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT: u32 = 16;
pub const APPCOMMAND_LAUNCH_APP1: u32 = 17;
pub const APPCOMMAND_LAUNCH_APP2: u32 = 18;
pub const APPCOMMAND_BASS_DOWN: u32 = 19;
pub const APPCOMMAND_BASS_BOOST: u32 = 20;
pub const APPCOMMAND_BASS_UP: u32 = 21;
pub const APPCOMMAND_TREBLE_DOWN: u32 = 22;
pub const APPCOMMAND_TREBLE_UP: u32 = 23;
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE: u32 = 24;
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN: u32 = 25;
pub const APPCOMMAND_MICROPHONE_VOLUME_UP: u32 = 26;
pub const APPCOMMAND_HELP: u32 = 27;
pub const APPCOMMAND_FIND: u32 = 28;
pub const APPCOMMAND_NEW: u32 = 29;
pub const APPCOMMAND_OPEN: u32 = 30;
pub const APPCOMMAND_CLOSE: u32 = 31;
pub const APPCOMMAND_SAVE: u32 = 32;
pub const APPCOMMAND_PRINT: u32 = 33;
pub const APPCOMMAND_UNDO: u32 = 34;
pub const APPCOMMAND_REDO: u32 = 35;
pub const APPCOMMAND_COPY: u32 = 36;
pub const APPCOMMAND_CUT: u32 = 37;
pub const APPCOMMAND_PASTE: u32 = 38;
pub const APPCOMMAND_REPLY_TO_MAIL: u32 = 39;
pub const APPCOMMAND_FORWARD_MAIL: u32 = 40;
pub const APPCOMMAND_SEND_MAIL: u32 = 41;
pub const APPCOMMAND_SPELL_CHECK: u32 = 42;
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE: u32 = 43;
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE: u32 = 44;
pub const APPCOMMAND_CORRECTION_LIST: u32 = 45;
pub const APPCOMMAND_MEDIA_PLAY: u32 = 46;
pub const APPCOMMAND_MEDIA_PAUSE: u32 = 47;
pub const APPCOMMAND_MEDIA_RECORD: u32 = 48;
pub const APPCOMMAND_MEDIA_FAST_FORWARD: u32 = 49;
pub const APPCOMMAND_MEDIA_REWIND: u32 = 50;
pub const APPCOMMAND_MEDIA_CHANNEL_UP: u32 = 51;
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN: u32 = 52;
pub const APPCOMMAND_DELETE: u32 = 53;
pub const APPCOMMAND_DWM_FLIP3D: u32 = 54;
pub const FAPPCOMMAND_MOUSE: u32 = 32768;
pub const FAPPCOMMAND_KEY: u32 = 0;
pub const FAPPCOMMAND_OEM: u32 = 4096;
pub const FAPPCOMMAND_MASK: u32 = 61440;
pub const LLKHF_EXTENDED: u32 = 1;
pub const LLKHF_INJECTED: u32 = 16;
pub const LLKHF_ALTDOWN: u32 = 32;
pub const LLKHF_UP: u32 = 128;
pub const LLKHF_LOWER_IL_INJECTED: u32 = 2;
pub const LLMHF_INJECTED: u32 = 1;
pub const LLMHF_LOWER_IL_INJECTED: u32 = 2;
pub const HKL_PREV: u32 = 0;
pub const HKL_NEXT: u32 = 1;
pub const KLF_ACTIVATE: u32 = 1;
pub const KLF_SUBSTITUTE_OK: u32 = 2;
pub const KLF_REORDER: u32 = 8;
pub const KLF_REPLACELANG: u32 = 16;
pub const KLF_NOTELLSHELL: u32 = 128;
pub const KLF_SETFORPROCESS: u32 = 256;
pub const KLF_SHIFTLOCK: u32 = 65536;
pub const KLF_RESET: u32 = 1073741824;
pub const INPUTLANGCHANGE_SYSCHARSET: u32 = 1;
pub const INPUTLANGCHANGE_FORWARD: u32 = 2;
pub const INPUTLANGCHANGE_BACKWARD: u32 = 4;
pub const KL_NAMELENGTH: u32 = 9;
pub const GMMP_USE_DISPLAY_POINTS: u32 = 1;
pub const GMMP_USE_HIGH_RESOLUTION_POINTS: u32 = 2;
pub const DESKTOP_READOBJECTS: u32 = 1;
pub const DESKTOP_CREATEWINDOW: u32 = 2;
pub const DESKTOP_CREATEMENU: u32 = 4;
pub const DESKTOP_HOOKCONTROL: u32 = 8;
pub const DESKTOP_JOURNALRECORD: u32 = 16;
pub const DESKTOP_JOURNALPLAYBACK: u32 = 32;
pub const DESKTOP_ENUMERATE: u32 = 64;
pub const DESKTOP_WRITEOBJECTS: u32 = 128;
pub const DESKTOP_SWITCHDESKTOP: u32 = 256;
pub const DF_ALLOWOTHERACCOUNTHOOK: u32 = 1;
pub const WINSTA_ENUMDESKTOPS: u32 = 1;
pub const WINSTA_READATTRIBUTES: u32 = 2;
pub const WINSTA_ACCESSCLIPBOARD: u32 = 4;
pub const WINSTA_CREATEDESKTOP: u32 = 8;
pub const WINSTA_WRITEATTRIBUTES: u32 = 16;
pub const WINSTA_ACCESSGLOBALATOMS: u32 = 32;
pub const WINSTA_EXITWINDOWS: u32 = 64;
pub const WINSTA_ENUMERATE: u32 = 256;
pub const WINSTA_READSCREEN: u32 = 512;
pub const WINSTA_ALL_ACCESS: u32 = 895;
pub const CWF_CREATE_ONLY: u32 = 1;
pub const WSF_VISIBLE: u32 = 1;
pub const UOI_FLAGS: u32 = 1;
pub const UOI_NAME: u32 = 2;
pub const UOI_TYPE: u32 = 3;
pub const UOI_USER_SID: u32 = 4;
pub const UOI_HEAPSIZE: u32 = 5;
pub const UOI_IO: u32 = 6;
pub const UOI_TIMERPROC_EXCEPTION_SUPPRESSION: u32 = 7;
pub const GWL_WNDPROC: i32 = -4;
pub const GWL_HINSTANCE: i32 = -6;
pub const GWL_HWNDPARENT: i32 = -8;
pub const GWL_STYLE: i32 = -16;
pub const GWL_EXSTYLE: i32 = -20;
pub const GWL_USERDATA: i32 = -21;
pub const GWL_ID: i32 = -12;
pub const GWLP_WNDPROC: i32 = -4;
pub const GWLP_HINSTANCE: i32 = -6;
pub const GWLP_HWNDPARENT: i32 = -8;
pub const GWLP_USERDATA: i32 = -21;
pub const GWLP_ID: i32 = -12;
pub const GCL_MENUNAME: i32 = -8;
pub const GCL_HBRBACKGROUND: i32 = -10;
pub const GCL_HCURSOR: i32 = -12;
pub const GCL_HICON: i32 = -14;
pub const GCL_HMODULE: i32 = -16;
pub const GCL_CBWNDEXTRA: i32 = -18;
pub const GCL_CBCLSEXTRA: i32 = -20;
pub const GCL_WNDPROC: i32 = -24;
pub const GCL_STYLE: i32 = -26;
pub const GCW_ATOM: i32 = -32;
pub const GCL_HICONSM: i32 = -34;
pub const GCLP_MENUNAME: i32 = -8;
pub const GCLP_HBRBACKGROUND: i32 = -10;
pub const GCLP_HCURSOR: i32 = -12;
pub const GCLP_HICON: i32 = -14;
pub const GCLP_HMODULE: i32 = -16;
pub const GCLP_WNDPROC: i32 = -24;
pub const GCLP_HICONSM: i32 = -34;
pub const WM_NULL: u32 = 0;
pub const WM_CREATE: u32 = 1;
pub const WM_DESTROY: u32 = 2;
pub const WM_MOVE: u32 = 3;
pub const WM_SIZE: u32 = 5;
pub const WM_ACTIVATE: u32 = 6;
pub const WA_INACTIVE: u32 = 0;
pub const WA_ACTIVE: u32 = 1;
pub const WA_CLICKACTIVE: u32 = 2;
pub const WM_SETFOCUS: u32 = 7;
pub const WM_KILLFOCUS: u32 = 8;
pub const WM_ENABLE: u32 = 10;
pub const WM_SETREDRAW: u32 = 11;
pub const WM_SETTEXT: u32 = 12;
pub const WM_GETTEXT: u32 = 13;
pub const WM_GETTEXTLENGTH: u32 = 14;
pub const WM_PAINT: u32 = 15;
pub const WM_CLOSE: u32 = 16;
pub const WM_QUERYENDSESSION: u32 = 17;
pub const WM_QUERYOPEN: u32 = 19;
pub const WM_ENDSESSION: u32 = 22;
pub const WM_QUIT: u32 = 18;
pub const WM_ERASEBKGND: u32 = 20;
pub const WM_SYSCOLORCHANGE: u32 = 21;
pub const WM_SHOWWINDOW: u32 = 24;
pub const WM_WININICHANGE: u32 = 26;
pub const WM_SETTINGCHANGE: u32 = 26;
pub const WM_DEVMODECHANGE: u32 = 27;
pub const WM_ACTIVATEAPP: u32 = 28;
pub const WM_FONTCHANGE: u32 = 29;
pub const WM_TIMECHANGE: u32 = 30;
pub const WM_CANCELMODE: u32 = 31;
pub const WM_SETCURSOR: u32 = 32;
pub const WM_MOUSEACTIVATE: u32 = 33;
pub const WM_CHILDACTIVATE: u32 = 34;
pub const WM_QUEUESYNC: u32 = 35;
pub const WM_GETMINMAXINFO: u32 = 36;
pub const WM_PAINTICON: u32 = 38;
pub const WM_ICONERASEBKGND: u32 = 39;
pub const WM_NEXTDLGCTL: u32 = 40;
pub const WM_SPOOLERSTATUS: u32 = 42;
pub const WM_DRAWITEM: u32 = 43;
pub const WM_MEASUREITEM: u32 = 44;
pub const WM_DELETEITEM: u32 = 45;
pub const WM_VKEYTOITEM: u32 = 46;
pub const WM_CHARTOITEM: u32 = 47;
pub const WM_SETFONT: u32 = 48;
pub const WM_GETFONT: u32 = 49;
pub const WM_SETHOTKEY: u32 = 50;
pub const WM_GETHOTKEY: u32 = 51;
pub const WM_QUERYDRAGICON: u32 = 55;
pub const WM_COMPAREITEM: u32 = 57;
pub const WM_GETOBJECT: u32 = 61;
pub const WM_COMPACTING: u32 = 65;
pub const WM_COMMNOTIFY: u32 = 68;
pub const WM_WINDOWPOSCHANGING: u32 = 70;
pub const WM_WINDOWPOSCHANGED: u32 = 71;
pub const WM_POWER: u32 = 72;
pub const PWR_OK: u32 = 1;
pub const PWR_FAIL: i32 = -1;
pub const PWR_SUSPENDREQUEST: u32 = 1;
pub const PWR_SUSPENDRESUME: u32 = 2;
pub const PWR_CRITICALRESUME: u32 = 3;
pub const WM_COPYDATA: u32 = 74;
pub const WM_CANCELJOURNAL: u32 = 75;
pub const WM_NOTIFY: u32 = 78;
pub const WM_INPUTLANGCHANGEREQUEST: u32 = 80;
pub const WM_INPUTLANGCHANGE: u32 = 81;
pub const WM_TCARD: u32 = 82;
pub const WM_HELP: u32 = 83;
pub const WM_USERCHANGED: u32 = 84;
pub const WM_NOTIFYFORMAT: u32 = 85;
pub const NFR_ANSI: u32 = 1;
pub const NFR_UNICODE: u32 = 2;
pub const NF_QUERY: u32 = 3;
pub const NF_REQUERY: u32 = 4;
pub const WM_CONTEXTMENU: u32 = 123;
pub const WM_STYLECHANGING: u32 = 124;
pub const WM_STYLECHANGED: u32 = 125;
pub const WM_DISPLAYCHANGE: u32 = 126;
pub const WM_GETICON: u32 = 127;
pub const WM_SETICON: u32 = 128;
pub const WM_NCCREATE: u32 = 129;
pub const WM_NCDESTROY: u32 = 130;
pub const WM_NCCALCSIZE: u32 = 131;
pub const WM_NCHITTEST: u32 = 132;
pub const WM_NCPAINT: u32 = 133;
pub const WM_NCACTIVATE: u32 = 134;
pub const WM_GETDLGCODE: u32 = 135;
pub const WM_SYNCPAINT: u32 = 136;
pub const WM_NCMOUSEMOVE: u32 = 160;
pub const WM_NCLBUTTONDOWN: u32 = 161;
pub const WM_NCLBUTTONUP: u32 = 162;
pub const WM_NCLBUTTONDBLCLK: u32 = 163;
pub const WM_NCRBUTTONDOWN: u32 = 164;
pub const WM_NCRBUTTONUP: u32 = 165;
pub const WM_NCRBUTTONDBLCLK: u32 = 166;
pub const WM_NCMBUTTONDOWN: u32 = 167;
pub const WM_NCMBUTTONUP: u32 = 168;
pub const WM_NCMBUTTONDBLCLK: u32 = 169;
pub const WM_NCXBUTTONDOWN: u32 = 171;
pub const WM_NCXBUTTONUP: u32 = 172;
pub const WM_NCXBUTTONDBLCLK: u32 = 173;
pub const WM_INPUT_DEVICE_CHANGE: u32 = 254;
pub const WM_INPUT: u32 = 255;
pub const WM_KEYFIRST: u32 = 256;
pub const WM_KEYDOWN: u32 = 256;
pub const WM_KEYUP: u32 = 257;
pub const WM_CHAR: u32 = 258;
pub const WM_DEADCHAR: u32 = 259;
pub const WM_SYSKEYDOWN: u32 = 260;
pub const WM_SYSKEYUP: u32 = 261;
pub const WM_SYSCHAR: u32 = 262;
pub const WM_SYSDEADCHAR: u32 = 263;
pub const WM_UNICHAR: u32 = 265;
pub const WM_KEYLAST: u32 = 265;
pub const UNICODE_NOCHAR: u32 = 65535;
pub const WM_IME_STARTCOMPOSITION: u32 = 269;
pub const WM_IME_ENDCOMPOSITION: u32 = 270;
pub const WM_IME_COMPOSITION: u32 = 271;
pub const WM_IME_KEYLAST: u32 = 271;
pub const WM_INITDIALOG: u32 = 272;
pub const WM_COMMAND: u32 = 273;
pub const WM_SYSCOMMAND: u32 = 274;
pub const WM_TIMER: u32 = 275;
pub const WM_HSCROLL: u32 = 276;
pub const WM_VSCROLL: u32 = 277;
pub const WM_INITMENU: u32 = 278;
pub const WM_INITMENUPOPUP: u32 = 279;
pub const WM_GESTURE: u32 = 281;
pub const WM_GESTURENOTIFY: u32 = 282;
pub const WM_MENUSELECT: u32 = 287;
pub const WM_MENUCHAR: u32 = 288;
pub const WM_ENTERIDLE: u32 = 289;
pub const WM_MENURBUTTONUP: u32 = 290;
pub const WM_MENUDRAG: u32 = 291;
pub const WM_MENUGETOBJECT: u32 = 292;
pub const WM_UNINITMENUPOPUP: u32 = 293;
pub const WM_MENUCOMMAND: u32 = 294;
pub const WM_CHANGEUISTATE: u32 = 295;
pub const WM_UPDATEUISTATE: u32 = 296;
pub const WM_QUERYUISTATE: u32 = 297;
pub const UIS_SET: u32 = 1;
pub const UIS_CLEAR: u32 = 2;
pub const UIS_INITIALIZE: u32 = 3;
pub const UISF_HIDEFOCUS: u32 = 1;
pub const UISF_HIDEACCEL: u32 = 2;
pub const UISF_ACTIVE: u32 = 4;
pub const WM_CTLCOLORMSGBOX: u32 = 306;
pub const WM_CTLCOLOREDIT: u32 = 307;
pub const WM_CTLCOLORLISTBOX: u32 = 308;
pub const WM_CTLCOLORBTN: u32 = 309;
pub const WM_CTLCOLORDLG: u32 = 310;
pub const WM_CTLCOLORSCROLLBAR: u32 = 311;
pub const WM_CTLCOLORSTATIC: u32 = 312;
pub const MN_GETHMENU: u32 = 481;
pub const WM_MOUSEFIRST: u32 = 512;
pub const WM_MOUSEMOVE: u32 = 512;
pub const WM_LBUTTONDOWN: u32 = 513;
pub const WM_LBUTTONUP: u32 = 514;
pub const WM_LBUTTONDBLCLK: u32 = 515;
pub const WM_RBUTTONDOWN: u32 = 516;
pub const WM_RBUTTONUP: u32 = 517;
pub const WM_RBUTTONDBLCLK: u32 = 518;
pub const WM_MBUTTONDOWN: u32 = 519;
pub const WM_MBUTTONUP: u32 = 520;
pub const WM_MBUTTONDBLCLK: u32 = 521;
pub const WM_MOUSEWHEEL: u32 = 522;
pub const WM_XBUTTONDOWN: u32 = 523;
pub const WM_XBUTTONUP: u32 = 524;
pub const WM_XBUTTONDBLCLK: u32 = 525;
pub const WM_MOUSEHWHEEL: u32 = 526;
pub const WM_MOUSELAST: u32 = 526;
pub const WHEEL_DELTA: u32 = 120;
pub const XBUTTON1: u32 = 1;
pub const XBUTTON2: u32 = 2;
pub const WM_PARENTNOTIFY: u32 = 528;
pub const WM_ENTERMENULOOP: u32 = 529;
pub const WM_EXITMENULOOP: u32 = 530;
pub const WM_NEXTMENU: u32 = 531;
pub const WM_SIZING: u32 = 532;
pub const WM_CAPTURECHANGED: u32 = 533;
pub const WM_MOVING: u32 = 534;
pub const WM_POWERBROADCAST: u32 = 536;
pub const PBT_APMQUERYSUSPEND: u32 = 0;
pub const PBT_APMQUERYSTANDBY: u32 = 1;
pub const PBT_APMQUERYSUSPENDFAILED: u32 = 2;
pub const PBT_APMQUERYSTANDBYFAILED: u32 = 3;
pub const PBT_APMSUSPEND: u32 = 4;
pub const PBT_APMSTANDBY: u32 = 5;
pub const PBT_APMRESUMECRITICAL: u32 = 6;
pub const PBT_APMRESUMESUSPEND: u32 = 7;
pub const PBT_APMRESUMESTANDBY: u32 = 8;
pub const PBTF_APMRESUMEFROMFAILURE: u32 = 1;
pub const PBT_APMBATTERYLOW: u32 = 9;
pub const PBT_APMPOWERSTATUSCHANGE: u32 = 10;
pub const PBT_APMOEMEVENT: u32 = 11;
pub const PBT_APMRESUMEAUTOMATIC: u32 = 18;
pub const PBT_POWERSETTINGCHANGE: u32 = 32787;
pub const WM_DEVICECHANGE: u32 = 537;
pub const WM_MDICREATE: u32 = 544;
pub const WM_MDIDESTROY: u32 = 545;
pub const WM_MDIACTIVATE: u32 = 546;
pub const WM_MDIRESTORE: u32 = 547;
pub const WM_MDINEXT: u32 = 548;
pub const WM_MDIMAXIMIZE: u32 = 549;
pub const WM_MDITILE: u32 = 550;
pub const WM_MDICASCADE: u32 = 551;
pub const WM_MDIICONARRANGE: u32 = 552;
pub const WM_MDIGETACTIVE: u32 = 553;
pub const WM_MDISETMENU: u32 = 560;
pub const WM_ENTERSIZEMOVE: u32 = 561;
pub const WM_EXITSIZEMOVE: u32 = 562;
pub const WM_DROPFILES: u32 = 563;
pub const WM_MDIREFRESHMENU: u32 = 564;
pub const WM_POINTERDEVICECHANGE: u32 = 568;
pub const WM_POINTERDEVICEINRANGE: u32 = 569;
pub const WM_POINTERDEVICEOUTOFRANGE: u32 = 570;
pub const WM_TOUCH: u32 = 576;
pub const WM_NCPOINTERUPDATE: u32 = 577;
pub const WM_NCPOINTERDOWN: u32 = 578;
pub const WM_NCPOINTERUP: u32 = 579;
pub const WM_POINTERUPDATE: u32 = 581;
pub const WM_POINTERDOWN: u32 = 582;
pub const WM_POINTERUP: u32 = 583;
pub const WM_POINTERENTER: u32 = 585;
pub const WM_POINTERLEAVE: u32 = 586;
pub const WM_POINTERACTIVATE: u32 = 587;
pub const WM_POINTERCAPTURECHANGED: u32 = 588;
pub const WM_TOUCHHITTESTING: u32 = 589;
pub const WM_POINTERWHEEL: u32 = 590;
pub const WM_POINTERHWHEEL: u32 = 591;
pub const DM_POINTERHITTEST: u32 = 592;
pub const WM_POINTERROUTEDTO: u32 = 593;
pub const WM_POINTERROUTEDAWAY: u32 = 594;
pub const WM_POINTERROUTEDRELEASED: u32 = 595;
pub const WM_IME_SETCONTEXT: u32 = 641;
pub const WM_IME_NOTIFY: u32 = 642;
pub const WM_IME_CONTROL: u32 = 643;
pub const WM_IME_COMPOSITIONFULL: u32 = 644;
pub const WM_IME_SELECT: u32 = 645;
pub const WM_IME_CHAR: u32 = 646;
pub const WM_IME_REQUEST: u32 = 648;
pub const WM_IME_KEYDOWN: u32 = 656;
pub const WM_IME_KEYUP: u32 = 657;
pub const WM_MOUSEHOVER: u32 = 673;
pub const WM_MOUSELEAVE: u32 = 675;
pub const WM_NCMOUSEHOVER: u32 = 672;
pub const WM_NCMOUSELEAVE: u32 = 674;
pub const WM_WTSSESSION_CHANGE: u32 = 689;
pub const WM_TABLET_FIRST: u32 = 704;
pub const WM_TABLET_LAST: u32 = 735;
pub const WM_DPICHANGED: u32 = 736;
pub const WM_DPICHANGED_BEFOREPARENT: u32 = 738;
pub const WM_DPICHANGED_AFTERPARENT: u32 = 739;
pub const WM_GETDPISCALEDSIZE: u32 = 740;
pub const WM_CUT: u32 = 768;
pub const WM_COPY: u32 = 769;
pub const WM_PASTE: u32 = 770;
pub const WM_CLEAR: u32 = 771;
pub const WM_UNDO: u32 = 772;
pub const WM_RENDERFORMAT: u32 = 773;
pub const WM_RENDERALLFORMATS: u32 = 774;
pub const WM_DESTROYCLIPBOARD: u32 = 775;
pub const WM_DRAWCLIPBOARD: u32 = 776;
pub const WM_PAINTCLIPBOARD: u32 = 777;
pub const WM_VSCROLLCLIPBOARD: u32 = 778;
pub const WM_SIZECLIPBOARD: u32 = 779;
pub const WM_ASKCBFORMATNAME: u32 = 780;
pub const WM_CHANGECBCHAIN: u32 = 781;
pub const WM_HSCROLLCLIPBOARD: u32 = 782;
pub const WM_QUERYNEWPALETTE: u32 = 783;
pub const WM_PALETTEISCHANGING: u32 = 784;
pub const WM_PALETTECHANGED: u32 = 785;
pub const WM_HOTKEY: u32 = 786;
pub const WM_PRINT: u32 = 791;
pub const WM_PRINTCLIENT: u32 = 792;
pub const WM_APPCOMMAND: u32 = 793;
pub const WM_THEMECHANGED: u32 = 794;
pub const WM_CLIPBOARDUPDATE: u32 = 797;
pub const WM_DWMCOMPOSITIONCHANGED: u32 = 798;
pub const WM_DWMNCRENDERINGCHANGED: u32 = 799;
pub const WM_DWMCOLORIZATIONCOLORCHANGED: u32 = 800;
pub const WM_DWMWINDOWMAXIMIZEDCHANGE: u32 = 801;
pub const WM_DWMSENDICONICTHUMBNAIL: u32 = 803;
pub const WM_DWMSENDICONICLIVEPREVIEWBITMAP: u32 = 806;
pub const WM_GETTITLEBARINFOEX: u32 = 831;
pub const WM_HANDHELDFIRST: u32 = 856;
pub const WM_HANDHELDLAST: u32 = 863;
pub const WM_AFXFIRST: u32 = 864;
pub const WM_AFXLAST: u32 = 895;
pub const WM_PENWINFIRST: u32 = 896;
pub const WM_PENWINLAST: u32 = 911;
pub const WM_APP: u32 = 32768;
pub const WM_USER: u32 = 1024;
pub const WMSZ_LEFT: u32 = 1;
pub const WMSZ_RIGHT: u32 = 2;
pub const WMSZ_TOP: u32 = 3;
pub const WMSZ_TOPLEFT: u32 = 4;
pub const WMSZ_TOPRIGHT: u32 = 5;
pub const WMSZ_BOTTOM: u32 = 6;
pub const WMSZ_BOTTOMLEFT: u32 = 7;
pub const WMSZ_BOTTOMRIGHT: u32 = 8;
pub const HTERROR: i32 = -2;
pub const HTTRANSPARENT: i32 = -1;
pub const HTNOWHERE: u32 = 0;
pub const HTCLIENT: u32 = 1;
pub const HTCAPTION: u32 = 2;
pub const HTSYSMENU: u32 = 3;
pub const HTGROWBOX: u32 = 4;
pub const HTSIZE: u32 = 4;
pub const HTMENU: u32 = 5;
pub const HTHSCROLL: u32 = 6;
pub const HTVSCROLL: u32 = 7;
pub const HTMINBUTTON: u32 = 8;
pub const HTMAXBUTTON: u32 = 9;
pub const HTLEFT: u32 = 10;
pub const HTRIGHT: u32 = 11;
pub const HTTOP: u32 = 12;
pub const HTTOPLEFT: u32 = 13;
pub const HTTOPRIGHT: u32 = 14;
pub const HTBOTTOM: u32 = 15;
pub const HTBOTTOMLEFT: u32 = 16;
pub const HTBOTTOMRIGHT: u32 = 17;
pub const HTBORDER: u32 = 18;
pub const HTREDUCE: u32 = 8;
pub const HTZOOM: u32 = 9;
pub const HTSIZEFIRST: u32 = 10;
pub const HTSIZELAST: u32 = 17;
pub const HTOBJECT: u32 = 19;
pub const HTCLOSE: u32 = 20;
pub const HTHELP: u32 = 21;
pub const SMTO_NORMAL: u32 = 0;
pub const SMTO_BLOCK: u32 = 1;
pub const SMTO_ABORTIFHUNG: u32 = 2;
pub const SMTO_NOTIMEOUTIFNOTHUNG: u32 = 8;
pub const SMTO_ERRORONEXIT: u32 = 32;
pub const MA_ACTIVATE: u32 = 1;
pub const MA_ACTIVATEANDEAT: u32 = 2;
pub const MA_NOACTIVATE: u32 = 3;
pub const MA_NOACTIVATEANDEAT: u32 = 4;
pub const ICON_SMALL: u32 = 0;
pub const ICON_BIG: u32 = 1;
pub const ICON_SMALL2: u32 = 2;
pub const SIZE_RESTORED: u32 = 0;
pub const SIZE_MINIMIZED: u32 = 1;
pub const SIZE_MAXIMIZED: u32 = 2;
pub const SIZE_MAXSHOW: u32 = 3;
pub const SIZE_MAXHIDE: u32 = 4;
pub const SIZENORMAL: u32 = 0;
pub const SIZEICONIC: u32 = 1;
pub const SIZEFULLSCREEN: u32 = 2;
pub const SIZEZOOMSHOW: u32 = 3;
pub const SIZEZOOMHIDE: u32 = 4;
pub const WVR_ALIGNTOP: u32 = 16;
pub const WVR_ALIGNLEFT: u32 = 32;
pub const WVR_ALIGNBOTTOM: u32 = 64;
pub const WVR_ALIGNRIGHT: u32 = 128;
pub const WVR_HREDRAW: u32 = 256;
pub const WVR_VREDRAW: u32 = 512;
pub const WVR_REDRAW: u32 = 768;
pub const WVR_VALIDRECTS: u32 = 1024;
pub const MK_LBUTTON: u32 = 1;
pub const MK_RBUTTON: u32 = 2;
pub const MK_SHIFT: u32 = 4;
pub const MK_CONTROL: u32 = 8;
pub const MK_MBUTTON: u32 = 16;
pub const MK_XBUTTON1: u32 = 32;
pub const MK_XBUTTON2: u32 = 64;
pub const TME_HOVER: u32 = 1;
pub const TME_LEAVE: u32 = 2;
pub const TME_NONCLIENT: u32 = 16;
pub const TME_QUERY: u32 = 1073741824;
pub const TME_CANCEL: u32 = 2147483648;
pub const HOVER_DEFAULT: u32 = 4294967295;
pub const WS_OVERLAPPED: u32 = 0;
pub const WS_POPUP: u32 = 2147483648;
pub const WS_CHILD: u32 = 1073741824;
pub const WS_MINIMIZE: u32 = 536870912;
pub const WS_VISIBLE: u32 = 268435456;
pub const WS_DISABLED: u32 = 134217728;
pub const WS_CLIPSIBLINGS: u32 = 67108864;
pub const WS_CLIPCHILDREN: u32 = 33554432;
pub const WS_MAXIMIZE: u32 = 16777216;
pub const WS_CAPTION: u32 = 12582912;
pub const WS_BORDER: u32 = 8388608;
pub const WS_DLGFRAME: u32 = 4194304;
pub const WS_VSCROLL: u32 = 2097152;
pub const WS_HSCROLL: u32 = 1048576;
pub const WS_SYSMENU: u32 = 524288;
pub const WS_THICKFRAME: u32 = 262144;
pub const WS_GROUP: u32 = 131072;
pub const WS_TABSTOP: u32 = 65536;
pub const WS_MINIMIZEBOX: u32 = 131072;
pub const WS_MAXIMIZEBOX: u32 = 65536;
pub const WS_TILED: u32 = 0;
pub const WS_ICONIC: u32 = 536870912;
pub const WS_SIZEBOX: u32 = 262144;
pub const WS_OVERLAPPEDWINDOW: u32 = 13565952;
pub const WS_POPUPWINDOW: u32 = 2156396544;
pub const WS_CHILDWINDOW: u32 = 1073741824;
pub const WS_EX_DLGMODALFRAME: u32 = 1;
pub const WS_EX_NOPARENTNOTIFY: u32 = 4;
pub const WS_EX_TOPMOST: u32 = 8;
pub const WS_EX_ACCEPTFILES: u32 = 16;
pub const WS_EX_TRANSPARENT: u32 = 32;
pub const WS_EX_MDICHILD: u32 = 64;
pub const WS_EX_TOOLWINDOW: u32 = 128;
pub const WS_EX_WINDOWEDGE: u32 = 256;
pub const WS_EX_CLIENTEDGE: u32 = 512;
pub const WS_EX_CONTEXTHELP: u32 = 1024;
pub const WS_EX_RIGHT: u32 = 4096;
pub const WS_EX_LEFT: u32 = 0;
pub const WS_EX_RTLREADING: u32 = 8192;
pub const WS_EX_LTRREADING: u32 = 0;
pub const WS_EX_LEFTSCROLLBAR: u32 = 16384;
pub const WS_EX_RIGHTSCROLLBAR: u32 = 0;
pub const WS_EX_CONTROLPARENT: u32 = 65536;
pub const WS_EX_STATICEDGE: u32 = 131072;
pub const WS_EX_APPWINDOW: u32 = 262144;
pub const WS_EX_OVERLAPPEDWINDOW: u32 = 768;
pub const WS_EX_PALETTEWINDOW: u32 = 392;
pub const WS_EX_LAYERED: u32 = 524288;
pub const WS_EX_NOINHERITLAYOUT: u32 = 1048576;
pub const WS_EX_NOREDIRECTIONBITMAP: u32 = 2097152;
pub const WS_EX_LAYOUTRTL: u32 = 4194304;
pub const WS_EX_COMPOSITED: u32 = 33554432;
pub const WS_EX_NOACTIVATE: u32 = 134217728;
pub const CS_VREDRAW: u32 = 1;
pub const CS_HREDRAW: u32 = 2;
pub const CS_DBLCLKS: u32 = 8;
pub const CS_OWNDC: u32 = 32;
pub const CS_CLASSDC: u32 = 64;
pub const CS_PARENTDC: u32 = 128;
pub const CS_NOCLOSE: u32 = 512;
pub const CS_SAVEBITS: u32 = 2048;
pub const CS_BYTEALIGNCLIENT: u32 = 4096;
pub const CS_BYTEALIGNWINDOW: u32 = 8192;
pub const CS_GLOBALCLASS: u32 = 16384;
pub const CS_IME: u32 = 65536;
pub const CS_DROPSHADOW: u32 = 131072;
pub const PRF_CHECKVISIBLE: u32 = 1;
pub const PRF_NONCLIENT: u32 = 2;
pub const PRF_CLIENT: u32 = 4;
pub const PRF_ERASEBKGND: u32 = 8;
pub const PRF_CHILDREN: u32 = 16;
pub const PRF_OWNED: u32 = 32;
pub const BDR_RAISEDOUTER: u32 = 1;
pub const BDR_SUNKENOUTER: u32 = 2;
pub const BDR_RAISEDINNER: u32 = 4;
pub const BDR_SUNKENINNER: u32 = 8;
pub const BDR_OUTER: u32 = 3;
pub const BDR_INNER: u32 = 12;
pub const BDR_RAISED: u32 = 5;
pub const BDR_SUNKEN: u32 = 10;
pub const EDGE_RAISED: u32 = 5;
pub const EDGE_SUNKEN: u32 = 10;
pub const EDGE_ETCHED: u32 = 6;
pub const EDGE_BUMP: u32 = 9;
pub const BF_LEFT: u32 = 1;
pub const BF_TOP: u32 = 2;
pub const BF_RIGHT: u32 = 4;
pub const BF_BOTTOM: u32 = 8;
pub const BF_TOPLEFT: u32 = 3;
pub const BF_TOPRIGHT: u32 = 6;
pub const BF_BOTTOMLEFT: u32 = 9;
pub const BF_BOTTOMRIGHT: u32 = 12;
pub const BF_RECT: u32 = 15;
pub const BF_DIAGONAL: u32 = 16;
pub const BF_DIAGONAL_ENDTOPRIGHT: u32 = 22;
pub const BF_DIAGONAL_ENDTOPLEFT: u32 = 19;
pub const BF_DIAGONAL_ENDBOTTOMLEFT: u32 = 25;
pub const BF_DIAGONAL_ENDBOTTOMRIGHT: u32 = 28;
pub const BF_MIDDLE: u32 = 2048;
pub const BF_SOFT: u32 = 4096;
pub const BF_ADJUST: u32 = 8192;
pub const BF_FLAT: u32 = 16384;
pub const BF_MONO: u32 = 32768;
pub const DFC_CAPTION: u32 = 1;
pub const DFC_MENU: u32 = 2;
pub const DFC_SCROLL: u32 = 3;
pub const DFC_BUTTON: u32 = 4;
pub const DFC_POPUPMENU: u32 = 5;
pub const DFCS_CAPTIONCLOSE: u32 = 0;
pub const DFCS_CAPTIONMIN: u32 = 1;
pub const DFCS_CAPTIONMAX: u32 = 2;
pub const DFCS_CAPTIONRESTORE: u32 = 3;
pub const DFCS_CAPTIONHELP: u32 = 4;
pub const DFCS_MENUARROW: u32 = 0;
pub const DFCS_MENUCHECK: u32 = 1;
pub const DFCS_MENUBULLET: u32 = 2;
pub const DFCS_MENUARROWRIGHT: u32 = 4;
pub const DFCS_SCROLLUP: u32 = 0;
pub const DFCS_SCROLLDOWN: u32 = 1;
pub const DFCS_SCROLLLEFT: u32 = 2;
pub const DFCS_SCROLLRIGHT: u32 = 3;
pub const DFCS_SCROLLCOMBOBOX: u32 = 5;
pub const DFCS_SCROLLSIZEGRIP: u32 = 8;
pub const DFCS_SCROLLSIZEGRIPRIGHT: u32 = 16;
pub const DFCS_BUTTONCHECK: u32 = 0;
pub const DFCS_BUTTONRADIOIMAGE: u32 = 1;
pub const DFCS_BUTTONRADIOMASK: u32 = 2;
pub const DFCS_BUTTONRADIO: u32 = 4;
pub const DFCS_BUTTON3STATE: u32 = 8;
pub const DFCS_BUTTONPUSH: u32 = 16;
pub const DFCS_INACTIVE: u32 = 256;
pub const DFCS_PUSHED: u32 = 512;
pub const DFCS_CHECKED: u32 = 1024;
pub const DFCS_TRANSPARENT: u32 = 2048;
pub const DFCS_HOT: u32 = 4096;
pub const DFCS_ADJUSTRECT: u32 = 8192;
pub const DFCS_FLAT: u32 = 16384;
pub const DFCS_MONO: u32 = 32768;
pub const DC_ACTIVE: u32 = 1;
pub const DC_SMALLCAP: u32 = 2;
pub const DC_ICON: u32 = 4;
pub const DC_TEXT: u32 = 8;
pub const DC_INBUTTON: u32 = 16;
pub const DC_GRADIENT: u32 = 32;
pub const DC_BUTTONS: u32 = 4096;
pub const IDANI_OPEN: u32 = 1;
pub const IDANI_CAPTION: u32 = 3;
pub const CF_TEXT: u32 = 1;
pub const CF_BITMAP: u32 = 2;
pub const CF_METAFILEPICT: u32 = 3;
pub const CF_SYLK: u32 = 4;
pub const CF_DIF: u32 = 5;
pub const CF_TIFF: u32 = 6;
pub const CF_OEMTEXT: u32 = 7;
pub const CF_DIB: u32 = 8;
pub const CF_PALETTE: u32 = 9;
pub const CF_PENDATA: u32 = 10;
pub const CF_RIFF: u32 = 11;
pub const CF_WAVE: u32 = 12;
pub const CF_UNICODETEXT: u32 = 13;
pub const CF_ENHMETAFILE: u32 = 14;
pub const CF_HDROP: u32 = 15;
pub const CF_LOCALE: u32 = 16;
pub const CF_DIBV5: u32 = 17;
pub const CF_MAX: u32 = 18;
pub const CF_OWNERDISPLAY: u32 = 128;
pub const CF_DSPTEXT: u32 = 129;
pub const CF_DSPBITMAP: u32 = 130;
pub const CF_DSPMETAFILEPICT: u32 = 131;
pub const CF_DSPENHMETAFILE: u32 = 142;
pub const CF_PRIVATEFIRST: u32 = 512;
pub const CF_PRIVATELAST: u32 = 767;
pub const CF_GDIOBJFIRST: u32 = 768;
pub const CF_GDIOBJLAST: u32 = 1023;
pub const FVIRTKEY: u32 = 1;
pub const FNOINVERT: u32 = 2;
pub const FSHIFT: u32 = 4;
pub const FCONTROL: u32 = 8;
pub const FALT: u32 = 16;
pub const WPF_SETMINPOSITION: u32 = 1;
pub const WPF_RESTORETOMAXIMIZED: u32 = 2;
pub const WPF_ASYNCWINDOWPLACEMENT: u32 = 4;
pub const ODT_MENU: u32 = 1;
pub const ODT_LISTBOX: u32 = 2;
pub const ODT_COMBOBOX: u32 = 3;
pub const ODT_BUTTON: u32 = 4;
pub const ODT_STATIC: u32 = 5;
pub const ODA_DRAWENTIRE: u32 = 1;
pub const ODA_SELECT: u32 = 2;
pub const ODA_FOCUS: u32 = 4;
pub const ODS_SELECTED: u32 = 1;
pub const ODS_GRAYED: u32 = 2;
pub const ODS_DISABLED: u32 = 4;
pub const ODS_CHECKED: u32 = 8;
pub const ODS_FOCUS: u32 = 16;
pub const ODS_DEFAULT: u32 = 32;
pub const ODS_COMBOBOXEDIT: u32 = 4096;
pub const ODS_HOTLIGHT: u32 = 64;
pub const ODS_INACTIVE: u32 = 128;
pub const ODS_NOACCEL: u32 = 256;
pub const ODS_NOFOCUSRECT: u32 = 512;
pub const PM_NOREMOVE: u32 = 0;
pub const PM_REMOVE: u32 = 1;
pub const PM_NOYIELD: u32 = 2;
pub const MOD_ALT: u32 = 1;
pub const MOD_CONTROL: u32 = 2;
pub const MOD_SHIFT: u32 = 4;
pub const MOD_WIN: u32 = 8;
pub const MOD_NOREPEAT: u32 = 16384;
pub const IDHOT_SNAPWINDOW: i32 = -1;
pub const IDHOT_SNAPDESKTOP: i32 = -2;
pub const ENDSESSION_CLOSEAPP: u32 = 1;
pub const ENDSESSION_CRITICAL: u32 = 1073741824;
pub const ENDSESSION_LOGOFF: u32 = 2147483648;
pub const EWX_LOGOFF: u32 = 0;
pub const EWX_SHUTDOWN: u32 = 1;
pub const EWX_REBOOT: u32 = 2;
pub const EWX_FORCE: u32 = 4;
pub const EWX_POWEROFF: u32 = 8;
pub const EWX_FORCEIFHUNG: u32 = 16;
pub const EWX_QUICKRESOLVE: u32 = 32;
pub const EWX_RESTARTAPPS: u32 = 64;
pub const EWX_HYBRID_SHUTDOWN: u32 = 4194304;
pub const EWX_BOOTOPTIONS: u32 = 16777216;
pub const BSM_ALLCOMPONENTS: u32 = 0;
pub const BSM_VXDS: u32 = 1;
pub const BSM_NETDRIVER: u32 = 2;
pub const BSM_INSTALLABLEDRIVERS: u32 = 4;
pub const BSM_APPLICATIONS: u32 = 8;
pub const BSM_ALLDESKTOPS: u32 = 16;
pub const BSF_QUERY: u32 = 1;
pub const BSF_IGNORECURRENTTASK: u32 = 2;
pub const BSF_FLUSHDISK: u32 = 4;
pub const BSF_NOHANG: u32 = 8;
pub const BSF_POSTMESSAGE: u32 = 16;
pub const BSF_FORCEIFHUNG: u32 = 32;
pub const BSF_NOTIMEOUTIFNOTHUNG: u32 = 64;
pub const BSF_ALLOWSFW: u32 = 128;
pub const BSF_SENDNOTIFYMESSAGE: u32 = 256;
pub const BSF_RETURNHDESK: u32 = 512;
pub const BSF_LUID: u32 = 1024;
pub const BROADCAST_QUERY_DENY: u32 = 1112363332;
pub const DEVICE_NOTIFY_WINDOW_HANDLE: u32 = 0;
pub const DEVICE_NOTIFY_SERVICE_HANDLE: u32 = 1;
pub const DEVICE_NOTIFY_ALL_INTERFACE_CLASSES: u32 = 4;
pub const ISMEX_NOSEND: u32 = 0;
pub const ISMEX_SEND: u32 = 1;
pub const ISMEX_NOTIFY: u32 = 2;
pub const ISMEX_CALLBACK: u32 = 4;
pub const ISMEX_REPLIED: u32 = 8;
pub const PW_CLIENTONLY: u32 = 1;
pub const PW_RENDERFULLCONTENT: u32 = 2;
pub const LWA_COLORKEY: u32 = 1;
pub const LWA_ALPHA: u32 = 2;
pub const ULW_COLORKEY: u32 = 1;
pub const ULW_ALPHA: u32 = 2;
pub const ULW_OPAQUE: u32 = 4;
pub const ULW_EX_NORESIZE: u32 = 8;
pub const FLASHW_STOP: u32 = 0;
pub const FLASHW_CAPTION: u32 = 1;
pub const FLASHW_TRAY: u32 = 2;
pub const FLASHW_ALL: u32 = 3;
pub const FLASHW_TIMER: u32 = 4;
pub const FLASHW_TIMERNOFG: u32 = 12;
pub const WDA_NONE: u32 = 0;
pub const WDA_MONITOR: u32 = 1;
pub const SWP_NOSIZE: u32 = 1;
pub const SWP_NOMOVE: u32 = 2;
pub const SWP_NOZORDER: u32 = 4;
pub const SWP_NOREDRAW: u32 = 8;
pub const SWP_NOACTIVATE: u32 = 16;
pub const SWP_FRAMECHANGED: u32 = 32;
pub const SWP_SHOWWINDOW: u32 = 64;
pub const SWP_HIDEWINDOW: u32 = 128;
pub const SWP_NOCOPYBITS: u32 = 256;
pub const SWP_NOOWNERZORDER: u32 = 512;
pub const SWP_NOSENDCHANGING: u32 = 1024;
pub const SWP_DRAWFRAME: u32 = 32;
pub const SWP_NOREPOSITION: u32 = 512;
pub const SWP_DEFERERASE: u32 = 8192;
pub const SWP_ASYNCWINDOWPOS: u32 = 16384;
pub const DLGWINDOWEXTRA: u32 = 30;
pub const KEYEVENTF_EXTENDEDKEY: u32 = 1;
pub const KEYEVENTF_KEYUP: u32 = 2;
pub const KEYEVENTF_UNICODE: u32 = 4;
pub const KEYEVENTF_SCANCODE: u32 = 8;
pub const MOUSEEVENTF_MOVE: u32 = 1;
pub const MOUSEEVENTF_LEFTDOWN: u32 = 2;
pub const MOUSEEVENTF_LEFTUP: u32 = 4;
pub const MOUSEEVENTF_RIGHTDOWN: u32 = 8;
pub const MOUSEEVENTF_RIGHTUP: u32 = 16;
pub const MOUSEEVENTF_MIDDLEDOWN: u32 = 32;
pub const MOUSEEVENTF_MIDDLEUP: u32 = 64;
pub const MOUSEEVENTF_XDOWN: u32 = 128;
pub const MOUSEEVENTF_XUP: u32 = 256;
pub const MOUSEEVENTF_WHEEL: u32 = 2048;
pub const MOUSEEVENTF_HWHEEL: u32 = 4096;
pub const MOUSEEVENTF_MOVE_NOCOALESCE: u32 = 8192;
pub const MOUSEEVENTF_VIRTUALDESK: u32 = 16384;
pub const MOUSEEVENTF_ABSOLUTE: u32 = 32768;
pub const INPUT_MOUSE: u32 = 0;
pub const INPUT_KEYBOARD: u32 = 1;
pub const INPUT_HARDWARE: u32 = 2;
pub const TOUCHEVENTF_MOVE: u32 = 1;
pub const TOUCHEVENTF_DOWN: u32 = 2;
pub const TOUCHEVENTF_UP: u32 = 4;
pub const TOUCHEVENTF_INRANGE: u32 = 8;
pub const TOUCHEVENTF_PRIMARY: u32 = 16;
pub const TOUCHEVENTF_NOCOALESCE: u32 = 32;
pub const TOUCHEVENTF_PEN: u32 = 64;
pub const TOUCHEVENTF_PALM: u32 = 128;
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM: u32 = 1;
pub const TOUCHINPUTMASKF_EXTRAINFO: u32 = 2;
pub const TOUCHINPUTMASKF_CONTACTAREA: u32 = 4;
pub const TWF_FINETOUCH: u32 = 1;
pub const TWF_WANTPALM: u32 = 2;
pub const POINTER_FLAG_NONE: u32 = 0;
pub const POINTER_FLAG_NEW: u32 = 1;
pub const POINTER_FLAG_INRANGE: u32 = 2;
pub const POINTER_FLAG_INCONTACT: u32 = 4;
pub const POINTER_FLAG_FIRSTBUTTON: u32 = 16;
pub const POINTER_FLAG_SECONDBUTTON: u32 = 32;
pub const POINTER_FLAG_THIRDBUTTON: u32 = 64;
pub const POINTER_FLAG_FOURTHBUTTON: u32 = 128;
pub const POINTER_FLAG_FIFTHBUTTON: u32 = 256;
pub const POINTER_FLAG_PRIMARY: u32 = 8192;
pub const POINTER_FLAG_CONFIDENCE: u32 = 16384;
pub const POINTER_FLAG_CANCELED: u32 = 32768;
pub const POINTER_FLAG_DOWN: u32 = 65536;
pub const POINTER_FLAG_UPDATE: u32 = 131072;
pub const POINTER_FLAG_UP: u32 = 262144;
pub const POINTER_FLAG_WHEEL: u32 = 524288;
pub const POINTER_FLAG_HWHEEL: u32 = 1048576;
pub const POINTER_FLAG_CAPTURECHANGED: u32 = 2097152;
pub const POINTER_FLAG_HASTRANSFORM: u32 = 4194304;
pub const POINTER_MOD_SHIFT: u32 = 4;
pub const POINTER_MOD_CTRL: u32 = 8;
pub const TOUCH_FLAG_NONE: u32 = 0;
pub const TOUCH_MASK_NONE: u32 = 0;
pub const TOUCH_MASK_CONTACTAREA: u32 = 1;
pub const TOUCH_MASK_ORIENTATION: u32 = 2;
pub const TOUCH_MASK_PRESSURE: u32 = 4;
pub const PEN_FLAG_NONE: u32 = 0;
pub const PEN_FLAG_BARREL: u32 = 1;
pub const PEN_FLAG_INVERTED: u32 = 2;
pub const PEN_FLAG_ERASER: u32 = 4;
pub const PEN_MASK_NONE: u32 = 0;
pub const PEN_MASK_PRESSURE: u32 = 1;
pub const PEN_MASK_ROTATION: u32 = 2;
pub const PEN_MASK_TILT_X: u32 = 4;
pub const PEN_MASK_TILT_Y: u32 = 8;
pub const POINTER_MESSAGE_FLAG_NEW: u32 = 1;
pub const POINTER_MESSAGE_FLAG_INRANGE: u32 = 2;
pub const POINTER_MESSAGE_FLAG_INCONTACT: u32 = 4;
pub const POINTER_MESSAGE_FLAG_FIRSTBUTTON: u32 = 16;
pub const POINTER_MESSAGE_FLAG_SECONDBUTTON: u32 = 32;
pub const POINTER_MESSAGE_FLAG_THIRDBUTTON: u32 = 64;
pub const POINTER_MESSAGE_FLAG_FOURTHBUTTON: u32 = 128;
pub const POINTER_MESSAGE_FLAG_FIFTHBUTTON: u32 = 256;
pub const POINTER_MESSAGE_FLAG_PRIMARY: u32 = 8192;
pub const POINTER_MESSAGE_FLAG_CONFIDENCE: u32 = 16384;
pub const POINTER_MESSAGE_FLAG_CANCELED: u32 = 32768;
pub const PA_ACTIVATE: u32 = 1;
pub const PA_NOACTIVATE: u32 = 3;
pub const MAX_TOUCH_COUNT: u32 = 256;
pub const TOUCH_FEEDBACK_DEFAULT: u32 = 1;
pub const TOUCH_FEEDBACK_INDIRECT: u32 = 2;
pub const TOUCH_FEEDBACK_NONE: u32 = 3;
pub const TOUCH_HIT_TESTING_DEFAULT: u32 = 0;
pub const TOUCH_HIT_TESTING_CLIENT: u32 = 1;
pub const TOUCH_HIT_TESTING_NONE: u32 = 2;
pub const TOUCH_HIT_TESTING_PROXIMITY_CLOSEST: u32 = 0;
pub const TOUCH_HIT_TESTING_PROXIMITY_FARTHEST: u32 = 4095;
pub const GWFS_INCLUDE_ANCESTORS: u32 = 1;
pub const MAPVK_VK_TO_VSC: u32 = 0;
pub const MAPVK_VSC_TO_VK: u32 = 1;
pub const MAPVK_VK_TO_CHAR: u32 = 2;
pub const MAPVK_VSC_TO_VK_EX: u32 = 3;
pub const MAPVK_VK_TO_VSC_EX: u32 = 4;
pub const MWMO_WAITALL: u32 = 1;
pub const MWMO_ALERTABLE: u32 = 2;
pub const MWMO_INPUTAVAILABLE: u32 = 4;
pub const QS_KEY: u32 = 1;
pub const QS_MOUSEMOVE: u32 = 2;
pub const QS_MOUSEBUTTON: u32 = 4;
pub const QS_POSTMESSAGE: u32 = 8;
pub const QS_TIMER: u32 = 16;
pub const QS_PAINT: u32 = 32;
pub const QS_SENDMESSAGE: u32 = 64;
pub const QS_HOTKEY: u32 = 128;
pub const QS_ALLPOSTMESSAGE: u32 = 256;
pub const QS_RAWINPUT: u32 = 1024;
pub const QS_TOUCH: u32 = 2048;
pub const QS_POINTER: u32 = 4096;
pub const QS_MOUSE: u32 = 6;
pub const QS_INPUT: u32 = 7175;
pub const QS_ALLEVENTS: u32 = 7359;
pub const QS_ALLINPUT: u32 = 7423;
pub const USER_TIMER_MAXIMUM: u32 = 2147483647;
pub const USER_TIMER_MINIMUM: u32 = 10;
pub const TIMERV_DEFAULT_COALESCING: u32 = 0;
pub const TIMERV_NO_COALESCING: u32 = 4294967295;
pub const TIMERV_COALESCING_MIN: u32 = 1;
pub const TIMERV_COALESCING_MAX: u32 = 2147483637;
pub const SM_CXSCREEN: u32 = 0;
pub const SM_CYSCREEN: u32 = 1;
pub const SM_CXVSCROLL: u32 = 2;
pub const SM_CYHSCROLL: u32 = 3;
pub const SM_CYCAPTION: u32 = 4;
pub const SM_CXBORDER: u32 = 5;
pub const SM_CYBORDER: u32 = 6;
pub const SM_CXDLGFRAME: u32 = 7;
pub const SM_CYDLGFRAME: u32 = 8;
pub const SM_CYVTHUMB: u32 = 9;
pub const SM_CXHTHUMB: u32 = 10;
pub const SM_CXICON: u32 = 11;
pub const SM_CYICON: u32 = 12;
pub const SM_CXCURSOR: u32 = 13;
pub const SM_CYCURSOR: u32 = 14;
pub const SM_CYMENU: u32 = 15;
pub const SM_CXFULLSCREEN: u32 = 16;
pub const SM_CYFULLSCREEN: u32 = 17;
pub const SM_CYKANJIWINDOW: u32 = 18;
pub const SM_MOUSEPRESENT: u32 = 19;
pub const SM_CYVSCROLL: u32 = 20;
pub const SM_CXHSCROLL: u32 = 21;
pub const SM_DEBUG: u32 = 22;
pub const SM_SWAPBUTTON: u32 = 23;
pub const SM_RESERVED1: u32 = 24;
pub const SM_RESERVED2: u32 = 25;
pub const SM_RESERVED3: u32 = 26;
pub const SM_RESERVED4: u32 = 27;
pub const SM_CXMIN: u32 = 28;
pub const SM_CYMIN: u32 = 29;
pub const SM_CXSIZE: u32 = 30;
pub const SM_CYSIZE: u32 = 31;
pub const SM_CXFRAME: u32 = 32;
pub const SM_CYFRAME: u32 = 33;
pub const SM_CXMINTRACK: u32 = 34;
pub const SM_CYMINTRACK: u32 = 35;
pub const SM_CXDOUBLECLK: u32 = 36;
pub const SM_CYDOUBLECLK: u32 = 37;
pub const SM_CXICONSPACING: u32 = 38;
pub const SM_CYICONSPACING: u32 = 39;
pub const SM_MENUDROPALIGNMENT: u32 = 40;
pub const SM_PENWINDOWS: u32 = 41;
pub const SM_DBCSENABLED: u32 = 42;
pub const SM_CMOUSEBUTTONS: u32 = 43;
pub const SM_CXFIXEDFRAME: u32 = 7;
pub const SM_CYFIXEDFRAME: u32 = 8;
pub const SM_CXSIZEFRAME: u32 = 32;
pub const SM_CYSIZEFRAME: u32 = 33;
pub const SM_SECURE: u32 = 44;
pub const SM_CXEDGE: u32 = 45;
pub const SM_CYEDGE: u32 = 46;
pub const SM_CXMINSPACING: u32 = 47;
pub const SM_CYMINSPACING: u32 = 48;
pub const SM_CXSMICON: u32 = 49;
pub const SM_CYSMICON: u32 = 50;
pub const SM_CYSMCAPTION: u32 = 51;
pub const SM_CXSMSIZE: u32 = 52;
pub const SM_CYSMSIZE: u32 = 53;
pub const SM_CXMENUSIZE: u32 = 54;
pub const SM_CYMENUSIZE: u32 = 55;
pub const SM_ARRANGE: u32 = 56;
pub const SM_CXMINIMIZED: u32 = 57;
pub const SM_CYMINIMIZED: u32 = 58;
pub const SM_CXMAXTRACK: u32 = 59;
pub const SM_CYMAXTRACK: u32 = 60;
pub const SM_CXMAXIMIZED: u32 = 61;
pub const SM_CYMAXIMIZED: u32 = 62;
pub const SM_NETWORK: u32 = 63;
pub const SM_CLEANBOOT: u32 = 67;
pub const SM_CXDRAG: u32 = 68;
pub const SM_CYDRAG: u32 = 69;
pub const SM_SHOWSOUNDS: u32 = 70;
pub const SM_CXMENUCHECK: u32 = 71;
pub const SM_CYMENUCHECK: u32 = 72;
pub const SM_SLOWMACHINE: u32 = 73;
pub const SM_MIDEASTENABLED: u32 = 74;
pub const SM_MOUSEWHEELPRESENT: u32 = 75;
pub const SM_XVIRTUALSCREEN: u32 = 76;
pub const SM_YVIRTUALSCREEN: u32 = 77;
pub const SM_CXVIRTUALSCREEN: u32 = 78;
pub const SM_CYVIRTUALSCREEN: u32 = 79;
pub const SM_CMONITORS: u32 = 80;
pub const SM_SAMEDISPLAYFORMAT: u32 = 81;
pub const SM_IMMENABLED: u32 = 82;
pub const SM_CXFOCUSBORDER: u32 = 83;
pub const SM_CYFOCUSBORDER: u32 = 84;
pub const SM_TABLETPC: u32 = 86;
pub const SM_MEDIACENTER: u32 = 87;
pub const SM_STARTER: u32 = 88;
pub const SM_SERVERR2: u32 = 89;
pub const SM_MOUSEHORIZONTALWHEELPRESENT: u32 = 91;
pub const SM_CXPADDEDBORDER: u32 = 92;
pub const SM_DIGITIZER: u32 = 94;
pub const SM_MAXIMUMTOUCHES: u32 = 95;
pub const SM_CMETRICS: u32 = 97;
pub const SM_REMOTESESSION: u32 = 4096;
pub const SM_SHUTTINGDOWN: u32 = 8192;
pub const SM_REMOTECONTROL: u32 = 8193;
pub const SM_CARETBLINKINGENABLED: u32 = 8194;
pub const SM_CONVERTIBLESLATEMODE: u32 = 8195;
pub const SM_SYSTEMDOCKED: u32 = 8196;
pub const PMB_ACTIVE: u32 = 1;
pub const MNC_IGNORE: u32 = 0;
pub const MNC_CLOSE: u32 = 1;
pub const MNC_EXECUTE: u32 = 2;
pub const MNC_SELECT: u32 = 3;
pub const MNS_NOCHECK: u32 = 2147483648;
pub const MNS_MODELESS: u32 = 1073741824;
pub const MNS_DRAGDROP: u32 = 536870912;
pub const MNS_AUTODISMISS: u32 = 268435456;
pub const MNS_NOTIFYBYPOS: u32 = 134217728;
pub const MNS_CHECKORBMP: u32 = 67108864;
pub const MIM_MAXHEIGHT: u32 = 1;
pub const MIM_BACKGROUND: u32 = 2;
pub const MIM_HELPID: u32 = 4;
pub const MIM_MENUDATA: u32 = 8;
pub const MIM_STYLE: u32 = 16;
pub const MIM_APPLYTOSUBMENUS: u32 = 2147483648;
pub const MND_CONTINUE: u32 = 0;
pub const MND_ENDMENU: u32 = 1;
pub const MNGOF_TOPGAP: u32 = 1;
pub const MNGOF_BOTTOMGAP: u32 = 2;
pub const MNGO_NOINTERFACE: u32 = 0;
pub const MNGO_NOERROR: u32 = 1;
pub const MIIM_STATE: u32 = 1;
pub const MIIM_ID: u32 = 2;
pub const MIIM_SUBMENU: u32 = 4;
pub const MIIM_CHECKMARKS: u32 = 8;
pub const MIIM_TYPE: u32 = 16;
pub const MIIM_DATA: u32 = 32;
pub const MIIM_STRING: u32 = 64;
pub const MIIM_BITMAP: u32 = 128;
pub const MIIM_FTYPE: u32 = 256;
pub const GMDI_USEDISABLED: u32 = 1;
pub const GMDI_GOINTOPOPUPS: u32 = 2;
pub const TPM_LEFTBUTTON: u32 = 0;
pub const TPM_RIGHTBUTTON: u32 = 2;
pub const TPM_LEFTALIGN: u32 = 0;
pub const TPM_CENTERALIGN: u32 = 4;
pub const TPM_RIGHTALIGN: u32 = 8;
pub const TPM_TOPALIGN: u32 = 0;
pub const TPM_VCENTERALIGN: u32 = 16;
pub const TPM_BOTTOMALIGN: u32 = 32;
pub const TPM_HORIZONTAL: u32 = 0;
pub const TPM_VERTICAL: u32 = 64;
pub const TPM_NONOTIFY: u32 = 128;
pub const TPM_RETURNCMD: u32 = 256;
pub const TPM_RECURSE: u32 = 1;
pub const TPM_HORPOSANIMATION: u32 = 1024;
pub const TPM_HORNEGANIMATION: u32 = 2048;
pub const TPM_VERPOSANIMATION: u32 = 4096;
pub const TPM_VERNEGANIMATION: u32 = 8192;
pub const TPM_NOANIMATION: u32 = 16384;
pub const TPM_LAYOUTRTL: u32 = 32768;
pub const TPM_WORKAREA: u32 = 65536;
pub const DOF_EXECUTABLE: u32 = 32769;
pub const DOF_DOCUMENT: u32 = 32770;
pub const DOF_DIRECTORY: u32 = 32771;
pub const DOF_MULTIPLE: u32 = 32772;
pub const DOF_PROGMAN: u32 = 1;
pub const DOF_SHELLDATA: u32 = 2;
pub const DO_DROPFILE: u32 = 1162627398;
pub const DO_PRINTFILE: u32 = 1414419024;
pub const DT_TOP: u32 = 0;
pub const DT_LEFT: u32 = 0;
pub const DT_CENTER: u32 = 1;
pub const DT_RIGHT: u32 = 2;
pub const DT_VCENTER: u32 = 4;
pub const DT_BOTTOM: u32 = 8;
pub const DT_WORDBREAK: u32 = 16;
pub const DT_SINGLELINE: u32 = 32;
pub const DT_EXPANDTABS: u32 = 64;
pub const DT_TABSTOP: u32 = 128;
pub const DT_NOCLIP: u32 = 256;
pub const DT_EXTERNALLEADING: u32 = 512;
pub const DT_CALCRECT: u32 = 1024;
pub const DT_NOPREFIX: u32 = 2048;
pub const DT_INTERNAL: u32 = 4096;
pub const DT_EDITCONTROL: u32 = 8192;
pub const DT_PATH_ELLIPSIS: u32 = 16384;
pub const DT_END_ELLIPSIS: u32 = 32768;
pub const DT_MODIFYSTRING: u32 = 65536;
pub const DT_RTLREADING: u32 = 131072;
pub const DT_WORD_ELLIPSIS: u32 = 262144;
pub const DT_NOFULLWIDTHCHARBREAK: u32 = 524288;
pub const DT_HIDEPREFIX: u32 = 1048576;
pub const DT_PREFIXONLY: u32 = 2097152;
pub const DST_COMPLEX: u32 = 0;
pub const DST_TEXT: u32 = 1;
pub const DST_PREFIXTEXT: u32 = 2;
pub const DST_ICON: u32 = 3;
pub const DST_BITMAP: u32 = 4;
pub const DSS_NORMAL: u32 = 0;
pub const DSS_UNION: u32 = 16;
pub const DSS_DISABLED: u32 = 32;
pub const DSS_MONO: u32 = 128;
pub const DSS_HIDEPREFIX: u32 = 512;
pub const DSS_PREFIXONLY: u32 = 1024;
pub const DSS_RIGHT: u32 = 32768;
pub const LSFW_LOCK: u32 = 1;
pub const LSFW_UNLOCK: u32 = 2;
pub const DCX_WINDOW: u32 = 1;
pub const DCX_CACHE: u32 = 2;
pub const DCX_NORESETATTRS: u32 = 4;
pub const DCX_CLIPCHILDREN: u32 = 8;
pub const DCX_CLIPSIBLINGS: u32 = 16;
pub const DCX_PARENTCLIP: u32 = 32;
pub const DCX_EXCLUDERGN: u32 = 64;
pub const DCX_INTERSECTRGN: u32 = 128;
pub const DCX_EXCLUDEUPDATE: u32 = 256;
pub const DCX_INTERSECTUPDATE: u32 = 512;
pub const DCX_LOCKWINDOWUPDATE: u32 = 1024;
pub const DCX_VALIDATE: u32 = 2097152;
pub const RDW_INVALIDATE: u32 = 1;
pub const RDW_INTERNALPAINT: u32 = 2;
pub const RDW_ERASE: u32 = 4;
pub const RDW_VALIDATE: u32 = 8;
pub const RDW_NOINTERNALPAINT: u32 = 16;
pub const RDW_NOERASE: u32 = 32;
pub const RDW_NOCHILDREN: u32 = 64;
pub const RDW_ALLCHILDREN: u32 = 128;
pub const RDW_UPDATENOW: u32 = 256;
pub const RDW_ERASENOW: u32 = 512;
pub const RDW_FRAME: u32 = 1024;
pub const RDW_NOFRAME: u32 = 2048;
pub const SW_SCROLLCHILDREN: u32 = 1;
pub const SW_INVALIDATE: u32 = 2;
pub const SW_ERASE: u32 = 4;
pub const SW_SMOOTHSCROLL: u32 = 16;
pub const ESB_ENABLE_BOTH: u32 = 0;
pub const ESB_DISABLE_BOTH: u32 = 3;
pub const ESB_DISABLE_LEFT: u32 = 1;
pub const ESB_DISABLE_RIGHT: u32 = 2;
pub const ESB_DISABLE_UP: u32 = 1;
pub const ESB_DISABLE_DOWN: u32 = 2;
pub const ESB_DISABLE_LTUP: u32 = 1;
pub const ESB_DISABLE_RTDN: u32 = 2;
pub const HELPINFO_WINDOW: u32 = 1;
pub const HELPINFO_MENUITEM: u32 = 2;
pub const MB_OK: u32 = 0;
pub const MB_OKCANCEL: u32 = 1;
pub const MB_ABORTRETRYIGNORE: u32 = 2;
pub const MB_YESNOCANCEL: u32 = 3;
pub const MB_YESNO: u32 = 4;
pub const MB_RETRYCANCEL: u32 = 5;
pub const MB_CANCELTRYCONTINUE: u32 = 6;
pub const MB_ICONHAND: u32 = 16;
pub const MB_ICONQUESTION: u32 = 32;
pub const MB_ICONEXCLAMATION: u32 = 48;
pub const MB_ICONASTERISK: u32 = 64;
pub const MB_USERICON: u32 = 128;
pub const MB_ICONWARNING: u32 = 48;
pub const MB_ICONERROR: u32 = 16;
pub const MB_ICONINFORMATION: u32 = 64;
pub const MB_ICONSTOP: u32 = 16;
pub const MB_DEFBUTTON1: u32 = 0;
pub const MB_DEFBUTTON2: u32 = 256;
pub const MB_DEFBUTTON3: u32 = 512;
pub const MB_DEFBUTTON4: u32 = 768;
pub const MB_APPLMODAL: u32 = 0;
pub const MB_SYSTEMMODAL: u32 = 4096;
pub const MB_TASKMODAL: u32 = 8192;
pub const MB_HELP: u32 = 16384;
pub const MB_NOFOCUS: u32 = 32768;
pub const MB_SETFOREGROUND: u32 = 65536;
pub const MB_DEFAULT_DESKTOP_ONLY: u32 = 131072;
pub const MB_TOPMOST: u32 = 262144;
pub const MB_RIGHT: u32 = 524288;
pub const MB_RTLREADING: u32 = 1048576;
pub const MB_SERVICE_NOTIFICATION: u32 = 2097152;
pub const MB_SERVICE_NOTIFICATION_NT3X: u32 = 262144;
pub const MB_TYPEMASK: u32 = 15;
pub const MB_ICONMASK: u32 = 240;
pub const MB_DEFMASK: u32 = 3840;
pub const MB_MODEMASK: u32 = 12288;
pub const MB_MISCMASK: u32 = 49152;
pub const CWP_ALL: u32 = 0;
pub const CWP_SKIPINVISIBLE: u32 = 1;
pub const CWP_SKIPDISABLED: u32 = 2;
pub const CWP_SKIPTRANSPARENT: u32 = 4;
pub const CTLCOLOR_MSGBOX: u32 = 0;
pub const CTLCOLOR_EDIT: u32 = 1;
pub const CTLCOLOR_LISTBOX: u32 = 2;
pub const CTLCOLOR_BTN: u32 = 3;
pub const CTLCOLOR_DLG: u32 = 4;
pub const CTLCOLOR_SCROLLBAR: u32 = 5;
pub const CTLCOLOR_STATIC: u32 = 6;
pub const CTLCOLOR_MAX: u32 = 7;
pub const COLOR_SCROLLBAR: u32 = 0;
pub const COLOR_BACKGROUND: u32 = 1;
pub const COLOR_ACTIVECAPTION: u32 = 2;
pub const COLOR_INACTIVECAPTION: u32 = 3;
pub const COLOR_MENU: u32 = 4;
pub const COLOR_WINDOW: u32 = 5;
pub const COLOR_WINDOWFRAME: u32 = 6;
pub const COLOR_MENUTEXT: u32 = 7;
pub const COLOR_WINDOWTEXT: u32 = 8;
pub const COLOR_CAPTIONTEXT: u32 = 9;
pub const COLOR_ACTIVEBORDER: u32 = 10;
pub const COLOR_INACTIVEBORDER: u32 = 11;
pub const COLOR_APPWORKSPACE: u32 = 12;
pub const COLOR_HIGHLIGHT: u32 = 13;
pub const COLOR_HIGHLIGHTTEXT: u32 = 14;
pub const COLOR_BTNFACE: u32 = 15;
pub const COLOR_BTNSHADOW: u32 = 16;
pub const COLOR_GRAYTEXT: u32 = 17;
pub const COLOR_BTNTEXT: u32 = 18;
pub const COLOR_INACTIVECAPTIONTEXT: u32 = 19;
pub const COLOR_BTNHIGHLIGHT: u32 = 20;
pub const COLOR_3DDKSHADOW: u32 = 21;
pub const COLOR_3DLIGHT: u32 = 22;
pub const COLOR_INFOTEXT: u32 = 23;
pub const COLOR_INFOBK: u32 = 24;
pub const COLOR_HOTLIGHT: u32 = 26;
pub const COLOR_GRADIENTACTIVECAPTION: u32 = 27;
pub const COLOR_GRADIENTINACTIVECAPTION: u32 = 28;
pub const COLOR_MENUHILIGHT: u32 = 29;
pub const COLOR_MENUBAR: u32 = 30;
pub const COLOR_DESKTOP: u32 = 1;
pub const COLOR_3DFACE: u32 = 15;
pub const COLOR_3DSHADOW: u32 = 16;
pub const COLOR_3DHIGHLIGHT: u32 = 20;
pub const COLOR_3DHILIGHT: u32 = 20;
pub const COLOR_BTNHILIGHT: u32 = 20;
pub const GW_HWNDFIRST: u32 = 0;
pub const GW_HWNDLAST: u32 = 1;
pub const GW_HWNDNEXT: u32 = 2;
pub const GW_HWNDPREV: u32 = 3;
pub const GW_OWNER: u32 = 4;
pub const GW_CHILD: u32 = 5;
pub const GW_ENABLEDPOPUP: u32 = 6;
pub const GW_MAX: u32 = 6;
pub const MF_INSERT: u32 = 0;
pub const MF_CHANGE: u32 = 128;
pub const MF_APPEND: u32 = 256;
pub const MF_DELETE: u32 = 512;
pub const MF_REMOVE: u32 = 4096;
pub const MF_BYCOMMAND: u32 = 0;
pub const MF_BYPOSITION: u32 = 1024;
pub const MF_SEPARATOR: u32 = 2048;
pub const MF_ENABLED: u32 = 0;
pub const MF_GRAYED: u32 = 1;
pub const MF_DISABLED: u32 = 2;
pub const MF_UNCHECKED: u32 = 0;
pub const MF_CHECKED: u32 = 8;
pub const MF_USECHECKBITMAPS: u32 = 512;
pub const MF_STRING: u32 = 0;
pub const MF_BITMAP: u32 = 4;
pub const MF_OWNERDRAW: u32 = 256;
pub const MF_POPUP: u32 = 16;
pub const MF_MENUBARBREAK: u32 = 32;
pub const MF_MENUBREAK: u32 = 64;
pub const MF_UNHILITE: u32 = 0;
pub const MF_HILITE: u32 = 128;
pub const MF_DEFAULT: u32 = 4096;
pub const MF_SYSMENU: u32 = 8192;
pub const MF_HELP: u32 = 16384;
pub const MF_RIGHTJUSTIFY: u32 = 16384;
pub const MF_MOUSESELECT: u32 = 32768;
pub const MF_END: u32 = 128;
pub const MFT_STRING: u32 = 0;
pub const MFT_BITMAP: u32 = 4;
pub const MFT_MENUBARBREAK: u32 = 32;
pub const MFT_MENUBREAK: u32 = 64;
pub const MFT_OWNERDRAW: u32 = 256;
pub const MFT_RADIOCHECK: u32 = 512;
pub const MFT_SEPARATOR: u32 = 2048;
pub const MFT_RIGHTORDER: u32 = 8192;
pub const MFT_RIGHTJUSTIFY: u32 = 16384;
pub const MFS_GRAYED: u32 = 3;
pub const MFS_DISABLED: u32 = 3;
pub const MFS_CHECKED: u32 = 8;
pub const MFS_HILITE: u32 = 128;
pub const MFS_ENABLED: u32 = 0;
pub const MFS_UNCHECKED: u32 = 0;
pub const MFS_UNHILITE: u32 = 0;
pub const MFS_DEFAULT: u32 = 4096;
pub const SC_SIZE: u32 = 61440;
pub const SC_MOVE: u32 = 61456;
pub const SC_MINIMIZE: u32 = 61472;
pub const SC_MAXIMIZE: u32 = 61488;
pub const SC_NEXTWINDOW: u32 = 61504;
pub const SC_PREVWINDOW: u32 = 61520;
pub const SC_CLOSE: u32 = 61536;
pub const SC_VSCROLL: u32 = 61552;
pub const SC_HSCROLL: u32 = 61568;
pub const SC_MOUSEMENU: u32 = 61584;
pub const SC_KEYMENU: u32 = 61696;
pub const SC_ARRANGE: u32 = 61712;
pub const SC_RESTORE: u32 = 61728;
pub const SC_TASKLIST: u32 = 61744;
pub const SC_SCREENSAVE: u32 = 61760;
pub const SC_HOTKEY: u32 = 61776;
pub const SC_DEFAULT: u32 = 61792;
pub const SC_MONITORPOWER: u32 = 61808;
pub const SC_CONTEXTHELP: u32 = 61824;
pub const SC_SEPARATOR: u32 = 61455;
pub const SCF_ISSECURE: u32 = 1;
pub const SC_ICON: u32 = 61472;
pub const SC_ZOOM: u32 = 61488;
pub const IMAGE_BITMAP: u32 = 0;
pub const IMAGE_ICON: u32 = 1;
pub const IMAGE_CURSOR: u32 = 2;
pub const IMAGE_ENHMETAFILE: u32 = 3;
pub const LR_DEFAULTCOLOR: u32 = 0;
pub const LR_MONOCHROME: u32 = 1;
pub const LR_COLOR: u32 = 2;
pub const LR_COPYRETURNORG: u32 = 4;
pub const LR_COPYDELETEORG: u32 = 8;
pub const LR_LOADFROMFILE: u32 = 16;
pub const LR_LOADTRANSPARENT: u32 = 32;
pub const LR_DEFAULTSIZE: u32 = 64;
pub const LR_VGACOLOR: u32 = 128;
pub const LR_LOADMAP3DCOLORS: u32 = 4096;
pub const LR_CREATEDIBSECTION: u32 = 8192;
pub const LR_COPYFROMRESOURCE: u32 = 16384;
pub const LR_SHARED: u32 = 32768;
pub const DI_MASK: u32 = 1;
pub const DI_IMAGE: u32 = 2;
pub const DI_NORMAL: u32 = 3;
pub const DI_COMPAT: u32 = 4;
pub const DI_DEFAULTSIZE: u32 = 8;
pub const DI_NOMIRROR: u32 = 16;
pub const RES_ICON: u32 = 1;
pub const RES_CURSOR: u32 = 2;
pub const ORD_LANGDRIVER: u32 = 1;
pub const IDOK: u32 = 1;
pub const IDCANCEL: u32 = 2;
pub const IDABORT: u32 = 3;
pub const IDRETRY: u32 = 4;
pub const IDIGNORE: u32 = 5;
pub const IDYES: u32 = 6;
pub const IDNO: u32 = 7;
pub const IDCLOSE: u32 = 8;
pub const IDHELP: u32 = 9;
pub const IDTRYAGAIN: u32 = 10;
pub const IDCONTINUE: u32 = 11;
pub const IDTIMEOUT: u32 = 32000;
pub const ES_LEFT: u32 = 0;
pub const ES_CENTER: u32 = 1;
pub const ES_RIGHT: u32 = 2;
pub const ES_MULTILINE: u32 = 4;
pub const ES_UPPERCASE: u32 = 8;
pub const ES_LOWERCASE: u32 = 16;
pub const ES_PASSWORD: u32 = 32;
pub const ES_AUTOVSCROLL: u32 = 64;
pub const ES_AUTOHSCROLL: u32 = 128;
pub const ES_NOHIDESEL: u32 = 256;
pub const ES_OEMCONVERT: u32 = 1024;
pub const ES_READONLY: u32 = 2048;
pub const ES_WANTRETURN: u32 = 4096;
pub const ES_NUMBER: u32 = 8192;
pub const EN_SETFOCUS: u32 = 256;
pub const EN_KILLFOCUS: u32 = 512;
pub const EN_CHANGE: u32 = 768;
pub const EN_UPDATE: u32 = 1024;
pub const EN_ERRSPACE: u32 = 1280;
pub const EN_MAXTEXT: u32 = 1281;
pub const EN_HSCROLL: u32 = 1537;
pub const EN_VSCROLL: u32 = 1538;
pub const EN_ALIGN_LTR_EC: u32 = 1792;
pub const EN_ALIGN_RTL_EC: u32 = 1793;
pub const EN_BEFORE_PASTE: u32 = 2048;
pub const EN_AFTER_PASTE: u32 = 2049;
pub const EC_LEFTMARGIN: u32 = 1;
pub const EC_RIGHTMARGIN: u32 = 2;
pub const EC_USEFONTINFO: u32 = 65535;
pub const EMSIS_COMPOSITIONSTRING: u32 = 1;
pub const EIMES_GETCOMPSTRATONCE: u32 = 1;
pub const EIMES_CANCELCOMPSTRINFOCUS: u32 = 2;
pub const EIMES_COMPLETECOMPSTRKILLFOCUS: u32 = 4;
pub const EM_GETSEL: u32 = 176;
pub const EM_SETSEL: u32 = 177;
pub const EM_GETRECT: u32 = 178;
pub const EM_SETRECT: u32 = 179;
pub const EM_SETRECTNP: u32 = 180;
pub const EM_SCROLL: u32 = 181;
pub const EM_LINESCROLL: u32 = 182;
pub const EM_SCROLLCARET: u32 = 183;
pub const EM_GETMODIFY: u32 = 184;
pub const EM_SETMODIFY: u32 = 185;
pub const EM_GETLINECOUNT: u32 = 186;
pub const EM_LINEINDEX: u32 = 187;
pub const EM_SETHANDLE: u32 = 188;
pub const EM_GETHANDLE: u32 = 189;
pub const EM_GETTHUMB: u32 = 190;
pub const EM_LINELENGTH: u32 = 193;
pub const EM_REPLACESEL: u32 = 194;
pub const EM_GETLINE: u32 = 196;
pub const EM_LIMITTEXT: u32 = 197;
pub const EM_CANUNDO: u32 = 198;
pub const EM_UNDO: u32 = 199;
pub const EM_FMTLINES: u32 = 200;
pub const EM_LINEFROMCHAR: u32 = 201;
pub const EM_SETTABSTOPS: u32 = 203;
pub const EM_SETPASSWORDCHAR: u32 = 204;
pub const EM_EMPTYUNDOBUFFER: u32 = 205;
pub const EM_GETFIRSTVISIBLELINE: u32 = 206;
pub const EM_SETREADONLY: u32 = 207;
pub const EM_SETWORDBREAKPROC: u32 = 208;
pub const EM_GETWORDBREAKPROC: u32 = 209;
pub const EM_GETPASSWORDCHAR: u32 = 210;
pub const EM_SETMARGINS: u32 = 211;
pub const EM_GETMARGINS: u32 = 212;
pub const EM_SETLIMITTEXT: u32 = 197;
pub const EM_GETLIMITTEXT: u32 = 213;
pub const EM_POSFROMCHAR: u32 = 214;
pub const EM_CHARFROMPOS: u32 = 215;
pub const EM_SETIMESTATUS: u32 = 216;
pub const EM_GETIMESTATUS: u32 = 217;
pub const EM_ENABLEFEATURE: u32 = 218;
pub const WB_LEFT: u32 = 0;
pub const WB_RIGHT: u32 = 1;
pub const WB_ISDELIMITER: u32 = 2;
pub const BS_PUSHBUTTON: u32 = 0;
pub const BS_DEFPUSHBUTTON: u32 = 1;
pub const BS_CHECKBOX: u32 = 2;
pub const BS_AUTOCHECKBOX: u32 = 3;
pub const BS_RADIOBUTTON: u32 = 4;
pub const BS_3STATE: u32 = 5;
pub const BS_AUTO3STATE: u32 = 6;
pub const BS_GROUPBOX: u32 = 7;
pub const BS_USERBUTTON: u32 = 8;
pub const BS_AUTORADIOBUTTON: u32 = 9;
pub const BS_PUSHBOX: u32 = 10;
pub const BS_OWNERDRAW: u32 = 11;
pub const BS_TYPEMASK: u32 = 15;
pub const BS_LEFTTEXT: u32 = 32;
pub const BS_TEXT: u32 = 0;
pub const BS_ICON: u32 = 64;
pub const BS_BITMAP: u32 = 128;
pub const BS_LEFT: u32 = 256;
pub const BS_RIGHT: u32 = 512;
pub const BS_CENTER: u32 = 768;
pub const BS_TOP: u32 = 1024;
pub const BS_BOTTOM: u32 = 2048;
pub const BS_VCENTER: u32 = 3072;
pub const BS_PUSHLIKE: u32 = 4096;
pub const BS_MULTILINE: u32 = 8192;
pub const BS_NOTIFY: u32 = 16384;
pub const BS_FLAT: u32 = 32768;
pub const BS_RIGHTBUTTON: u32 = 32;
pub const BN_CLICKED: u32 = 0;
pub const BN_PAINT: u32 = 1;
pub const BN_HILITE: u32 = 2;
pub const BN_UNHILITE: u32 = 3;
pub const BN_DISABLE: u32 = 4;
pub const BN_DOUBLECLICKED: u32 = 5;
pub const BN_PUSHED: u32 = 2;
pub const BN_UNPUSHED: u32 = 3;
pub const BN_DBLCLK: u32 = 5;
pub const BN_SETFOCUS: u32 = 6;
pub const BN_KILLFOCUS: u32 = 7;
pub const BM_GETCHECK: u32 = 240;
pub const BM_SETCHECK: u32 = 241;
pub const BM_GETSTATE: u32 = 242;
pub const BM_SETSTATE: u32 = 243;
pub const BM_SETSTYLE: u32 = 244;
pub const BM_CLICK: u32 = 245;
pub const BM_GETIMAGE: u32 = 246;
pub const BM_SETIMAGE: u32 = 247;
pub const BM_SETDONTCLICK: u32 = 248;
pub const BST_UNCHECKED: u32 = 0;
pub const BST_CHECKED: u32 = 1;
pub const BST_INDETERMINATE: u32 = 2;
pub const BST_PUSHED: u32 = 4;
pub const BST_FOCUS: u32 = 8;
pub const SS_LEFT: u32 = 0;
pub const SS_CENTER: u32 = 1;
pub const SS_RIGHT: u32 = 2;
pub const SS_ICON: u32 = 3;
pub const SS_BLACKRECT: u32 = 4;
pub const SS_GRAYRECT: u32 = 5;
pub const SS_WHITERECT: u32 = 6;
pub const SS_BLACKFRAME: u32 = 7;
pub const SS_GRAYFRAME: u32 = 8;
pub const SS_WHITEFRAME: u32 = 9;
pub const SS_USERITEM: u32 = 10;
pub const SS_SIMPLE: u32 = 11;
pub const SS_LEFTNOWORDWRAP: u32 = 12;
pub const SS_OWNERDRAW: u32 = 13;
pub const SS_BITMAP: u32 = 14;
pub const SS_ENHMETAFILE: u32 = 15;
pub const SS_ETCHEDHORZ: u32 = 16;
pub const SS_ETCHEDVERT: u32 = 17;
pub const SS_ETCHEDFRAME: u32 = 18;
pub const SS_TYPEMASK: u32 = 31;
pub const SS_REALSIZECONTROL: u32 = 64;
pub const SS_NOPREFIX: u32 = 128;
pub const SS_NOTIFY: u32 = 256;
pub const SS_CENTERIMAGE: u32 = 512;
pub const SS_RIGHTJUST: u32 = 1024;
pub const SS_REALSIZEIMAGE: u32 = 2048;
pub const SS_SUNKEN: u32 = 4096;
pub const SS_EDITCONTROL: u32 = 8192;
pub const SS_ENDELLIPSIS: u32 = 16384;
pub const SS_PATHELLIPSIS: u32 = 32768;
pub const SS_WORDELLIPSIS: u32 = 49152;
pub const SS_ELLIPSISMASK: u32 = 49152;
pub const STM_SETICON: u32 = 368;
pub const STM_GETICON: u32 = 369;
pub const STM_SETIMAGE: u32 = 370;
pub const STM_GETIMAGE: u32 = 371;
pub const STN_CLICKED: u32 = 0;
pub const STN_DBLCLK: u32 = 1;
pub const STN_ENABLE: u32 = 2;
pub const STN_DISABLE: u32 = 3;
pub const STM_MSGMAX: u32 = 372;
pub const DWL_MSGRESULT: u32 = 0;
pub const DWL_DLGPROC: u32 = 4;
pub const DWL_USER: u32 = 8;
pub const DWLP_MSGRESULT: u32 = 0;
pub const DDL_READWRITE: u32 = 0;
pub const DDL_READONLY: u32 = 1;
pub const DDL_HIDDEN: u32 = 2;
pub const DDL_SYSTEM: u32 = 4;
pub const DDL_DIRECTORY: u32 = 16;
pub const DDL_ARCHIVE: u32 = 32;
pub const DDL_POSTMSGS: u32 = 8192;
pub const DDL_DRIVES: u32 = 16384;
pub const DDL_EXCLUSIVE: u32 = 32768;
pub const DS_ABSALIGN: u32 = 1;
pub const DS_SYSMODAL: u32 = 2;
pub const DS_LOCALEDIT: u32 = 32;
pub const DS_SETFONT: u32 = 64;
pub const DS_MODALFRAME: u32 = 128;
pub const DS_NOIDLEMSG: u32 = 256;
pub const DS_SETFOREGROUND: u32 = 512;
pub const DS_3DLOOK: u32 = 4;
pub const DS_FIXEDSYS: u32 = 8;
pub const DS_NOFAILCREATE: u32 = 16;
pub const DS_CONTROL: u32 = 1024;
pub const DS_CENTER: u32 = 2048;
pub const DS_CENTERMOUSE: u32 = 4096;
pub const DS_CONTEXTHELP: u32 = 8192;
pub const DS_SHELLFONT: u32 = 72;
pub const DM_GETDEFID: u32 = 1024;
pub const DM_SETDEFID: u32 = 1025;
pub const DM_REPOSITION: u32 = 1026;
pub const DC_HASDEFID: u32 = 21323;
pub const DLGC_WANTARROWS: u32 = 1;
pub const DLGC_WANTTAB: u32 = 2;
pub const DLGC_WANTALLKEYS: u32 = 4;
pub const DLGC_WANTMESSAGE: u32 = 4;
pub const DLGC_HASSETSEL: u32 = 8;
pub const DLGC_DEFPUSHBUTTON: u32 = 16;
pub const DLGC_UNDEFPUSHBUTTON: u32 = 32;
pub const DLGC_RADIOBUTTON: u32 = 64;
pub const DLGC_WANTCHARS: u32 = 128;
pub const DLGC_STATIC: u32 = 256;
pub const DLGC_BUTTON: u32 = 8192;
pub const LB_CTLCODE: u32 = 0;
pub const LB_OKAY: u32 = 0;
pub const LB_ERR: i32 = -1;
pub const LB_ERRSPACE: i32 = -2;
pub const LBN_ERRSPACE: i32 = -2;
pub const LBN_SELCHANGE: u32 = 1;
pub const LBN_DBLCLK: u32 = 2;
pub const LBN_SELCANCEL: u32 = 3;
pub const LBN_SETFOCUS: u32 = 4;
pub const LBN_KILLFOCUS: u32 = 5;
pub const LB_ADDSTRING: u32 = 384;
pub const LB_INSERTSTRING: u32 = 385;
pub const LB_DELETESTRING: u32 = 386;
pub const LB_SELITEMRANGEEX: u32 = 387;
pub const LB_RESETCONTENT: u32 = 388;
pub const LB_SETSEL: u32 = 389;
pub const LB_SETCURSEL: u32 = 390;
pub const LB_GETSEL: u32 = 391;
pub const LB_GETCURSEL: u32 = 392;
pub const LB_GETTEXT: u32 = 393;
pub const LB_GETTEXTLEN: u32 = 394;
pub const LB_GETCOUNT: u32 = 395;
pub const LB_SELECTSTRING: u32 = 396;
pub const LB_DIR: u32 = 397;
pub const LB_GETTOPINDEX: u32 = 398;
pub const LB_FINDSTRING: u32 = 399;
pub const LB_GETSELCOUNT: u32 = 400;
pub const LB_GETSELITEMS: u32 = 401;
pub const LB_SETTABSTOPS: u32 = 402;
pub const LB_GETHORIZONTALEXTENT: u32 = 403;
pub const LB_SETHORIZONTALEXTENT: u32 = 404;
pub const LB_SETCOLUMNWIDTH: u32 = 405;
pub const LB_ADDFILE: u32 = 406;
pub const LB_SETTOPINDEX: u32 = 407;
pub const LB_GETITEMRECT: u32 = 408;
pub const LB_GETITEMDATA: u32 = 409;
pub const LB_SETITEMDATA: u32 = 410;
pub const LB_SELITEMRANGE: u32 = 411;
pub const LB_SETANCHORINDEX: u32 = 412;
pub const LB_GETANCHORINDEX: u32 = 413;
pub const LB_SETCARETINDEX: u32 = 414;
pub const LB_GETCARETINDEX: u32 = 415;
pub const LB_SETITEMHEIGHT: u32 = 416;
pub const LB_GETITEMHEIGHT: u32 = 417;
pub const LB_FINDSTRINGEXACT: u32 = 418;
pub const LB_SETLOCALE: u32 = 421;
pub const LB_GETLOCALE: u32 = 422;
pub const LB_SETCOUNT: u32 = 423;
pub const LB_INITSTORAGE: u32 = 424;
pub const LB_ITEMFROMPOINT: u32 = 425;
pub const LB_GETLISTBOXINFO: u32 = 434;
pub const LB_MSGMAX: u32 = 435;
pub const LBS_NOTIFY: u32 = 1;
pub const LBS_SORT: u32 = 2;
pub const LBS_NOREDRAW: u32 = 4;
pub const LBS_MULTIPLESEL: u32 = 8;
pub const LBS_OWNERDRAWFIXED: u32 = 16;
pub const LBS_OWNERDRAWVARIABLE: u32 = 32;
pub const LBS_HASSTRINGS: u32 = 64;
pub const LBS_USETABSTOPS: u32 = 128;
pub const LBS_NOINTEGRALHEIGHT: u32 = 256;
pub const LBS_MULTICOLUMN: u32 = 512;
pub const LBS_WANTKEYBOARDINPUT: u32 = 1024;
pub const LBS_EXTENDEDSEL: u32 = 2048;
pub const LBS_DISABLENOSCROLL: u32 = 4096;
pub const LBS_NODATA: u32 = 8192;
pub const LBS_NOSEL: u32 = 16384;
pub const LBS_COMBOBOX: u32 = 32768;
pub const LBS_STANDARD: u32 = 10485763;
pub const CB_OKAY: u32 = 0;
pub const CB_ERR: i32 = -1;
pub const CB_ERRSPACE: i32 = -2;
pub const CBN_ERRSPACE: i32 = -1;
pub const CBN_SELCHANGE: u32 = 1;
pub const CBN_DBLCLK: u32 = 2;
pub const CBN_SETFOCUS: u32 = 3;
pub const CBN_KILLFOCUS: u32 = 4;
pub const CBN_EDITCHANGE: u32 = 5;
pub const CBN_EDITUPDATE: u32 = 6;
pub const CBN_DROPDOWN: u32 = 7;
pub const CBN_CLOSEUP: u32 = 8;
pub const CBN_SELENDOK: u32 = 9;
pub const CBN_SELENDCANCEL: u32 = 10;
pub const CBS_SIMPLE: u32 = 1;
pub const CBS_DROPDOWN: u32 = 2;
pub const CBS_DROPDOWNLIST: u32 = 3;
pub const CBS_OWNERDRAWFIXED: u32 = 16;
pub const CBS_OWNERDRAWVARIABLE: u32 = 32;
pub const CBS_AUTOHSCROLL: u32 = 64;
pub const CBS_OEMCONVERT: u32 = 128;
pub const CBS_SORT: u32 = 256;
pub const CBS_HASSTRINGS: u32 = 512;
pub const CBS_NOINTEGRALHEIGHT: u32 = 1024;
pub const CBS_DISABLENOSCROLL: u32 = 2048;
pub const CBS_UPPERCASE: u32 = 8192;
pub const CBS_LOWERCASE: u32 = 16384;
pub const CB_GETEDITSEL: u32 = 320;
pub const CB_LIMITTEXT: u32 = 321;
pub const CB_SETEDITSEL: u32 = 322;
pub const CB_ADDSTRING: u32 = 323;
pub const CB_DELETESTRING: u32 = 324;
pub const CB_DIR: u32 = 325;
pub const CB_GETCOUNT: u32 = 326;
pub const CB_GETCURSEL: u32 = 327;
pub const CB_GETLBTEXT: u32 = 328;
pub const CB_GETLBTEXTLEN: u32 = 329;
pub const CB_INSERTSTRING: u32 = 330;
pub const CB_RESETCONTENT: u32 = 331;
pub const CB_FINDSTRING: u32 = 332;
pub const CB_SELECTSTRING: u32 = 333;
pub const CB_SETCURSEL: u32 = 334;
pub const CB_SHOWDROPDOWN: u32 = 335;
pub const CB_GETITEMDATA: u32 = 336;
pub const CB_SETITEMDATA: u32 = 337;
pub const CB_GETDROPPEDCONTROLRECT: u32 = 338;
pub const CB_SETITEMHEIGHT: u32 = 339;
pub const CB_GETITEMHEIGHT: u32 = 340;
pub const CB_SETEXTENDEDUI: u32 = 341;
pub const CB_GETEXTENDEDUI: u32 = 342;
pub const CB_GETDROPPEDSTATE: u32 = 343;
pub const CB_FINDSTRINGEXACT: u32 = 344;
pub const CB_SETLOCALE: u32 = 345;
pub const CB_GETLOCALE: u32 = 346;
pub const CB_GETTOPINDEX: u32 = 347;
pub const CB_SETTOPINDEX: u32 = 348;
pub const CB_GETHORIZONTALEXTENT: u32 = 349;
pub const CB_SETHORIZONTALEXTENT: u32 = 350;
pub const CB_GETDROPPEDWIDTH: u32 = 351;
pub const CB_SETDROPPEDWIDTH: u32 = 352;
pub const CB_INITSTORAGE: u32 = 353;
pub const CB_GETCOMBOBOXINFO: u32 = 356;
pub const CB_MSGMAX: u32 = 357;
pub const SBS_HORZ: u32 = 0;
pub const SBS_VERT: u32 = 1;
pub const SBS_TOPALIGN: u32 = 2;
pub const SBS_LEFTALIGN: u32 = 2;
pub const SBS_BOTTOMALIGN: u32 = 4;
pub const SBS_RIGHTALIGN: u32 = 4;
pub const SBS_SIZEBOXTOPLEFTALIGN: u32 = 2;
pub const SBS_SIZEBOXBOTTOMRIGHTALIGN: u32 = 4;
pub const SBS_SIZEBOX: u32 = 8;
pub const SBS_SIZEGRIP: u32 = 16;
pub const SBM_SETPOS: u32 = 224;
pub const SBM_GETPOS: u32 = 225;
pub const SBM_SETRANGE: u32 = 226;
pub const SBM_SETRANGEREDRAW: u32 = 230;
pub const SBM_GETRANGE: u32 = 227;
pub const SBM_ENABLE_ARROWS: u32 = 228;
pub const SBM_SETSCROLLINFO: u32 = 233;
pub const SBM_GETSCROLLINFO: u32 = 234;
pub const SBM_GETSCROLLBARINFO: u32 = 235;
pub const SIF_RANGE: u32 = 1;
pub const SIF_PAGE: u32 = 2;
pub const SIF_POS: u32 = 4;
pub const SIF_DISABLENOSCROLL: u32 = 8;
pub const SIF_TRACKPOS: u32 = 16;
pub const SIF_ALL: u32 = 23;
pub const MDIS_ALLCHILDSTYLES: u32 = 1;
pub const MDITILE_VERTICAL: u32 = 0;
pub const MDITILE_HORIZONTAL: u32 = 1;
pub const MDITILE_SKIPDISABLED: u32 = 2;
pub const MDITILE_ZORDER: u32 = 4;
pub const HELP_CONTEXT: u32 = 1;
pub const HELP_QUIT: u32 = 2;
pub const HELP_INDEX: u32 = 3;
pub const HELP_CONTENTS: u32 = 3;
pub const HELP_HELPONHELP: u32 = 4;
pub const HELP_SETINDEX: u32 = 5;
pub const HELP_SETCONTENTS: u32 = 5;
pub const HELP_CONTEXTPOPUP: u32 = 8;
pub const HELP_FORCEFILE: u32 = 9;
pub const HELP_KEY: u32 = 257;
pub const HELP_COMMAND: u32 = 258;
pub const HELP_PARTIALKEY: u32 = 261;
pub const HELP_MULTIKEY: u32 = 513;
pub const HELP_SETWINPOS: u32 = 515;
pub const HELP_CONTEXTMENU: u32 = 10;
pub const HELP_FINDER: u32 = 11;
pub const HELP_WM_HELP: u32 = 12;
pub const HELP_SETPOPUP_POS: u32 = 13;
pub const HELP_TCARD: u32 = 32768;
pub const HELP_TCARD_DATA: u32 = 16;
pub const HELP_TCARD_OTHER_CALLER: u32 = 17;
pub const IDH_NO_HELP: u32 = 28440;
pub const IDH_MISSING_CONTEXT: u32 = 28441;
pub const IDH_GENERIC_HELP_BUTTON: u32 = 28442;
pub const IDH_OK: u32 = 28443;
pub const IDH_CANCEL: u32 = 28444;
pub const IDH_HELP: u32 = 28445;
pub const GR_GDIOBJECTS: u32 = 0;
pub const GR_USEROBJECTS: u32 = 1;
pub const GR_GDIOBJECTS_PEAK: u32 = 2;
pub const GR_USEROBJECTS_PEAK: u32 = 4;
pub const SPI_GETBEEP: u32 = 1;
pub const SPI_SETBEEP: u32 = 2;
pub const SPI_GETMOUSE: u32 = 3;
pub const SPI_SETMOUSE: u32 = 4;
pub const SPI_GETBORDER: u32 = 5;
pub const SPI_SETBORDER: u32 = 6;
pub const SPI_GETKEYBOARDSPEED: u32 = 10;
pub const SPI_SETKEYBOARDSPEED: u32 = 11;
pub const SPI_LANGDRIVER: u32 = 12;
pub const SPI_ICONHORIZONTALSPACING: u32 = 13;
pub const SPI_GETSCREENSAVETIMEOUT: u32 = 14;
pub const SPI_SETSCREENSAVETIMEOUT: u32 = 15;
pub const SPI_GETSCREENSAVEACTIVE: u32 = 16;
pub const SPI_SETSCREENSAVEACTIVE: u32 = 17;
pub const SPI_GETGRIDGRANULARITY: u32 = 18;
pub const SPI_SETGRIDGRANULARITY: u32 = 19;
pub const SPI_SETDESKWALLPAPER: u32 = 20;
pub const SPI_SETDESKPATTERN: u32 = 21;
pub const SPI_GETKEYBOARDDELAY: u32 = 22;
pub const SPI_SETKEYBOARDDELAY: u32 = 23;
pub const SPI_ICONVERTICALSPACING: u32 = 24;
pub const SPI_GETICONTITLEWRAP: u32 = 25;
pub const SPI_SETICONTITLEWRAP: u32 = 26;
pub const SPI_GETMENUDROPALIGNMENT: u32 = 27;
pub const SPI_SETMENUDROPALIGNMENT: u32 = 28;
pub const SPI_SETDOUBLECLKWIDTH: u32 = 29;
pub const SPI_SETDOUBLECLKHEIGHT: u32 = 30;
pub const SPI_GETICONTITLELOGFONT: u32 = 31;
pub const SPI_SETDOUBLECLICKTIME: u32 = 32;
pub const SPI_SETMOUSEBUTTONSWAP: u32 = 33;
pub const SPI_SETICONTITLELOGFONT: u32 = 34;
pub const SPI_GETFASTTASKSWITCH: u32 = 35;
pub const SPI_SETFASTTASKSWITCH: u32 = 36;
pub const SPI_SETDRAGFULLWINDOWS: u32 = 37;
pub const SPI_GETDRAGFULLWINDOWS: u32 = 38;
pub const SPI_GETNONCLIENTMETRICS: u32 = 41;
pub const SPI_SETNONCLIENTMETRICS: u32 = 42;
pub const SPI_GETMINIMIZEDMETRICS: u32 = 43;
pub const SPI_SETMINIMIZEDMETRICS: u32 = 44;
pub const SPI_GETICONMETRICS: u32 = 45;
pub const SPI_SETICONMETRICS: u32 = 46;
pub const SPI_SETWORKAREA: u32 = 47;
pub const SPI_GETWORKAREA: u32 = 48;
pub const SPI_SETPENWINDOWS: u32 = 49;
pub const SPI_GETHIGHCONTRAST: u32 = 66;
pub const SPI_SETHIGHCONTRAST: u32 = 67;
pub const SPI_GETKEYBOARDPREF: u32 = 68;
pub const SPI_SETKEYBOARDPREF: u32 = 69;
pub const SPI_GETSCREENREADER: u32 = 70;
pub const SPI_SETSCREENREADER: u32 = 71;
pub const SPI_GETANIMATION: u32 = 72;
pub const SPI_SETANIMATION: u32 = 73;
pub const SPI_GETFONTSMOOTHING: u32 = 74;
pub const SPI_SETFONTSMOOTHING: u32 = 75;
pub const SPI_SETDRAGWIDTH: u32 = 76;
pub const SPI_SETDRAGHEIGHT: u32 = 77;
pub const SPI_SETHANDHELD: u32 = 78;
pub const SPI_GETLOWPOWERTIMEOUT: u32 = 79;
pub const SPI_GETPOWEROFFTIMEOUT: u32 = 80;
pub const SPI_SETLOWPOWERTIMEOUT: u32 = 81;
pub const SPI_SETPOWEROFFTIMEOUT: u32 = 82;
pub const SPI_GETLOWPOWERACTIVE: u32 = 83;
pub const SPI_GETPOWEROFFACTIVE: u32 = 84;
pub const SPI_SETLOWPOWERACTIVE: u32 = 85;
pub const SPI_SETPOWEROFFACTIVE: u32 = 86;
pub const SPI_SETCURSORS: u32 = 87;
pub const SPI_SETICONS: u32 = 88;
pub const SPI_GETDEFAULTINPUTLANG: u32 = 89;
pub const SPI_SETDEFAULTINPUTLANG: u32 = 90;
pub const SPI_SETLANGTOGGLE: u32 = 91;
pub const SPI_GETWINDOWSEXTENSION: u32 = 92;
pub const SPI_SETMOUSETRAILS: u32 = 93;
pub const SPI_GETMOUSETRAILS: u32 = 94;
pub const SPI_SETSCREENSAVERRUNNING: u32 = 97;
pub const SPI_SCREENSAVERRUNNING: u32 = 97;
pub const SPI_GETFILTERKEYS: u32 = 50;
pub const SPI_SETFILTERKEYS: u32 = 51;
pub const SPI_GETTOGGLEKEYS: u32 = 52;
pub const SPI_SETTOGGLEKEYS: u32 = 53;
pub const SPI_GETMOUSEKEYS: u32 = 54;
pub const SPI_SETMOUSEKEYS: u32 = 55;
pub const SPI_GETSHOWSOUNDS: u32 = 56;
pub const SPI_SETSHOWSOUNDS: u32 = 57;
pub const SPI_GETSTICKYKEYS: u32 = 58;
pub const SPI_SETSTICKYKEYS: u32 = 59;
pub const SPI_GETACCESSTIMEOUT: u32 = 60;
pub const SPI_SETACCESSTIMEOUT: u32 = 61;
pub const SPI_GETSERIALKEYS: u32 = 62;
pub const SPI_SETSERIALKEYS: u32 = 63;
pub const SPI_GETSOUNDSENTRY: u32 = 64;
pub const SPI_SETSOUNDSENTRY: u32 = 65;
pub const SPI_GETSNAPTODEFBUTTON: u32 = 95;
pub const SPI_SETSNAPTODEFBUTTON: u32 = 96;
pub const SPI_GETMOUSEHOVERWIDTH: u32 = 98;
pub const SPI_SETMOUSEHOVERWIDTH: u32 = 99;
pub const SPI_GETMOUSEHOVERHEIGHT: u32 = 100;
pub const SPI_SETMOUSEHOVERHEIGHT: u32 = 101;
pub const SPI_GETMOUSEHOVERTIME: u32 = 102;
pub const SPI_SETMOUSEHOVERTIME: u32 = 103;
pub const SPI_GETWHEELSCROLLLINES: u32 = 104;
pub const SPI_SETWHEELSCROLLLINES: u32 = 105;
pub const SPI_GETMENUSHOWDELAY: u32 = 106;
pub const SPI_SETMENUSHOWDELAY: u32 = 107;
pub const SPI_GETWHEELSCROLLCHARS: u32 = 108;
pub const SPI_SETWHEELSCROLLCHARS: u32 = 109;
pub const SPI_GETSHOWIMEUI: u32 = 110;
pub const SPI_SETSHOWIMEUI: u32 = 111;
pub const SPI_GETMOUSESPEED: u32 = 112;
pub const SPI_SETMOUSESPEED: u32 = 113;
pub const SPI_GETSCREENSAVERRUNNING: u32 = 114;
pub const SPI_GETDESKWALLPAPER: u32 = 115;
pub const SPI_GETAUDIODESCRIPTION: u32 = 116;
pub const SPI_SETAUDIODESCRIPTION: u32 = 117;
pub const SPI_GETSCREENSAVESECURE: u32 = 118;
pub const SPI_SETSCREENSAVESECURE: u32 = 119;
pub const SPI_GETHUNGAPPTIMEOUT: u32 = 120;
pub const SPI_SETHUNGAPPTIMEOUT: u32 = 121;
pub const SPI_GETWAITTOKILLTIMEOUT: u32 = 122;
pub const SPI_SETWAITTOKILLTIMEOUT: u32 = 123;
pub const SPI_GETWAITTOKILLSERVICETIMEOUT: u32 = 124;
pub const SPI_SETWAITTOKILLSERVICETIMEOUT: u32 = 125;
pub const SPI_GETMOUSEDOCKTHRESHOLD: u32 = 126;
pub const SPI_SETMOUSEDOCKTHRESHOLD: u32 = 127;
pub const SPI_GETPENDOCKTHRESHOLD: u32 = 128;
pub const SPI_SETPENDOCKTHRESHOLD: u32 = 129;
pub const SPI_GETWINARRANGING: u32 = 130;
pub const SPI_SETWINARRANGING: u32 = 131;
pub const SPI_GETMOUSEDRAGOUTTHRESHOLD: u32 = 132;
pub const SPI_SETMOUSEDRAGOUTTHRESHOLD: u32 = 133;
pub const SPI_GETPENDRAGOUTTHRESHOLD: u32 = 134;
pub const SPI_SETPENDRAGOUTTHRESHOLD: u32 = 135;
pub const SPI_GETMOUSESIDEMOVETHRESHOLD: u32 = 136;
pub const SPI_SETMOUSESIDEMOVETHRESHOLD: u32 = 137;
pub const SPI_GETPENSIDEMOVETHRESHOLD: u32 = 138;
pub const SPI_SETPENSIDEMOVETHRESHOLD: u32 = 139;
pub const SPI_GETDRAGFROMMAXIMIZE: u32 = 140;
pub const SPI_SETDRAGFROMMAXIMIZE: u32 = 141;
pub const SPI_GETSNAPSIZING: u32 = 142;
pub const SPI_SETSNAPSIZING: u32 = 143;
pub const SPI_GETDOCKMOVING: u32 = 144;
pub const SPI_SETDOCKMOVING: u32 = 145;
pub const MAX_TOUCH_PREDICTION_FILTER_TAPS: u32 = 3;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY: u32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME: u32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP: u32 = 1;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_DELTA: f64 = 0.001;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN: f64 = 0.9;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX: f64 = 0.999;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE: f64 = 0.001;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA: f64 = 0.99;
pub const SPI_GETTOUCHPREDICTIONPARAMETERS: u32 = 156;
pub const SPI_SETTOUCHPREDICTIONPARAMETERS: u32 = 157;
pub const MAX_LOGICALDPIOVERRIDE: u32 = 2;
pub const MIN_LOGICALDPIOVERRIDE: i32 = -2;
pub const SPI_GETLOGICALDPIOVERRIDE: u32 = 158;
pub const SPI_SETLOGICALDPIOVERRIDE: u32 = 159;
pub const SPI_GETMENURECT: u32 = 162;
pub const SPI_SETMENURECT: u32 = 163;
pub const SPI_GETACTIVEWINDOWTRACKING: u32 = 4096;
pub const SPI_SETACTIVEWINDOWTRACKING: u32 = 4097;
pub const SPI_GETMENUANIMATION: u32 = 4098;
pub const SPI_SETMENUANIMATION: u32 = 4099;
pub const SPI_GETCOMBOBOXANIMATION: u32 = 4100;
pub const SPI_SETCOMBOBOXANIMATION: u32 = 4101;
pub const SPI_GETLISTBOXSMOOTHSCROLLING: u32 = 4102;
pub const SPI_SETLISTBOXSMOOTHSCROLLING: u32 = 4103;
pub const SPI_GETGRADIENTCAPTIONS: u32 = 4104;
pub const SPI_SETGRADIENTCAPTIONS: u32 = 4105;
pub const SPI_GETKEYBOARDCUES: u32 = 4106;
pub const SPI_SETKEYBOARDCUES: u32 = 4107;
pub const SPI_GETMENUUNDERLINES: u32 = 4106;
pub const SPI_SETMENUUNDERLINES: u32 = 4107;
pub const SPI_GETACTIVEWNDTRKZORDER: u32 = 4108;
pub const SPI_SETACTIVEWNDTRKZORDER: u32 = 4109;
pub const SPI_GETHOTTRACKING: u32 = 4110;
pub const SPI_SETHOTTRACKING: u32 = 4111;
pub const SPI_GETMENUFADE: u32 = 4114;
pub const SPI_SETMENUFADE: u32 = 4115;
pub const SPI_GETSELECTIONFADE: u32 = 4116;
pub const SPI_SETSELECTIONFADE: u32 = 4117;
pub const SPI_GETTOOLTIPANIMATION: u32 = 4118;
pub const SPI_SETTOOLTIPANIMATION: u32 = 4119;
pub const SPI_GETTOOLTIPFADE: u32 = 4120;
pub const SPI_SETTOOLTIPFADE: u32 = 4121;
pub const SPI_GETCURSORSHADOW: u32 = 4122;
pub const SPI_SETCURSORSHADOW: u32 = 4123;
pub const SPI_GETMOUSESONAR: u32 = 4124;
pub const SPI_SETMOUSESONAR: u32 = 4125;
pub const SPI_GETMOUSECLICKLOCK: u32 = 4126;
pub const SPI_SETMOUSECLICKLOCK: u32 = 4127;
pub const SPI_GETMOUSEVANISH: u32 = 4128;
pub const SPI_SETMOUSEVANISH: u32 = 4129;
pub const SPI_GETFLATMENU: u32 = 4130;
pub const SPI_SETFLATMENU: u32 = 4131;
pub const SPI_GETDROPSHADOW: u32 = 4132;
pub const SPI_SETDROPSHADOW: u32 = 4133;
pub const SPI_GETBLOCKSENDINPUTRESETS: u32 = 4134;
pub const SPI_SETBLOCKSENDINPUTRESETS: u32 = 4135;
pub const SPI_GETUIEFFECTS: u32 = 4158;
pub const SPI_SETUIEFFECTS: u32 = 4159;
pub const SPI_GETDISABLEOVERLAPPEDCONTENT: u32 = 4160;
pub const SPI_SETDISABLEOVERLAPPEDCONTENT: u32 = 4161;
pub const SPI_GETCLIENTAREAANIMATION: u32 = 4162;
pub const SPI_SETCLIENTAREAANIMATION: u32 = 4163;
pub const SPI_GETCLEARTYPE: u32 = 4168;
pub const SPI_SETCLEARTYPE: u32 = 4169;
pub const SPI_GETSPEECHRECOGNITION: u32 = 4170;
pub const SPI_SETSPEECHRECOGNITION: u32 = 4171;
pub const SPI_GETCARETBROWSING: u32 = 4172;
pub const SPI_SETCARETBROWSING: u32 = 4173;
pub const SPI_GETTHREADLOCALINPUTSETTINGS: u32 = 4174;
pub const SPI_SETTHREADLOCALINPUTSETTINGS: u32 = 4175;
pub const SPI_GETSYSTEMLANGUAGEBAR: u32 = 4176;
pub const SPI_SETSYSTEMLANGUAGEBAR: u32 = 4177;
pub const SPI_GETFOREGROUNDLOCKTIMEOUT: u32 = 8192;
pub const SPI_SETFOREGROUNDLOCKTIMEOUT: u32 = 8193;
pub const SPI_GETACTIVEWNDTRKTIMEOUT: u32 = 8194;
pub const SPI_SETACTIVEWNDTRKTIMEOUT: u32 = 8195;
pub const SPI_GETFOREGROUNDFLASHCOUNT: u32 = 8196;
pub const SPI_SETFOREGROUNDFLASHCOUNT: u32 = 8197;
pub const SPI_GETCARETWIDTH: u32 = 8198;
pub const SPI_SETCARETWIDTH: u32 = 8199;
pub const SPI_GETMOUSECLICKLOCKTIME: u32 = 8200;
pub const SPI_SETMOUSECLICKLOCKTIME: u32 = 8201;
pub const SPI_GETFONTSMOOTHINGTYPE: u32 = 8202;
pub const SPI_SETFONTSMOOTHINGTYPE: u32 = 8203;
pub const FE_FONTSMOOTHINGSTANDARD: u32 = 1;
pub const FE_FONTSMOOTHINGCLEARTYPE: u32 = 2;
pub const SPI_GETFONTSMOOTHINGCONTRAST: u32 = 8204;
pub const SPI_SETFONTSMOOTHINGCONTRAST: u32 = 8205;
pub const SPI_GETFOCUSBORDERWIDTH: u32 = 8206;
pub const SPI_SETFOCUSBORDERWIDTH: u32 = 8207;
pub const SPI_GETFOCUSBORDERHEIGHT: u32 = 8208;
pub const SPI_SETFOCUSBORDERHEIGHT: u32 = 8209;
pub const SPI_GETFONTSMOOTHINGORIENTATION: u32 = 8210;
pub const SPI_SETFONTSMOOTHINGORIENTATION: u32 = 8211;
pub const FE_FONTSMOOTHINGORIENTATIONBGR: u32 = 0;
pub const FE_FONTSMOOTHINGORIENTATIONRGB: u32 = 1;
pub const SPI_GETMINIMUMHITRADIUS: u32 = 8212;
pub const SPI_SETMINIMUMHITRADIUS: u32 = 8213;
pub const SPI_GETMESSAGEDURATION: u32 = 8214;
pub const SPI_SETMESSAGEDURATION: u32 = 8215;
pub const SPI_GETCONTACTVISUALIZATION: u32 = 8216;
pub const SPI_SETCONTACTVISUALIZATION: u32 = 8217;
pub const CONTACTVISUALIZATION_OFF: u32 = 0;
pub const CONTACTVISUALIZATION_ON: u32 = 1;
pub const CONTACTVISUALIZATION_PRESENTATIONMODE: u32 = 2;
pub const SPI_GETGESTUREVISUALIZATION: u32 = 8218;
pub const SPI_SETGESTUREVISUALIZATION: u32 = 8219;
pub const GESTUREVISUALIZATION_OFF: u32 = 0;
pub const GESTUREVISUALIZATION_ON: u32 = 31;
pub const GESTUREVISUALIZATION_TAP: u32 = 1;
pub const GESTUREVISUALIZATION_DOUBLETAP: u32 = 2;
pub const GESTUREVISUALIZATION_PRESSANDTAP: u32 = 4;
pub const GESTUREVISUALIZATION_PRESSANDHOLD: u32 = 8;
pub const GESTUREVISUALIZATION_RIGHTTAP: u32 = 16;
pub const SPI_GETMOUSEWHEELROUTING: u32 = 8220;
pub const SPI_SETMOUSEWHEELROUTING: u32 = 8221;
pub const MOUSEWHEEL_ROUTING_FOCUS: u32 = 0;
pub const MOUSEWHEEL_ROUTING_HYBRID: u32 = 1;
pub const MOUSEWHEEL_ROUTING_MOUSE_POS: u32 = 2;
pub const SPI_GETPENVISUALIZATION: u32 = 8222;
pub const SPI_SETPENVISUALIZATION: u32 = 8223;
pub const PENVISUALIZATION_ON: u32 = 35;
pub const PENVISUALIZATION_OFF: u32 = 0;
pub const PENVISUALIZATION_TAP: u32 = 1;
pub const PENVISUALIZATION_DOUBLETAP: u32 = 2;
pub const PENVISUALIZATION_CURSOR: u32 = 32;
pub const SPI_GETPENARBITRATIONTYPE: u32 = 8224;
pub const SPI_SETPENARBITRATIONTYPE: u32 = 8225;
pub const PENARBITRATIONTYPE_NONE: u32 = 0;
pub const PENARBITRATIONTYPE_WIN8: u32 = 1;
pub const PENARBITRATIONTYPE_FIS: u32 = 2;
pub const PENARBITRATIONTYPE_SPT: u32 = 3;
pub const PENARBITRATIONTYPE_MAX: u32 = 4;
pub const SPI_GETCARETTIMEOUT: u32 = 8226;
pub const SPI_SETCARETTIMEOUT: u32 = 8227;
pub const SPIF_UPDATEINIFILE: u32 = 1;
pub const SPIF_SENDWININICHANGE: u32 = 2;
pub const SPIF_SENDCHANGE: u32 = 2;
pub const METRICS_USEDEFAULT: i32 = -1;
pub const ARW_BOTTOMLEFT: u32 = 0;
pub const ARW_BOTTOMRIGHT: u32 = 1;
pub const ARW_TOPLEFT: u32 = 2;
pub const ARW_TOPRIGHT: u32 = 3;
pub const ARW_STARTMASK: u32 = 3;
pub const ARW_STARTRIGHT: u32 = 1;
pub const ARW_STARTTOP: u32 = 2;
pub const ARW_LEFT: u32 = 0;
pub const ARW_RIGHT: u32 = 0;
pub const ARW_UP: u32 = 4;
pub const ARW_DOWN: u32 = 4;
pub const ARW_HIDE: u32 = 8;
pub const SERKF_SERIALKEYSON: u32 = 1;
pub const SERKF_AVAILABLE: u32 = 2;
pub const SERKF_INDICATOR: u32 = 4;
pub const HCF_HIGHCONTRASTON: u32 = 1;
pub const HCF_AVAILABLE: u32 = 2;
pub const HCF_HOTKEYACTIVE: u32 = 4;
pub const HCF_CONFIRMHOTKEY: u32 = 8;
pub const HCF_HOTKEYSOUND: u32 = 16;
pub const HCF_INDICATOR: u32 = 32;
pub const HCF_HOTKEYAVAILABLE: u32 = 64;
pub const HCF_LOGONDESKTOP: u32 = 256;
pub const HCF_DEFAULTDESKTOP: u32 = 512;
pub const CDS_UPDATEREGISTRY: u32 = 1;
pub const CDS_TEST: u32 = 2;
pub const CDS_FULLSCREEN: u32 = 4;
pub const CDS_GLOBAL: u32 = 8;
pub const CDS_SET_PRIMARY: u32 = 16;
pub const CDS_VIDEOPARAMETERS: u32 = 32;
pub const CDS_ENABLE_UNSAFE_MODES: u32 = 256;
pub const CDS_DISABLE_UNSAFE_MODES: u32 = 512;
pub const CDS_RESET: u32 = 1073741824;
pub const CDS_RESET_EX: u32 = 536870912;
pub const CDS_NORESET: u32 = 268435456;
pub const VP_COMMAND_GET: u32 = 1;
pub const VP_COMMAND_SET: u32 = 2;
pub const VP_FLAGS_TV_MODE: u32 = 1;
pub const VP_FLAGS_TV_STANDARD: u32 = 2;
pub const VP_FLAGS_FLICKER: u32 = 4;
pub const VP_FLAGS_OVERSCAN: u32 = 8;
pub const VP_FLAGS_MAX_UNSCALED: u32 = 16;
pub const VP_FLAGS_POSITION: u32 = 32;
pub const VP_FLAGS_BRIGHTNESS: u32 = 64;
pub const VP_FLAGS_CONTRAST: u32 = 128;
pub const VP_FLAGS_COPYPROTECT: u32 = 256;
pub const VP_MODE_WIN_GRAPHICS: u32 = 1;
pub const VP_MODE_TV_PLAYBACK: u32 = 2;
pub const VP_TV_STANDARD_NTSC_M: u32 = 1;
pub const VP_TV_STANDARD_NTSC_M_J: u32 = 2;
pub const VP_TV_STANDARD_PAL_B: u32 = 4;
pub const VP_TV_STANDARD_PAL_D: u32 = 8;
pub const VP_TV_STANDARD_PAL_H: u32 = 16;
pub const VP_TV_STANDARD_PAL_I: u32 = 32;
pub const VP_TV_STANDARD_PAL_M: u32 = 64;
pub const VP_TV_STANDARD_PAL_N: u32 = 128;
pub const VP_TV_STANDARD_SECAM_B: u32 = 256;
pub const VP_TV_STANDARD_SECAM_D: u32 = 512;
pub const VP_TV_STANDARD_SECAM_G: u32 = 1024;
pub const VP_TV_STANDARD_SECAM_H: u32 = 2048;
pub const VP_TV_STANDARD_SECAM_K: u32 = 4096;
pub const VP_TV_STANDARD_SECAM_K1: u32 = 8192;
pub const VP_TV_STANDARD_SECAM_L: u32 = 16384;
pub const VP_TV_STANDARD_WIN_VGA: u32 = 32768;
pub const VP_TV_STANDARD_NTSC_433: u32 = 65536;
pub const VP_TV_STANDARD_PAL_G: u32 = 131072;
pub const VP_TV_STANDARD_PAL_60: u32 = 262144;
pub const VP_TV_STANDARD_SECAM_L1: u32 = 524288;
pub const VP_CP_TYPE_APS_TRIGGER: u32 = 1;
pub const VP_CP_TYPE_MACROVISION: u32 = 2;
pub const VP_CP_CMD_ACTIVATE: u32 = 1;
pub const VP_CP_CMD_DEACTIVATE: u32 = 2;
pub const VP_CP_CMD_CHANGE: u32 = 4;
pub const DISP_CHANGE_SUCCESSFUL: u32 = 0;
pub const DISP_CHANGE_RESTART: u32 = 1;
pub const DISP_CHANGE_FAILED: i32 = -1;
pub const DISP_CHANGE_BADMODE: i32 = -2;
pub const DISP_CHANGE_NOTUPDATED: i32 = -3;
pub const DISP_CHANGE_BADFLAGS: i32 = -4;
pub const DISP_CHANGE_BADPARAM: i32 = -5;
pub const DISP_CHANGE_BADDUALVIEW: i32 = -6;
pub const EDS_RAWMODE: u32 = 2;
pub const EDS_ROTATEDMODE: u32 = 4;
pub const EDD_GET_DEVICE_INTERFACE_NAME: u32 = 1;
pub const FKF_FILTERKEYSON: u32 = 1;
pub const FKF_AVAILABLE: u32 = 2;
pub const FKF_HOTKEYACTIVE: u32 = 4;
pub const FKF_CONFIRMHOTKEY: u32 = 8;
pub const FKF_HOTKEYSOUND: u32 = 16;
pub const FKF_INDICATOR: u32 = 32;
pub const FKF_CLICKON: u32 = 64;
pub const SKF_STICKYKEYSON: u32 = 1;
pub const SKF_AVAILABLE: u32 = 2;
pub const SKF_HOTKEYACTIVE: u32 = 4;
pub const SKF_CONFIRMHOTKEY: u32 = 8;
pub const SKF_HOTKEYSOUND: u32 = 16;
pub const SKF_INDICATOR: u32 = 32;
pub const SKF_AUDIBLEFEEDBACK: u32 = 64;
pub const SKF_TRISTATE: u32 = 128;
pub const SKF_TWOKEYSOFF: u32 = 256;
pub const SKF_LALTLATCHED: u32 = 268435456;
pub const SKF_LCTLLATCHED: u32 = 67108864;
pub const SKF_LSHIFTLATCHED: u32 = 16777216;
pub const SKF_RALTLATCHED: u32 = 536870912;
pub const SKF_RCTLLATCHED: u32 = 134217728;
pub const SKF_RSHIFTLATCHED: u32 = 33554432;
pub const SKF_LWINLATCHED: u32 = 1073741824;
pub const SKF_RWINLATCHED: u32 = 2147483648;
pub const SKF_LALTLOCKED: u32 = 1048576;
pub const SKF_LCTLLOCKED: u32 = 262144;
pub const SKF_LSHIFTLOCKED: u32 = 65536;
pub const SKF_RALTLOCKED: u32 = 2097152;
pub const SKF_RCTLLOCKED: u32 = 524288;
pub const SKF_RSHIFTLOCKED: u32 = 131072;
pub const SKF_LWINLOCKED: u32 = 4194304;
pub const SKF_RWINLOCKED: u32 = 8388608;
pub const MKF_MOUSEKEYSON: u32 = 1;
pub const MKF_AVAILABLE: u32 = 2;
pub const MKF_HOTKEYACTIVE: u32 = 4;
pub const MKF_CONFIRMHOTKEY: u32 = 8;
pub const MKF_HOTKEYSOUND: u32 = 16;
pub const MKF_INDICATOR: u32 = 32;
pub const MKF_MODIFIERS: u32 = 64;
pub const MKF_REPLACENUMBERS: u32 = 128;
pub const MKF_LEFTBUTTONSEL: u32 = 268435456;
pub const MKF_RIGHTBUTTONSEL: u32 = 536870912;
pub const MKF_LEFTBUTTONDOWN: u32 = 16777216;
pub const MKF_RIGHTBUTTONDOWN: u32 = 33554432;
pub const MKF_MOUSEMODE: u32 = 2147483648;
pub const ATF_TIMEOUTON: u32 = 1;
pub const ATF_ONOFFFEEDBACK: u32 = 2;
pub const SSGF_NONE: u32 = 0;
pub const SSGF_DISPLAY: u32 = 3;
pub const SSTF_NONE: u32 = 0;
pub const SSTF_CHARS: u32 = 1;
pub const SSTF_BORDER: u32 = 2;
pub const SSTF_DISPLAY: u32 = 3;
pub const SSWF_NONE: u32 = 0;
pub const SSWF_TITLE: u32 = 1;
pub const SSWF_WINDOW: u32 = 2;
pub const SSWF_DISPLAY: u32 = 3;
pub const SSWF_CUSTOM: u32 = 4;
pub const SSF_SOUNDSENTRYON: u32 = 1;
pub const SSF_AVAILABLE: u32 = 2;
pub const SSF_INDICATOR: u32 = 4;
pub const TKF_TOGGLEKEYSON: u32 = 1;
pub const TKF_AVAILABLE: u32 = 2;
pub const TKF_HOTKEYACTIVE: u32 = 4;
pub const TKF_CONFIRMHOTKEY: u32 = 8;
pub const TKF_HOTKEYSOUND: u32 = 16;
pub const TKF_INDICATOR: u32 = 32;
pub const SLE_ERROR: u32 = 1;
pub const SLE_MINORERROR: u32 = 2;
pub const SLE_WARNING: u32 = 3;
pub const MONITOR_DEFAULTTONULL: u32 = 0;
pub const MONITOR_DEFAULTTOPRIMARY: u32 = 1;
pub const MONITOR_DEFAULTTONEAREST: u32 = 2;
pub const MONITORINFOF_PRIMARY: u32 = 1;
pub const WINEVENT_OUTOFCONTEXT: u32 = 0;
pub const WINEVENT_SKIPOWNTHREAD: u32 = 1;
pub const WINEVENT_SKIPOWNPROCESS: u32 = 2;
pub const WINEVENT_INCONTEXT: u32 = 4;
pub const CHILDID_SELF: u32 = 0;
pub const INDEXID_OBJECT: u32 = 0;
pub const INDEXID_CONTAINER: u32 = 0;
pub const EVENT_MIN: u32 = 1;
pub const EVENT_MAX: u32 = 2147483647;
pub const EVENT_SYSTEM_SOUND: u32 = 1;
pub const EVENT_SYSTEM_ALERT: u32 = 2;
pub const EVENT_SYSTEM_FOREGROUND: u32 = 3;
pub const EVENT_SYSTEM_MENUSTART: u32 = 4;
pub const EVENT_SYSTEM_MENUEND: u32 = 5;
pub const EVENT_SYSTEM_MENUPOPUPSTART: u32 = 6;
pub const EVENT_SYSTEM_MENUPOPUPEND: u32 = 7;
pub const EVENT_SYSTEM_CAPTURESTART: u32 = 8;
pub const EVENT_SYSTEM_CAPTUREEND: u32 = 9;
pub const EVENT_SYSTEM_MOVESIZESTART: u32 = 10;
pub const EVENT_SYSTEM_MOVESIZEEND: u32 = 11;
pub const EVENT_SYSTEM_CONTEXTHELPSTART: u32 = 12;
pub const EVENT_SYSTEM_CONTEXTHELPEND: u32 = 13;
pub const EVENT_SYSTEM_DRAGDROPSTART: u32 = 14;
pub const EVENT_SYSTEM_DRAGDROPEND: u32 = 15;
pub const EVENT_SYSTEM_DIALOGSTART: u32 = 16;
pub const EVENT_SYSTEM_DIALOGEND: u32 = 17;
pub const EVENT_SYSTEM_SCROLLINGSTART: u32 = 18;
pub const EVENT_SYSTEM_SCROLLINGEND: u32 = 19;
pub const EVENT_SYSTEM_SWITCHSTART: u32 = 20;
pub const EVENT_SYSTEM_SWITCHEND: u32 = 21;
pub const EVENT_SYSTEM_MINIMIZESTART: u32 = 22;
pub const EVENT_SYSTEM_MINIMIZEEND: u32 = 23;
pub const EVENT_SYSTEM_DESKTOPSWITCH: u32 = 32;
pub const EVENT_SYSTEM_SWITCHER_APPGRABBED: u32 = 36;
pub const EVENT_SYSTEM_SWITCHER_APPOVERTARGET: u32 = 37;
pub const EVENT_SYSTEM_SWITCHER_APPDROPPED: u32 = 38;
pub const EVENT_SYSTEM_SWITCHER_CANCELLED: u32 = 39;
pub const EVENT_SYSTEM_IME_KEY_NOTIFICATION: u32 = 41;
pub const EVENT_SYSTEM_END: u32 = 255;
pub const EVENT_OEM_DEFINED_START: u32 = 257;
pub const EVENT_OEM_DEFINED_END: u32 = 511;
pub const EVENT_UIA_EVENTID_START: u32 = 19968;
pub const EVENT_UIA_EVENTID_END: u32 = 20223;
pub const EVENT_UIA_PROPID_START: u32 = 29952;
pub const EVENT_UIA_PROPID_END: u32 = 30207;
pub const EVENT_CONSOLE_CARET: u32 = 16385;
pub const EVENT_CONSOLE_UPDATE_REGION: u32 = 16386;
pub const EVENT_CONSOLE_UPDATE_SIMPLE: u32 = 16387;
pub const EVENT_CONSOLE_UPDATE_SCROLL: u32 = 16388;
pub const EVENT_CONSOLE_LAYOUT: u32 = 16389;
pub const EVENT_CONSOLE_START_APPLICATION: u32 = 16390;
pub const EVENT_CONSOLE_END_APPLICATION: u32 = 16391;
pub const CONSOLE_APPLICATION_16BIT: u32 = 0;
pub const CONSOLE_CARET_SELECTION: u32 = 1;
pub const CONSOLE_CARET_VISIBLE: u32 = 2;
pub const EVENT_CONSOLE_END: u32 = 16639;
pub const EVENT_OBJECT_CREATE: u32 = 32768;
pub const EVENT_OBJECT_DESTROY: u32 = 32769;
pub const EVENT_OBJECT_SHOW: u32 = 32770;
pub const EVENT_OBJECT_HIDE: u32 = 32771;
pub const EVENT_OBJECT_REORDER: u32 = 32772;
pub const EVENT_OBJECT_FOCUS: u32 = 32773;
pub const EVENT_OBJECT_SELECTION: u32 = 32774;
pub const EVENT_OBJECT_SELECTIONADD: u32 = 32775;
pub const EVENT_OBJECT_SELECTIONREMOVE: u32 = 32776;
pub const EVENT_OBJECT_SELECTIONWITHIN: u32 = 32777;
pub const EVENT_OBJECT_STATECHANGE: u32 = 32778;
pub const EVENT_OBJECT_LOCATIONCHANGE: u32 = 32779;
pub const EVENT_OBJECT_NAMECHANGE: u32 = 32780;
pub const EVENT_OBJECT_DESCRIPTIONCHANGE: u32 = 32781;
pub const EVENT_OBJECT_VALUECHANGE: u32 = 32782;
pub const EVENT_OBJECT_PARENTCHANGE: u32 = 32783;
pub const EVENT_OBJECT_HELPCHANGE: u32 = 32784;
pub const EVENT_OBJECT_DEFACTIONCHANGE: u32 = 32785;
pub const EVENT_OBJECT_ACCELERATORCHANGE: u32 = 32786;
pub const EVENT_OBJECT_INVOKED: u32 = 32787;
pub const EVENT_OBJECT_TEXTSELECTIONCHANGED: u32 = 32788;
pub const EVENT_OBJECT_CONTENTSCROLLED: u32 = 32789;
pub const EVENT_SYSTEM_ARRANGMENTPREVIEW: u32 = 32790;
pub const EVENT_OBJECT_CLOAKED: u32 = 32791;
pub const EVENT_OBJECT_UNCLOAKED: u32 = 32792;
pub const EVENT_OBJECT_LIVEREGIONCHANGED: u32 = 32793;
pub const EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED: u32 = 32800;
pub const EVENT_OBJECT_DRAGSTART: u32 = 32801;
pub const EVENT_OBJECT_DRAGCANCEL: u32 = 32802;
pub const EVENT_OBJECT_DRAGCOMPLETE: u32 = 32803;
pub const EVENT_OBJECT_DRAGENTER: u32 = 32804;
pub const EVENT_OBJECT_DRAGLEAVE: u32 = 32805;
pub const EVENT_OBJECT_DRAGDROPPED: u32 = 32806;
pub const EVENT_OBJECT_IME_SHOW: u32 = 32807;
pub const EVENT_OBJECT_IME_HIDE: u32 = 32808;
pub const EVENT_OBJECT_IME_CHANGE: u32 = 32809;
pub const EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED: u32 = 32816;
pub const EVENT_OBJECT_END: u32 = 33023;
pub const EVENT_AIA_START: u32 = 40960;
pub const EVENT_AIA_END: u32 = 45055;
pub const SOUND_SYSTEM_STARTUP: u32 = 1;
pub const SOUND_SYSTEM_SHUTDOWN: u32 = 2;
pub const SOUND_SYSTEM_BEEP: u32 = 3;
pub const SOUND_SYSTEM_ERROR: u32 = 4;
pub const SOUND_SYSTEM_QUESTION: u32 = 5;
pub const SOUND_SYSTEM_WARNING: u32 = 6;
pub const SOUND_SYSTEM_INFORMATION: u32 = 7;
pub const SOUND_SYSTEM_MAXIMIZE: u32 = 8;
pub const SOUND_SYSTEM_MINIMIZE: u32 = 9;
pub const SOUND_SYSTEM_RESTOREUP: u32 = 10;
pub const SOUND_SYSTEM_RESTOREDOWN: u32 = 11;
pub const SOUND_SYSTEM_APPSTART: u32 = 12;
pub const SOUND_SYSTEM_FAULT: u32 = 13;
pub const SOUND_SYSTEM_APPEND: u32 = 14;
pub const SOUND_SYSTEM_MENUCOMMAND: u32 = 15;
pub const SOUND_SYSTEM_MENUPOPUP: u32 = 16;
pub const CSOUND_SYSTEM: u32 = 16;
pub const ALERT_SYSTEM_INFORMATIONAL: u32 = 1;
pub const ALERT_SYSTEM_WARNING: u32 = 2;
pub const ALERT_SYSTEM_ERROR: u32 = 3;
pub const ALERT_SYSTEM_QUERY: u32 = 4;
pub const ALERT_SYSTEM_CRITICAL: u32 = 5;
pub const CALERT_SYSTEM: u32 = 6;
pub const GUI_CARETBLINKING: u32 = 1;
pub const GUI_INMOVESIZE: u32 = 2;
pub const GUI_INMENUMODE: u32 = 4;
pub const GUI_SYSTEMMENUMODE: u32 = 8;
pub const GUI_POPUPMENUMODE: u32 = 16;
pub const GUI_16BITTASK: u32 = 0;
pub const USER_DEFAULT_SCREEN_DPI: u32 = 96;
pub const STATE_SYSTEM_UNAVAILABLE: u32 = 1;
pub const STATE_SYSTEM_SELECTED: u32 = 2;
pub const STATE_SYSTEM_FOCUSED: u32 = 4;
pub const STATE_SYSTEM_PRESSED: u32 = 8;
pub const STATE_SYSTEM_CHECKED: u32 = 16;
pub const STATE_SYSTEM_MIXED: u32 = 32;
pub const STATE_SYSTEM_INDETERMINATE: u32 = 32;
pub const STATE_SYSTEM_READONLY: u32 = 64;
pub const STATE_SYSTEM_HOTTRACKED: u32 = 128;
pub const STATE_SYSTEM_DEFAULT: u32 = 256;
pub const STATE_SYSTEM_EXPANDED: u32 = 512;
pub const STATE_SYSTEM_COLLAPSED: u32 = 1024;
pub const STATE_SYSTEM_BUSY: u32 = 2048;
pub const STATE_SYSTEM_FLOATING: u32 = 4096;
pub const STATE_SYSTEM_MARQUEED: u32 = 8192;
pub const STATE_SYSTEM_ANIMATED: u32 = 16384;
pub const STATE_SYSTEM_INVISIBLE: u32 = 32768;
pub const STATE_SYSTEM_OFFSCREEN: u32 = 65536;
pub const STATE_SYSTEM_SIZEABLE: u32 = 131072;
pub const STATE_SYSTEM_MOVEABLE: u32 = 262144;
pub const STATE_SYSTEM_SELFVOICING: u32 = 524288;
pub const STATE_SYSTEM_FOCUSABLE: u32 = 1048576;
pub const STATE_SYSTEM_SELECTABLE: u32 = 2097152;
pub const STATE_SYSTEM_LINKED: u32 = 4194304;
pub const STATE_SYSTEM_TRAVERSED: u32 = 8388608;
pub const STATE_SYSTEM_MULTISELECTABLE: u32 = 16777216;
pub const STATE_SYSTEM_EXTSELECTABLE: u32 = 33554432;
pub const STATE_SYSTEM_ALERT_LOW: u32 = 67108864;
pub const STATE_SYSTEM_ALERT_MEDIUM: u32 = 134217728;
pub const STATE_SYSTEM_ALERT_HIGH: u32 = 268435456;
pub const STATE_SYSTEM_PROTECTED: u32 = 536870912;
pub const STATE_SYSTEM_VALID: u32 = 1073741823;
pub const CCHILDREN_TITLEBAR: u32 = 5;
pub const CCHILDREN_SCROLLBAR: u32 = 5;
pub const CURSOR_SHOWING: u32 = 1;
pub const CURSOR_SUPPRESSED: u32 = 2;
pub const WS_ACTIVECAPTION: u32 = 1;
pub const GA_PARENT: u32 = 1;
pub const GA_ROOT: u32 = 2;
pub const GA_ROOTOWNER: u32 = 3;
pub const RIM_INPUT: u32 = 0;
pub const RIM_INPUTSINK: u32 = 1;
pub const RIM_TYPEMOUSE: u32 = 0;
pub const RIM_TYPEKEYBOARD: u32 = 1;
pub const RIM_TYPEHID: u32 = 2;
pub const RIM_TYPEMAX: u32 = 2;
pub const RI_MOUSE_LEFT_BUTTON_DOWN: u32 = 1;
pub const RI_MOUSE_LEFT_BUTTON_UP: u32 = 2;
pub const RI_MOUSE_RIGHT_BUTTON_DOWN: u32 = 4;
pub const RI_MOUSE_RIGHT_BUTTON_UP: u32 = 8;
pub const RI_MOUSE_MIDDLE_BUTTON_DOWN: u32 = 16;
pub const RI_MOUSE_MIDDLE_BUTTON_UP: u32 = 32;
pub const RI_MOUSE_BUTTON_1_DOWN: u32 = 1;
pub const RI_MOUSE_BUTTON_1_UP: u32 = 2;
pub const RI_MOUSE_BUTTON_2_DOWN: u32 = 4;
pub const RI_MOUSE_BUTTON_2_UP: u32 = 8;
pub const RI_MOUSE_BUTTON_3_DOWN: u32 = 16;
pub const RI_MOUSE_BUTTON_3_UP: u32 = 32;
pub const RI_MOUSE_BUTTON_4_DOWN: u32 = 64;
pub const RI_MOUSE_BUTTON_4_UP: u32 = 128;
pub const RI_MOUSE_BUTTON_5_DOWN: u32 = 256;
pub const RI_MOUSE_BUTTON_5_UP: u32 = 512;
pub const RI_MOUSE_WHEEL: u32 = 1024;
pub const RI_MOUSE_HWHEEL: u32 = 2048;
pub const MOUSE_MOVE_RELATIVE: u32 = 0;
pub const MOUSE_MOVE_ABSOLUTE: u32 = 1;
pub const MOUSE_VIRTUAL_DESKTOP: u32 = 2;
pub const MOUSE_ATTRIBUTES_CHANGED: u32 = 4;
pub const MOUSE_MOVE_NOCOALESCE: u32 = 8;
pub const KEYBOARD_OVERRUN_MAKE_CODE: u32 = 255;
pub const RI_KEY_MAKE: u32 = 0;
pub const RI_KEY_BREAK: u32 = 1;
pub const RI_KEY_E0: u32 = 2;
pub const RI_KEY_E1: u32 = 4;
pub const RI_KEY_TERMSRV_SET_LED: u32 = 8;
pub const RI_KEY_TERMSRV_SHADOW: u32 = 16;
pub const RID_INPUT: u32 = 268435459;
pub const RID_HEADER: u32 = 268435461;
pub const RIDI_PREPARSEDDATA: u32 = 536870917;
pub const RIDI_DEVICENAME: u32 = 536870919;
pub const RIDI_DEVICEINFO: u32 = 536870923;
pub const RIDEV_REMOVE: u32 = 1;
pub const RIDEV_EXCLUDE: u32 = 16;
pub const RIDEV_PAGEONLY: u32 = 32;
pub const RIDEV_NOLEGACY: u32 = 48;
pub const RIDEV_INPUTSINK: u32 = 256;
pub const RIDEV_CAPTUREMOUSE: u32 = 512;
pub const RIDEV_NOHOTKEYS: u32 = 512;
pub const RIDEV_APPKEYS: u32 = 1024;
pub const RIDEV_EXINPUTSINK: u32 = 4096;
pub const RIDEV_DEVNOTIFY: u32 = 8192;
pub const RIDEV_EXMODEMASK: u32 = 240;
pub const GIDC_ARRIVAL: u32 = 1;
pub const GIDC_REMOVAL: u32 = 2;
pub const POINTER_DEVICE_PRODUCT_STRING_MAX: u32 = 520;
pub const PDC_ARRIVAL: u32 = 1;
pub const PDC_REMOVAL: u32 = 2;
pub const PDC_ORIENTATION_0: u32 = 4;
pub const PDC_ORIENTATION_90: u32 = 8;
pub const PDC_ORIENTATION_180: u32 = 16;
pub const PDC_ORIENTATION_270: u32 = 32;
pub const PDC_MODE_DEFAULT: u32 = 64;
pub const PDC_MODE_CENTERED: u32 = 128;
pub const PDC_MAPPING_CHANGE: u32 = 256;
pub const PDC_RESOLUTION: u32 = 512;
pub const PDC_ORIGIN: u32 = 1024;
pub const PDC_MODE_ASPECTRATIOPRESERVED: u32 = 2048;
pub const MSGFLT_ADD: u32 = 1;
pub const MSGFLT_REMOVE: u32 = 2;
pub const MSGFLTINFO_NONE: u32 = 0;
pub const MSGFLTINFO_ALREADYALLOWED_FORWND: u32 = 1;
pub const MSGFLTINFO_ALREADYDISALLOWED_FORWND: u32 = 2;
pub const MSGFLTINFO_ALLOWED_HIGHER: u32 = 3;
pub const MSGFLT_RESET: u32 = 0;
pub const MSGFLT_ALLOW: u32 = 1;
pub const MSGFLT_DISALLOW: u32 = 2;
pub const GF_BEGIN: u32 = 1;
pub const GF_INERTIA: u32 = 2;
pub const GF_END: u32 = 4;
pub const GID_BEGIN: u32 = 1;
pub const GID_END: u32 = 2;
pub const GID_ZOOM: u32 = 3;
pub const GID_PAN: u32 = 4;
pub const GID_ROTATE: u32 = 5;
pub const GID_TWOFINGERTAP: u32 = 6;
pub const GID_PRESSANDTAP: u32 = 7;
pub const GID_ROLLOVER: u32 = 7;
pub const GC_ALLGESTURES: u32 = 1;
pub const GC_ZOOM: u32 = 1;
pub const GC_PAN: u32 = 1;
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY: u32 = 2;
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY: u32 = 4;
pub const GC_PAN_WITH_GUTTER: u32 = 8;
pub const GC_PAN_WITH_INERTIA: u32 = 16;
pub const GC_ROTATE: u32 = 1;
pub const GC_TWOFINGERTAP: u32 = 1;
pub const GC_PRESSANDTAP: u32 = 1;
pub const GC_ROLLOVER: u32 = 1;
pub const GESTURECONFIGMAXCOUNT: u32 = 256;
pub const GCF_INCLUDE_ANCESTORS: u32 = 1;
pub const NID_INTEGRATED_TOUCH: u32 = 1;
pub const NID_EXTERNAL_TOUCH: u32 = 2;
pub const NID_INTEGRATED_PEN: u32 = 4;
pub const NID_EXTERNAL_PEN: u32 = 8;
pub const NID_MULTI_INPUT: u32 = 64;
pub const NID_READY: u32 = 128;
pub const MAX_STR_BLOCKREASON: u32 = 256;
pub const MAX_LEADBYTES: u32 = 12;
pub const MAX_DEFAULTCHAR: u32 = 2;
pub const HIGH_SURROGATE_START: u32 = 55296;
pub const HIGH_SURROGATE_END: u32 = 56319;
pub const LOW_SURROGATE_START: u32 = 56320;
pub const LOW_SURROGATE_END: u32 = 57343;
pub const MB_PRECOMPOSED: u32 = 1;
pub const MB_COMPOSITE: u32 = 2;
pub const MB_USEGLYPHCHARS: u32 = 4;
pub const MB_ERR_INVALID_CHARS: u32 = 8;
pub const WC_COMPOSITECHECK: u32 = 512;
pub const WC_DISCARDNS: u32 = 16;
pub const WC_SEPCHARS: u32 = 32;
pub const WC_DEFAULTCHAR: u32 = 64;
pub const WC_ERR_INVALID_CHARS: u32 = 128;
pub const WC_NO_BEST_FIT_CHARS: u32 = 1024;
pub const CT_CTYPE1: u32 = 1;
pub const CT_CTYPE2: u32 = 2;
pub const CT_CTYPE3: u32 = 4;
pub const C1_UPPER: u32 = 1;
pub const C1_LOWER: u32 = 2;
pub const C1_DIGIT: u32 = 4;
pub const C1_SPACE: u32 = 8;
pub const C1_PUNCT: u32 = 16;
pub const C1_CNTRL: u32 = 32;
pub const C1_BLANK: u32 = 64;
pub const C1_XDIGIT: u32 = 128;
pub const C1_ALPHA: u32 = 256;
pub const C1_DEFINED: u32 = 512;
pub const C2_LEFTTORIGHT: u32 = 1;
pub const C2_RIGHTTOLEFT: u32 = 2;
pub const C2_EUROPENUMBER: u32 = 3;
pub const C2_EUROPESEPARATOR: u32 = 4;
pub const C2_EUROPETERMINATOR: u32 = 5;
pub const C2_ARABICNUMBER: u32 = 6;
pub const C2_COMMONSEPARATOR: u32 = 7;
pub const C2_BLOCKSEPARATOR: u32 = 8;
pub const C2_SEGMENTSEPARATOR: u32 = 9;
pub const C2_WHITESPACE: u32 = 10;
pub const C2_OTHERNEUTRAL: u32 = 11;
pub const C2_NOTAPPLICABLE: u32 = 0;
pub const C3_NONSPACING: u32 = 1;
pub const C3_DIACRITIC: u32 = 2;
pub const C3_VOWELMARK: u32 = 4;
pub const C3_SYMBOL: u32 = 8;
pub const C3_KATAKANA: u32 = 16;
pub const C3_HIRAGANA: u32 = 32;
pub const C3_HALFWIDTH: u32 = 64;
pub const C3_FULLWIDTH: u32 = 128;
pub const C3_IDEOGRAPH: u32 = 256;
pub const C3_KASHIDA: u32 = 512;
pub const C3_LEXICAL: u32 = 1024;
pub const C3_HIGHSURROGATE: u32 = 2048;
pub const C3_LOWSURROGATE: u32 = 4096;
pub const C3_ALPHA: u32 = 32768;
pub const C3_NOTAPPLICABLE: u32 = 0;
pub const NORM_IGNORECASE: u32 = 1;
pub const NORM_IGNORENONSPACE: u32 = 2;
pub const NORM_IGNORESYMBOLS: u32 = 4;
pub const LINGUISTIC_IGNORECASE: u32 = 16;
pub const LINGUISTIC_IGNOREDIACRITIC: u32 = 32;
pub const NORM_IGNOREKANATYPE: u32 = 65536;
pub const NORM_IGNOREWIDTH: u32 = 131072;
pub const NORM_LINGUISTIC_CASING: u32 = 134217728;
pub const MAP_FOLDCZONE: u32 = 16;
pub const MAP_PRECOMPOSED: u32 = 32;
pub const MAP_COMPOSITE: u32 = 64;
pub const MAP_FOLDDIGITS: u32 = 128;
pub const MAP_EXPAND_LIGATURES: u32 = 8192;
pub const LCMAP_LOWERCASE: u32 = 256;
pub const LCMAP_UPPERCASE: u32 = 512;
pub const LCMAP_TITLECASE: u32 = 768;
pub const LCMAP_SORTKEY: u32 = 1024;
pub const LCMAP_BYTEREV: u32 = 2048;
pub const LCMAP_HIRAGANA: u32 = 1048576;
pub const LCMAP_KATAKANA: u32 = 2097152;
pub const LCMAP_HALFWIDTH: u32 = 4194304;
pub const LCMAP_FULLWIDTH: u32 = 8388608;
pub const LCMAP_LINGUISTIC_CASING: u32 = 16777216;
pub const LCMAP_SIMPLIFIED_CHINESE: u32 = 33554432;
pub const LCMAP_TRADITIONAL_CHINESE: u32 = 67108864;
pub const LCMAP_SORTHANDLE: u32 = 536870912;
pub const LCMAP_HASH: u32 = 262144;
pub const FIND_STARTSWITH: u32 = 1048576;
pub const FIND_ENDSWITH: u32 = 2097152;
pub const FIND_FROMSTART: u32 = 4194304;
pub const FIND_FROMEND: u32 = 8388608;
pub const LGRPID_INSTALLED: u32 = 1;
pub const LGRPID_SUPPORTED: u32 = 2;
pub const LCID_INSTALLED: u32 = 1;
pub const LCID_SUPPORTED: u32 = 2;
pub const LCID_ALTERNATE_SORTS: u32 = 4;
pub const LOCALE_ALL: u32 = 0;
pub const LOCALE_WINDOWS: u32 = 1;
pub const LOCALE_SUPPLEMENTAL: u32 = 2;
pub const LOCALE_ALTERNATE_SORTS: u32 = 4;
pub const LOCALE_REPLACEMENT: u32 = 8;
pub const LOCALE_NEUTRALDATA: u32 = 16;
pub const LOCALE_SPECIFICDATA: u32 = 32;
pub const CP_INSTALLED: u32 = 1;
pub const CP_SUPPORTED: u32 = 2;
pub const SORT_STRINGSORT: u32 = 4096;
pub const SORT_DIGITSASNUMBERS: u32 = 8;
pub const CSTR_LESS_THAN: u32 = 1;
pub const CSTR_EQUAL: u32 = 2;
pub const CSTR_GREATER_THAN: u32 = 3;
pub const CP_ACP: u32 = 0;
pub const CP_OEMCP: u32 = 1;
pub const CP_MACCP: u32 = 2;
pub const CP_THREAD_ACP: u32 = 3;
pub const CP_SYMBOL: u32 = 42;
pub const CP_UTF7: u32 = 65000;
pub const CP_UTF8: u32 = 65001;
pub const CTRY_DEFAULT: u32 = 0;
pub const CTRY_ALBANIA: u32 = 355;
pub const CTRY_ALGERIA: u32 = 213;
pub const CTRY_ARGENTINA: u32 = 54;
pub const CTRY_ARMENIA: u32 = 374;
pub const CTRY_AUSTRALIA: u32 = 61;
pub const CTRY_AUSTRIA: u32 = 43;
pub const CTRY_AZERBAIJAN: u32 = 994;
pub const CTRY_BAHRAIN: u32 = 973;
pub const CTRY_BELARUS: u32 = 375;
pub const CTRY_BELGIUM: u32 = 32;
pub const CTRY_BELIZE: u32 = 501;
pub const CTRY_BOLIVIA: u32 = 591;
pub const CTRY_BRAZIL: u32 = 55;
pub const CTRY_BRUNEI_DARUSSALAM: u32 = 673;
pub const CTRY_BULGARIA: u32 = 359;
pub const CTRY_CANADA: u32 = 2;
pub const CTRY_CARIBBEAN: u32 = 1;
pub const CTRY_CHILE: u32 = 56;
pub const CTRY_COLOMBIA: u32 = 57;
pub const CTRY_COSTA_RICA: u32 = 506;
pub const CTRY_CROATIA: u32 = 385;
pub const CTRY_CZECH: u32 = 420;
pub const CTRY_DENMARK: u32 = 45;
pub const CTRY_DOMINICAN_REPUBLIC: u32 = 1;
pub const CTRY_ECUADOR: u32 = 593;
pub const CTRY_EGYPT: u32 = 20;
pub const CTRY_EL_SALVADOR: u32 = 503;
pub const CTRY_ESTONIA: u32 = 372;
pub const CTRY_FAEROE_ISLANDS: u32 = 298;
pub const CTRY_FINLAND: u32 = 358;
pub const CTRY_FRANCE: u32 = 33;
pub const CTRY_GEORGIA: u32 = 995;
pub const CTRY_GERMANY: u32 = 49;
pub const CTRY_GREECE: u32 = 30;
pub const CTRY_GUATEMALA: u32 = 502;
pub const CTRY_HONDURAS: u32 = 504;
pub const CTRY_HONG_KONG: u32 = 852;
pub const CTRY_HUNGARY: u32 = 36;
pub const CTRY_ICELAND: u32 = 354;
pub const CTRY_INDIA: u32 = 91;
pub const CTRY_INDONESIA: u32 = 62;
pub const CTRY_IRAN: u32 = 981;
pub const CTRY_IRAQ: u32 = 964;
pub const CTRY_IRELAND: u32 = 353;
pub const CTRY_ISRAEL: u32 = 972;
pub const CTRY_ITALY: u32 = 39;
pub const CTRY_JAMAICA: u32 = 1;
pub const CTRY_JAPAN: u32 = 81;
pub const CTRY_JORDAN: u32 = 962;
pub const CTRY_KAZAKSTAN: u32 = 7;
pub const CTRY_KENYA: u32 = 254;
pub const CTRY_KUWAIT: u32 = 965;
pub const CTRY_KYRGYZSTAN: u32 = 996;
pub const CTRY_LATVIA: u32 = 371;
pub const CTRY_LEBANON: u32 = 961;
pub const CTRY_LIBYA: u32 = 218;
pub const CTRY_LIECHTENSTEIN: u32 = 41;
pub const CTRY_LITHUANIA: u32 = 370;
pub const CTRY_LUXEMBOURG: u32 = 352;
pub const CTRY_MACAU: u32 = 853;
pub const CTRY_MACEDONIA: u32 = 389;
pub const CTRY_MALAYSIA: u32 = 60;
pub const CTRY_MALDIVES: u32 = 960;
pub const CTRY_MEXICO: u32 = 52;
pub const CTRY_MONACO: u32 = 33;
pub const CTRY_MONGOLIA: u32 = 976;
pub const CTRY_MOROCCO: u32 = 212;
pub const CTRY_NETHERLANDS: u32 = 31;
pub const CTRY_NEW_ZEALAND: u32 = 64;
pub const CTRY_NICARAGUA: u32 = 505;
pub const CTRY_NORWAY: u32 = 47;
pub const CTRY_OMAN: u32 = 968;
pub const CTRY_PAKISTAN: u32 = 92;
pub const CTRY_PANAMA: u32 = 507;
pub const CTRY_PARAGUAY: u32 = 595;
pub const CTRY_PERU: u32 = 51;
pub const CTRY_PHILIPPINES: u32 = 63;
pub const CTRY_POLAND: u32 = 48;
pub const CTRY_PORTUGAL: u32 = 351;
pub const CTRY_PRCHINA: u32 = 86;
pub const CTRY_PUERTO_RICO: u32 = 1;
pub const CTRY_QATAR: u32 = 974;
pub const CTRY_ROMANIA: u32 = 40;
pub const CTRY_RUSSIA: u32 = 7;
pub const CTRY_SAUDI_ARABIA: u32 = 966;
pub const CTRY_SERBIA: u32 = 381;
pub const CTRY_SINGAPORE: u32 = 65;
pub const CTRY_SLOVAK: u32 = 421;
pub const CTRY_SLOVENIA: u32 = 386;
pub const CTRY_SOUTH_AFRICA: u32 = 27;
pub const CTRY_SOUTH_KOREA: u32 = 82;
pub const CTRY_SPAIN: u32 = 34;
pub const CTRY_SWEDEN: u32 = 46;
pub const CTRY_SWITZERLAND: u32 = 41;
pub const CTRY_SYRIA: u32 = 963;
pub const CTRY_TAIWAN: u32 = 886;
pub const CTRY_TATARSTAN: u32 = 7;
pub const CTRY_THAILAND: u32 = 66;
pub const CTRY_TRINIDAD_Y_TOBAGO: u32 = 1;
pub const CTRY_TUNISIA: u32 = 216;
pub const CTRY_TURKEY: u32 = 90;
pub const CTRY_UAE: u32 = 971;
pub const CTRY_UKRAINE: u32 = 380;
pub const CTRY_UNITED_KINGDOM: u32 = 44;
pub const CTRY_UNITED_STATES: u32 = 1;
pub const CTRY_URUGUAY: u32 = 598;
pub const CTRY_UZBEKISTAN: u32 = 7;
pub const CTRY_VENEZUELA: u32 = 58;
pub const CTRY_VIET_NAM: u32 = 84;
pub const CTRY_YEMEN: u32 = 967;
pub const CTRY_ZIMBABWE: u32 = 263;
pub const LOCALE_NOUSEROVERRIDE: u32 = 2147483648;
pub const LOCALE_USE_CP_ACP: u32 = 1073741824;
pub const LOCALE_RETURN_NUMBER: u32 = 536870912;
pub const LOCALE_RETURN_GENITIVE_NAMES: u32 = 268435456;
pub const LOCALE_ALLOW_NEUTRAL_NAMES: u32 = 134217728;
pub const LOCALE_SLOCALIZEDDISPLAYNAME: u32 = 2;
pub const LOCALE_SENGLISHDISPLAYNAME: u32 = 114;
pub const LOCALE_SNATIVEDISPLAYNAME: u32 = 115;
pub const LOCALE_SLOCALIZEDLANGUAGENAME: u32 = 111;
pub const LOCALE_SENGLISHLANGUAGENAME: u32 = 4097;
pub const LOCALE_SNATIVELANGUAGENAME: u32 = 4;
pub const LOCALE_SLOCALIZEDCOUNTRYNAME: u32 = 6;
pub const LOCALE_SENGLISHCOUNTRYNAME: u32 = 4098;
pub const LOCALE_SNATIVECOUNTRYNAME: u32 = 8;
pub const LOCALE_IDIALINGCODE: u32 = 5;
pub const LOCALE_SLIST: u32 = 12;
pub const LOCALE_IMEASURE: u32 = 13;
pub const LOCALE_SDECIMAL: u32 = 14;
pub const LOCALE_STHOUSAND: u32 = 15;
pub const LOCALE_SGROUPING: u32 = 16;
pub const LOCALE_IDIGITS: u32 = 17;
pub const LOCALE_ILZERO: u32 = 18;
pub const LOCALE_INEGNUMBER: u32 = 4112;
pub const LOCALE_SNATIVEDIGITS: u32 = 19;
pub const LOCALE_SCURRENCY: u32 = 20;
pub const LOCALE_SINTLSYMBOL: u32 = 21;
pub const LOCALE_SMONDECIMALSEP: u32 = 22;
pub const LOCALE_SMONTHOUSANDSEP: u32 = 23;
pub const LOCALE_SMONGROUPING: u32 = 24;
pub const LOCALE_ICURRDIGITS: u32 = 25;
pub const LOCALE_ICURRENCY: u32 = 27;
pub const LOCALE_INEGCURR: u32 = 28;
pub const LOCALE_SSHORTDATE: u32 = 31;
pub const LOCALE_SLONGDATE: u32 = 32;
pub const LOCALE_STIMEFORMAT: u32 = 4099;
pub const LOCALE_SAM: u32 = 40;
pub const LOCALE_SPM: u32 = 41;
pub const LOCALE_ICALENDARTYPE: u32 = 4105;
pub const LOCALE_IOPTIONALCALENDAR: u32 = 4107;
pub const LOCALE_IFIRSTDAYOFWEEK: u32 = 4108;
pub const LOCALE_IFIRSTWEEKOFYEAR: u32 = 4109;
pub const LOCALE_SDAYNAME1: u32 = 42;
pub const LOCALE_SDAYNAME2: u32 = 43;
pub const LOCALE_SDAYNAME3: u32 = 44;
pub const LOCALE_SDAYNAME4: u32 = 45;
pub const LOCALE_SDAYNAME5: u32 = 46;
pub const LOCALE_SDAYNAME6: u32 = 47;
pub const LOCALE_SDAYNAME7: u32 = 48;
pub const LOCALE_SABBREVDAYNAME1: u32 = 49;
pub const LOCALE_SABBREVDAYNAME2: u32 = 50;
pub const LOCALE_SABBREVDAYNAME3: u32 = 51;
pub const LOCALE_SABBREVDAYNAME4: u32 = 52;
pub const LOCALE_SABBREVDAYNAME5: u32 = 53;
pub const LOCALE_SABBREVDAYNAME6: u32 = 54;
pub const LOCALE_SABBREVDAYNAME7: u32 = 55;
pub const LOCALE_SMONTHNAME1: u32 = 56;
pub const LOCALE_SMONTHNAME2: u32 = 57;
pub const LOCALE_SMONTHNAME3: u32 = 58;
pub const LOCALE_SMONTHNAME4: u32 = 59;
pub const LOCALE_SMONTHNAME5: u32 = 60;
pub const LOCALE_SMONTHNAME6: u32 = 61;
pub const LOCALE_SMONTHNAME7: u32 = 62;
pub const LOCALE_SMONTHNAME8: u32 = 63;
pub const LOCALE_SMONTHNAME9: u32 = 64;
pub const LOCALE_SMONTHNAME10: u32 = 65;
pub const LOCALE_SMONTHNAME11: u32 = 66;
pub const LOCALE_SMONTHNAME12: u32 = 67;
pub const LOCALE_SMONTHNAME13: u32 = 4110;
pub const LOCALE_SABBREVMONTHNAME1: u32 = 68;
pub const LOCALE_SABBREVMONTHNAME2: u32 = 69;
pub const LOCALE_SABBREVMONTHNAME3: u32 = 70;
pub const LOCALE_SABBREVMONTHNAME4: u32 = 71;
pub const LOCALE_SABBREVMONTHNAME5: u32 = 72;
pub const LOCALE_SABBREVMONTHNAME6: u32 = 73;
pub const LOCALE_SABBREVMONTHNAME7: u32 = 74;
pub const LOCALE_SABBREVMONTHNAME8: u32 = 75;
pub const LOCALE_SABBREVMONTHNAME9: u32 = 76;
pub const LOCALE_SABBREVMONTHNAME10: u32 = 77;
pub const LOCALE_SABBREVMONTHNAME11: u32 = 78;
pub const LOCALE_SABBREVMONTHNAME12: u32 = 79;
pub const LOCALE_SABBREVMONTHNAME13: u32 = 4111;
pub const LOCALE_SPOSITIVESIGN: u32 = 80;
pub const LOCALE_SNEGATIVESIGN: u32 = 81;
pub const LOCALE_IPOSSIGNPOSN: u32 = 82;
pub const LOCALE_INEGSIGNPOSN: u32 = 83;
pub const LOCALE_IPOSSYMPRECEDES: u32 = 84;
pub const LOCALE_IPOSSEPBYSPACE: u32 = 85;
pub const LOCALE_INEGSYMPRECEDES: u32 = 86;
pub const LOCALE_INEGSEPBYSPACE: u32 = 87;
pub const LOCALE_FONTSIGNATURE: u32 = 88;
pub const LOCALE_SISO639LANGNAME: u32 = 89;
pub const LOCALE_SISO3166CTRYNAME: u32 = 90;
pub const LOCALE_IPAPERSIZE: u32 = 4106;
pub const LOCALE_SENGCURRNAME: u32 = 4103;
pub const LOCALE_SNATIVECURRNAME: u32 = 4104;
pub const LOCALE_SYEARMONTH: u32 = 4102;
pub const LOCALE_SSORTNAME: u32 = 4115;
pub const LOCALE_IDIGITSUBSTITUTION: u32 = 4116;
pub const LOCALE_SNAME: u32 = 92;
pub const LOCALE_SDURATION: u32 = 93;
pub const LOCALE_SSHORTESTDAYNAME1: u32 = 96;
pub const LOCALE_SSHORTESTDAYNAME2: u32 = 97;
pub const LOCALE_SSHORTESTDAYNAME3: u32 = 98;
pub const LOCALE_SSHORTESTDAYNAME4: u32 = 99;
pub const LOCALE_SSHORTESTDAYNAME5: u32 = 100;
pub const LOCALE_SSHORTESTDAYNAME6: u32 = 101;
pub const LOCALE_SSHORTESTDAYNAME7: u32 = 102;
pub const LOCALE_SISO639LANGNAME2: u32 = 103;
pub const LOCALE_SISO3166CTRYNAME2: u32 = 104;
pub const LOCALE_SNAN: u32 = 105;
pub const LOCALE_SPOSINFINITY: u32 = 106;
pub const LOCALE_SNEGINFINITY: u32 = 107;
pub const LOCALE_SSCRIPTS: u32 = 108;
pub const LOCALE_SPARENT: u32 = 109;
pub const LOCALE_SCONSOLEFALLBACKNAME: u32 = 110;
pub const LOCALE_IREADINGLAYOUT: u32 = 112;
pub const LOCALE_INEUTRAL: u32 = 113;
pub const LOCALE_INEGATIVEPERCENT: u32 = 116;
pub const LOCALE_IPOSITIVEPERCENT: u32 = 117;
pub const LOCALE_SPERCENT: u32 = 118;
pub const LOCALE_SPERMILLE: u32 = 119;
pub const LOCALE_SMONTHDAY: u32 = 120;
pub const LOCALE_SSHORTTIME: u32 = 121;
pub const LOCALE_SOPENTYPELANGUAGETAG: u32 = 122;
pub const LOCALE_SSORTLOCALE: u32 = 123;
pub const LOCALE_SRELATIVELONGDATE: u32 = 124;
pub const LOCALE_SSHORTESTAM: u32 = 126;
pub const LOCALE_SSHORTESTPM: u32 = 127;
pub const LOCALE_IDEFAULTCODEPAGE: u32 = 11;
pub const LOCALE_IDEFAULTANSICODEPAGE: u32 = 4100;
pub const LOCALE_IDEFAULTMACCODEPAGE: u32 = 4113;
pub const LOCALE_IDEFAULTEBCDICCODEPAGE: u32 = 4114;
pub const LOCALE_ILANGUAGE: u32 = 1;
pub const LOCALE_SABBREVLANGNAME: u32 = 3;
pub const LOCALE_SABBREVCTRYNAME: u32 = 7;
pub const LOCALE_IGEOID: u32 = 91;
pub const LOCALE_IDEFAULTLANGUAGE: u32 = 9;
pub const LOCALE_IDEFAULTCOUNTRY: u32 = 10;
pub const LOCALE_IINTLCURRDIGITS: u32 = 26;
pub const LOCALE_SDATE: u32 = 29;
pub const LOCALE_STIME: u32 = 30;
pub const LOCALE_IDATE: u32 = 33;
pub const LOCALE_ILDATE: u32 = 34;
pub const LOCALE_ITIME: u32 = 35;
pub const LOCALE_ITIMEMARKPOSN: u32 = 4101;
pub const LOCALE_ICENTURY: u32 = 36;
pub const LOCALE_ITLZERO: u32 = 37;
pub const LOCALE_IDAYLZERO: u32 = 38;
pub const LOCALE_IMONLZERO: u32 = 39;
pub const LOCALE_SKEYBOARDSTOINSTALL: u32 = 94;
pub const LOCALE_SLANGUAGE: u32 = 2;
pub const LOCALE_SLANGDISPLAYNAME: u32 = 111;
pub const LOCALE_SENGLANGUAGE: u32 = 4097;
pub const LOCALE_SNATIVELANGNAME: u32 = 4;
pub const LOCALE_SCOUNTRY: u32 = 6;
pub const LOCALE_SENGCOUNTRY: u32 = 4098;
pub const LOCALE_SNATIVECTRYNAME: u32 = 8;
pub const LOCALE_ICOUNTRY: u32 = 5;
pub const LOCALE_S1159: u32 = 40;
pub const LOCALE_S2359: u32 = 41;
pub const TIME_NOMINUTESORSECONDS: u32 = 1;
pub const TIME_NOSECONDS: u32 = 2;
pub const TIME_NOTIMEMARKER: u32 = 4;
pub const TIME_FORCE24HOURFORMAT: u32 = 8;
pub const DATE_SHORTDATE: u32 = 1;
pub const DATE_LONGDATE: u32 = 2;
pub const DATE_USE_ALT_CALENDAR: u32 = 4;
pub const DATE_YEARMONTH: u32 = 8;
pub const DATE_LTRREADING: u32 = 16;
pub const DATE_RTLREADING: u32 = 32;
pub const DATE_AUTOLAYOUT: u32 = 64;
pub const DATE_MONTHDAY: u32 = 128;
pub const CAL_NOUSEROVERRIDE: u32 = 2147483648;
pub const CAL_USE_CP_ACP: u32 = 1073741824;
pub const CAL_RETURN_NUMBER: u32 = 536870912;
pub const CAL_RETURN_GENITIVE_NAMES: u32 = 268435456;
pub const CAL_ICALINTVALUE: u32 = 1;
pub const CAL_SCALNAME: u32 = 2;
pub const CAL_IYEAROFFSETRANGE: u32 = 3;
pub const CAL_SERASTRING: u32 = 4;
pub const CAL_SSHORTDATE: u32 = 5;
pub const CAL_SLONGDATE: u32 = 6;
pub const CAL_SDAYNAME1: u32 = 7;
pub const CAL_SDAYNAME2: u32 = 8;
pub const CAL_SDAYNAME3: u32 = 9;
pub const CAL_SDAYNAME4: u32 = 10;
pub const CAL_SDAYNAME5: u32 = 11;
pub const CAL_SDAYNAME6: u32 = 12;
pub const CAL_SDAYNAME7: u32 = 13;
pub const CAL_SABBREVDAYNAME1: u32 = 14;
pub const CAL_SABBREVDAYNAME2: u32 = 15;
pub const CAL_SABBREVDAYNAME3: u32 = 16;
pub const CAL_SABBREVDAYNAME4: u32 = 17;
pub const CAL_SABBREVDAYNAME5: u32 = 18;
pub const CAL_SABBREVDAYNAME6: u32 = 19;
pub const CAL_SABBREVDAYNAME7: u32 = 20;
pub const CAL_SMONTHNAME1: u32 = 21;
pub const CAL_SMONTHNAME2: u32 = 22;
pub const CAL_SMONTHNAME3: u32 = 23;
pub const CAL_SMONTHNAME4: u32 = 24;
pub const CAL_SMONTHNAME5: u32 = 25;
pub const CAL_SMONTHNAME6: u32 = 26;
pub const CAL_SMONTHNAME7: u32 = 27;
pub const CAL_SMONTHNAME8: u32 = 28;
pub const CAL_SMONTHNAME9: u32 = 29;
pub const CAL_SMONTHNAME10: u32 = 30;
pub const CAL_SMONTHNAME11: u32 = 31;
pub const CAL_SMONTHNAME12: u32 = 32;
pub const CAL_SMONTHNAME13: u32 = 33;
pub const CAL_SABBREVMONTHNAME1: u32 = 34;
pub const CAL_SABBREVMONTHNAME2: u32 = 35;
pub const CAL_SABBREVMONTHNAME3: u32 = 36;
pub const CAL_SABBREVMONTHNAME4: u32 = 37;
pub const CAL_SABBREVMONTHNAME5: u32 = 38;
pub const CAL_SABBREVMONTHNAME6: u32 = 39;
pub const CAL_SABBREVMONTHNAME7: u32 = 40;
pub const CAL_SABBREVMONTHNAME8: u32 = 41;
pub const CAL_SABBREVMONTHNAME9: u32 = 42;
pub const CAL_SABBREVMONTHNAME10: u32 = 43;
pub const CAL_SABBREVMONTHNAME11: u32 = 44;
pub const CAL_SABBREVMONTHNAME12: u32 = 45;
pub const CAL_SABBREVMONTHNAME13: u32 = 46;
pub const CAL_SYEARMONTH: u32 = 47;
pub const CAL_ITWODIGITYEARMAX: u32 = 48;
pub const CAL_SSHORTESTDAYNAME1: u32 = 49;
pub const CAL_SSHORTESTDAYNAME2: u32 = 50;
pub const CAL_SSHORTESTDAYNAME3: u32 = 51;
pub const CAL_SSHORTESTDAYNAME4: u32 = 52;
pub const CAL_SSHORTESTDAYNAME5: u32 = 53;
pub const CAL_SSHORTESTDAYNAME6: u32 = 54;
pub const CAL_SSHORTESTDAYNAME7: u32 = 55;
pub const CAL_SMONTHDAY: u32 = 56;
pub const CAL_SABBREVERASTRING: u32 = 57;
pub const CAL_SRELATIVELONGDATE: u32 = 58;
pub const CAL_SENGLISHERANAME: u32 = 59;
pub const CAL_SENGLISHABBREVERANAME: u32 = 60;
pub const ENUM_ALL_CALENDARS: u32 = 4294967295;
pub const CAL_GREGORIAN: u32 = 1;
pub const CAL_GREGORIAN_US: u32 = 2;
pub const CAL_JAPAN: u32 = 3;
pub const CAL_TAIWAN: u32 = 4;
pub const CAL_KOREA: u32 = 5;
pub const CAL_HIJRI: u32 = 6;
pub const CAL_THAI: u32 = 7;
pub const CAL_HEBREW: u32 = 8;
pub const CAL_GREGORIAN_ME_FRENCH: u32 = 9;
pub const CAL_GREGORIAN_ARABIC: u32 = 10;
pub const CAL_GREGORIAN_XLIT_ENGLISH: u32 = 11;
pub const CAL_GREGORIAN_XLIT_FRENCH: u32 = 12;
pub const CAL_PERSIAN: u32 = 22;
pub const CAL_UMALQURA: u32 = 23;
pub const LGRPID_WESTERN_EUROPE: u32 = 1;
pub const LGRPID_CENTRAL_EUROPE: u32 = 2;
pub const LGRPID_BALTIC: u32 = 3;
pub const LGRPID_GREEK: u32 = 4;
pub const LGRPID_CYRILLIC: u32 = 5;
pub const LGRPID_TURKIC: u32 = 6;
pub const LGRPID_TURKISH: u32 = 6;
pub const LGRPID_JAPANESE: u32 = 7;
pub const LGRPID_KOREAN: u32 = 8;
pub const LGRPID_TRADITIONAL_CHINESE: u32 = 9;
pub const LGRPID_SIMPLIFIED_CHINESE: u32 = 10;
pub const LGRPID_THAI: u32 = 11;
pub const LGRPID_HEBREW: u32 = 12;
pub const LGRPID_ARABIC: u32 = 13;
pub const LGRPID_VIETNAMESE: u32 = 14;
pub const LGRPID_INDIC: u32 = 15;
pub const LGRPID_GEORGIAN: u32 = 16;
pub const LGRPID_ARMENIAN: u32 = 17;
pub const MUI_LANGUAGE_ID: u32 = 4;
pub const MUI_LANGUAGE_NAME: u32 = 8;
pub const MUI_MERGE_SYSTEM_FALLBACK: u32 = 16;
pub const MUI_MERGE_USER_FALLBACK: u32 = 32;
pub const MUI_UI_FALLBACK: u32 = 48;
pub const MUI_THREAD_LANGUAGES: u32 = 64;
pub const MUI_CONSOLE_FILTER: u32 = 256;
pub const MUI_COMPLEX_SCRIPT_FILTER: u32 = 512;
pub const MUI_RESET_FILTERS: u32 = 1;
pub const MUI_USER_PREFERRED_UI_LANGUAGES: u32 = 16;
pub const MUI_USE_INSTALLED_LANGUAGES: u32 = 32;
pub const MUI_USE_SEARCH_ALL_LANGUAGES: u32 = 64;
pub const MUI_LANG_NEUTRAL_PE_FILE: u32 = 256;
pub const MUI_NON_LANG_NEUTRAL_FILE: u32 = 512;
pub const MUI_MACHINE_LANGUAGE_SETTINGS: u32 = 1024;
pub const MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL: u32 = 1;
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN: u32 = 2;
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI: u32 = 4;
pub const MUI_QUERY_TYPE: u32 = 1;
pub const MUI_QUERY_CHECKSUM: u32 = 2;
pub const MUI_QUERY_LANGUAGE_NAME: u32 = 4;
pub const MUI_QUERY_RESOURCE_TYPES: u32 = 8;
pub const MUI_FILEINFO_VERSION: u32 = 1;
pub const MUI_FULL_LANGUAGE: u32 = 1;
pub const MUI_PARTIAL_LANGUAGE: u32 = 2;
pub const MUI_LIP_LANGUAGE: u32 = 4;
pub const MUI_LANGUAGE_INSTALLED: u32 = 32;
pub const MUI_LANGUAGE_LICENSED: u32 = 64;
pub const GEOID_NOT_AVAILABLE: i32 = -1;
pub const IDN_ALLOW_UNASSIGNED: u32 = 1;
pub const IDN_USE_STD3_ASCII_RULES: u32 = 2;
pub const IDN_EMAIL_ADDRESS: u32 = 4;
pub const IDN_RAW_PUNYCODE: u32 = 8;
pub const VS_ALLOW_LATIN: u32 = 1;
pub const GSS_ALLOW_INHERITED_COMMON: u32 = 1;
pub const MUI_FORMAT_REG_COMPAT: u32 = 1;
pub const MUI_FORMAT_INF_COMPAT: u32 = 2;
pub const MUI_VERIFY_FILE_EXISTS: u32 = 4;
pub const MUI_SKIP_STRING_CACHE: u32 = 8;
pub const MUI_IMMUTABLE_LOOKUP: u32 = 16;
pub const LOCALE_NAME_INVARIANT: &'static [u8; 1usize] = b"\0";
pub const LOCALE_NAME_SYSTEM_DEFAULT: &'static [u8; 22usize] = b"!x-sys-default-locale\0";
pub const RIGHT_ALT_PRESSED: u32 = 1;
pub const LEFT_ALT_PRESSED: u32 = 2;
pub const RIGHT_CTRL_PRESSED: u32 = 4;
pub const LEFT_CTRL_PRESSED: u32 = 8;
pub const SHIFT_PRESSED: u32 = 16;
pub const NUMLOCK_ON: u32 = 32;
pub const SCROLLLOCK_ON: u32 = 64;
pub const CAPSLOCK_ON: u32 = 128;
pub const ENHANCED_KEY: u32 = 256;
pub const NLS_DBCSCHAR: u32 = 65536;
pub const NLS_ALPHANUMERIC: u32 = 0;
pub const NLS_KATAKANA: u32 = 131072;
pub const NLS_HIRAGANA: u32 = 262144;
pub const NLS_ROMAN: u32 = 4194304;
pub const NLS_IME_CONVERSION: u32 = 8388608;
pub const NLS_IME_DISABLE: u32 = 536870912;
pub const FROM_LEFT_1ST_BUTTON_PRESSED: u32 = 1;
pub const RIGHTMOST_BUTTON_PRESSED: u32 = 2;
pub const FROM_LEFT_2ND_BUTTON_PRESSED: u32 = 4;
pub const FROM_LEFT_3RD_BUTTON_PRESSED: u32 = 8;
pub const FROM_LEFT_4TH_BUTTON_PRESSED: u32 = 16;
pub const MOUSE_MOVED: u32 = 1;
pub const DOUBLE_CLICK: u32 = 2;
pub const MOUSE_WHEELED: u32 = 4;
pub const MOUSE_HWHEELED: u32 = 8;
pub const KEY_EVENT: u32 = 1;
pub const MOUSE_EVENT: u32 = 2;
pub const WINDOW_BUFFER_SIZE_EVENT: u32 = 4;
pub const MENU_EVENT: u32 = 8;
pub const FOCUS_EVENT: u32 = 16;
pub const FOREGROUND_BLUE: u32 = 1;
pub const FOREGROUND_GREEN: u32 = 2;
pub const FOREGROUND_RED: u32 = 4;
pub const FOREGROUND_INTENSITY: u32 = 8;
pub const BACKGROUND_BLUE: u32 = 16;
pub const BACKGROUND_GREEN: u32 = 32;
pub const BACKGROUND_RED: u32 = 64;
pub const BACKGROUND_INTENSITY: u32 = 128;
pub const COMMON_LVB_LEADING_BYTE: u32 = 256;
pub const COMMON_LVB_TRAILING_BYTE: u32 = 512;
pub const COMMON_LVB_GRID_HORIZONTAL: u32 = 1024;
pub const COMMON_LVB_GRID_LVERTICAL: u32 = 2048;
pub const COMMON_LVB_GRID_RVERTICAL: u32 = 4096;
pub const COMMON_LVB_REVERSE_VIDEO: u32 = 16384;
pub const COMMON_LVB_UNDERSCORE: u32 = 32768;
pub const COMMON_LVB_SBCSDBCS: u32 = 768;
pub const HISTORY_NO_DUP_FLAG: u32 = 1;
pub const CONSOLE_NO_SELECTION: u32 = 0;
pub const CONSOLE_SELECTION_IN_PROGRESS: u32 = 1;
pub const CONSOLE_SELECTION_NOT_EMPTY: u32 = 2;
pub const CONSOLE_MOUSE_SELECTION: u32 = 4;
pub const CONSOLE_MOUSE_DOWN: u32 = 8;
pub const CTRL_C_EVENT: u32 = 0;
pub const CTRL_BREAK_EVENT: u32 = 1;
pub const CTRL_CLOSE_EVENT: u32 = 2;
pub const CTRL_LOGOFF_EVENT: u32 = 5;
pub const CTRL_SHUTDOWN_EVENT: u32 = 6;
pub const ENABLE_PROCESSED_INPUT: u32 = 1;
pub const ENABLE_LINE_INPUT: u32 = 2;
pub const ENABLE_ECHO_INPUT: u32 = 4;
pub const ENABLE_WINDOW_INPUT: u32 = 8;
pub const ENABLE_MOUSE_INPUT: u32 = 16;
pub const ENABLE_INSERT_MODE: u32 = 32;
pub const ENABLE_QUICK_EDIT_MODE: u32 = 64;
pub const ENABLE_EXTENDED_FLAGS: u32 = 128;
pub const ENABLE_AUTO_POSITION: u32 = 256;
pub const ENABLE_VIRTUAL_TERMINAL_INPUT: u32 = 512;
pub const ENABLE_PROCESSED_OUTPUT: u32 = 1;
pub const ENABLE_WRAP_AT_EOL_OUTPUT: u32 = 2;
pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING: u32 = 4;
pub const DISABLE_NEWLINE_AUTO_RETURN: u32 = 8;
pub const ENABLE_LVB_GRID_WORLDWIDE: u32 = 16;
pub const CONSOLE_TEXTMODE_BUFFER: u32 = 1;
pub const CONSOLE_FULLSCREEN: u32 = 1;
pub const CONSOLE_FULLSCREEN_HARDWARE: u32 = 2;
pub const CONSOLE_FULLSCREEN_MODE: u32 = 1;
pub const CONSOLE_WINDOWED_MODE: u32 = 2;
pub const VS_VERSION_INFO: u32 = 1;
pub const VS_USER_DEFINED: u32 = 100;
pub const VS_FFI_SIGNATURE: u32 = 4277077181;
pub const VS_FFI_STRUCVERSION: u32 = 65536;
pub const VS_FFI_FILEFLAGSMASK: u32 = 63;
pub const VS_FF_DEBUG: u32 = 1;
pub const VS_FF_PRERELEASE: u32 = 2;
pub const VS_FF_PATCHED: u32 = 4;
pub const VS_FF_PRIVATEBUILD: u32 = 8;
pub const VS_FF_INFOINFERRED: u32 = 16;
pub const VS_FF_SPECIALBUILD: u32 = 32;
pub const VOS_UNKNOWN: u32 = 0;
pub const VOS_DOS: u32 = 65536;
pub const VOS_OS216: u32 = 131072;
pub const VOS_OS232: u32 = 196608;
pub const VOS_NT: u32 = 262144;
pub const VOS_WINCE: u32 = 327680;
pub const VOS__BASE: u32 = 0;
pub const VOS__WINDOWS16: u32 = 1;
pub const VOS__PM16: u32 = 2;
pub const VOS__PM32: u32 = 3;
pub const VOS__WINDOWS32: u32 = 4;
pub const VOS_DOS_WINDOWS16: u32 = 65537;
pub const VOS_DOS_WINDOWS32: u32 = 65540;
pub const VOS_OS216_PM16: u32 = 131074;
pub const VOS_OS232_PM32: u32 = 196611;
pub const VOS_NT_WINDOWS32: u32 = 262148;
pub const VFT_UNKNOWN: u32 = 0;
pub const VFT_APP: u32 = 1;
pub const VFT_DLL: u32 = 2;
pub const VFT_DRV: u32 = 3;
pub const VFT_FONT: u32 = 4;
pub const VFT_VXD: u32 = 5;
pub const VFT_STATIC_LIB: u32 = 7;
pub const VFT2_UNKNOWN: u32 = 0;
pub const VFT2_DRV_PRINTER: u32 = 1;
pub const VFT2_DRV_KEYBOARD: u32 = 2;
pub const VFT2_DRV_LANGUAGE: u32 = 3;
pub const VFT2_DRV_DISPLAY: u32 = 4;
pub const VFT2_DRV_MOUSE: u32 = 5;
pub const VFT2_DRV_NETWORK: u32 = 6;
pub const VFT2_DRV_SYSTEM: u32 = 7;
pub const VFT2_DRV_INSTALLABLE: u32 = 8;
pub const VFT2_DRV_SOUND: u32 = 9;
pub const VFT2_DRV_COMM: u32 = 10;
pub const VFT2_DRV_INPUTMETHOD: u32 = 11;
pub const VFT2_DRV_VERSIONED_PRINTER: u32 = 12;
pub const VFT2_FONT_RASTER: u32 = 1;
pub const VFT2_FONT_VECTOR: u32 = 2;
pub const VFT2_FONT_TRUETYPE: u32 = 3;
pub const VFFF_ISSHAREDFILE: u32 = 1;
pub const VFF_CURNEDEST: u32 = 1;
pub const VFF_FILEINUSE: u32 = 2;
pub const VFF_BUFFTOOSMALL: u32 = 4;
pub const VIFF_FORCEINSTALL: u32 = 1;
pub const VIFF_DONTDELETEOLD: u32 = 2;
pub const VIF_TEMPFILE: u32 = 1;
pub const VIF_MISMATCH: u32 = 2;
pub const VIF_SRCOLD: u32 = 4;
pub const VIF_DIFFLANG: u32 = 8;
pub const VIF_DIFFCODEPG: u32 = 16;
pub const VIF_DIFFTYPE: u32 = 32;
pub const VIF_WRITEPROT: u32 = 64;
pub const VIF_FILEINUSE: u32 = 128;
pub const VIF_OUTOFSPACE: u32 = 256;
pub const VIF_ACCESSVIOLATION: u32 = 512;
pub const VIF_SHARINGVIOLATION: u32 = 1024;
pub const VIF_CANNOTCREATE: u32 = 2048;
pub const VIF_CANNOTDELETE: u32 = 4096;
pub const VIF_CANNOTRENAME: u32 = 8192;
pub const VIF_CANNOTDELETECUR: u32 = 16384;
pub const VIF_OUTOFMEMORY: u32 = 32768;
pub const VIF_CANNOTREADSRC: u32 = 65536;
pub const VIF_CANNOTREADDST: u32 = 131072;
pub const VIF_BUFFTOOSMALL: u32 = 262144;
pub const VIF_CANNOTLOADLZ32: u32 = 524288;
pub const VIF_CANNOTLOADCABINET: u32 = 1048576;
pub const FILE_VER_GET_LOCALISED: u32 = 1;
pub const FILE_VER_GET_NEUTRAL: u32 = 2;
pub const FILE_VER_GET_PREFETCHED: u32 = 4;
pub const RRF_RT_REG_NONE: u32 = 1;
pub const RRF_RT_REG_SZ: u32 = 2;
pub const RRF_RT_REG_EXPAND_SZ: u32 = 4;
pub const RRF_RT_REG_BINARY: u32 = 8;
pub const RRF_RT_REG_DWORD: u32 = 16;
pub const RRF_RT_REG_MULTI_SZ: u32 = 32;
pub const RRF_RT_REG_QWORD: u32 = 64;
pub const RRF_RT_DWORD: u32 = 24;
pub const RRF_RT_QWORD: u32 = 72;
pub const RRF_RT_ANY: u32 = 65535;
pub const RRF_SUBKEY_WOW6464KEY: u32 = 65536;
pub const RRF_SUBKEY_WOW6432KEY: u32 = 131072;
pub const RRF_WOW64_MASK: u32 = 196608;
pub const RRF_NOEXPAND: u32 = 268435456;
pub const RRF_ZEROONFAILURE: u32 = 536870912;
pub const REG_PROCESS_APPKEY: u32 = 1;
pub const PROVIDER_KEEPS_VALUE_LENGTH: u32 = 1;
pub const REG_MUI_STRING_TRUNCATE: u32 = 1;
pub const REG_SECURE_CONNECTION: u32 = 1;
pub const SHTDN_REASON_FLAG_COMMENT_REQUIRED: u32 = 16777216;
pub const SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED: u32 = 33554432;
pub const SHTDN_REASON_FLAG_CLEAN_UI: u32 = 67108864;
pub const SHTDN_REASON_FLAG_DIRTY_UI: u32 = 134217728;
pub const SHTDN_REASON_FLAG_MOBILE_UI_RESERVED: u32 = 268435456;
pub const SHTDN_REASON_FLAG_USER_DEFINED: u32 = 1073741824;
pub const SHTDN_REASON_FLAG_PLANNED: u32 = 2147483648;
pub const SHTDN_REASON_MAJOR_OTHER: u32 = 0;
pub const SHTDN_REASON_MAJOR_NONE: u32 = 0;
pub const SHTDN_REASON_MAJOR_HARDWARE: u32 = 65536;
pub const SHTDN_REASON_MAJOR_OPERATINGSYSTEM: u32 = 131072;
pub const SHTDN_REASON_MAJOR_SOFTWARE: u32 = 196608;
pub const SHTDN_REASON_MAJOR_APPLICATION: u32 = 262144;
pub const SHTDN_REASON_MAJOR_SYSTEM: u32 = 327680;
pub const SHTDN_REASON_MAJOR_POWER: u32 = 393216;
pub const SHTDN_REASON_MAJOR_LEGACY_API: u32 = 458752;
pub const SHTDN_REASON_MINOR_OTHER: u32 = 0;
pub const SHTDN_REASON_MINOR_NONE: u32 = 255;
pub const SHTDN_REASON_MINOR_MAINTENANCE: u32 = 1;
pub const SHTDN_REASON_MINOR_INSTALLATION: u32 = 2;
pub const SHTDN_REASON_MINOR_UPGRADE: u32 = 3;
pub const SHTDN_REASON_MINOR_RECONFIG: u32 = 4;
pub const SHTDN_REASON_MINOR_HUNG: u32 = 5;
pub const SHTDN_REASON_MINOR_UNSTABLE: u32 = 6;
pub const SHTDN_REASON_MINOR_DISK: u32 = 7;
pub const SHTDN_REASON_MINOR_PROCESSOR: u32 = 8;
pub const SHTDN_REASON_MINOR_NETWORKCARD: u32 = 9;
pub const SHTDN_REASON_MINOR_POWER_SUPPLY: u32 = 10;
pub const SHTDN_REASON_MINOR_CORDUNPLUGGED: u32 = 11;
pub const SHTDN_REASON_MINOR_ENVIRONMENT: u32 = 12;
pub const SHTDN_REASON_MINOR_HARDWARE_DRIVER: u32 = 13;
pub const SHTDN_REASON_MINOR_OTHERDRIVER: u32 = 14;
pub const SHTDN_REASON_MINOR_BLUESCREEN: u32 = 15;
pub const SHTDN_REASON_MINOR_SERVICEPACK: u32 = 16;
pub const SHTDN_REASON_MINOR_HOTFIX: u32 = 17;
pub const SHTDN_REASON_MINOR_SECURITYFIX: u32 = 18;
pub const SHTDN_REASON_MINOR_SECURITY: u32 = 19;
pub const SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY: u32 = 20;
pub const SHTDN_REASON_MINOR_WMI: u32 = 21;
pub const SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL: u32 = 22;
pub const SHTDN_REASON_MINOR_HOTFIX_UNINSTALL: u32 = 23;
pub const SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL: u32 = 24;
pub const SHTDN_REASON_MINOR_MMC: u32 = 25;
pub const SHTDN_REASON_MINOR_SYSTEMRESTORE: u32 = 26;
pub const SHTDN_REASON_MINOR_TERMSRV: u32 = 32;
pub const SHTDN_REASON_MINOR_DC_PROMOTION: u32 = 33;
pub const SHTDN_REASON_MINOR_DC_DEMOTION: u32 = 34;
pub const SHTDN_REASON_UNKNOWN: u32 = 255;
pub const SHTDN_REASON_LEGACY_API: u32 = 2147942400;
pub const SHTDN_REASON_VALID_BIT_MASK: u32 = 3238002687;
pub const PCLEANUI: u32 = 2214592512;
pub const UCLEANUI: u32 = 67108864;
pub const PDIRTYUI: u32 = 2281701376;
pub const UDIRTYUI: u32 = 134217728;
pub const MAX_REASON_NAME_LEN: u32 = 64;
pub const MAX_REASON_DESC_LEN: u32 = 256;
pub const MAX_REASON_BUGID_LEN: u32 = 32;
pub const MAX_REASON_COMMENT_LEN: u32 = 512;
pub const SHUTDOWN_TYPE_LEN: u32 = 32;
pub const POLICY_SHOWREASONUI_NEVER: u32 = 0;
pub const POLICY_SHOWREASONUI_ALWAYS: u32 = 1;
pub const POLICY_SHOWREASONUI_WORKSTATIONONLY: u32 = 2;
pub const POLICY_SHOWREASONUI_SERVERONLY: u32 = 3;
pub const SNAPSHOT_POLICY_NEVER: u32 = 0;
pub const SNAPSHOT_POLICY_ALWAYS: u32 = 1;
pub const SNAPSHOT_POLICY_UNPLANNED: u32 = 2;
pub const MAX_NUM_REASONS: u32 = 256;
pub const REASON_SWINSTALL: u32 = 196610;
pub const REASON_HWINSTALL: u32 = 65538;
pub const REASON_SERVICEHANG: u32 = 196613;
pub const REASON_UNSTABLE: u32 = 327686;
pub const REASON_SWHWRECONF: u32 = 196612;
pub const REASON_OTHER: u32 = 0;
pub const REASON_UNKNOWN: u32 = 255;
pub const REASON_LEGACY_API: u32 = 2147942400;
pub const REASON_PLANNED_FLAG: u32 = 2147483648;
pub const MAX_SHUTDOWN_TIMEOUT: u32 = 315360000;
pub const SHUTDOWN_FORCE_OTHERS: u32 = 1;
pub const SHUTDOWN_FORCE_SELF: u32 = 2;
pub const SHUTDOWN_RESTART: u32 = 4;
pub const SHUTDOWN_POWEROFF: u32 = 8;
pub const SHUTDOWN_NOREBOOT: u32 = 16;
pub const SHUTDOWN_GRACE_OVERRIDE: u32 = 32;
pub const SHUTDOWN_INSTALL_UPDATES: u32 = 64;
pub const SHUTDOWN_RESTARTAPPS: u32 = 128;
pub const SHUTDOWN_SKIP_SVC_PRESHUTDOWN: u32 = 256;
pub const SHUTDOWN_HYBRID: u32 = 512;
pub const SHUTDOWN_RESTART_BOOTOPTIONS: u32 = 1024;
pub const SHUTDOWN_SOFT_REBOOT: u32 = 2048;
pub const SHUTDOWN_MOBILE_UI: u32 = 4096;
pub const WNNC_NET_MSNET: u32 = 65536;
pub const WNNC_NET_SMB: u32 = 131072;
pub const WNNC_NET_NETWARE: u32 = 196608;
pub const WNNC_NET_VINES: u32 = 262144;
pub const WNNC_NET_10NET: u32 = 327680;
pub const WNNC_NET_LOCUS: u32 = 393216;
pub const WNNC_NET_SUN_PC_NFS: u32 = 458752;
pub const WNNC_NET_LANSTEP: u32 = 524288;
pub const WNNC_NET_9TILES: u32 = 589824;
pub const WNNC_NET_LANTASTIC: u32 = 655360;
pub const WNNC_NET_AS400: u32 = 720896;
pub const WNNC_NET_FTP_NFS: u32 = 786432;
pub const WNNC_NET_PATHWORKS: u32 = 851968;
pub const WNNC_NET_LIFENET: u32 = 917504;
pub const WNNC_NET_POWERLAN: u32 = 983040;
pub const WNNC_NET_BWNFS: u32 = 1048576;
pub const WNNC_NET_COGENT: u32 = 1114112;
pub const WNNC_NET_FARALLON: u32 = 1179648;
pub const WNNC_NET_APPLETALK: u32 = 1245184;
pub const WNNC_NET_INTERGRAPH: u32 = 1310720;
pub const WNNC_NET_SYMFONET: u32 = 1376256;
pub const WNNC_NET_CLEARCASE: u32 = 1441792;
pub const WNNC_NET_FRONTIER: u32 = 1507328;
pub const WNNC_NET_BMC: u32 = 1572864;
pub const WNNC_NET_DCE: u32 = 1638400;
pub const WNNC_NET_AVID: u32 = 1703936;
pub const WNNC_NET_DOCUSPACE: u32 = 1769472;
pub const WNNC_NET_MANGOSOFT: u32 = 1835008;
pub const WNNC_NET_SERNET: u32 = 1900544;
pub const WNNC_NET_RIVERFRONT2: u32 = 2031616;
pub const WNNC_NET_DECORB: u32 = 2097152;
pub const WNNC_NET_PROTSTOR: u32 = 2162688;
pub const WNNC_NET_FJ_REDIR: u32 = 2228224;
pub const WNNC_NET_DISTINCT: u32 = 2293760;
pub const WNNC_NET_TWINS: u32 = 2359296;
pub const WNNC_NET_RDR2SAMPLE: u32 = 2424832;
pub const WNNC_NET_CSC: u32 = 2490368;
pub const WNNC_NET_3IN1: u32 = 2555904;
pub const WNNC_NET_EXTENDNET: u32 = 2686976;
pub const WNNC_NET_STAC: u32 = 2752512;
pub const WNNC_NET_FOXBAT: u32 = 2818048;
pub const WNNC_NET_YAHOO: u32 = 2883584;
pub const WNNC_NET_EXIFS: u32 = 2949120;
pub const WNNC_NET_DAV: u32 = 3014656;
pub const WNNC_NET_KNOWARE: u32 = 3080192;
pub const WNNC_NET_OBJECT_DIRE: u32 = 3145728;
pub const WNNC_NET_MASFAX: u32 = 3211264;
pub const WNNC_NET_HOB_NFS: u32 = 3276800;
pub const WNNC_NET_SHIVA: u32 = 3342336;
pub const WNNC_NET_IBMAL: u32 = 3407872;
pub const WNNC_NET_LOCK: u32 = 3473408;
pub const WNNC_NET_TERMSRV: u32 = 3538944;
pub const WNNC_NET_SRT: u32 = 3604480;
pub const WNNC_NET_QUINCY: u32 = 3670016;
pub const WNNC_NET_OPENAFS: u32 = 3735552;
pub const WNNC_NET_DFS: u32 = 3866624;
pub const WNNC_NET_KWNP: u32 = 3932160;
pub const WNNC_NET_ZENWORKS: u32 = 3997696;
pub const WNNC_NET_DRIVEONWEB: u32 = 4063232;
pub const WNNC_NET_VMWARE: u32 = 4128768;
pub const WNNC_NET_RSFX: u32 = 4194304;
pub const WNNC_NET_MFILES: u32 = 4259840;
pub const WNNC_NET_MS_NFS: u32 = 4325376;
pub const WNNC_NET_GOOGLE: u32 = 4390912;
pub const WNNC_NET_NDFS: u32 = 4456448;
pub const WNNC_NET_DOCUSHARE: u32 = 4521984;
pub const WNNC_CRED_MANAGER: u32 = 4294901760;
pub const WNNC_NET_LANMAN: u32 = 131072;
pub const RESOURCE_CONNECTED: u32 = 1;
pub const RESOURCE_GLOBALNET: u32 = 2;
pub const RESOURCE_REMEMBERED: u32 = 3;
pub const RESOURCE_RECENT: u32 = 4;
pub const RESOURCE_CONTEXT: u32 = 5;
pub const RESOURCETYPE_ANY: u32 = 0;
pub const RESOURCETYPE_DISK: u32 = 1;
pub const RESOURCETYPE_PRINT: u32 = 2;
pub const RESOURCETYPE_RESERVED: u32 = 8;
pub const RESOURCETYPE_UNKNOWN: u32 = 4294967295;
pub const RESOURCEUSAGE_CONNECTABLE: u32 = 1;
pub const RESOURCEUSAGE_CONTAINER: u32 = 2;
pub const RESOURCEUSAGE_NOLOCALDEVICE: u32 = 4;
pub const RESOURCEUSAGE_SIBLING: u32 = 8;
pub const RESOURCEUSAGE_ATTACHED: u32 = 16;
pub const RESOURCEUSAGE_ALL: u32 = 19;
pub const RESOURCEUSAGE_RESERVED: u32 = 2147483648;
pub const RESOURCEDISPLAYTYPE_GENERIC: u32 = 0;
pub const RESOURCEDISPLAYTYPE_DOMAIN: u32 = 1;
pub const RESOURCEDISPLAYTYPE_SERVER: u32 = 2;
pub const RESOURCEDISPLAYTYPE_SHARE: u32 = 3;
pub const RESOURCEDISPLAYTYPE_FILE: u32 = 4;
pub const RESOURCEDISPLAYTYPE_GROUP: u32 = 5;
pub const RESOURCEDISPLAYTYPE_NETWORK: u32 = 6;
pub const RESOURCEDISPLAYTYPE_ROOT: u32 = 7;
pub const RESOURCEDISPLAYTYPE_SHAREADMIN: u32 = 8;
pub const RESOURCEDISPLAYTYPE_DIRECTORY: u32 = 9;
pub const RESOURCEDISPLAYTYPE_TREE: u32 = 10;
pub const RESOURCEDISPLAYTYPE_NDSCONTAINER: u32 = 11;
pub const NETPROPERTY_PERSISTENT: u32 = 1;
pub const CONNECT_UPDATE_PROFILE: u32 = 1;
pub const CONNECT_UPDATE_RECENT: u32 = 2;
pub const CONNECT_TEMPORARY: u32 = 4;
pub const CONNECT_INTERACTIVE: u32 = 8;
pub const CONNECT_PROMPT: u32 = 16;
pub const CONNECT_NEED_DRIVE: u32 = 32;
pub const CONNECT_REFCOUNT: u32 = 64;
pub const CONNECT_REDIRECT: u32 = 128;
pub const CONNECT_LOCALDRIVE: u32 = 256;
pub const CONNECT_CURRENT_MEDIA: u32 = 512;
pub const CONNECT_DEFERRED: u32 = 1024;
pub const CONNECT_RESERVED: u32 = 4278190080;
pub const CONNECT_COMMANDLINE: u32 = 2048;
pub const CONNECT_CMD_SAVECRED: u32 = 4096;
pub const CONNECT_CRED_RESET: u32 = 8192;
pub const CONNECT_REQUIRE_INTEGRITY: u32 = 16384;
pub const CONNECT_REQUIRE_PRIVACY: u32 = 32768;
pub const CONNDLG_RO_PATH: u32 = 1;
pub const CONNDLG_CONN_POINT: u32 = 2;
pub const CONNDLG_USE_MRU: u32 = 4;
pub const CONNDLG_HIDE_BOX: u32 = 8;
pub const CONNDLG_PERSIST: u32 = 16;
pub const CONNDLG_NOT_PERSIST: u32 = 32;
pub const DISC_UPDATE_PROFILE: u32 = 1;
pub const DISC_NO_FORCE: u32 = 64;
pub const UNIVERSAL_NAME_INFO_LEVEL: u32 = 1;
pub const REMOTE_NAME_INFO_LEVEL: u32 = 2;
pub const WNFMT_MULTILINE: u32 = 1;
pub const WNFMT_ABBREVIATED: u32 = 2;
pub const WNFMT_INENUM: u32 = 16;
pub const WNFMT_CONNECTION: u32 = 32;
pub const NETINFO_DLL16: u32 = 1;
pub const NETINFO_DISKRED: u32 = 4;
pub const NETINFO_PRINTERRED: u32 = 8;
pub const WN_SUCCESS: u32 = 0;
pub const WN_NO_ERROR: u32 = 0;
pub const WN_NOT_SUPPORTED: u32 = 50;
pub const WN_CANCEL: u32 = 1223;
pub const WN_RETRY: u32 = 1237;
pub const WN_NET_ERROR: u32 = 59;
pub const WN_MORE_DATA: u32 = 234;
pub const WN_BAD_POINTER: u32 = 487;
pub const WN_BAD_VALUE: u32 = 87;
pub const WN_BAD_USER: u32 = 2202;
pub const WN_BAD_PASSWORD: u32 = 86;
pub const WN_ACCESS_DENIED: u32 = 5;
pub const WN_FUNCTION_BUSY: u32 = 170;
pub const WN_WINDOWS_ERROR: u32 = 59;
pub const WN_OUT_OF_MEMORY: u32 = 8;
pub const WN_NO_NETWORK: u32 = 1222;
pub const WN_EXTENDED_ERROR: u32 = 1208;
pub const WN_BAD_LEVEL: u32 = 124;
pub const WN_BAD_HANDLE: u32 = 6;
pub const WN_NOT_INITIALIZING: u32 = 1247;
pub const WN_NO_MORE_DEVICES: u32 = 1248;
pub const WN_NOT_CONNECTED: u32 = 2250;
pub const WN_OPEN_FILES: u32 = 2401;
pub const WN_DEVICE_IN_USE: u32 = 2404;
pub const WN_BAD_NETNAME: u32 = 67;
pub const WN_BAD_LOCALNAME: u32 = 1200;
pub const WN_ALREADY_CONNECTED: u32 = 85;
pub const WN_DEVICE_ERROR: u32 = 31;
pub const WN_CONNECTION_CLOSED: u32 = 1201;
pub const WN_NO_NET_OR_BAD_PATH: u32 = 1203;
pub const WN_BAD_PROVIDER: u32 = 1204;
pub const WN_CANNOT_OPEN_PROFILE: u32 = 1205;
pub const WN_BAD_PROFILE: u32 = 1206;
pub const WN_BAD_DEV_TYPE: u32 = 66;
pub const WN_DEVICE_ALREADY_REMEMBERED: u32 = 1202;
pub const WN_CONNECTED_OTHER_PASSWORD: u32 = 2108;
pub const WN_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 2109;
pub const WN_NO_MORE_ENTRIES: u32 = 259;
pub const WN_NOT_CONTAINER: u32 = 1207;
pub const WN_NOT_AUTHENTICATED: u32 = 1244;
pub const WN_NOT_LOGGED_ON: u32 = 1245;
pub const WN_NOT_VALIDATED: u32 = 1311;
pub const WNCON_FORNETCARD: u32 = 1;
pub const WNCON_NOTROUTED: u32 = 2;
pub const WNCON_SLOWLINK: u32 = 4;
pub const WNCON_DYNAMIC: u32 = 8;
pub const _STRALIGN_USE_SECURE_CRT: u32 = 1;
pub const SERVICES_ACTIVE_DATABASEW: &'static [u8; 15usize] = b"ServicesActive\0";
pub const SERVICES_FAILED_DATABASEW: &'static [u8; 15usize] = b"ServicesFailed\0";
pub const SERVICES_ACTIVE_DATABASEA: &'static [u8; 15usize] = b"ServicesActive\0";
pub const SERVICES_FAILED_DATABASEA: &'static [u8; 15usize] = b"ServicesFailed\0";
pub const SC_GROUP_IDENTIFIERW: u8 = 43u8;
pub const SC_GROUP_IDENTIFIERA: u8 = 43u8;
pub const SERVICES_ACTIVE_DATABASE: &'static [u8; 15usize] = b"ServicesActive\0";
pub const SERVICES_FAILED_DATABASE: &'static [u8; 15usize] = b"ServicesFailed\0";
pub const SC_GROUP_IDENTIFIER: u8 = 43u8;
pub const SERVICE_NO_CHANGE: u32 = 4294967295;
pub const SERVICE_ACTIVE: u32 = 1;
pub const SERVICE_INACTIVE: u32 = 2;
pub const SERVICE_STATE_ALL: u32 = 3;
pub const SERVICE_CONTROL_STOP: u32 = 1;
pub const SERVICE_CONTROL_PAUSE: u32 = 2;
pub const SERVICE_CONTROL_CONTINUE: u32 = 3;
pub const SERVICE_CONTROL_INTERROGATE: u32 = 4;
pub const SERVICE_CONTROL_SHUTDOWN: u32 = 5;
pub const SERVICE_CONTROL_PARAMCHANGE: u32 = 6;
pub const SERVICE_CONTROL_NETBINDADD: u32 = 7;
pub const SERVICE_CONTROL_NETBINDREMOVE: u32 = 8;
pub const SERVICE_CONTROL_NETBINDENABLE: u32 = 9;
pub const SERVICE_CONTROL_NETBINDDISABLE: u32 = 10;
pub const SERVICE_CONTROL_DEVICEEVENT: u32 = 11;
pub const SERVICE_CONTROL_HARDWAREPROFILECHANGE: u32 = 12;
pub const SERVICE_CONTROL_POWEREVENT: u32 = 13;
pub const SERVICE_CONTROL_SESSIONCHANGE: u32 = 14;
pub const SERVICE_CONTROL_PRESHUTDOWN: u32 = 15;
pub const SERVICE_CONTROL_TIMECHANGE: u32 = 16;
pub const SERVICE_CONTROL_TRIGGEREVENT: u32 = 32;
pub const SERVICE_CONTROL_LOWRESOURCES: u32 = 96;
pub const SERVICE_CONTROL_SYSTEMLOWRESOURCES: u32 = 97;
pub const SERVICE_STOPPED: u32 = 1;
pub const SERVICE_START_PENDING: u32 = 2;
pub const SERVICE_STOP_PENDING: u32 = 3;
pub const SERVICE_RUNNING: u32 = 4;
pub const SERVICE_CONTINUE_PENDING: u32 = 5;
pub const SERVICE_PAUSE_PENDING: u32 = 6;
pub const SERVICE_PAUSED: u32 = 7;
pub const SERVICE_ACCEPT_STOP: u32 = 1;
pub const SERVICE_ACCEPT_PAUSE_CONTINUE: u32 = 2;
pub const SERVICE_ACCEPT_SHUTDOWN: u32 = 4;
pub const SERVICE_ACCEPT_PARAMCHANGE: u32 = 8;
pub const SERVICE_ACCEPT_NETBINDCHANGE: u32 = 16;
pub const SERVICE_ACCEPT_HARDWAREPROFILECHANGE: u32 = 32;
pub const SERVICE_ACCEPT_POWEREVENT: u32 = 64;
pub const SERVICE_ACCEPT_SESSIONCHANGE: u32 = 128;
pub const SERVICE_ACCEPT_PRESHUTDOWN: u32 = 256;
pub const SERVICE_ACCEPT_TIMECHANGE: u32 = 512;
pub const SERVICE_ACCEPT_TRIGGEREVENT: u32 = 1024;
pub const SERVICE_ACCEPT_USER_LOGOFF: u32 = 2048;
pub const SERVICE_ACCEPT_LOWRESOURCES: u32 = 8192;
pub const SERVICE_ACCEPT_SYSTEMLOWRESOURCES: u32 = 16384;
pub const SC_MANAGER_CONNECT: u32 = 1;
pub const SC_MANAGER_CREATE_SERVICE: u32 = 2;
pub const SC_MANAGER_ENUMERATE_SERVICE: u32 = 4;
pub const SC_MANAGER_LOCK: u32 = 8;
pub const SC_MANAGER_QUERY_LOCK_STATUS: u32 = 16;
pub const SC_MANAGER_MODIFY_BOOT_CONFIG: u32 = 32;
pub const SC_MANAGER_ALL_ACCESS: u32 = 983103;
pub const SERVICE_QUERY_CONFIG: u32 = 1;
pub const SERVICE_CHANGE_CONFIG: u32 = 2;
pub const SERVICE_QUERY_STATUS: u32 = 4;
pub const SERVICE_ENUMERATE_DEPENDENTS: u32 = 8;
pub const SERVICE_START: u32 = 16;
pub const SERVICE_STOP: u32 = 32;
pub const SERVICE_PAUSE_CONTINUE: u32 = 64;
pub const SERVICE_INTERROGATE: u32 = 128;
pub const SERVICE_USER_DEFINED_CONTROL: u32 = 256;
pub const SERVICE_ALL_ACCESS: u32 = 983551;
pub const SERVICE_RUNS_IN_SYSTEM_PROCESS: u32 = 1;
pub const SERVICE_CONFIG_DESCRIPTION: u32 = 1;
pub const SERVICE_CONFIG_FAILURE_ACTIONS: u32 = 2;
pub const SERVICE_CONFIG_DELAYED_AUTO_START_INFO: u32 = 3;
pub const SERVICE_CONFIG_FAILURE_ACTIONS_FLAG: u32 = 4;
pub const SERVICE_CONFIG_SERVICE_SID_INFO: u32 = 5;
pub const SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO: u32 = 6;
pub const SERVICE_CONFIG_PRESHUTDOWN_INFO: u32 = 7;
pub const SERVICE_CONFIG_TRIGGER_INFO: u32 = 8;
pub const SERVICE_CONFIG_PREFERRED_NODE: u32 = 9;
pub const SERVICE_CONFIG_LAUNCH_PROTECTED: u32 = 12;
pub const SERVICE_NOTIFY_STATUS_CHANGE_1: u32 = 1;
pub const SERVICE_NOTIFY_STATUS_CHANGE_2: u32 = 2;
pub const SERVICE_NOTIFY_STATUS_CHANGE: u32 = 2;
pub const SERVICE_NOTIFY_STOPPED: u32 = 1;
pub const SERVICE_NOTIFY_START_PENDING: u32 = 2;
pub const SERVICE_NOTIFY_STOP_PENDING: u32 = 4;
pub const SERVICE_NOTIFY_RUNNING: u32 = 8;
pub const SERVICE_NOTIFY_CONTINUE_PENDING: u32 = 16;
pub const SERVICE_NOTIFY_PAUSE_PENDING: u32 = 32;
pub const SERVICE_NOTIFY_PAUSED: u32 = 64;
pub const SERVICE_NOTIFY_CREATED: u32 = 128;
pub const SERVICE_NOTIFY_DELETED: u32 = 256;
pub const SERVICE_NOTIFY_DELETE_PENDING: u32 = 512;
pub const SERVICE_STOP_REASON_FLAG_MIN: u32 = 0;
pub const SERVICE_STOP_REASON_FLAG_UNPLANNED: u32 = 268435456;
pub const SERVICE_STOP_REASON_FLAG_CUSTOM: u32 = 536870912;
pub const SERVICE_STOP_REASON_FLAG_PLANNED: u32 = 1073741824;
pub const SERVICE_STOP_REASON_FLAG_MAX: u32 = 2147483648;
pub const SERVICE_STOP_REASON_MAJOR_MIN: u32 = 0;
pub const SERVICE_STOP_REASON_MAJOR_OTHER: u32 = 65536;
pub const SERVICE_STOP_REASON_MAJOR_HARDWARE: u32 = 131072;
pub const SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM: u32 = 196608;
pub const SERVICE_STOP_REASON_MAJOR_SOFTWARE: u32 = 262144;
pub const SERVICE_STOP_REASON_MAJOR_APPLICATION: u32 = 327680;
pub const SERVICE_STOP_REASON_MAJOR_NONE: u32 = 393216;
pub const SERVICE_STOP_REASON_MAJOR_MAX: u32 = 458752;
pub const SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM: u32 = 4194304;
pub const SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM: u32 = 16711680;
pub const SERVICE_STOP_REASON_MINOR_MIN: u32 = 0;
pub const SERVICE_STOP_REASON_MINOR_OTHER: u32 = 1;
pub const SERVICE_STOP_REASON_MINOR_MAINTENANCE: u32 = 2;
pub const SERVICE_STOP_REASON_MINOR_INSTALLATION: u32 = 3;
pub const SERVICE_STOP_REASON_MINOR_UPGRADE: u32 = 4;
pub const SERVICE_STOP_REASON_MINOR_RECONFIG: u32 = 5;
pub const SERVICE_STOP_REASON_MINOR_HUNG: u32 = 6;
pub const SERVICE_STOP_REASON_MINOR_UNSTABLE: u32 = 7;
pub const SERVICE_STOP_REASON_MINOR_DISK: u32 = 8;
pub const SERVICE_STOP_REASON_MINOR_NETWORKCARD: u32 = 9;
pub const SERVICE_STOP_REASON_MINOR_ENVIRONMENT: u32 = 10;
pub const SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER: u32 = 11;
pub const SERVICE_STOP_REASON_MINOR_OTHERDRIVER: u32 = 12;
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK: u32 = 13;
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE: u32 = 14;
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX: u32 = 15;
pub const SERVICE_STOP_REASON_MINOR_SECURITY: u32 = 16;
pub const SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY: u32 = 17;
pub const SERVICE_STOP_REASON_MINOR_WMI: u32 = 18;
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL: u32 = 19;
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL: u32 = 20;
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL: u32 = 21;
pub const SERVICE_STOP_REASON_MINOR_MMC: u32 = 22;
pub const SERVICE_STOP_REASON_MINOR_NONE: u32 = 23;
pub const SERVICE_STOP_REASON_MINOR_MEMOTYLIMIT: u32 = 24;
pub const SERVICE_STOP_REASON_MINOR_MAX: u32 = 25;
pub const SERVICE_STOP_REASON_MINOR_MIN_CUSTOM: u32 = 256;
pub const SERVICE_STOP_REASON_MINOR_MAX_CUSTOM: u32 = 65535;
pub const SERVICE_CONTROL_STATUS_REASON_INFO: u32 = 1;
pub const SERVICE_SID_TYPE_NONE: u32 = 0;
pub const SERVICE_SID_TYPE_UNRESTRICTED: u32 = 1;
pub const SERVICE_SID_TYPE_RESTRICTED: u32 = 3;
pub const SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL: u32 = 1;
pub const SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY: u32 = 2;
pub const SERVICE_TRIGGER_TYPE_DOMAIN_JOIN: u32 = 3;
pub const SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT: u32 = 4;
pub const SERVICE_TRIGGER_TYPE_GROUP_POLICY: u32 = 5;
pub const SERVICE_TRIGGER_TYPE_NETWORK_ENDPOINT: u32 = 6;
pub const SERVICE_TRIGGER_TYPE_CUSTOM_SYSTEM_STATE_CHANGE: u32 = 7;
pub const SERVICE_TRIGGER_TYPE_CUSTOM: u32 = 20;
pub const SERVICE_TRIGGER_TYPE_AGGREGATE: u32 = 30;
pub const SERVICE_TRIGGER_DATA_TYPE_BINARY: u32 = 1;
pub const SERVICE_TRIGGER_DATA_TYPE_STRING: u32 = 2;
pub const SERVICE_TRIGGER_DATA_TYPE_LEVEL: u32 = 3;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ANY: u32 = 4;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ALL: u32 = 5;
pub const SERVICE_START_REASON_DEMAND: u32 = 1;
pub const SERVICE_START_REASON_AUTO: u32 = 2;
pub const SERVICE_START_REASON_TRIGGER: u32 = 4;
pub const SERVICE_START_REASON_RESTART_ON_FAILURE: u32 = 8;
pub const SERVICE_START_REASON_DELAYEDAUTO: u32 = 16;
pub const SERVICE_DYNAMIC_INFORMATION_LEVEL_START_REASON: u32 = 1;
pub const SERVICE_LAUNCH_PROTECTED_NONE: u32 = 0;
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS: u32 = 1;
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS_LIGHT: u32 = 2;
pub const SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT: u32 = 3;
pub const SERVICE_TRIGGER_ACTION_SERVICE_START: u32 = 1;
pub const SERVICE_TRIGGER_ACTION_SERVICE_STOP: u32 = 2;
pub const SERVICE_TRIGGER_STARTED_ARGUMENT: &'static [u8; 15usize] = b"TriggerStarted\0";
pub const SC_AGGREGATE_STORAGE_KEY: &'static [u8; 57usize] =
  b"System\\CurrentControlSet\\Control\\ServiceAggregatedEvents\0";
pub const DIALOPTION_BILLING: u32 = 64;
pub const DIALOPTION_QUIET: u32 = 128;
pub const DIALOPTION_DIALTONE: u32 = 256;
pub const MDMVOLFLAG_LOW: u32 = 1;
pub const MDMVOLFLAG_MEDIUM: u32 = 2;
pub const MDMVOLFLAG_HIGH: u32 = 4;
pub const MDMVOL_LOW: u32 = 0;
pub const MDMVOL_MEDIUM: u32 = 1;
pub const MDMVOL_HIGH: u32 = 2;
pub const MDMSPKRFLAG_OFF: u32 = 1;
pub const MDMSPKRFLAG_DIAL: u32 = 2;
pub const MDMSPKRFLAG_ON: u32 = 4;
pub const MDMSPKRFLAG_CALLSETUP: u32 = 8;
pub const MDMSPKR_OFF: u32 = 0;
pub const MDMSPKR_DIAL: u32 = 1;
pub const MDMSPKR_ON: u32 = 2;
pub const MDMSPKR_CALLSETUP: u32 = 3;
pub const MDM_COMPRESSION: u32 = 1;
pub const MDM_ERROR_CONTROL: u32 = 2;
pub const MDM_FORCED_EC: u32 = 4;
pub const MDM_CELLULAR: u32 = 8;
pub const MDM_FLOWCONTROL_HARD: u32 = 16;
pub const MDM_FLOWCONTROL_SOFT: u32 = 32;
pub const MDM_CCITT_OVERRIDE: u32 = 64;
pub const MDM_SPEED_ADJUST: u32 = 128;
pub const MDM_TONE_DIAL: u32 = 256;
pub const MDM_BLIND_DIAL: u32 = 512;
pub const MDM_V23_OVERRIDE: u32 = 1024;
pub const MDM_DIAGNOSTICS: u32 = 2048;
pub const MDM_MASK_BEARERMODE: u32 = 61440;
pub const MDM_SHIFT_BEARERMODE: u32 = 12;
pub const MDM_MASK_PROTOCOLID: u32 = 983040;
pub const MDM_SHIFT_PROTOCOLID: u32 = 16;
pub const MDM_MASK_PROTOCOLDATA: u32 = 267386880;
pub const MDM_SHIFT_PROTOCOLDATA: u32 = 20;
pub const MDM_MASK_PROTOCOLINFO: u32 = 268369920;
pub const MDM_SHIFT_PROTOCOLINFO: u32 = 16;
pub const MDM_MASK_EXTENDEDINFO: u32 = 268431360;
pub const MDM_SHIFT_EXTENDEDINFO: u32 = 12;
pub const MDM_BEARERMODE_ANALOG: u32 = 0;
pub const MDM_BEARERMODE_ISDN: u32 = 1;
pub const MDM_BEARERMODE_GSM: u32 = 2;
pub const MDM_PROTOCOLID_DEFAULT: u32 = 0;
pub const MDM_PROTOCOLID_HDLCPPP: u32 = 1;
pub const MDM_PROTOCOLID_V128: u32 = 2;
pub const MDM_PROTOCOLID_X75: u32 = 3;
pub const MDM_PROTOCOLID_V110: u32 = 4;
pub const MDM_PROTOCOLID_V120: u32 = 5;
pub const MDM_PROTOCOLID_AUTO: u32 = 6;
pub const MDM_PROTOCOLID_ANALOG: u32 = 7;
pub const MDM_PROTOCOLID_GPRS: u32 = 8;
pub const MDM_PROTOCOLID_PIAFS: u32 = 9;
pub const MDM_SHIFT_HDLCPPP_SPEED: u32 = 0;
pub const MDM_MASK_HDLCPPP_SPEED: u32 = 7;
pub const MDM_HDLCPPP_SPEED_DEFAULT: u32 = 0;
pub const MDM_HDLCPPP_SPEED_64K: u32 = 1;
pub const MDM_HDLCPPP_SPEED_56K: u32 = 2;
pub const MDM_SHIFT_HDLCPPP_AUTH: u32 = 3;
pub const MDM_MASK_HDLCPPP_AUTH: u32 = 56;
pub const MDM_HDLCPPP_AUTH_DEFAULT: u32 = 0;
pub const MDM_HDLCPPP_AUTH_NONE: u32 = 1;
pub const MDM_HDLCPPP_AUTH_PAP: u32 = 2;
pub const MDM_HDLCPPP_AUTH_CHAP: u32 = 3;
pub const MDM_HDLCPPP_AUTH_MSCHAP: u32 = 4;
pub const MDM_SHIFT_HDLCPPP_ML: u32 = 6;
pub const MDM_MASK_HDLCPPP_ML: u32 = 192;
pub const MDM_HDLCPPP_ML_DEFAULT: u32 = 0;
pub const MDM_HDLCPPP_ML_NONE: u32 = 1;
pub const MDM_HDLCPPP_ML_2: u32 = 2;
pub const MDM_SHIFT_V120_SPEED: u32 = 0;
pub const MDM_MASK_V120_SPEED: u32 = 7;
pub const MDM_V120_SPEED_DEFAULT: u32 = 0;
pub const MDM_V120_SPEED_64K: u32 = 1;
pub const MDM_V120_SPEED_56K: u32 = 2;
pub const MDM_SHIFT_V120_ML: u32 = 6;
pub const MDM_MASK_V120_ML: u32 = 192;
pub const MDM_V120_ML_DEFAULT: u32 = 0;
pub const MDM_V120_ML_NONE: u32 = 1;
pub const MDM_V120_ML_2: u32 = 2;
pub const MDM_SHIFT_X75_DATA: u32 = 0;
pub const MDM_MASK_X75_DATA: u32 = 7;
pub const MDM_X75_DATA_DEFAULT: u32 = 0;
pub const MDM_X75_DATA_64K: u32 = 1;
pub const MDM_X75_DATA_128K: u32 = 2;
pub const MDM_X75_DATA_T_70: u32 = 3;
pub const MDM_X75_DATA_BTX: u32 = 4;
pub const MDM_SHIFT_V110_SPEED: u32 = 0;
pub const MDM_MASK_V110_SPEED: u32 = 15;
pub const MDM_V110_SPEED_DEFAULT: u32 = 0;
pub const MDM_V110_SPEED_1DOT2K: u32 = 1;
pub const MDM_V110_SPEED_2DOT4K: u32 = 2;
pub const MDM_V110_SPEED_4DOT8K: u32 = 3;
pub const MDM_V110_SPEED_9DOT6K: u32 = 4;
pub const MDM_V110_SPEED_12DOT0K: u32 = 5;
pub const MDM_V110_SPEED_14DOT4K: u32 = 6;
pub const MDM_V110_SPEED_19DOT2K: u32 = 7;
pub const MDM_V110_SPEED_28DOT8K: u32 = 8;
pub const MDM_V110_SPEED_38DOT4K: u32 = 9;
pub const MDM_V110_SPEED_57DOT6K: u32 = 10;
pub const MDM_SHIFT_AUTO_SPEED: u32 = 0;
pub const MDM_MASK_AUTO_SPEED: u32 = 7;
pub const MDM_AUTO_SPEED_DEFAULT: u32 = 0;
pub const MDM_SHIFT_AUTO_ML: u32 = 6;
pub const MDM_MASK_AUTO_ML: u32 = 192;
pub const MDM_AUTO_ML_DEFAULT: u32 = 0;
pub const MDM_AUTO_ML_NONE: u32 = 1;
pub const MDM_AUTO_ML_2: u32 = 2;
pub const MDM_ANALOG_RLP_ON: u32 = 0;
pub const MDM_ANALOG_RLP_OFF: u32 = 1;
pub const MDM_ANALOG_V34: u32 = 2;
pub const MDM_PIAFS_INCOMING: u32 = 0;
pub const MDM_PIAFS_OUTGOING: u32 = 1;
pub const STYLE_DESCRIPTION_SIZE: u32 = 32;
pub const IMEMENUITEM_STRING_SIZE: u32 = 80;
pub const IMC_GETCANDIDATEPOS: u32 = 7;
pub const IMC_SETCANDIDATEPOS: u32 = 8;
pub const IMC_GETCOMPOSITIONFONT: u32 = 9;
pub const IMC_SETCOMPOSITIONFONT: u32 = 10;
pub const IMC_GETCOMPOSITIONWINDOW: u32 = 11;
pub const IMC_SETCOMPOSITIONWINDOW: u32 = 12;
pub const IMC_GETSTATUSWINDOWPOS: u32 = 15;
pub const IMC_SETSTATUSWINDOWPOS: u32 = 16;
pub const IMC_CLOSESTATUSWINDOW: u32 = 33;
pub const IMC_OPENSTATUSWINDOW: u32 = 34;
pub const NI_OPENCANDIDATE: u32 = 16;
pub const NI_CLOSECANDIDATE: u32 = 17;
pub const NI_SELECTCANDIDATESTR: u32 = 18;
pub const NI_CHANGECANDIDATELIST: u32 = 19;
pub const NI_FINALIZECONVERSIONRESULT: u32 = 20;
pub const NI_COMPOSITIONSTR: u32 = 21;
pub const NI_SETCANDIDATE_PAGESTART: u32 = 22;
pub const NI_SETCANDIDATE_PAGESIZE: u32 = 23;
pub const NI_IMEMENUSELECTED: u32 = 24;
pub const ISC_SHOWUICANDIDATEWINDOW: u32 = 1;
pub const ISC_SHOWUICOMPOSITIONWINDOW: u32 = 2147483648;
pub const ISC_SHOWUIGUIDELINE: u32 = 1073741824;
pub const ISC_SHOWUIALLCANDIDATEWINDOW: u32 = 15;
pub const ISC_SHOWUIALL: u32 = 3221225487;
pub const CPS_COMPLETE: u32 = 1;
pub const CPS_CONVERT: u32 = 2;
pub const CPS_REVERT: u32 = 3;
pub const CPS_CANCEL: u32 = 4;
pub const MOD_LEFT: u32 = 32768;
pub const MOD_RIGHT: u32 = 16384;
pub const MOD_ON_KEYUP: u32 = 2048;
pub const MOD_IGNORE_ALL_MODIFIER: u32 = 1024;
pub const IME_CHOTKEY_IME_NONIME_TOGGLE: u32 = 16;
pub const IME_CHOTKEY_SHAPE_TOGGLE: u32 = 17;
pub const IME_CHOTKEY_SYMBOL_TOGGLE: u32 = 18;
pub const IME_JHOTKEY_CLOSE_OPEN: u32 = 48;
pub const IME_KHOTKEY_SHAPE_TOGGLE: u32 = 80;
pub const IME_KHOTKEY_HANJACONVERT: u32 = 81;
pub const IME_KHOTKEY_ENGLISH: u32 = 82;
pub const IME_THOTKEY_IME_NONIME_TOGGLE: u32 = 112;
pub const IME_THOTKEY_SHAPE_TOGGLE: u32 = 113;
pub const IME_THOTKEY_SYMBOL_TOGGLE: u32 = 114;
pub const IME_HOTKEY_DSWITCH_FIRST: u32 = 256;
pub const IME_HOTKEY_DSWITCH_LAST: u32 = 287;
pub const IME_HOTKEY_PRIVATE_FIRST: u32 = 512;
pub const IME_ITHOTKEY_RESEND_RESULTSTR: u32 = 512;
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION: u32 = 513;
pub const IME_ITHOTKEY_UISTYLE_TOGGLE: u32 = 514;
pub const IME_ITHOTKEY_RECONVERTSTRING: u32 = 515;
pub const IME_HOTKEY_PRIVATE_LAST: u32 = 543;
pub const GCS_COMPREADSTR: u32 = 1;
pub const GCS_COMPREADATTR: u32 = 2;
pub const GCS_COMPREADCLAUSE: u32 = 4;
pub const GCS_COMPSTR: u32 = 8;
pub const GCS_COMPATTR: u32 = 16;
pub const GCS_COMPCLAUSE: u32 = 32;
pub const GCS_CURSORPOS: u32 = 128;
pub const GCS_DELTASTART: u32 = 256;
pub const GCS_RESULTREADSTR: u32 = 512;
pub const GCS_RESULTREADCLAUSE: u32 = 1024;
pub const GCS_RESULTSTR: u32 = 2048;
pub const GCS_RESULTCLAUSE: u32 = 4096;
pub const CS_INSERTCHAR: u32 = 8192;
pub const CS_NOMOVECARET: u32 = 16384;
pub const IMEVER_0310: u32 = 196618;
pub const IMEVER_0400: u32 = 262144;
pub const IME_PROP_AT_CARET: u32 = 65536;
pub const IME_PROP_SPECIAL_UI: u32 = 131072;
pub const IME_PROP_CANDLIST_START_FROM_1: u32 = 262144;
pub const IME_PROP_UNICODE: u32 = 524288;
pub const IME_PROP_COMPLETE_ON_UNSELECT: u32 = 1048576;
pub const UI_CAP_2700: u32 = 1;
pub const UI_CAP_ROT90: u32 = 2;
pub const UI_CAP_ROTANY: u32 = 4;
pub const SCS_CAP_COMPSTR: u32 = 1;
pub const SCS_CAP_MAKEREAD: u32 = 2;
pub const SCS_CAP_SETRECONVERTSTRING: u32 = 4;
pub const SELECT_CAP_CONVERSION: u32 = 1;
pub const SELECT_CAP_SENTENCE: u32 = 2;
pub const GGL_LEVEL: u32 = 1;
pub const GGL_INDEX: u32 = 2;
pub const GGL_STRING: u32 = 3;
pub const GGL_PRIVATE: u32 = 4;
pub const GL_LEVEL_NOGUIDELINE: u32 = 0;
pub const GL_LEVEL_FATAL: u32 = 1;
pub const GL_LEVEL_ERROR: u32 = 2;
pub const GL_LEVEL_WARNING: u32 = 3;
pub const GL_LEVEL_INFORMATION: u32 = 4;
pub const GL_ID_UNKNOWN: u32 = 0;
pub const GL_ID_NOMODULE: u32 = 1;
pub const GL_ID_NODICTIONARY: u32 = 16;
pub const GL_ID_CANNOTSAVE: u32 = 17;
pub const GL_ID_NOCONVERT: u32 = 32;
pub const GL_ID_TYPINGERROR: u32 = 33;
pub const GL_ID_TOOMANYSTROKE: u32 = 34;
pub const GL_ID_READINGCONFLICT: u32 = 35;
pub const GL_ID_INPUTREADING: u32 = 36;
pub const GL_ID_INPUTRADICAL: u32 = 37;
pub const GL_ID_INPUTCODE: u32 = 38;
pub const GL_ID_INPUTSYMBOL: u32 = 39;
pub const GL_ID_CHOOSECANDIDATE: u32 = 40;
pub const GL_ID_REVERSECONVERSION: u32 = 41;
pub const GL_ID_PRIVATE_FIRST: u32 = 32768;
pub const GL_ID_PRIVATE_LAST: u32 = 65535;
pub const IGP_PROPERTY: u32 = 4;
pub const IGP_CONVERSION: u32 = 8;
pub const IGP_SENTENCE: u32 = 12;
pub const IGP_UI: u32 = 16;
pub const IGP_SETCOMPSTR: u32 = 20;
pub const IGP_SELECT: u32 = 24;
pub const SCS_SETSTR: u32 = 9;
pub const SCS_CHANGEATTR: u32 = 18;
pub const SCS_CHANGECLAUSE: u32 = 36;
pub const SCS_SETRECONVERTSTRING: u32 = 65536;
pub const SCS_QUERYRECONVERTSTRING: u32 = 131072;
pub const ATTR_INPUT: u32 = 0;
pub const ATTR_TARGET_CONVERTED: u32 = 1;
pub const ATTR_CONVERTED: u32 = 2;
pub const ATTR_TARGET_NOTCONVERTED: u32 = 3;
pub const ATTR_INPUT_ERROR: u32 = 4;
pub const ATTR_FIXEDCONVERTED: u32 = 5;
pub const CFS_DEFAULT: u32 = 0;
pub const CFS_RECT: u32 = 1;
pub const CFS_POINT: u32 = 2;
pub const CFS_FORCE_POSITION: u32 = 32;
pub const CFS_CANDIDATEPOS: u32 = 64;
pub const CFS_EXCLUDE: u32 = 128;
pub const GCL_CONVERSION: u32 = 1;
pub const GCL_REVERSECONVERSION: u32 = 2;
pub const GCL_REVERSE_LENGTH: u32 = 3;
pub const IME_CMODE_ALPHANUMERIC: u32 = 0;
pub const IME_CMODE_NATIVE: u32 = 1;
pub const IME_CMODE_CHINESE: u32 = 1;
pub const IME_CMODE_HANGUL: u32 = 1;
pub const IME_CMODE_JAPANESE: u32 = 1;
pub const IME_CMODE_KATAKANA: u32 = 2;
pub const IME_CMODE_LANGUAGE: u32 = 3;
pub const IME_CMODE_FULLSHAPE: u32 = 8;
pub const IME_CMODE_ROMAN: u32 = 16;
pub const IME_CMODE_CHARCODE: u32 = 32;
pub const IME_CMODE_HANJACONVERT: u32 = 64;
pub const IME_CMODE_NATIVESYMBOL: u32 = 128;
pub const IME_CMODE_HANGEUL: u32 = 1;
pub const IME_CMODE_SOFTKBD: u32 = 128;
pub const IME_CMODE_NOCONVERSION: u32 = 256;
pub const IME_CMODE_EUDC: u32 = 512;
pub const IME_CMODE_SYMBOL: u32 = 1024;
pub const IME_CMODE_FIXED: u32 = 2048;
pub const IME_CMODE_RESERVED: u32 = 4026531840;
pub const IME_SMODE_NONE: u32 = 0;
pub const IME_SMODE_PLAURALCLAUSE: u32 = 1;
pub const IME_SMODE_SINGLECONVERT: u32 = 2;
pub const IME_SMODE_AUTOMATIC: u32 = 4;
pub const IME_SMODE_PHRASEPREDICT: u32 = 8;
pub const IME_SMODE_CONVERSATION: u32 = 16;
pub const IME_SMODE_RESERVED: u32 = 61440;
pub const IME_CAND_UNKNOWN: u32 = 0;
pub const IME_CAND_READ: u32 = 1;
pub const IME_CAND_CODE: u32 = 2;
pub const IME_CAND_MEANING: u32 = 3;
pub const IME_CAND_RADICAL: u32 = 4;
pub const IME_CAND_STROKE: u32 = 5;
pub const IMN_CLOSESTATUSWINDOW: u32 = 1;
pub const IMN_OPENSTATUSWINDOW: u32 = 2;
pub const IMN_CHANGECANDIDATE: u32 = 3;
pub const IMN_CLOSECANDIDATE: u32 = 4;
pub const IMN_OPENCANDIDATE: u32 = 5;
pub const IMN_SETCONVERSIONMODE: u32 = 6;
pub const IMN_SETSENTENCEMODE: u32 = 7;
pub const IMN_SETOPENSTATUS: u32 = 8;
pub const IMN_SETCANDIDATEPOS: u32 = 9;
pub const IMN_SETCOMPOSITIONFONT: u32 = 10;
pub const IMN_SETCOMPOSITIONWINDOW: u32 = 11;
pub const IMN_SETSTATUSWINDOWPOS: u32 = 12;
pub const IMN_GUIDELINE: u32 = 13;
pub const IMN_PRIVATE: u32 = 14;
pub const IMR_COMPOSITIONWINDOW: u32 = 1;
pub const IMR_CANDIDATEWINDOW: u32 = 2;
pub const IMR_COMPOSITIONFONT: u32 = 3;
pub const IMR_RECONVERTSTRING: u32 = 4;
pub const IMR_CONFIRMRECONVERTSTRING: u32 = 5;
pub const IMR_QUERYCHARPOSITION: u32 = 6;
pub const IMR_DOCUMENTFEED: u32 = 7;
pub const IMM_ERROR_NODATA: i32 = -1;
pub const IMM_ERROR_GENERAL: i32 = -2;
pub const IME_CONFIG_GENERAL: u32 = 1;
pub const IME_CONFIG_REGISTERWORD: u32 = 2;
pub const IME_CONFIG_SELECTDICTIONARY: u32 = 3;
pub const IME_ESC_QUERY_SUPPORT: u32 = 3;
pub const IME_ESC_RESERVED_FIRST: u32 = 4;
pub const IME_ESC_RESERVED_LAST: u32 = 2047;
pub const IME_ESC_PRIVATE_FIRST: u32 = 2048;
pub const IME_ESC_PRIVATE_LAST: u32 = 4095;
pub const IME_ESC_SEQUENCE_TO_INTERNAL: u32 = 4097;
pub const IME_ESC_GET_EUDC_DICTIONARY: u32 = 4099;
pub const IME_ESC_SET_EUDC_DICTIONARY: u32 = 4100;
pub const IME_ESC_MAX_KEY: u32 = 4101;
pub const IME_ESC_IME_NAME: u32 = 4102;
pub const IME_ESC_SYNC_HOTKEY: u32 = 4103;
pub const IME_ESC_HANJA_MODE: u32 = 4104;
pub const IME_ESC_AUTOMATA: u32 = 4105;
pub const IME_ESC_PRIVATE_HOTKEY: u32 = 4106;
pub const IME_ESC_GETHELPFILENAME: u32 = 4107;
pub const IME_REGWORD_STYLE_EUDC: u32 = 1;
pub const IME_REGWORD_STYLE_USER_FIRST: u32 = 2147483648;
pub const IME_REGWORD_STYLE_USER_LAST: u32 = 4294967295;
pub const IACE_CHILDREN: u32 = 1;
pub const IACE_DEFAULT: u32 = 16;
pub const IACE_IGNORENOCONTEXT: u32 = 32;
pub const IGIMIF_RIGHTMENU: u32 = 1;
pub const IGIMII_CMODE: u32 = 1;
pub const IGIMII_SMODE: u32 = 2;
pub const IGIMII_CONFIGURE: u32 = 4;
pub const IGIMII_TOOLS: u32 = 8;
pub const IGIMII_HELP: u32 = 16;
pub const IGIMII_OTHER: u32 = 32;
pub const IGIMII_INPUTTOOLS: u32 = 64;
pub const IMFT_RADIOCHECK: u32 = 1;
pub const IMFT_SEPARATOR: u32 = 2;
pub const IMFT_SUBMENU: u32 = 4;
pub const IMFS_GRAYED: u32 = 3;
pub const IMFS_DISABLED: u32 = 3;
pub const IMFS_CHECKED: u32 = 8;
pub const IMFS_HILITE: u32 = 128;
pub const IMFS_ENABLED: u32 = 0;
pub const IMFS_UNCHECKED: u32 = 0;
pub const IMFS_UNHILITE: u32 = 0;
pub const IMFS_DEFAULT: u32 = 4096;
pub const SOFTKEYBOARD_TYPE_T1: u32 = 1;
pub const SOFTKEYBOARD_TYPE_C1: u32 = 2;
extern "C" {
  #[doc = "  \\brief Gets the name of the platform."]
  pub fn SDL_GetPlatform() -> *const libc::c_char;
}
pub type wchar_t = libc::c_ushort;
pub type max_align_t = f64;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub mod SDL_bool {
  pub type Type = i32;
  pub const SDL_FALSE: Type = 0;
  pub const SDL_TRUE: Type = 1;
}
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [libc::c_int; 1usize];
pub mod SDL_DUMMY_ENUM {
  pub type Type = i32;
  pub const DUMMY_ENUM_VALUE: Type = 0;
}
pub type SDL_compile_time_assert_enum = [libc::c_int; 1usize];
extern "C" {
  pub fn SDL_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_realloc(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_free(mem: *mut libc::c_void);
}
pub type SDL_malloc_func =
  ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut libc::c_void>;
pub type SDL_calloc_func =
  ::core::option::Option<unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut libc::c_void>;
pub type SDL_realloc_func = ::core::option::Option<
  unsafe extern "C" fn(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void,
>;
pub type SDL_free_func = ::core::option::Option<unsafe extern "C" fn(mem: *mut libc::c_void)>;
extern "C" {
  #[doc = "  \\brief Get the current set of SDL memory functions"]
  pub fn SDL_GetMemoryFunctions(
    malloc_func: *mut SDL_malloc_func, calloc_func: *mut SDL_calloc_func,
    realloc_func: *mut SDL_realloc_func, free_func: *mut SDL_free_func,
  );
}
extern "C" {
  #[doc = "  \\brief Replace SDL\'s memory allocation functions with a custom set"]
  #[doc = ""]
  #[doc = "  \\note If you are replacing SDL\'s memory functions, you should call"]
  #[doc = "        SDL_GetNumAllocations() and be very careful if it returns non-zero."]
  #[doc = "        That means that your free function will be called with memory"]
  #[doc = "        allocated by the previous memory allocation functions."]
  pub fn SDL_SetMemoryFunctions(
    malloc_func: SDL_malloc_func, calloc_func: SDL_calloc_func, realloc_func: SDL_realloc_func,
    free_func: SDL_free_func,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the number of outstanding (unfreed) allocations"]
  pub fn SDL_GetNumAllocations() -> libc::c_int;
}
extern "C" {
  pub fn SDL_getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_setenv(
    name: *const libc::c_char, value: *const libc::c_char, overwrite: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_qsort(
    base: *mut libc::c_void, nmemb: usize, size: usize,
    compare: ::core::option::Option<
      unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
    >,
  );
}
extern "C" {
  pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: usize) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_memcpy(
    dst: *mut libc::c_void, src: *const libc::c_void, len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_memmove(
    dst: *mut libc::c_void, src: *const libc::c_void, len: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: usize) -> libc::c_int;
}
extern "C" {
  pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
  pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strlen(str: *const libc::c_char) -> usize;
}
extern "C" {
  pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_utf8strlcpy(
    dst: *mut libc::c_char, src: *const libc::c_char, dst_bytes: usize,
  ) -> usize;
}
extern "C" {
  pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
  pub fn SDL_strdup(str: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strrev(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strupr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strlwr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strrchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_strstr(
    haystack: *const libc::c_char, needle: *const libc::c_char,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_utf8strlen(str: *const libc::c_char) -> usize;
}
extern "C" {
  pub fn SDL_itoa(
    value: libc::c_int, str: *mut libc::c_char, radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_uitoa(
    value: libc::c_uint, str: *mut libc::c_char, radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_ltoa(
    value: libc::c_long, str: *mut libc::c_char, radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_ultoa(
    value: libc::c_ulong, str: *mut libc::c_char, radix: libc::c_int,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_lltoa(value: Sint64, str: *mut libc::c_char, radix: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_ulltoa(value: Uint64, str: *mut libc::c_char, radix: libc::c_int)
    -> *mut libc::c_char;
}
extern "C" {
  pub fn SDL_atoi(str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_atof(str: *const libc::c_char) -> f64;
}
extern "C" {
  pub fn SDL_strtol(
    str: *const libc::c_char, endp: *mut *mut libc::c_char, base: libc::c_int,
  ) -> libc::c_long;
}
extern "C" {
  pub fn SDL_strtoul(
    str: *const libc::c_char, endp: *mut *mut libc::c_char, base: libc::c_int,
  ) -> libc::c_ulong;
}
extern "C" {
  pub fn SDL_strtoll(
    str: *const libc::c_char, endp: *mut *mut libc::c_char, base: libc::c_int,
  ) -> Sint64;
}
extern "C" {
  pub fn SDL_strtoull(
    str: *const libc::c_char, endp: *mut *mut libc::c_char, base: libc::c_int,
  ) -> Uint64;
}
extern "C" {
  pub fn SDL_strtod(str: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
extern "C" {
  pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strncmp(
    str1: *const libc::c_char, str2: *const libc::c_char, maxlen: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_strncasecmp(
    str1: *const libc::c_char, str2: *const libc::c_char, len: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  pub fn SDL_vsscanf(
    text: *const libc::c_char, fmt: *const libc::c_char, ap: va_list,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_snprintf(
    text: *mut libc::c_char, maxlen: usize, fmt: *const libc::c_char, ...
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_vsnprintf(
    text: *mut libc::c_char, maxlen: usize, fmt: *const libc::c_char, ap: va_list,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_atan2f(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
  pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
  pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
  pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
  pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
  pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
  pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_iconv_t {
  _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
  pub fn SDL_iconv_open(tocode: *const libc::c_char, fromcode: *const libc::c_char) -> SDL_iconv_t;
}
extern "C" {
  pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
extern "C" {
  pub fn SDL_iconv(
    cd: SDL_iconv_t, inbuf: *mut *const libc::c_char, inbytesleft: *mut usize,
    outbuf: *mut *mut libc::c_char, outbytesleft: *mut usize,
  ) -> usize;
}
extern "C" {
  #[doc = "  This function converts a string between encodings in one pass, returning a"]
  #[doc = "  string that must be freed with SDL_free() or NULL on error."]
  pub fn SDL_iconv_string(
    tocode: *const libc::c_char, fromcode: *const libc::c_char, inbuf: *const libc::c_char,
    inbytesleft: usize,
  ) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  The prototype for the application\'s main() function"]
  pub fn SDL_main(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is called by the real SDL main function to let the rest of the"]
  #[doc = "  library know that initialization was done properly."]
  #[doc = ""]
  #[doc = "  Calling this yourself without knowing what you\'re doing can cause"]
  #[doc = "  crashes and hard to diagnose problems with your application."]
  pub fn SDL_SetMainReady();
}
extern "C" {
  #[doc = "  This can be called to set the application class at startup"]
  pub fn SDL_RegisterApp(
    name: *mut libc::c_char, style: Uint32, hInst: *mut libc::c_void,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UnregisterApp();
}
extern "C" {
  pub fn __debugbreak();
}
pub mod SDL_AssertState {
  pub type Type = i32;
  #[doc = "< Retry the assert immediately."]
  pub const SDL_ASSERTION_RETRY: Type = 0;
  #[doc = "< Make the debugger trigger a breakpoint."]
  pub const SDL_ASSERTION_BREAK: Type = 1;
  #[doc = "< Terminate the program."]
  pub const SDL_ASSERTION_ABORT: Type = 2;
  #[doc = "< Ignore the assert."]
  pub const SDL_ASSERTION_IGNORE: Type = 3;
  #[doc = "< Ignore the assert from now on."]
  pub const SDL_ASSERTION_ALWAYS_IGNORE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AssertData {
  pub always_ignore: libc::c_int,
  pub trigger_count: libc::c_uint,
  pub condition: *const libc::c_char,
  pub filename: *const libc::c_char,
  pub linenum: libc::c_int,
  pub function: *const libc::c_char,
  pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AssertData>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_AssertData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AssertData>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_AssertData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).always_ignore as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(always_ignore)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).trigger_count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(trigger_count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).condition as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(condition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).filename as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(filename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).linenum as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(linenum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).function as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(function)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).next as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AssertData),
      "::",
      stringify!(next)
    )
  );
}
impl Default for SDL_AssertData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_ReportAssertion(
    arg1: *mut SDL_AssertData, arg2: *const libc::c_char, arg3: *const libc::c_char,
    arg4: libc::c_int,
  ) -> SDL_AssertState::Type;
}
pub type SDL_AssertionHandler = ::core::option::Option<
  unsafe extern "C" fn(
    data: *const SDL_AssertData,
    userdata: *mut libc::c_void,
  ) -> SDL_AssertState::Type,
>;
extern "C" {
  #[doc = "  \\brief Set an application-defined assertion handler."]
  #[doc = ""]
  #[doc = "  This allows an app to show its own assertion UI and/or force the"]
  #[doc = "  response to an assertion failure. If the app doesn\'t provide this, SDL"]
  #[doc = "  will try to do the right thing, popping up a system-specific GUI dialog,"]
  #[doc = "  and probably minimizing any fullscreen windows."]
  #[doc = ""]
  #[doc = "  This callback may fire from any thread, but it runs wrapped in a mutex, so"]
  #[doc = "  it will only fire from one thread at a time."]
  #[doc = ""]
  #[doc = "  Setting the callback to NULL restores SDL\'s original internal handler."]
  #[doc = ""]
  #[doc = "  This callback is NOT reset to SDL\'s internal handler upon SDL_Quit()!"]
  #[doc = ""]
  #[doc = "  Return SDL_AssertState value of how to handle the assertion failure."]
  #[doc = ""]
  #[doc = "  \\param handler Callback function, called when an assertion fails."]
  #[doc = "  \\param userdata A pointer passed to the callback as-is."]
  pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  \\brief Get the default assertion handler."]
  #[doc = ""]
  #[doc = "  This returns the function pointer that is called by default when an"]
  #[doc = "   assertion is triggered. This is an internal function provided by SDL,"]
  #[doc = "   that is used for assertions when SDL_SetAssertionHandler() hasn\'t been"]
  #[doc = "   used to provide a different function."]
  #[doc = ""]
  #[doc = "  \\return The default SDL_AssertionHandler that is called when an assert triggers."]
  pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
  #[doc = "  \\brief Get the current assertion handler."]
  #[doc = ""]
  #[doc = "  This returns the function pointer that is called when an assertion is"]
  #[doc = "   triggered. This is either the value last passed to"]
  #[doc = "   SDL_SetAssertionHandler(), or if no application-specified function is"]
  #[doc = "   set, is equivalent to calling SDL_GetDefaultAssertionHandler()."]
  #[doc = ""]
  #[doc = "   \\param puserdata Pointer to a void*, which will store the \"userdata\""]
  #[doc = "                    pointer that was passed to SDL_SetAssertionHandler()."]
  #[doc = "                    This value will always be NULL for the default handler."]
  #[doc = "                    If you don\'t care about this data, it is safe to pass"]
  #[doc = "                    a NULL pointer to this function to ignore it."]
  #[doc = "  \\return The SDL_AssertionHandler that is called when an assert triggers."]
  pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
extern "C" {
  #[doc = "  \\brief Get a list of all assertion failures."]
  #[doc = ""]
  #[doc = "  Get all assertions triggered since last call to SDL_ResetAssertionReport(),"]
  #[doc = "  or the start of the program."]
  #[doc = ""]
  #[doc = "  The proper way to examine this data looks something like this:"]
  #[doc = ""]
  #[doc = "  <code>"]
  #[doc = "  const SDL_AssertData *item = SDL_GetAssertionReport();"]
  #[doc = "  while (item) {"]
  #[doc = "      printf(\"\'%s\', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\","]
  #[doc = "             item->condition, item->function, item->filename,"]
  #[doc = "             item->linenum, item->trigger_count,"]
  #[doc = "             item->always_ignore ? \"yes\" : \"no\");"]
  #[doc = "      item = item->next;"]
  #[doc = "  }"]
  #[doc = "  </code>"]
  #[doc = ""]
  #[doc = "  \\return List of all assertions."]
  #[doc = "  \\sa SDL_ResetAssertionReport"]
  pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
  #[doc = "  \\brief Reset the list of all assertion failures."]
  #[doc = ""]
  #[doc = "  Reset list of all assertions triggered."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetAssertionReport"]
  pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = libc::c_int;
extern "C" {
  #[doc = " \\brief Try to lock a spin lock by setting it to a non-zero value."]
  #[doc = ""]
  #[doc = " \\param lock Points to the lock."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held."]
  pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Lock a spin lock by setting it to a non-zero value."]
  #[doc = ""]
  #[doc = " \\param lock Points to the lock."]
  pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
  #[doc = " \\brief Unlock a spin lock by setting it to 0. Always returns immediately"]
  #[doc = ""]
  #[doc = " \\param lock Points to the lock."]
  pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
  #[doc = " Memory barriers are designed to prevent reads and writes from being"]
  #[doc = " reordered by the compiler and being seen out of order on multi-core CPUs."]
  #[doc = ""]
  #[doc = " A typical pattern would be for thread A to write some data and a flag,"]
  #[doc = " and for thread B to read the flag and get the data. In this case you"]
  #[doc = " would insert a release barrier between writing the data and the flag,"]
  #[doc = " guaranteeing that the data write completes no later than the flag is"]
  #[doc = " written, and you would insert an acquire barrier between reading the"]
  #[doc = " flag and reading the data, to ensure that all the reads associated"]
  #[doc = " with the flag have completed."]
  #[doc = ""]
  #[doc = " In this pattern you should always see a release barrier paired with"]
  #[doc = " an acquire barrier and you should gate the data reads/writes with a"]
  #[doc = " single flag variable."]
  #[doc = ""]
  #[doc = " For more information on these semantics, take a look at the blog post:"]
  #[doc = " http://preshing.com/20120913/acquire-and-release-semantics"]
  pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
  pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " \\brief A type representing an atomic integer value.  It is a struct"]
#[doc = "        so people don\'t accidentally use numeric operations on it."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_atomic_t {
  pub value: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
  assert_eq!(
    ::core::mem::size_of::<SDL_atomic_t>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_atomic_t))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_atomic_t>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_atomic_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_atomic_t>())).value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_atomic_t),
      "::",
      stringify!(value)
    )
  );
}
extern "C" {
  #[doc = " \\brief Set an atomic variable to a new value if it is currently an old value."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = " \\note If you don\'t know what this function is for, you shouldn\'t use it!"]
  pub fn SDL_AtomicCAS(
    a: *mut SDL_atomic_t, oldval: libc::c_int, newval: libc::c_int,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Set an atomic variable to a value."]
  #[doc = ""]
  #[doc = " \\return The previous value of the atomic variable."]
  pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get the value of an atomic variable"]
  pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Add to an atomic variable."]
  #[doc = ""]
  #[doc = " \\return The previous value of the atomic variable."]
  #[doc = ""]
  #[doc = " \\note This same style can be used for any number operation"]
  pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Set a pointer to a new value if it is currently an old value."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the pointer was set, SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = " \\note If you don\'t know what this function is for, you shouldn\'t use it!"]
  pub fn SDL_AtomicCASPtr(
    a: *mut *mut libc::c_void, oldval: *mut libc::c_void, newval: *mut libc::c_void,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Set a pointer to a value atomically."]
  #[doc = ""]
  #[doc = " \\return The previous value of the pointer."]
  pub fn SDL_AtomicSetPtr(a: *mut *mut libc::c_void, v: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
  #[doc = " \\brief Get the value of a pointer atomically."]
  pub fn SDL_AtomicGetPtr(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetError() -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_ClearError();
}
pub mod SDL_errorcode {
  pub type Type = i32;
  pub const SDL_ENOMEM: Type = 0;
  pub const SDL_EFREAD: Type = 1;
  pub const SDL_EFWRITE: Type = 2;
  pub const SDL_EFSEEK: Type = 3;
  pub const SDL_UNSUPPORTED: Type = 4;
  pub const SDL_LASTERROR: Type = 5;
}
extern "C" {
  pub fn SDL_Error(code: SDL_errorcode::Type) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "  Create a mutex, initialized unlocked."]
  pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
  pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[doc = "  Try to lock the mutex"]
  #[doc = ""]
  #[doc = "  \\return 0, SDL_MUTEX_TIMEDOUT, or -1 on error"]
  pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[doc = "  Destroy a mutex."]
  pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
  _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
  #[doc = "  Create a semaphore, initialized with value, returns NULL on failure."]
  pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
  #[doc = "  Destroy a semaphore."]
  pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
  #[doc = "  This function suspends the calling thread until the semaphore pointed"]
  #[doc = "  to by \\c sem has a positive count. It then atomically decreases the"]
  #[doc = "  semaphore count."]
  pub fn SDL_SemWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  #[doc = "  Non-blocking variant of SDL_SemWait()."]
  #[doc = ""]
  #[doc = "  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would"]
  #[doc = "          block, and -1 on error."]
  pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  #[doc = "  Variant of SDL_SemWait() with a timeout in milliseconds."]
  #[doc = ""]
  #[doc = "  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not"]
  #[doc = "          succeed in the allotted time, and -1 on error."]
  #[doc = ""]
  #[doc = "  \\warning On some platforms this function is implemented by looping with a"]
  #[doc = "           delay of 1 ms, and so should be avoided if possible."]
  pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  Atomically increases the semaphore\'s count (not blocking)."]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 on error."]
  pub fn SDL_SemPost(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
  #[doc = "  Returns the current count of the semaphore."]
  pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "  Create a condition variable."]
  #[doc = ""]
  #[doc = "  Typical use of condition variables:"]
  #[doc = ""]
  #[doc = "  Thread A:"]
  #[doc = "    SDL_LockMutex(lock);"]
  #[doc = "    while ( ! condition ) {"]
  #[doc = "        SDL_CondWait(cond, lock);"]
  #[doc = "    }"]
  #[doc = "    SDL_UnlockMutex(lock);"]
  #[doc = ""]
  #[doc = "  Thread B:"]
  #[doc = "    SDL_LockMutex(lock);"]
  #[doc = "    ..."]
  #[doc = "    condition = true;"]
  #[doc = "    ..."]
  #[doc = "    SDL_CondSignal(cond);"]
  #[doc = "    SDL_UnlockMutex(lock);"]
  #[doc = ""]
  #[doc = "  There is some discussion whether to signal the condition variable"]
  #[doc = "  with the mutex locked or not.  There is some potential performance"]
  #[doc = "  benefit to unlocking first on some platforms, but there are some"]
  #[doc = "  potential race conditions depending on how your code is structured."]
  #[doc = ""]
  #[doc = "  In general it\'s safer to signal the condition variable while the"]
  #[doc = "  mutex is locked."]
  pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
  #[doc = "  Destroy a condition variable."]
  pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
  #[doc = "  Restart one of the threads that are waiting on the condition variable."]
  #[doc = ""]
  #[doc = "  \\return 0 or -1 on error."]
  pub fn SDL_CondSignal(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
  #[doc = "  Restart all threads that are waiting on the condition variable."]
  #[doc = ""]
  #[doc = "  \\return 0 or -1 on error."]
  pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
  #[doc = "  Wait on the condition variable, unlocking the provided mutex."]
  #[doc = ""]
  #[doc = "  \\warning The mutex must be locked before entering this function!"]
  #[doc = ""]
  #[doc = "  The mutex is re-locked once the condition variable is signaled."]
  #[doc = ""]
  #[doc = "  \\return 0 when it is signaled, or -1 on error."]
  pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
  #[doc = "  Waits for at most \\c ms milliseconds, and returns 0 if the condition"]
  #[doc = "  variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not"]
  #[doc = "  signaled in the allotted time, and -1 on error."]
  #[doc = ""]
  #[doc = "  \\warning On some platforms this function is implemented by looping with a"]
  #[doc = "           delay of 1 ms, and so should be avoided if possible."]
  pub fn SDL_CondWaitTimeout(cond: *mut SDL_cond, mutex: *mut SDL_mutex, ms: Uint32)
    -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
  _unused: [u8; 0],
}
pub type SDL_threadID = libc::c_ulong;
pub type SDL_TLSID = libc::c_uint;
pub mod SDL_ThreadPriority {
  #[doc = "  The SDL thread priority."]
  #[doc = ""]
  #[doc = "  \\note On many systems you require special privileges to set high or time critical priority."]
  pub type Type = i32;
  pub const SDL_THREAD_PRIORITY_LOW: Type = 0;
  pub const SDL_THREAD_PRIORITY_NORMAL: Type = 1;
  pub const SDL_THREAD_PRIORITY_HIGH: Type = 2;
  pub const SDL_THREAD_PRIORITY_TIME_CRITICAL: Type = 3;
}
#[doc = "  The function passed to SDL_CreateThread()."]
#[doc = "  It is passed a void* user context parameter and returns an int."]
pub type SDL_ThreadFunction =
  ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> libc::c_int>;
extern "C" {
  pub fn __va_start(arg1: *mut *mut libc::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
  pub fn __security_init_cookie();
}
extern "C" {
  pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
  pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
  #[link_name = "\u{1}__security_cookie"]
  pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
  pub fn _invalid_parameter_noinfo();
}
extern "C" {
  pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
  pub fn _invoke_watson(
    _Expression: *const wchar_t, _FunctionName: *const wchar_t, _FileName: *const wchar_t,
    _LineNo: libc::c_uint, _Reserved: usize,
  );
}
pub type errno_t = libc::c_int;
pub type wint_t = libc::c_ushort;
pub type wctype_t = libc::c_ushort;
pub type __time32_t = libc::c_long;
pub type __time64_t = libc::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __crt_locale_data_public {
  pub _locale_pctype: *const libc::c_ushort,
  pub _locale_mb_cur_max: libc::c_int,
  pub _locale_lc_codepage: libc::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
  assert_eq!(
    ::core::mem::size_of::<__crt_locale_data_public>(),
    16usize,
    concat!("Size of: ", stringify!(__crt_locale_data_public))
  );
  assert_eq!(
    ::core::mem::align_of::<__crt_locale_data_public>(),
    8usize,
    concat!("Alignment of ", stringify!(__crt_locale_data_public))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_data_public),
      "::",
      stringify!(_locale_pctype)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_data_public),
      "::",
      stringify!(_locale_mb_cur_max)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_data_public),
      "::",
      stringify!(_locale_lc_codepage)
    )
  );
}
impl Default for __crt_locale_data_public {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __crt_locale_pointers {
  pub locinfo: *mut __crt_locale_data,
  pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
  assert_eq!(
    ::core::mem::size_of::<__crt_locale_pointers>(),
    16usize,
    concat!("Size of: ", stringify!(__crt_locale_pointers))
  );
  assert_eq!(
    ::core::mem::align_of::<__crt_locale_pointers>(),
    8usize,
    concat!("Alignment of ", stringify!(__crt_locale_pointers))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_pointers),
      "::",
      stringify!(locinfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_pointers),
      "::",
      stringify!(mbcinfo)
    )
  );
}
impl Default for __crt_locale_pointers {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _Mbstatet {
  pub _Wchar: libc::c_ulong,
  pub _Byte: libc::c_ushort,
  pub _State: libc::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
  assert_eq!(
    ::core::mem::size_of::<_Mbstatet>(),
    8usize,
    concat!("Size of: ", stringify!(_Mbstatet))
  );
  assert_eq!(
    ::core::mem::align_of::<_Mbstatet>(),
    4usize,
    concat!("Alignment of ", stringify!(_Mbstatet))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_Mbstatet),
      "::",
      stringify!(_Wchar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_Mbstatet),
      "::",
      stringify!(_Byte)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_Mbstatet),
      "::",
      stringify!(_State)
    )
  );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _exception {
  pub type_: libc::c_int,
  pub name: *mut libc::c_char,
  pub arg1: f64,
  pub arg2: f64,
  pub retval: f64,
}
#[test]
fn bindgen_test_layout__exception() {
  assert_eq!(
    ::core::mem::size_of::<_exception>(),
    40usize,
    concat!("Size of: ", stringify!(_exception))
  );
  assert_eq!(
    ::core::mem::align_of::<_exception>(),
    8usize,
    concat!("Alignment of ", stringify!(_exception))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_exception>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_exception),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_exception>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_exception),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_exception>())).arg1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_exception),
      "::",
      stringify!(arg1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_exception>())).arg2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_exception),
      "::",
      stringify!(arg2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_exception>())).retval as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_exception),
      "::",
      stringify!(retval)
    )
  );
}
impl Default for _exception {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _complex {
  pub x: f64,
  pub y: f64,
}
#[test]
fn bindgen_test_layout__complex() {
  assert_eq!(
    ::core::mem::size_of::<_complex>(),
    16usize,
    concat!("Size of: ", stringify!(_complex))
  );
  assert_eq!(
    ::core::mem::align_of::<_complex>(),
    8usize,
    concat!("Alignment of ", stringify!(_complex))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_complex>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_complex),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_complex>())).y as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_complex),
      "::",
      stringify!(y)
    )
  );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
  #[link_name = "\u{1}_HUGE"]
  pub static _HUGE: f64;
}
extern "C" {
  pub fn _fperrraise(_Except: libc::c_int);
}
extern "C" {
  pub fn _dclass(_X: f64) -> libc::c_short;
}
extern "C" {
  pub fn _ldclass(_X: f64) -> libc::c_short;
}
extern "C" {
  pub fn _fdclass(_X: f32) -> libc::c_short;
}
extern "C" {
  pub fn _dsign(_X: f64) -> libc::c_int;
}
extern "C" {
  pub fn _ldsign(_X: f64) -> libc::c_int;
}
extern "C" {
  pub fn _fdsign(_X: f32) -> libc::c_int;
}
extern "C" {
  pub fn _dpcomp(_X: f64, _Y: f64) -> libc::c_int;
}
extern "C" {
  pub fn _ldpcomp(_X: f64, _Y: f64) -> libc::c_int;
}
extern "C" {
  pub fn _fdpcomp(_X: f32, _Y: f32) -> libc::c_int;
}
extern "C" {
  pub fn _dtest(_Px: *mut f64) -> libc::c_short;
}
extern "C" {
  pub fn _ldtest(_Px: *mut f64) -> libc::c_short;
}
extern "C" {
  pub fn _fdtest(_Px: *mut f32) -> libc::c_short;
}
extern "C" {
  pub fn _d_int(_Px: *mut f64, _Xexp: libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _ld_int(_Px: *mut f64, _Xexp: libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _fd_int(_Px: *mut f32, _Xexp: libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _dscale(_Px: *mut f64, _Lexp: libc::c_long) -> libc::c_short;
}
extern "C" {
  pub fn _ldscale(_Px: *mut f64, _Lexp: libc::c_long) -> libc::c_short;
}
extern "C" {
  pub fn _fdscale(_Px: *mut f32, _Lexp: libc::c_long) -> libc::c_short;
}
extern "C" {
  pub fn _dunscale(_Pex: *mut libc::c_short, _Px: *mut f64) -> libc::c_short;
}
extern "C" {
  pub fn _ldunscale(_Pex: *mut libc::c_short, _Px: *mut f64) -> libc::c_short;
}
extern "C" {
  pub fn _fdunscale(_Pex: *mut libc::c_short, _Px: *mut f32) -> libc::c_short;
}
extern "C" {
  pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: libc::c_long) -> libc::c_short;
}
extern "C" {
  pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: libc::c_long) -> libc::c_short;
}
extern "C" {
  pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: libc::c_long) -> libc::c_short;
}
extern "C" {
  pub fn _dnorm(_Ps: *mut libc::c_ushort) -> libc::c_short;
}
extern "C" {
  pub fn _fdnorm(_Ps: *mut libc::c_ushort) -> libc::c_short;
}
extern "C" {
  pub fn _dpoly(_X: f64, _Tab: *const f64, _N: libc::c_int) -> f64;
}
extern "C" {
  pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: libc::c_int) -> f64;
}
extern "C" {
  pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: libc::c_int) -> f32;
}
extern "C" {
  pub fn _dlog(_X: f64, _Baseflag: libc::c_int) -> f64;
}
extern "C" {
  pub fn _ldlog(_X: f64, _Baseflag: libc::c_int) -> f64;
}
extern "C" {
  pub fn _fdlog(_X: f32, _Baseflag: libc::c_int) -> f32;
}
extern "C" {
  pub fn _dsin(_X: f64, _Qoff: libc::c_uint) -> f64;
}
extern "C" {
  pub fn _ldsin(_X: f64, _Qoff: libc::c_uint) -> f64;
}
extern "C" {
  pub fn _fdsin(_X: f32, _Qoff: libc::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
  pub _Sh: [libc::c_ushort; 4usize],
  pub _Val: f64,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__double_val() {
  assert_eq!(
    ::core::mem::size_of::<_double_val>(),
    8usize,
    concat!("Size of: ", stringify!(_double_val))
  );
  assert_eq!(
    ::core::mem::align_of::<_double_val>(),
    8usize,
    concat!("Alignment of ", stringify!(_double_val))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_double_val>()))._Sh as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_double_val),
      "::",
      stringify!(_Sh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_double_val>()))._Val as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_double_val),
      "::",
      stringify!(_Val)
    )
  );
}
impl Default for _double_val {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _double_val {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_double_val {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
  pub _Sh: [libc::c_ushort; 2usize],
  pub _Val: f32,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__float_val() {
  assert_eq!(
    ::core::mem::size_of::<_float_val>(),
    4usize,
    concat!("Size of: ", stringify!(_float_val))
  );
  assert_eq!(
    ::core::mem::align_of::<_float_val>(),
    4usize,
    concat!("Alignment of ", stringify!(_float_val))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_float_val>()))._Sh as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_float_val),
      "::",
      stringify!(_Sh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_float_val>()))._Val as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_float_val),
      "::",
      stringify!(_Val)
    )
  );
}
impl Default for _float_val {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _float_val {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_float_val {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
  pub _Sh: [libc::c_ushort; 4usize],
  pub _Val: f64,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__ldouble_val() {
  assert_eq!(
    ::core::mem::size_of::<_ldouble_val>(),
    8usize,
    concat!("Size of: ", stringify!(_ldouble_val))
  );
  assert_eq!(
    ::core::mem::align_of::<_ldouble_val>(),
    8usize,
    concat!("Alignment of ", stringify!(_ldouble_val))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ldouble_val>()))._Sh as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ldouble_val),
      "::",
      stringify!(_Sh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ldouble_val>()))._Val as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ldouble_val),
      "::",
      stringify!(_Val)
    )
  );
}
impl Default for _ldouble_val {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ldouble_val {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_ldouble_val {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
  pub _Word: [libc::c_ushort; 4usize],
  pub _Float: f32,
  pub _Double: f64,
  pub _Long_double: f64,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__float_const() {
  assert_eq!(
    ::core::mem::size_of::<_float_const>(),
    8usize,
    concat!("Size of: ", stringify!(_float_const))
  );
  assert_eq!(
    ::core::mem::align_of::<_float_const>(),
    8usize,
    concat!("Alignment of ", stringify!(_float_const))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_float_const>()))._Word as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_float_const),
      "::",
      stringify!(_Word)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_float_const>()))._Float as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_float_const),
      "::",
      stringify!(_Float)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_float_const>()))._Double as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_float_const),
      "::",
      stringify!(_Double)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_float_const>()))._Long_double as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_float_const),
      "::",
      stringify!(_Long_double)
    )
  );
}
impl Default for _float_const {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _float_const {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_float_const {{ union }}")
  }
}
extern "C" {
  #[link_name = "\u{1}_Denorm_C"]
  pub static _Denorm_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Inf_C"]
  pub static _Inf_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Nan_C"]
  pub static _Nan_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Snan_C"]
  pub static _Snan_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Hugeval_C"]
  pub static _Hugeval_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_FDenorm_C"]
  pub static _FDenorm_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_FInf_C"]
  pub static _FInf_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_FNan_C"]
  pub static _FNan_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_FSnan_C"]
  pub static _FSnan_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_LDenorm_C"]
  pub static _LDenorm_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_LInf_C"]
  pub static _LInf_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_LNan_C"]
  pub static _LNan_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_LSnan_C"]
  pub static _LSnan_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Eps_C"]
  pub static _Eps_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Rteps_C"]
  pub static _Rteps_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_FEps_C"]
  pub static _FEps_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_FRteps_C"]
  pub static _FRteps_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_LEps_C"]
  pub static _LEps_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_LRteps_C"]
  pub static _LRteps_C: _float_const;
}
extern "C" {
  #[link_name = "\u{1}_Zero_C"]
  pub static _Zero_C: f64;
}
extern "C" {
  #[link_name = "\u{1}_Xbig_C"]
  pub static _Xbig_C: f64;
}
extern "C" {
  #[link_name = "\u{1}_FZero_C"]
  pub static _FZero_C: f32;
}
extern "C" {
  #[link_name = "\u{1}_FXbig_C"]
  pub static _FXbig_C: f32;
}
extern "C" {
  #[link_name = "\u{1}_LZero_C"]
  pub static _LZero_C: f64;
}
extern "C" {
  #[link_name = "\u{1}_LXbig_C"]
  pub static _LXbig_C: f64;
}
extern "C" {
  pub fn abs(_X: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn labs(_X: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn llabs(_X: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
  pub fn acos(_X: f64) -> f64;
}
extern "C" {
  pub fn asin(_X: f64) -> f64;
}
extern "C" {
  pub fn atan(_X: f64) -> f64;
}
extern "C" {
  pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
  pub fn cos(_X: f64) -> f64;
}
extern "C" {
  pub fn cosh(_X: f64) -> f64;
}
extern "C" {
  pub fn exp(_X: f64) -> f64;
}
extern "C" {
  pub fn fabs(_X: f64) -> f64;
}
extern "C" {
  pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn log(_X: f64) -> f64;
}
extern "C" {
  pub fn log10(_X: f64) -> f64;
}
extern "C" {
  pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn sin(_X: f64) -> f64;
}
extern "C" {
  pub fn sinh(_X: f64) -> f64;
}
extern "C" {
  pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
  pub fn tan(_X: f64) -> f64;
}
extern "C" {
  pub fn tanh(_X: f64) -> f64;
}
extern "C" {
  pub fn acosh(_X: f64) -> f64;
}
extern "C" {
  pub fn asinh(_X: f64) -> f64;
}
extern "C" {
  pub fn atanh(_X: f64) -> f64;
}
extern "C" {
  pub fn atof(_String: *const libc::c_char) -> f64;
}
extern "C" {
  pub fn _atof_l(_String: *const libc::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
  pub fn _cabs(_Complex_value: _complex) -> f64;
}
extern "C" {
  pub fn cbrt(_X: f64) -> f64;
}
extern "C" {
  pub fn ceil(_X: f64) -> f64;
}
extern "C" {
  pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
  pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
  pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
  pub fn erf(_X: f64) -> f64;
}
extern "C" {
  pub fn erfc(_X: f64) -> f64;
}
extern "C" {
  pub fn exp2(_X: f64) -> f64;
}
extern "C" {
  pub fn expm1(_X: f64) -> f64;
}
extern "C" {
  pub fn fdim(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn floor(_X: f64) -> f64;
}
extern "C" {
  pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
  pub fn fmax(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn fmin(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn frexp(_X: f64, _Y: *mut libc::c_int) -> f64;
}
extern "C" {
  pub fn hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn ilogb(_X: f64) -> libc::c_int;
}
extern "C" {
  pub fn ldexp(_X: f64, _Y: libc::c_int) -> f64;
}
extern "C" {
  pub fn lgamma(_X: f64) -> f64;
}
extern "C" {
  pub fn llrint(_X: f64) -> libc::c_longlong;
}
extern "C" {
  pub fn llround(_X: f64) -> libc::c_longlong;
}
extern "C" {
  pub fn log1p(_X: f64) -> f64;
}
extern "C" {
  pub fn log2(_X: f64) -> f64;
}
extern "C" {
  pub fn logb(_X: f64) -> f64;
}
extern "C" {
  pub fn lrint(_X: f64) -> libc::c_long;
}
extern "C" {
  pub fn lround(_X: f64) -> libc::c_long;
}
extern "C" {
  pub fn _matherr(_Except: *mut _exception) -> libc::c_int;
}
extern "C" {
  pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
  pub fn nan(_X: *const libc::c_char) -> f64;
}
extern "C" {
  pub fn nearbyint(_X: f64) -> f64;
}
extern "C" {
  pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn remainder(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn remquo(_X: f64, _Y: f64, _Z: *mut libc::c_int) -> f64;
}
extern "C" {
  pub fn rint(_X: f64) -> f64;
}
extern "C" {
  pub fn round(_X: f64) -> f64;
}
extern "C" {
  pub fn scalbln(_X: f64, _Y: libc::c_long) -> f64;
}
extern "C" {
  pub fn scalbn(_X: f64, _Y: libc::c_int) -> f64;
}
extern "C" {
  pub fn tgamma(_X: f64) -> f64;
}
extern "C" {
  pub fn trunc(_X: f64) -> f64;
}
extern "C" {
  pub fn _j0(_X: f64) -> f64;
}
extern "C" {
  pub fn _j1(_X: f64) -> f64;
}
extern "C" {
  pub fn _jn(_X: libc::c_int, _Y: f64) -> f64;
}
extern "C" {
  pub fn _y0(_X: f64) -> f64;
}
extern "C" {
  pub fn _y1(_X: f64) -> f64;
}
extern "C" {
  pub fn _yn(_X: libc::c_int, _Y: f64) -> f64;
}
extern "C" {
  pub fn acoshf(_X: f32) -> f32;
}
extern "C" {
  pub fn asinhf(_X: f32) -> f32;
}
extern "C" {
  pub fn atanhf(_X: f32) -> f32;
}
extern "C" {
  pub fn cbrtf(_X: f32) -> f32;
}
extern "C" {
  pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
  pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
  pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
  pub fn erff(_X: f32) -> f32;
}
extern "C" {
  pub fn erfcf(_X: f32) -> f32;
}
extern "C" {
  pub fn expm1f(_X: f32) -> f32;
}
extern "C" {
  pub fn exp2f(_X: f32) -> f32;
}
extern "C" {
  pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
extern "C" {
  pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn fminf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn ilogbf(_X: f32) -> libc::c_int;
}
extern "C" {
  pub fn lgammaf(_X: f32) -> f32;
}
extern "C" {
  pub fn llrintf(_X: f32) -> libc::c_longlong;
}
extern "C" {
  pub fn llroundf(_X: f32) -> libc::c_longlong;
}
extern "C" {
  pub fn log1pf(_X: f32) -> f32;
}
extern "C" {
  pub fn log2f(_X: f32) -> f32;
}
extern "C" {
  pub fn logbf(_X: f32) -> f32;
}
extern "C" {
  pub fn lrintf(_X: f32) -> libc::c_long;
}
extern "C" {
  pub fn lroundf(_X: f32) -> libc::c_long;
}
extern "C" {
  pub fn nanf(_X: *const libc::c_char) -> f32;
}
extern "C" {
  pub fn nearbyintf(_X: f32) -> f32;
}
extern "C" {
  pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
extern "C" {
  pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn remquof(_X: f32, _Y: f32, _Z: *mut libc::c_int) -> f32;
}
extern "C" {
  pub fn rintf(_X: f32) -> f32;
}
extern "C" {
  pub fn roundf(_X: f32) -> f32;
}
extern "C" {
  pub fn scalblnf(_X: f32, _Y: libc::c_long) -> f32;
}
extern "C" {
  pub fn scalbnf(_X: f32, _Y: libc::c_int) -> f32;
}
extern "C" {
  pub fn tgammaf(_X: f32) -> f32;
}
extern "C" {
  pub fn truncf(_X: f32) -> f32;
}
extern "C" {
  pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
  pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn _finitef(_X: f32) -> libc::c_int;
}
extern "C" {
  pub fn _isnanf(_X: f32) -> libc::c_int;
}
extern "C" {
  pub fn _fpclassf(_X: f32) -> libc::c_int;
}
extern "C" {
  pub fn _set_FMA3_enable(_Flag: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _get_FMA3_enable() -> libc::c_int;
}
extern "C" {
  pub fn acosf(_X: f32) -> f32;
}
extern "C" {
  pub fn asinf(_X: f32) -> f32;
}
extern "C" {
  pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
extern "C" {
  pub fn atanf(_X: f32) -> f32;
}
extern "C" {
  pub fn ceilf(_X: f32) -> f32;
}
extern "C" {
  pub fn cosf(_X: f32) -> f32;
}
extern "C" {
  pub fn coshf(_X: f32) -> f32;
}
extern "C" {
  pub fn expf(_X: f32) -> f32;
}
extern "C" {
  pub fn floorf(_X: f32) -> f32;
}
extern "C" {
  pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn log10f(_X: f32) -> f32;
}
extern "C" {
  pub fn logf(_X: f32) -> f32;
}
extern "C" {
  pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
extern "C" {
  pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
  pub fn sinf(_X: f32) -> f32;
}
extern "C" {
  pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
  pub fn sqrtf(_X: f32) -> f32;
}
extern "C" {
  pub fn tanf(_X: f32) -> f32;
}
extern "C" {
  pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
  pub fn acoshl(_X: f64) -> f64;
}
extern "C" {
  pub fn asinhl(_X: f64) -> f64;
}
extern "C" {
  pub fn atanhl(_X: f64) -> f64;
}
extern "C" {
  pub fn cbrtl(_X: f64) -> f64;
}
extern "C" {
  pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
  pub fn erfl(_X: f64) -> f64;
}
extern "C" {
  pub fn erfcl(_X: f64) -> f64;
}
extern "C" {
  pub fn exp2l(_X: f64) -> f64;
}
extern "C" {
  pub fn expm1l(_X: f64) -> f64;
}
extern "C" {
  pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
  pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn fminl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn ilogbl(_X: f64) -> libc::c_int;
}
extern "C" {
  pub fn lgammal(_X: f64) -> f64;
}
extern "C" {
  pub fn llrintl(_X: f64) -> libc::c_longlong;
}
extern "C" {
  pub fn llroundl(_X: f64) -> libc::c_longlong;
}
extern "C" {
  pub fn log1pl(_X: f64) -> f64;
}
extern "C" {
  pub fn log2l(_X: f64) -> f64;
}
extern "C" {
  pub fn logbl(_X: f64) -> f64;
}
extern "C" {
  pub fn lrintl(_X: f64) -> libc::c_long;
}
extern "C" {
  pub fn lroundl(_X: f64) -> libc::c_long;
}
extern "C" {
  pub fn nanl(_X: *const libc::c_char) -> f64;
}
extern "C" {
  pub fn nearbyintl(_X: f64) -> f64;
}
extern "C" {
  pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
  pub fn remquol(_X: f64, _Y: f64, _Z: *mut libc::c_int) -> f64;
}
extern "C" {
  pub fn rintl(_X: f64) -> f64;
}
extern "C" {
  pub fn roundl(_X: f64) -> f64;
}
extern "C" {
  pub fn scalblnl(_X: f64, _Y: libc::c_long) -> f64;
}
extern "C" {
  pub fn scalbnl(_X: f64, _Y: libc::c_int) -> f64;
}
extern "C" {
  pub fn tgammal(_X: f64) -> f64;
}
extern "C" {
  pub fn truncl(_X: f64) -> f64;
}
extern "C" {
  #[link_name = "\u{1}HUGE"]
  pub static mut HUGE: f64;
}
extern "C" {
  pub fn j0(_X: f64) -> f64;
}
extern "C" {
  pub fn j1(_X: f64) -> f64;
}
extern "C" {
  pub fn jn(_X: libc::c_int, _Y: f64) -> f64;
}
extern "C" {
  pub fn y0(_X: f64) -> f64;
}
extern "C" {
  pub fn y1(_X: f64) -> f64;
}
extern "C" {
  pub fn yn(_X: libc::c_int, _Y: f64) -> f64;
}
pub mod _crt_argv_mode {
  pub type Type = i32;
  pub const _crt_argv_no_arguments: Type = 0;
  pub const _crt_argv_unexpanded_arguments: Type = 1;
  pub const _crt_argv_expanded_arguments: Type = 2;
}
pub mod _crt_exit_return_mode {
  pub type Type = i32;
  pub const _crt_exit_terminate_process: Type = 0;
  pub const _crt_exit_return_to_caller: Type = 1;
}
pub mod _crt_exit_cleanup_mode {
  pub type Type = i32;
  pub const _crt_exit_full_cleanup: Type = 0;
  pub const _crt_exit_quick_cleanup: Type = 1;
  pub const _crt_exit_no_cleanup: Type = 2;
}
extern "C" {
  #[link_name = "\u{1}__current_exit_return_mode"]
  pub static mut __current_exit_return_mode: _crt_exit_return_mode::Type;
}
extern "C" {
  pub fn __vcrt_initialize() -> __vcrt_bool;
}
extern "C" {
  pub fn __vcrt_uninitialize(_Terminating: __vcrt_bool) -> __vcrt_bool;
}
extern "C" {
  pub fn __vcrt_uninitialize_critical() -> __vcrt_bool;
}
extern "C" {
  pub fn __vcrt_thread_attach() -> __vcrt_bool;
}
extern "C" {
  pub fn __vcrt_thread_detach() -> __vcrt_bool;
}
extern "C" {
  pub fn __isa_available_init() -> libc::c_int;
}
extern "C" {
  pub fn _get_startup_argv_mode() -> _crt_argv_mode::Type;
}
extern "C" {
  pub fn _seh_filter_dll(
    _ExceptionNum: libc::c_ulong, _ExceptionPtr: *mut _EXCEPTION_POINTERS,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _seh_filter_exe(
    _ExceptionNum: libc::c_ulong, _ExceptionPtr: *mut _EXCEPTION_POINTERS,
  ) -> libc::c_int;
}
pub mod _crt_app_type {
  pub type Type = i32;
  pub const _crt_unknown_app: Type = 0;
  pub const _crt_console_app: Type = 1;
  pub const _crt_gui_app: Type = 2;
}
extern "C" {
  pub fn _query_app_type() -> _crt_app_type::Type;
}
extern "C" {
  pub fn _set_app_type(_Type: _crt_app_type::Type);
}
pub type _UserMathErrorFunctionPointer =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut _exception) -> libc::c_int>;
extern "C" {
  pub fn __setusermatherr(_UserMathErrorFunction: _UserMathErrorFunctionPointer);
}
extern "C" {
  pub fn _is_c_termination_complete() -> libc::c_int;
}
extern "C" {
  pub fn _configure_narrow_argv(mode: _crt_argv_mode::Type) -> errno_t;
}
extern "C" {
  pub fn _configure_wide_argv(mode: _crt_argv_mode::Type) -> errno_t;
}
extern "C" {
  pub fn _initialize_narrow_environment() -> libc::c_int;
}
extern "C" {
  pub fn _initialize_wide_environment() -> libc::c_int;
}
extern "C" {
  pub fn _get_initial_narrow_environment() -> *mut *mut libc::c_char;
}
extern "C" {
  pub fn _get_initial_wide_environment() -> *mut *mut wchar_t;
}
extern "C" {
  pub fn _get_narrow_winmain_command_line() -> *mut libc::c_char;
}
extern "C" {
  pub fn _get_wide_winmain_command_line() -> *mut wchar_t;
}
extern "C" {
  pub fn __p__acmdln() -> *mut *mut libc::c_char;
}
extern "C" {
  pub fn __p__wcmdln() -> *mut *mut wchar_t;
}
pub type _PVFV = ::core::option::Option<unsafe extern "C" fn()>;
pub type _PIFV = ::core::option::Option<unsafe extern "C" fn() -> libc::c_int>;
pub type _PVFI = ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
extern "C" {
  pub fn _initterm(_First: *mut _PVFV, _Last: *mut _PVFV);
}
extern "C" {
  pub fn _initterm_e(_First: *mut _PIFV, _Last: *mut _PIFV) -> libc::c_int;
}
pub type _onexit_t = ::core::option::Option<unsafe extern "C" fn() -> libc::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _onexit_table_t {
  pub _first: *mut _PVFV,
  pub _last: *mut _PVFV,
  pub _end: *mut _PVFV,
}
#[test]
fn bindgen_test_layout__onexit_table_t() {
  assert_eq!(
    ::core::mem::size_of::<_onexit_table_t>(),
    24usize,
    concat!("Size of: ", stringify!(_onexit_table_t))
  );
  assert_eq!(
    ::core::mem::align_of::<_onexit_table_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_onexit_table_t))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_onexit_table_t>()))._first as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_onexit_table_t),
      "::",
      stringify!(_first)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_onexit_table_t>()))._last as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_onexit_table_t),
      "::",
      stringify!(_last)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_onexit_table_t>()))._end as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_onexit_table_t),
      "::",
      stringify!(_end)
    )
  );
}
impl Default for _onexit_table_t {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn _initialize_onexit_table(_Table: *mut _onexit_table_t) -> libc::c_int;
}
extern "C" {
  pub fn _register_onexit_function(
    _Table: *mut _onexit_table_t, _Function: _onexit_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _execute_onexit_table(_Table: *mut _onexit_table_t) -> libc::c_int;
}
extern "C" {
  pub fn _crt_atexit(_Function: _PVFV) -> libc::c_int;
}
extern "C" {
  pub fn _crt_at_quick_exit(_Function: _PVFV) -> libc::c_int;
}
extern "C" {
  pub fn __acrt_initialize() -> __crt_bool;
}
extern "C" {
  pub fn __acrt_uninitialize(_Terminating: __crt_bool) -> __crt_bool;
}
extern "C" {
  pub fn __acrt_uninitialize_critical(_Terminating: __crt_bool) -> __crt_bool;
}
extern "C" {
  pub fn __acrt_thread_attach() -> __crt_bool;
}
extern "C" {
  pub fn __acrt_thread_detach() -> __crt_bool;
}
extern "C" {
  pub fn _wexecl(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
  pub fn _wexecle(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
  pub fn _wexeclp(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
  pub fn _wexeclpe(_FileName: *const wchar_t, _ArgList: *const wchar_t, ...) -> isize;
}
extern "C" {
  pub fn _wexecv(_FileName: *const wchar_t, _ArgList: *const *const wchar_t) -> isize;
}
extern "C" {
  pub fn _wexecve(
    _FileName: *const wchar_t, _ArgList: *const *const wchar_t, _Env: *const *const wchar_t,
  ) -> isize;
}
extern "C" {
  pub fn _wexecvp(_FileName: *const wchar_t, _ArgList: *const *const wchar_t) -> isize;
}
extern "C" {
  pub fn _wexecvpe(
    _FileName: *const wchar_t, _ArgList: *const *const wchar_t, _Env: *const *const wchar_t,
  ) -> isize;
}
extern "C" {
  pub fn _wspawnl(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const wchar_t, ...
  ) -> isize;
}
extern "C" {
  pub fn _wspawnle(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const wchar_t, ...
  ) -> isize;
}
extern "C" {
  pub fn _wspawnlp(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const wchar_t, ...
  ) -> isize;
}
extern "C" {
  pub fn _wspawnlpe(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const wchar_t, ...
  ) -> isize;
}
extern "C" {
  pub fn _wspawnv(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const *const wchar_t,
  ) -> isize;
}
extern "C" {
  pub fn _wspawnve(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const *const wchar_t,
    _Env: *const *const wchar_t,
  ) -> isize;
}
extern "C" {
  pub fn _wspawnvp(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const *const wchar_t,
  ) -> isize;
}
extern "C" {
  pub fn _wspawnvpe(
    _Mode: libc::c_int, _FileName: *const wchar_t, _ArgList: *const *const wchar_t,
    _Env: *const *const wchar_t,
  ) -> isize;
}
extern "C" {
  pub fn _wsystem(_Command: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn exit(_Code: libc::c_int);
}
extern "C" {
  pub fn _exit(_Code: libc::c_int);
}
extern "C" {
  pub fn _Exit(_Code: libc::c_int);
}
extern "C" {
  pub fn quick_exit(_Code: libc::c_int);
}
extern "C" {
  pub fn abort();
}
extern "C" {
  pub fn system(_Command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn _cexit();
}
extern "C" {
  pub fn _c_exit();
}
pub type _tls_callback_type = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: libc::c_ulong, arg3: *mut libc::c_void),
>;
extern "C" {
  pub fn _register_thread_local_exe_atexit_callback(_Callback: _tls_callback_type);
}
pub type _beginthread_proc_type =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>;
pub type _beginthreadex_proc_type =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_uint>;
extern "C" {
  pub fn _beginthread(
    _StartAddress: _beginthread_proc_type, _StackSize: libc::c_uint, _ArgList: *mut libc::c_void,
  ) -> usize;
}
extern "C" {
  pub fn _endthread();
}
extern "C" {
  pub fn _beginthreadex(
    _Security: *mut libc::c_void, _StackSize: libc::c_uint,
    _StartAddress: _beginthreadex_proc_type, _ArgList: *mut libc::c_void, _InitFlag: libc::c_uint,
    _ThrdAddr: *mut libc::c_uint,
  ) -> usize;
}
extern "C" {
  pub fn _endthreadex(_ReturnCode: libc::c_uint);
}
extern "C" {
  pub fn _getpid() -> libc::c_int;
}
extern "C" {
  pub fn _cwait(_TermStat: *mut libc::c_int, _ProcHandle: isize, _Action: libc::c_int) -> isize;
}
extern "C" {
  pub fn _execl(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn _execle(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn _execlp(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn _execlpe(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn _execv(_FileName: *const libc::c_char, _Arguments: *const *const libc::c_char) -> isize;
}
extern "C" {
  pub fn _execve(
    _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn _execvp(_FileName: *const libc::c_char, _Arguments: *const *const libc::c_char) -> isize;
}
extern "C" {
  pub fn _execvpe(
    _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn _spawnl(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn _spawnle(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn _spawnlp(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn _spawnlpe(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn _spawnv(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn _spawnve(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn _spawnvp(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn _spawnvpe(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn _loaddll(_FileName: *mut libc::c_char) -> isize;
}
extern "C" {
  pub fn _unloaddll(_Handle: isize) -> libc::c_int;
}
pub type _GetDllProcAddrProcType = ::core::option::Option<unsafe extern "C" fn() -> libc::c_int>;
extern "C" {
  pub fn _getdllprocaddr(
    _Handle: isize, _ProcedureName: *mut libc::c_char, _Ordinal: isize,
  ) -> _GetDllProcAddrProcType;
}
extern "C" {
  pub fn cwait(_TermStat: *mut libc::c_int, _ProcHandle: isize, _Action: libc::c_int) -> isize;
}
extern "C" {
  pub fn execl(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn execle(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn execlp(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn execlpe(_FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...) -> isize;
}
extern "C" {
  pub fn execv(_FileName: *const libc::c_char, _Arguments: *const *const libc::c_char) -> isize;
}
extern "C" {
  pub fn execve(
    _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn execvp(_FileName: *const libc::c_char, _Arguments: *const *const libc::c_char) -> isize;
}
extern "C" {
  pub fn execvpe(
    _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn spawnl(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn spawnle(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn spawnlp(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn spawnlpe(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const libc::c_char, ...
  ) -> isize;
}
extern "C" {
  pub fn spawnv(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn spawnve(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn spawnvp(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn spawnvpe(
    _Mode: libc::c_int, _FileName: *const libc::c_char, _Arguments: *const *const libc::c_char,
    _Environment: *const *const libc::c_char,
  ) -> isize;
}
extern "C" {
  pub fn getpid() -> libc::c_int;
}
pub type pfnSDL_CurrentBeginThread = ::core::option::Option<
  unsafe extern "C" fn(
    arg1: *mut libc::c_void,
    arg2: libc::c_uint,
    func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_uint>,
    arg3: *mut libc::c_void,
    arg4: libc::c_uint,
    arg5: *mut libc::c_uint,
  ) -> usize,
>;
pub type pfnSDL_CurrentEndThread = ::core::option::Option<unsafe extern "C" fn(code: libc::c_uint)>;
extern "C" {
  #[doc = "  Create a thread."]
  pub fn SDL_CreateThread(
    fn_: SDL_ThreadFunction, name: *const libc::c_char, data: *mut libc::c_void,
    pfnBeginThread: pfnSDL_CurrentBeginThread, pfnEndThread: pfnSDL_CurrentEndThread,
  ) -> *mut SDL_Thread;
}
extern "C" {
  pub fn SDL_CreateThreadWithStackSize(
    fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    name: *const libc::c_char, stacksize: usize, data: *mut libc::c_void,
    pfnBeginThread: pfnSDL_CurrentBeginThread, pfnEndThread: pfnSDL_CurrentEndThread,
  ) -> *mut SDL_Thread;
}
extern "C" {
  #[doc = " Get the thread name, as it was specified in SDL_CreateThread()."]
  #[doc = "  This function returns a pointer to a UTF-8 string that names the"]
  #[doc = "  specified thread, or NULL if it doesn\'t have a name. This is internal"]
  #[doc = "  memory, not to be free()\'d by the caller, and remains valid until the"]
  #[doc = "  specified thread is cleaned up by SDL_WaitThread()."]
  pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the thread identifier for the current thread."]
  pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
  #[doc = "  Get the thread identifier for the specified thread."]
  #[doc = ""]
  #[doc = "  Equivalent to SDL_ThreadID() if the specified thread is NULL."]
  pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
  #[doc = "  Set the priority for the current thread"]
  pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority::Type) -> libc::c_int;
}
extern "C" {
  #[doc = "  Wait for a thread to finish. Threads that haven\'t been detached will"]
  #[doc = "  remain (as a \"zombie\") until this function cleans them up. Not doing so"]
  #[doc = "  is a resource leak."]
  #[doc = ""]
  #[doc = "  Once a thread has been cleaned up through this function, the SDL_Thread"]
  #[doc = "  that references it becomes invalid and should not be referenced again."]
  #[doc = "  As such, only one thread may call SDL_WaitThread() on another."]
  #[doc = ""]
  #[doc = "  The return code for the thread function is placed in the area"]
  #[doc = "  pointed to by \\c status, if \\c status is not NULL."]
  #[doc = ""]
  #[doc = "  You may not wait on a thread that has been used in a call to"]
  #[doc = "  SDL_DetachThread(). Use either that function or this one, but not"]
  #[doc = "  both, or behavior is undefined."]
  #[doc = ""]
  #[doc = "  It is safe to pass NULL to this function; it is a no-op."]
  pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
extern "C" {
  #[doc = "  A thread may be \"detached\" to signify that it should not remain until"]
  #[doc = "  another thread has called SDL_WaitThread() on it. Detaching a thread"]
  #[doc = "  is useful for long-running threads that nothing needs to synchronize"]
  #[doc = "  with or further manage. When a detached thread is done, it simply"]
  #[doc = "  goes away."]
  #[doc = ""]
  #[doc = "  There is no way to recover the return code of a detached thread. If you"]
  #[doc = "  need this, don\'t detach the thread and instead use SDL_WaitThread()."]
  #[doc = ""]
  #[doc = "  Once a thread is detached, you should usually assume the SDL_Thread isn\'t"]
  #[doc = "  safe to reference again, as it will become invalid immediately upon"]
  #[doc = "  the detached thread\'s exit, instead of remaining until someone has called"]
  #[doc = "  SDL_WaitThread() to finally clean it up. As such, don\'t detach the same"]
  #[doc = "  thread more than once."]
  #[doc = ""]
  #[doc = "  If a thread has already exited when passed to SDL_DetachThread(), it will"]
  #[doc = "  stop waiting for a call to SDL_WaitThread() and clean up immediately."]
  #[doc = "  It is not safe to detach a thread that might be used with SDL_WaitThread()."]
  #[doc = ""]
  #[doc = "  You may not call SDL_WaitThread() on a thread that has been detached."]
  #[doc = "  Use either that function or this one, but not both, or behavior is"]
  #[doc = "  undefined."]
  #[doc = ""]
  #[doc = "  It is safe to pass NULL to this function; it is a no-op."]
  pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
  #[doc = "  \\brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific."]
  #[doc = ""]
  #[doc = "  \\return The newly created thread local storage identifier, or 0 on error"]
  #[doc = ""]
  #[doc = "  \\code"]
  #[doc = "  static SDL_SpinLock tls_lock;"]
  #[doc = "  static SDL_TLSID thread_local_storage;"]
  #[doc = ""]
  #[doc = "  void SetMyThreadData(void *value)"]
  #[doc = "  {"]
  #[doc = "      if (!thread_local_storage) {"]
  #[doc = "          SDL_AtomicLock(&tls_lock);"]
  #[doc = "          if (!thread_local_storage) {"]
  #[doc = "              thread_local_storage = SDL_TLSCreate();"]
  #[doc = "          }"]
  #[doc = "          SDL_AtomicUnlock(&tls_lock);"]
  #[doc = "      }"]
  #[doc = "      SDL_TLSSet(thread_local_storage, value, 0);"]
  #[doc = "  }"]
  #[doc = ""]
  #[doc = "  void *GetMyThreadData(void)"]
  #[doc = "  {"]
  #[doc = "      return SDL_TLSGet(thread_local_storage);"]
  #[doc = "  }"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  \\sa SDL_TLSGet()"]
  #[doc = "  \\sa SDL_TLSSet()"]
  pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
  #[doc = "  \\brief Get the value associated with a thread local storage ID for the current thread."]
  #[doc = ""]
  #[doc = "  \\param id The thread local storage ID"]
  #[doc = ""]
  #[doc = "  \\return The value associated with the ID for the current thread, or NULL if no value has been set."]
  #[doc = ""]
  #[doc = "  \\sa SDL_TLSCreate()"]
  #[doc = "  \\sa SDL_TLSSet()"]
  pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Set the value associated with a thread local storage ID for the current thread."]
  #[doc = ""]
  #[doc = "  \\param id The thread local storage ID"]
  #[doc = "  \\param value The value to associate with the ID for the current thread"]
  #[doc = "  \\param destructor A function called when the thread exits, to free the value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_TLSCreate()"]
  #[doc = "  \\sa SDL_TLSGet()"]
  pub fn SDL_TLSSet(
    id: SDL_TLSID, value: *const libc::c_void,
    destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
  ) -> libc::c_int;
}
#[doc = " This is the read/write operation structure -- very basic."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
  #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
  pub size: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
  #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio\'s whence values:"]
  #[doc = "  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END"]
  #[doc = ""]
  #[doc = "  \\return the final offset in the data stream, or -1 on error."]
  pub seek: ::core::option::Option<
    unsafe extern "C" fn(context: *mut SDL_RWops, offset: Sint64, whence: libc::c_int) -> Sint64,
  >,
  #[doc = "  Read up to \\c maxnum objects each of size \\c size from the data"]
  #[doc = "  stream to the area pointed at by \\c ptr."]
  #[doc = ""]
  #[doc = "  \\return the number of objects read, or 0 at error or end of file."]
  pub read: ::core::option::Option<
    unsafe extern "C" fn(
      context: *mut SDL_RWops,
      ptr: *mut libc::c_void,
      size: usize,
      maxnum: usize,
    ) -> usize,
  >,
  #[doc = "  Write exactly \\c num objects each of size \\c size from the area"]
  #[doc = "  pointed at by \\c ptr to data stream."]
  #[doc = ""]
  #[doc = "  \\return the number of objects written, or 0 at error or end of file."]
  pub write: ::core::option::Option<
    unsafe extern "C" fn(
      context: *mut SDL_RWops,
      ptr: *const libc::c_void,
      size: usize,
      num: usize,
    ) -> usize,
  >,
  #[doc = "  Close and free an allocated SDL_RWops structure."]
  #[doc = ""]
  #[doc = "  \\return 0 if successful or -1 on write error when flushing data."]
  pub close: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> libc::c_int>,
  pub type_: Uint32,
  pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
  pub windowsio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
  pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
  pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
  _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
  pub append: SDL_bool::Type,
  pub h: *mut libc::c_void,
  pub buffer: SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub data: *mut libc::c_void,
  pub size: usize,
  pub left: usize,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).data
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).size
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).left
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(left)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).append as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(append)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).h as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).buffer as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(buffer)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
  pub base: *mut Uint8,
  pub here: *mut Uint8,
  pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).base as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).here as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(here)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).stop as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(stop)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
  pub data1: *mut libc::c_void,
  pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>())).data2 as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(data2)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).windowsio as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(windowsio)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).mem as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(mem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).unknown as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops__bindgen_ty_1),
      "::",
      stringify!(unknown)
    )
  );
}
impl Default for SDL_RWops__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_RWops__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_RWops__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RWops>(),
    88usize,
    concat!("Size of: ", stringify!(SDL_RWops))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RWops>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_RWops))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).seek as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(seek)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).read as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(read)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).write as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(write)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).close as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(close)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).type_ as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RWops>())).hidden as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RWops),
      "::",
      stringify!(hidden)
    )
  );
}
impl Default for SDL_RWops {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_RWops {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "SDL_RWops {{ size: {:?}, seek: {:?}, read: {:?}, write: {:?}, close: {:?}, type: {:?}, hidden: {:?} }}" , self . size , self . seek , self . read , self . write , self . close , self . type_ , self . hidden )
  }
}
extern "C" {
  pub fn SDL_RWFromFile(file: *const libc::c_char, mode: *const libc::c_char) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_RWFromFP(fp: *mut libc::c_void, autoclose: SDL_bool::Type) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_RWFromMem(mem: *mut libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_RWFromConstMem(mem: *const libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
  pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
  #[doc = "  Load all the data from an SDL data stream."]
  #[doc = ""]
  #[doc = "  The data is allocated with a zero byte at the end (null terminated)"]
  #[doc = ""]
  #[doc = "  If \\c datasize is not NULL, it is filled with the size of the data read."]
  #[doc = ""]
  #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
  #[doc = ""]
  #[doc = "  The data should be freed with SDL_free()."]
  #[doc = ""]
  #[doc = "  \\return the data, or NULL if there was an error."]
  pub fn SDL_LoadFile_RW(
    src: *mut SDL_RWops, datasize: *mut usize, freesrc: libc::c_int,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
  pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
  pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
  pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
  pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
  pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
  pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
  pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
  pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
  pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
  pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
  pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
  pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
  pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
#[doc = "  \\brief Audio format flags."]
#[doc = ""]
#[doc = "  These are what the 16 bits in SDL_AudioFormat currently mean..."]
#[doc = "  (Unspecified bits are always zero)."]
#[doc = ""]
#[doc = "  \\verbatim"]
#[doc = "++-----------------------sample is signed if set"]
#[doc = "||"]
#[doc = "||       ++-----------sample is bigendian if set"]
#[doc = "||       ||"]
#[doc = "||       ||          ++---sample is float if set"]
#[doc = "||       ||          ||"]
#[doc = "||       ||          || +---sample bit size---+"]
#[doc = "||       ||          || |                     |"]
#[doc = "15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  There are macros in SDL 2.0 and later to query these bits."]
pub type SDL_AudioFormat = Uint16;
#[doc = "  This function is called when the audio device needs more data."]
#[doc = ""]
#[doc = "  \\param userdata An application-specific parameter saved in"]
#[doc = "                  the SDL_AudioSpec structure"]
#[doc = "  \\param stream A pointer to the audio data buffer."]
#[doc = "  \\param len    The length of that buffer in bytes."]
#[doc = ""]
#[doc = "  Once the callback returns, the buffer will no longer be valid."]
#[doc = "  Stereo samples are stored in a LRLRLR ordering."]
#[doc = ""]
#[doc = "  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if"]
#[doc = "  you like. Just open your audio device with a NULL callback."]
pub type SDL_AudioCallback = ::core::option::Option<
  unsafe extern "C" fn(userdata: *mut libc::c_void, stream: *mut Uint8, len: libc::c_int),
>;
#[doc = "  The calculated values in this structure are calculated by SDL_OpenAudio()."]
#[doc = ""]
#[doc = "  For multi-channel audio, the default SDL channel mapping is:"]
#[doc = "  2:  FL FR                       (stereo)"]
#[doc = "  3:  FL FR LFE                   (2.1 surround)"]
#[doc = "  4:  FL FR BL BR                 (quad)"]
#[doc = "  5:  FL FR FC BL BR              (quad + center)"]
#[doc = "  6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)"]
#[doc = "  7:  FL FR FC LFE BC SL SR       (6.1 surround)"]
#[doc = "  8:  FL FR FC LFE BL BR SL SR    (7.1 surround)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AudioSpec {
  #[doc = "< DSP frequency -- samples per second"]
  pub freq: libc::c_int,
  #[doc = "< Audio data format"]
  pub format: SDL_AudioFormat,
  #[doc = "< Number of channels: 1 mono, 2 stereo"]
  pub channels: Uint8,
  #[doc = "< Audio buffer silence value (calculated)"]
  pub silence: Uint8,
  #[doc = "< Audio buffer size in sample FRAMES (total samples divided by channel count)"]
  pub samples: Uint16,
  #[doc = "< Necessary for some compile environments"]
  pub padding: Uint16,
  #[doc = "< Audio buffer size in bytes (calculated)"]
  pub size: Uint32,
  #[doc = "< Callback that feeds the audio device (NULL to use SDL_QueueAudio())."]
  pub callback: SDL_AudioCallback,
  #[doc = "< Userdata passed to callback (ignored for NULL callbacks)."]
  pub userdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioSpec>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_AudioSpec))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioSpec>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_AudioSpec))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).freq as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(freq)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).channels as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).silence as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(silence)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).samples as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).padding as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).size as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).callback as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(callback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).userdata as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioSpec),
      "::",
      stringify!(userdata)
    )
  );
}
impl Default for SDL_AudioSpec {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SDL_AudioFilter =
  ::core::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_AudioCVT {
  #[doc = "< Set to 1 if conversion possible"]
  pub needed: libc::c_int,
  #[doc = "< Source audio format"]
  pub src_format: SDL_AudioFormat,
  #[doc = "< Target audio format"]
  pub dst_format: SDL_AudioFormat,
  #[doc = "< Rate conversion increment"]
  pub rate_incr: f64,
  #[doc = "< Buffer to hold entire audio data"]
  pub buf: *mut Uint8,
  #[doc = "< Length of original audio buffer"]
  pub len: libc::c_int,
  #[doc = "< Length of converted audio buffer"]
  pub len_cvt: libc::c_int,
  #[doc = "< buffer must be len*len_mult big"]
  pub len_mult: libc::c_int,
  #[doc = "< Given len, final size is len*len_ratio"]
  pub len_ratio: f64,
  #[doc = "< NULL-terminated list of filter functions"]
  pub filters: [SDL_AudioFilter; 10usize],
  #[doc = "< Current audio conversion function"]
  pub filter_index: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioCVT>(),
    136usize,
    concat!("Size of: ", stringify!(SDL_AudioCVT))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioCVT>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_AudioCVT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).needed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(needed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).src_format as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(src_format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).dst_format as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(dst_format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).rate_incr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(rate_incr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).buf as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_cvt as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_cvt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_mult as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_mult)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_ratio as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(len_ratio)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filters as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(filters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filter_index as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioCVT),
      "::",
      stringify!(filter_index)
    )
  );
}
impl Default for SDL_AudioCVT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
extern "C" {
  pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  pub fn SDL_AudioInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn SDL_AudioQuit();
}
extern "C" {
  #[doc = "  This function returns the name of the current audio driver, or NULL"]
  #[doc = "  if no driver has been initialized."]
  pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
extern "C" {
  #[doc = "  This function opens the audio device with the desired parameters, and"]
  #[doc = "  returns 0 if successful, placing the actual hardware parameters in the"]
  #[doc = "  structure pointed to by \\c obtained.  If \\c obtained is NULL, the audio"]
  #[doc = "  data passed to the callback function will be guaranteed to be in the"]
  #[doc = "  requested format, and will be automatically converted to the hardware"]
  #[doc = "  audio format if necessary.  This function returns -1 if it failed"]
  #[doc = "  to open the audio device, or couldn\'t set up the audio thread."]
  #[doc = ""]
  #[doc = "  When filling in the desired audio spec structure,"]
  #[doc = "    - \\c desired->freq should be the desired audio frequency in samples-per-"]
  #[doc = "      second."]
  #[doc = "    - \\c desired->format should be the desired audio format."]
  #[doc = "    - \\c desired->samples is the desired size of the audio buffer, in"]
  #[doc = "      samples.  This number should be a power of two, and may be adjusted by"]
  #[doc = "      the audio driver to a value more suitable for the hardware.  Good values"]
  #[doc = "      seem to range between 512 and 8096 inclusive, depending on the"]
  #[doc = "      application and CPU speed.  Smaller values yield faster response time,"]
  #[doc = "      but can lead to underflow if the application is doing heavy processing"]
  #[doc = "      and cannot fill the audio buffer in time.  A stereo sample consists of"]
  #[doc = "      both right and left channels in LR ordering."]
  #[doc = "      Note that the number of samples is directly related to time by the"]
  #[doc = "      following formula:  \\code ms = (samples*1000)/freq \\endcode"]
  #[doc = "    - \\c desired->size is the size in bytes of the audio buffer, and is"]
  #[doc = "      calculated by SDL_OpenAudio()."]
  #[doc = "    - \\c desired->silence is the value used to set the buffer to silence,"]
  #[doc = "      and is calculated by SDL_OpenAudio()."]
  #[doc = "    - \\c desired->callback should be set to a function that will be called"]
  #[doc = "      when the audio device is ready for more data.  It is passed a pointer"]
  #[doc = "      to the audio buffer, and the length in bytes of the audio buffer."]
  #[doc = "      This function usually runs in a separate thread, and so you should"]
  #[doc = "      protect data structures that it accesses by calling SDL_LockAudio()"]
  #[doc = "      and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL"]
  #[doc = "      pointer here, and call SDL_QueueAudio() with some frequency, to queue"]
  #[doc = "      more audio samples to be played (or for capture devices, call"]
  #[doc = "      SDL_DequeueAudio() with some frequency, to obtain audio samples)."]
  #[doc = "    - \\c desired->userdata is passed as the first parameter to your callback"]
  #[doc = "      function. If you passed a NULL callback, this value is ignored."]
  #[doc = ""]
  #[doc = "  The audio device starts out playing silence when it\'s opened, and should"]
  #[doc = "  be enabled for playing by calling \\c SDL_PauseAudio(0) when you are ready"]
  #[doc = "  for your audio callback function to be called.  Since the audio driver"]
  #[doc = "  may modify the requested size of the audio buffer, you should allocate"]
  #[doc = "  any local mixing buffers after you open the audio device."]
  pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec, obtained: *mut SDL_AudioSpec) -> libc::c_int;
}
#[doc = "  SDL Audio Device IDs."]
#[doc = ""]
#[doc = "  A successful call to SDL_OpenAudio() is always device id 1, and legacy"]
#[doc = "  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls"]
#[doc = "  always returns devices >= 2 on success. The legacy calls are good both"]
#[doc = "  for backwards compatibility and when you don\'t care about multiple,"]
#[doc = "  specific, or capture devices."]
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
  #[doc = "  Get the number of available devices exposed by the current driver."]
  #[doc = "  Only valid after a successfully initializing the audio subsystem."]
  #[doc = "  Returns -1 if an explicit list of devices can\'t be determined; this is"]
  #[doc = "  not an error. For example, if SDL is set up to talk to a remote audio"]
  #[doc = "  server, it can\'t list every one available on the Internet, but it will"]
  #[doc = "  still allow a specific host to be specified to SDL_OpenAudioDevice()."]
  #[doc = ""]
  #[doc = "  In many common cases, when this function returns a value <= 0, it can still"]
  #[doc = "  successfully open the default device (NULL for first argument of"]
  #[doc = "  SDL_OpenAudioDevice())."]
  pub fn SDL_GetNumAudioDevices(iscapture: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the human-readable name of a specific audio device."]
  #[doc = "  Must be a value between 0 and (number of audio devices-1)."]
  #[doc = "  Only valid after a successfully initializing the audio subsystem."]
  #[doc = "  The values returned by this function reflect the latest call to"]
  #[doc = "  SDL_GetNumAudioDevices(); recall that function to redetect available"]
  #[doc = "  hardware."]
  #[doc = ""]
  #[doc = "  The string returned by this function is UTF-8 encoded, read-only, and"]
  #[doc = "  managed internally. You are not to free it. If you need to keep the"]
  #[doc = "  string for any length of time, you should make your own copy of it, as it"]
  #[doc = "  will be invalid next time any of several other SDL functions is called."]
  pub fn SDL_GetAudioDeviceName(index: libc::c_int, iscapture: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Open a specific audio device. Passing in a device name of NULL requests"]
  #[doc = "  the most reasonable default (and is equivalent to calling SDL_OpenAudio())."]
  #[doc = ""]
  #[doc = "  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but"]
  #[doc = "  some drivers allow arbitrary and driver-specific strings, such as a"]
  #[doc = "  hostname/IP address for a remote audio server, or a filename in the"]
  #[doc = "  diskaudio driver."]
  #[doc = ""]
  #[doc = "  \\return 0 on error, a valid device ID that is >= 2 on success."]
  #[doc = ""]
  #[doc = "  SDL_OpenAudio(), unlike this function, always acts on device ID 1."]
  pub fn SDL_OpenAudioDevice(
    device: *const libc::c_char, iscapture: libc::c_int, desired: *const SDL_AudioSpec,
    obtained: *mut SDL_AudioSpec, allowed_changes: libc::c_int,
  ) -> SDL_AudioDeviceID;
}
pub mod SDL_AudioStatus {
  pub type Type = i32;
  pub const SDL_AUDIO_STOPPED: Type = 0;
  pub const SDL_AUDIO_PLAYING: Type = 1;
  pub const SDL_AUDIO_PAUSED: Type = 2;
}
extern "C" {
  pub fn SDL_GetAudioStatus() -> SDL_AudioStatus::Type;
}
extern "C" {
  pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus::Type;
}
extern "C" {
  pub fn SDL_PauseAudio(pause_on: libc::c_int);
}
extern "C" {
  pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: libc::c_int);
}
extern "C" {
  #[doc = "  This function loads a WAVE from the data source, automatically freeing"]
  #[doc = "  that source if \\c freesrc is non-zero.  For example, to load a WAVE file,"]
  #[doc = "  you could do:"]
  #[doc = "  \\code"]
  #[doc = "      SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, ...);"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  If this function succeeds, it returns the given SDL_AudioSpec,"]
  #[doc = "  filled with the audio data format of the wave data, and sets"]
  #[doc = "  \\c *audio_buf to a malloc()\'d buffer containing the audio data,"]
  #[doc = "  and sets \\c *audio_len to the length of that audio buffer, in bytes."]
  #[doc = "  You need to free the audio buffer with SDL_FreeWAV() when you are"]
  #[doc = "  done with it."]
  #[doc = ""]
  #[doc = "  This function returns NULL and sets the SDL error message if the"]
  #[doc = "  wave file cannot be opened, uses an unknown data format, or is"]
  #[doc = "  corrupt.  Currently raw and MS-ADPCM WAVE files are supported."]
  pub fn SDL_LoadWAV_RW(
    src: *mut SDL_RWops, freesrc: libc::c_int, spec: *mut SDL_AudioSpec,
    audio_buf: *mut *mut Uint8, audio_len: *mut Uint32,
  ) -> *mut SDL_AudioSpec;
}
extern "C" {
  #[doc = "  This function frees data previously allocated with SDL_LoadWAV_RW()"]
  pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
  #[doc = "  This function takes a source format and rate and a destination format"]
  #[doc = "  and rate, and initializes the \\c cvt structure with information needed"]
  #[doc = "  by SDL_ConvertAudio() to convert a buffer of audio data from one format"]
  #[doc = "  to the other. An unsupported format causes an error and -1 will be returned."]
  #[doc = ""]
  #[doc = "  \\return 0 if no conversion is needed, 1 if the audio filter is set up,"]
  #[doc = "  or -1 on error."]
  pub fn SDL_BuildAudioCVT(
    cvt: *mut SDL_AudioCVT, src_format: SDL_AudioFormat, src_channels: Uint8,
    src_rate: libc::c_int, dst_format: SDL_AudioFormat, dst_channels: Uint8, dst_rate: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Once you have initialized the \\c cvt structure using SDL_BuildAudioCVT(),"]
  #[doc = "  created an audio buffer \\c cvt->buf, and filled it with \\c cvt->len bytes of"]
  #[doc = "  audio data in the source format, this function will convert it in-place"]
  #[doc = "  to the desired format."]
  #[doc = ""]
  #[doc = "  The data conversion may expand the size of the audio data, so the buffer"]
  #[doc = "  \\c cvt->buf should be allocated after the \\c cvt structure is initialized by"]
  #[doc = "  SDL_BuildAudioCVT(), and should be \\c cvt->len*cvt->len_mult bytes long."]
  #[doc = ""]
  #[doc = "  \\return 0 on success or -1 if \\c cvt->buf is NULL."]
  pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_AudioStream {
  _unused: [u8; 0],
}
pub type SDL_AudioStream = _SDL_AudioStream;
extern "C" {
  #[doc = "  Create a new audio stream"]
  #[doc = ""]
  #[doc = "  \\param src_format The format of the source audio"]
  #[doc = "  \\param src_channels The number of channels of the source audio"]
  #[doc = "  \\param src_rate The sampling rate of the source audio"]
  #[doc = "  \\param dst_format The format of the desired audio output"]
  #[doc = "  \\param dst_channels The number of channels of the desired audio output"]
  #[doc = "  \\param dst_rate The sampling rate of the desired audio output"]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  pub fn SDL_NewAudioStream(
    src_format: SDL_AudioFormat, src_channels: Uint8, src_rate: libc::c_int,
    dst_format: SDL_AudioFormat, dst_channels: Uint8, dst_rate: libc::c_int,
  ) -> *mut SDL_AudioStream;
}
extern "C" {
  #[doc = "  Add data to be converted/resampled to the stream"]
  #[doc = ""]
  #[doc = "  \\param stream The stream the audio data is being added to"]
  #[doc = "  \\param buf A pointer to the audio data to add"]
  #[doc = "  \\param len The number of bytes to write to the stream"]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  pub fn SDL_AudioStreamPut(
    stream: *mut SDL_AudioStream, buf: *const libc::c_void, len: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get converted/resampled data from the stream"]
  #[doc = ""]
  #[doc = "  \\param stream The stream the audio is being requested from"]
  #[doc = "  \\param buf A buffer to fill with audio data"]
  #[doc = "  \\param len The maximum number of bytes to fill"]
  #[doc = "  \\return The number of bytes read from the stream, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  pub fn SDL_AudioStreamGet(
    stream: *mut SDL_AudioStream, buf: *mut libc::c_void, len: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = " Get the number of converted/resampled bytes available. The stream may be"]
  #[doc = "  buffering data behind the scenes until it has enough to resample"]
  #[doc = "  correctly, so this number might be lower than what you expect, or even"]
  #[doc = "  be zero. Add more data or flush the stream if you need the data now."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  pub fn SDL_AudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
  #[doc = " Tell the stream that you\'re done sending data, and anything being buffered"]
  #[doc = "  should be converted/resampled and made available immediately."]
  #[doc = ""]
  #[doc = " It is legal to add more data to a stream after flushing, but there will"]
  #[doc = "  be audio gaps in the output. Generally this is intended to signal the"]
  #[doc = "  end of input, so the complete output becomes available."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  pub fn SDL_AudioStreamFlush(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
  #[doc = "  Clear any pending data in the stream without converting it"]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_FreeAudioStream"]
  pub fn SDL_AudioStreamClear(stream: *mut SDL_AudioStream);
}
extern "C" {
  #[doc = " Free an audio stream"]
  #[doc = ""]
  #[doc = "  \\sa SDL_NewAudioStream"]
  #[doc = "  \\sa SDL_AudioStreamPut"]
  #[doc = "  \\sa SDL_AudioStreamGet"]
  #[doc = "  \\sa SDL_AudioStreamAvailable"]
  #[doc = "  \\sa SDL_AudioStreamFlush"]
  #[doc = "  \\sa SDL_AudioStreamClear"]
  pub fn SDL_FreeAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
  #[doc = "  This takes two audio buffers of the playing audio format and mixes"]
  #[doc = "  them, performing addition, volume adjustment, and overflow clipping."]
  #[doc = "  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME"]
  #[doc = "  for full audio volume.  Note this does not change hardware volume."]
  #[doc = "  This is provided for convenience -- you can mix your own audio data."]
  pub fn SDL_MixAudio(dst: *mut Uint8, src: *const Uint8, len: Uint32, volume: libc::c_int);
}
extern "C" {
  #[doc = "  This works like SDL_MixAudio(), but you specify the audio format instead of"]
  #[doc = "  using the format of audio device 1. Thus it can be used when no audio"]
  #[doc = "  device is open at all."]
  pub fn SDL_MixAudioFormat(
    dst: *mut Uint8, src: *const Uint8, format: SDL_AudioFormat, len: Uint32, volume: libc::c_int,
  );
}
extern "C" {
  #[doc = "  Queue more audio on non-callback devices."]
  #[doc = ""]
  #[doc = "  (If you are looking to retrieve queued audio from a non-callback capture"]
  #[doc = "  device, you want SDL_DequeueAudio() instead. This will return -1 to"]
  #[doc = "  signify an error if you use it with capture devices.)"]
  #[doc = ""]
  #[doc = "  SDL offers two ways to feed audio to the device: you can either supply a"]
  #[doc = "  callback that SDL triggers with some frequency to obtain more audio"]
  #[doc = "  (pull method), or you can supply no callback, and then SDL will expect"]
  #[doc = "  you to supply data at regular intervals (push method) with this function."]
  #[doc = ""]
  #[doc = "  There are no limits on the amount of data you can queue, short of"]
  #[doc = "  exhaustion of address space. Queued data will drain to the device as"]
  #[doc = "  necessary without further intervention from you. If the device needs"]
  #[doc = "  audio but there is not enough queued, it will play silence to make up"]
  #[doc = "  the difference. This means you will have skips in your audio playback"]
  #[doc = "  if you aren\'t routinely queueing sufficient data."]
  #[doc = ""]
  #[doc = "  This function copies the supplied data, so you are safe to free it when"]
  #[doc = "  the function returns. This function is thread-safe, but queueing to the"]
  #[doc = "  same device from two threads at once does not promise which buffer will"]
  #[doc = "  be queued first."]
  #[doc = ""]
  #[doc = "  You may not queue audio on a device that is using an application-supplied"]
  #[doc = "  callback; doing so returns an error. You have to use the audio callback"]
  #[doc = "  or queue audio with this function, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before queueing; SDL"]
  #[doc = "  handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID to which we will queue audio."]
  #[doc = "  \\param data The data to queue to the device for later playback."]
  #[doc = "  \\param len The number of bytes (not samples!) to which (data) points."]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetQueuedAudioSize"]
  #[doc = "  \\sa SDL_ClearQueuedAudio"]
  pub fn SDL_QueueAudio(
    dev: SDL_AudioDeviceID, data: *const libc::c_void, len: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Dequeue more audio on non-callback devices."]
  #[doc = ""]
  #[doc = "  (If you are looking to queue audio for output on a non-callback playback"]
  #[doc = "  device, you want SDL_QueueAudio() instead. This will always return 0"]
  #[doc = "  if you use it with playback devices.)"]
  #[doc = ""]
  #[doc = "  SDL offers two ways to retrieve audio from a capture device: you can"]
  #[doc = "  either supply a callback that SDL triggers with some frequency as the"]
  #[doc = "  device records more audio data, (push method), or you can supply no"]
  #[doc = "  callback, and then SDL will expect you to retrieve data at regular"]
  #[doc = "  intervals (pull method) with this function."]
  #[doc = ""]
  #[doc = "  There are no limits on the amount of data you can queue, short of"]
  #[doc = "  exhaustion of address space. Data from the device will keep queuing as"]
  #[doc = "  necessary without further intervention from you. This means you will"]
  #[doc = "  eventually run out of memory if you aren\'t routinely dequeueing data."]
  #[doc = ""]
  #[doc = "  Capture devices will not queue data when paused; if you are expecting"]
  #[doc = "  to not need captured audio for some length of time, use"]
  #[doc = "  SDL_PauseAudioDevice() to stop the capture device from queueing more"]
  #[doc = "  data. This can be useful during, say, level loading times. When"]
  #[doc = "  unpaused, capture devices will start queueing data from that point,"]
  #[doc = "  having flushed any capturable data available while paused."]
  #[doc = ""]
  #[doc = "  This function is thread-safe, but dequeueing from the same device from"]
  #[doc = "  two threads at once does not promise which thread will dequeued data"]
  #[doc = "  first."]
  #[doc = ""]
  #[doc = "  You may not dequeue audio from a device that is using an"]
  #[doc = "  application-supplied callback; doing so returns an error. You have to use"]
  #[doc = "  the audio callback, or dequeue audio with this function, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before queueing; SDL"]
  #[doc = "  handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID from which we will dequeue audio."]
  #[doc = "  \\param data A pointer into where audio data should be copied."]
  #[doc = "  \\param len The number of bytes (not samples!) to which (data) points."]
  #[doc = "  \\return number of bytes dequeued, which could be less than requested."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetQueuedAudioSize"]
  #[doc = "  \\sa SDL_ClearQueuedAudio"]
  pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID, data: *mut libc::c_void, len: Uint32) -> Uint32;
}
extern "C" {
  #[doc = "  Get the number of bytes of still-queued audio."]
  #[doc = ""]
  #[doc = "  For playback device:"]
  #[doc = ""]
  #[doc = "    This is the number of bytes that have been queued for playback with"]
  #[doc = "    SDL_QueueAudio(), but have not yet been sent to the hardware. This"]
  #[doc = "    number may shrink at any time, so this only informs of pending data."]
  #[doc = ""]
  #[doc = "    Once we\'ve sent it to the hardware, this function can not decide the"]
  #[doc = "    exact byte boundary of what has been played. It\'s possible that we just"]
  #[doc = "    gave the hardware several kilobytes right before you called this"]
  #[doc = "    function, but it hasn\'t played any of it yet, or maybe half of it, etc."]
  #[doc = ""]
  #[doc = "  For capture devices:"]
  #[doc = ""]
  #[doc = "    This is the number of bytes that have been captured by the device and"]
  #[doc = "    are waiting for you to dequeue. This number may grow at any time, so"]
  #[doc = "    this only informs of the lower-bound of available data."]
  #[doc = ""]
  #[doc = "  You may not queue audio on a device that is using an application-supplied"]
  #[doc = "  callback; calling this function on such a device always returns 0."]
  #[doc = "  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use"]
  #[doc = "  the audio callback, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before querying; SDL"]
  #[doc = "  handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID of which we will query queued audio size."]
  #[doc = "  \\return Number of bytes (not samples!) of queued audio."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueueAudio"]
  #[doc = "  \\sa SDL_ClearQueuedAudio"]
  pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
  #[doc = "  Drop any queued audio data. For playback devices, this is any queued data"]
  #[doc = "  still waiting to be submitted to the hardware. For capture devices, this"]
  #[doc = "  is any data that was queued by the device that hasn\'t yet been dequeued by"]
  #[doc = "  the application."]
  #[doc = ""]
  #[doc = "  Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For"]
  #[doc = "  playback devices, the hardware will start playing silence if more audio"]
  #[doc = "  isn\'t queued. Unpaused capture devices will start filling the queue again"]
  #[doc = "  as soon as they have more data available (which, depending on the state"]
  #[doc = "  of the hardware and the thread, could be before this function call"]
  #[doc = "  returns!)."]
  #[doc = ""]
  #[doc = "  This will not prevent playback of queued audio that\'s already been sent"]
  #[doc = "  to the hardware, as we can not undo that, so expect there to be some"]
  #[doc = "  fraction of a second of audio that might still be heard. This can be"]
  #[doc = "  useful if you want to, say, drop any pending music during a level change"]
  #[doc = "  in your game."]
  #[doc = ""]
  #[doc = "  You may not queue audio on a device that is using an application-supplied"]
  #[doc = "  callback; calling this function on such a device is always a no-op."]
  #[doc = "  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use"]
  #[doc = "  the audio callback, but not both."]
  #[doc = ""]
  #[doc = "  You should not call SDL_LockAudio() on the device before clearing the"]
  #[doc = "  queue; SDL handles locking internally for this function."]
  #[doc = ""]
  #[doc = "  This function always succeeds and thus returns void."]
  #[doc = ""]
  #[doc = "  \\param dev The device ID of which to clear the audio queue."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueueAudio"]
  #[doc = "  \\sa SDL_GetQueuedAudioSize"]
  pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
  pub fn SDL_LockAudio();
}
extern "C" {
  pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  pub fn SDL_UnlockAudio();
}
extern "C" {
  pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  #[doc = "  This function shuts down audio processing and closes the audio device."]
  pub fn SDL_CloseAudio();
}
extern "C" {
  pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
  #[doc = " \\brief Put UTF-8 text into the clipboard"]
  #[doc = ""]
  #[doc = " \\sa SDL_GetClipboardText()"]
  pub fn SDL_SetClipboardText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()"]
  #[doc = ""]
  #[doc = " \\sa SDL_SetClipboardText()"]
  pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
extern "C" {
  #[doc = " \\brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty"]
  #[doc = ""]
  #[doc = " \\sa SDL_GetClipboardText()"]
  pub fn SDL_HasClipboardText() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns the number of CPU cores available."]
  pub fn SDL_GetCPUCount() -> libc::c_int;
}
extern "C" {
  #[doc = "  This function returns the L1 cache line size of the CPU"]
  #[doc = ""]
  #[doc = "  This is useful for determining multi-threaded structure padding"]
  #[doc = "  or SIMD prefetch sizes."]
  pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has the RDTSC instruction."]
  pub fn SDL_HasRDTSC() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AltiVec features."]
  pub fn SDL_HasAltiVec() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has MMX features."]
  pub fn SDL_HasMMX() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has 3DNow! features."]
  pub fn SDL_Has3DNow() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE features."]
  pub fn SDL_HasSSE() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE2 features."]
  pub fn SDL_HasSSE2() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE3 features."]
  pub fn SDL_HasSSE3() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE4.1 features."]
  pub fn SDL_HasSSE41() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has SSE4.2 features."]
  pub fn SDL_HasSSE42() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AVX features."]
  pub fn SDL_HasAVX() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AVX2 features."]
  pub fn SDL_HasAVX2() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has AVX-512F (foundation) features."]
  pub fn SDL_HasAVX512F() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns true if the CPU has NEON (ARM SIMD) features."]
  pub fn SDL_HasNEON() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function returns the amount of RAM configured in the system, in MB."]
  pub fn SDL_GetSystemRAM() -> libc::c_int;
}
pub mod _bindgen_ty_1 {
  #[doc = " Pixel type."]
  pub type Type = i32;
  pub const SDL_PIXELTYPE_UNKNOWN: Type = 0;
  pub const SDL_PIXELTYPE_INDEX1: Type = 1;
  pub const SDL_PIXELTYPE_INDEX4: Type = 2;
  pub const SDL_PIXELTYPE_INDEX8: Type = 3;
  pub const SDL_PIXELTYPE_PACKED8: Type = 4;
  pub const SDL_PIXELTYPE_PACKED16: Type = 5;
  pub const SDL_PIXELTYPE_PACKED32: Type = 6;
  pub const SDL_PIXELTYPE_ARRAYU8: Type = 7;
  pub const SDL_PIXELTYPE_ARRAYU16: Type = 8;
  pub const SDL_PIXELTYPE_ARRAYU32: Type = 9;
  pub const SDL_PIXELTYPE_ARRAYF16: Type = 10;
  pub const SDL_PIXELTYPE_ARRAYF32: Type = 11;
}
pub mod _bindgen_ty_2 {
  #[doc = " Bitmap pixel order, high bit -> low bit."]
  pub type Type = i32;
  pub const SDL_BITMAPORDER_NONE: Type = 0;
  pub const SDL_BITMAPORDER_4321: Type = 1;
  pub const SDL_BITMAPORDER_1234: Type = 2;
}
pub mod _bindgen_ty_3 {
  #[doc = " Packed component order, high bit -> low bit."]
  pub type Type = i32;
  pub const SDL_PACKEDORDER_NONE: Type = 0;
  pub const SDL_PACKEDORDER_XRGB: Type = 1;
  pub const SDL_PACKEDORDER_RGBX: Type = 2;
  pub const SDL_PACKEDORDER_ARGB: Type = 3;
  pub const SDL_PACKEDORDER_RGBA: Type = 4;
  pub const SDL_PACKEDORDER_XBGR: Type = 5;
  pub const SDL_PACKEDORDER_BGRX: Type = 6;
  pub const SDL_PACKEDORDER_ABGR: Type = 7;
  pub const SDL_PACKEDORDER_BGRA: Type = 8;
}
pub mod _bindgen_ty_4 {
  #[doc = " Array component order, low byte -> high byte."]
  pub type Type = i32;
  pub const SDL_ARRAYORDER_NONE: Type = 0;
  pub const SDL_ARRAYORDER_RGB: Type = 1;
  pub const SDL_ARRAYORDER_RGBA: Type = 2;
  pub const SDL_ARRAYORDER_ARGB: Type = 3;
  pub const SDL_ARRAYORDER_BGR: Type = 4;
  pub const SDL_ARRAYORDER_BGRA: Type = 5;
  pub const SDL_ARRAYORDER_ABGR: Type = 6;
}
pub mod _bindgen_ty_5 {
  #[doc = " Packed component layout."]
  pub type Type = i32;
  pub const SDL_PACKEDLAYOUT_NONE: Type = 0;
  pub const SDL_PACKEDLAYOUT_332: Type = 1;
  pub const SDL_PACKEDLAYOUT_4444: Type = 2;
  pub const SDL_PACKEDLAYOUT_1555: Type = 3;
  pub const SDL_PACKEDLAYOUT_5551: Type = 4;
  pub const SDL_PACKEDLAYOUT_565: Type = 5;
  pub const SDL_PACKEDLAYOUT_8888: Type = 6;
  pub const SDL_PACKEDLAYOUT_2101010: Type = 7;
  pub const SDL_PACKEDLAYOUT_1010102: Type = 8;
}
pub mod _bindgen_ty_6 {
  pub type Type = i32;
  pub const SDL_PIXELFORMAT_UNKNOWN: Type = 0;
  pub const SDL_PIXELFORMAT_INDEX1LSB: Type = 286261504;
  pub const SDL_PIXELFORMAT_INDEX1MSB: Type = 287310080;
  pub const SDL_PIXELFORMAT_INDEX4LSB: Type = 303039488;
  pub const SDL_PIXELFORMAT_INDEX4MSB: Type = 304088064;
  pub const SDL_PIXELFORMAT_INDEX8: Type = 318769153;
  pub const SDL_PIXELFORMAT_RGB332: Type = 336660481;
  pub const SDL_PIXELFORMAT_RGB444: Type = 353504258;
  pub const SDL_PIXELFORMAT_RGB555: Type = 353570562;
  pub const SDL_PIXELFORMAT_BGR555: Type = 357764866;
  pub const SDL_PIXELFORMAT_ARGB4444: Type = 355602434;
  pub const SDL_PIXELFORMAT_RGBA4444: Type = 356651010;
  pub const SDL_PIXELFORMAT_ABGR4444: Type = 359796738;
  pub const SDL_PIXELFORMAT_BGRA4444: Type = 360845314;
  pub const SDL_PIXELFORMAT_ARGB1555: Type = 355667970;
  pub const SDL_PIXELFORMAT_RGBA5551: Type = 356782082;
  pub const SDL_PIXELFORMAT_ABGR1555: Type = 359862274;
  pub const SDL_PIXELFORMAT_BGRA5551: Type = 360976386;
  pub const SDL_PIXELFORMAT_RGB565: Type = 353701890;
  pub const SDL_PIXELFORMAT_BGR565: Type = 357896194;
  pub const SDL_PIXELFORMAT_RGB24: Type = 386930691;
  pub const SDL_PIXELFORMAT_BGR24: Type = 390076419;
  pub const SDL_PIXELFORMAT_RGB888: Type = 370546692;
  pub const SDL_PIXELFORMAT_RGBX8888: Type = 371595268;
  pub const SDL_PIXELFORMAT_BGR888: Type = 374740996;
  pub const SDL_PIXELFORMAT_BGRX8888: Type = 375789572;
  pub const SDL_PIXELFORMAT_ARGB8888: Type = 372645892;
  pub const SDL_PIXELFORMAT_RGBA8888: Type = 373694468;
  pub const SDL_PIXELFORMAT_ABGR8888: Type = 376840196;
  pub const SDL_PIXELFORMAT_BGRA8888: Type = 377888772;
  pub const SDL_PIXELFORMAT_ARGB2101010: Type = 372711428;
  pub const SDL_PIXELFORMAT_RGBA32: Type = 376840196;
  pub const SDL_PIXELFORMAT_ARGB32: Type = 377888772;
  pub const SDL_PIXELFORMAT_BGRA32: Type = 372645892;
  pub const SDL_PIXELFORMAT_ABGR32: Type = 373694468;
  #[doc = "< Planar mode: Y + V + U  (3 planes)"]
  pub const SDL_PIXELFORMAT_YV12: Type = 842094169;
  #[doc = "< Planar mode: Y + U + V  (3 planes)"]
  pub const SDL_PIXELFORMAT_IYUV: Type = 1448433993;
  #[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
  pub const SDL_PIXELFORMAT_YUY2: Type = 844715353;
  #[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
  pub const SDL_PIXELFORMAT_UYVY: Type = 1498831189;
  #[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
  pub const SDL_PIXELFORMAT_YVYU: Type = 1431918169;
  #[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
  pub const SDL_PIXELFORMAT_NV12: Type = 842094158;
  #[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
  pub const SDL_PIXELFORMAT_NV21: Type = 825382478;
  #[doc = "< Android video texture format"]
  pub const SDL_PIXELFORMAT_EXTERNAL_OES: Type = 542328143;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Color {
  pub r: Uint8,
  pub g: Uint8,
  pub b: Uint8,
  pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Color>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_Color))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Color>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_Color))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(b)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Color>())).a as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Color),
      "::",
      stringify!(a)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Palette {
  pub ncolors: libc::c_int,
  pub colors: *mut SDL_Color,
  pub version: Uint32,
  pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Palette>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_Palette))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Palette>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Palette))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).ncolors as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(ncolors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).colors as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(colors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).version as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Palette>())).refcount as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Palette),
      "::",
      stringify!(refcount)
    )
  );
}
impl Default for SDL_Palette {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\note Everything in the pixel format structure is read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_PixelFormat {
  pub format: Uint32,
  pub palette: *mut SDL_Palette,
  pub BitsPerPixel: Uint8,
  pub BytesPerPixel: Uint8,
  pub padding: [Uint8; 2usize],
  pub Rmask: Uint32,
  pub Gmask: Uint32,
  pub Bmask: Uint32,
  pub Amask: Uint32,
  pub Rloss: Uint8,
  pub Gloss: Uint8,
  pub Bloss: Uint8,
  pub Aloss: Uint8,
  pub Rshift: Uint8,
  pub Gshift: Uint8,
  pub Bshift: Uint8,
  pub Ashift: Uint8,
  pub refcount: libc::c_int,
  pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
  assert_eq!(
    ::core::mem::size_of::<SDL_PixelFormat>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_PixelFormat))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_PixelFormat>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_PixelFormat))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).format as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).palette as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(palette)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BitsPerPixel as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(BitsPerPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BytesPerPixel as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(BytesPerPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).padding as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rmask as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gmask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bmask as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bmask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Amask as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Amask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rloss as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gloss as *const _ as usize },
    37usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bloss as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Aloss as *const _ as usize },
    39usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Aloss)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rshift as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Rshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gshift as *const _ as usize },
    41usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Gshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bshift as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Bshift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Ashift as *const _ as usize },
    43usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(Ashift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).refcount as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_PixelFormat),
      "::",
      stringify!(next)
    )
  );
}
impl Default for SDL_PixelFormat {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[doc = " \\brief Get the human readable name of a pixel format"]
  pub fn SDL_GetPixelFormatName(format: Uint32) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Convert one of the enumerated pixel formats to a bpp and RGBA masks."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE, or SDL_FALSE if the conversion wasn\'t possible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MasksToPixelFormatEnum()"]
  pub fn SDL_PixelFormatEnumToMasks(
    format: Uint32, bpp: *mut libc::c_int, Rmask: *mut Uint32, Gmask: *mut Uint32,
    Bmask: *mut Uint32, Amask: *mut Uint32,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Convert a bpp and RGBA masks to an enumerated pixel format."]
  #[doc = ""]
  #[doc = "  \\return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion"]
  #[doc = "          wasn\'t possible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_PixelFormatEnumToMasks()"]
  pub fn SDL_MasksToPixelFormatEnum(
    bpp: libc::c_int, Rmask: Uint32, Gmask: Uint32, Bmask: Uint32, Amask: Uint32,
  ) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Create an SDL_PixelFormat structure from a pixel format enum."]
  pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
  #[doc = "  \\brief Free an SDL_PixelFormat structure."]
  pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
  #[doc = "  \\brief Create a palette structure with the specified number of color"]
  #[doc = "         entries."]
  #[doc = ""]
  #[doc = "  \\return A new palette, or NULL if there wasn\'t enough memory."]
  #[doc = ""]
  #[doc = "  \\note The palette entries are initialized to white."]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreePalette()"]
  pub fn SDL_AllocPalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
extern "C" {
  #[doc = "  \\brief Set the palette for a pixel format structure."]
  pub fn SDL_SetPixelFormatPalette(
    format: *mut SDL_PixelFormat, palette: *mut SDL_Palette,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set a range of colors in a palette."]
  #[doc = ""]
  #[doc = "  \\param palette    The palette to modify."]
  #[doc = "  \\param colors     An array of colors to copy into the palette."]
  #[doc = "  \\param firstcolor The index of the first palette entry to modify."]
  #[doc = "  \\param ncolors    The number of entries to modify."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if not all of the colors could be set."]
  pub fn SDL_SetPaletteColors(
    palette: *mut SDL_Palette, colors: *const SDL_Color, firstcolor: libc::c_int,
    ncolors: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Free a palette created with SDL_AllocPalette()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_AllocPalette()"]
  pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
  #[doc = "  \\brief Maps an RGB triple to an opaque pixel value for a given pixel format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MapRGBA"]
  pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Maps an RGBA quadruple to a pixel value for a given pixel format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MapRGB"]
  pub fn SDL_MapRGBA(
    format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8, a: Uint8,
  ) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Get the RGB components from a pixel of the specified format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRGBA"]
  pub fn SDL_GetRGB(
    pixel: Uint32, format: *const SDL_PixelFormat, r: *mut Uint8, g: *mut Uint8, b: *mut Uint8,
  );
}
extern "C" {
  #[doc = "  \\brief Get the RGBA components from a pixel of the specified format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRGB"]
  pub fn SDL_GetRGBA(
    pixel: Uint32, format: *const SDL_PixelFormat, r: *mut Uint8, g: *mut Uint8, b: *mut Uint8,
    a: *mut Uint8,
  );
}
extern "C" {
  #[doc = "  \\brief Calculate a 256 entry gamma ramp for a gamma value."]
  pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
#[doc = "  \\brief  The structure that defines a point"]
#[doc = ""]
#[doc = "  \\sa SDL_EnclosePoints"]
#[doc = "  \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Point {
  pub x: libc::c_int,
  pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Point>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_Point))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Point>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Point))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Point>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Point),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Point>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Point),
      "::",
      stringify!(y)
    )
  );
}
#[doc = "  \\brief A rectangle, with the origin at the upper left."]
#[doc = ""]
#[doc = "  \\sa SDL_RectEmpty"]
#[doc = "  \\sa SDL_RectEquals"]
#[doc = "  \\sa SDL_HasIntersection"]
#[doc = "  \\sa SDL_IntersectRect"]
#[doc = "  \\sa SDL_UnionRect"]
#[doc = "  \\sa SDL_EnclosePoints"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Rect {
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub w: libc::c_int,
  pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Rect>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Rect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Rect>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Rect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).w as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Rect>())).h as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Rect),
      "::",
      stringify!(h)
    )
  );
}
extern "C" {
  #[doc = "  \\brief Determine whether two rectangles intersect."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
  pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Calculate the intersection of two rectangles."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
  pub fn SDL_IntersectRect(
    A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Calculate the union of two rectangles."]
  pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Calculate a minimal rectangle enclosing a set of points"]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if any points were within the clipping rect"]
  pub fn SDL_EnclosePoints(
    points: *const SDL_Point, count: libc::c_int, clip: *const SDL_Rect, result: *mut SDL_Rect,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Calculate the intersection of a rectangle and line segment."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
  pub fn SDL_IntersectRectAndLine(
    rect: *const SDL_Rect, X1: *mut libc::c_int, Y1: *mut libc::c_int, X2: *mut libc::c_int,
    Y2: *mut libc::c_int,
  ) -> SDL_bool::Type;
}
pub mod SDL_BlendMode {
  #[doc = "  \\brief The blend mode used in SDL_RenderCopy() and drawing operations."]
  pub type Type = i32;
  #[doc = "< no blending"]
  #[doc = "dstRGBA = srcRGBA"]
  pub const SDL_BLENDMODE_NONE: Type = 0;
  #[doc = "< alpha blending"]
  #[doc = "dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))"]
  #[doc = "dstA = srcA + (dstA * (1-srcA))"]
  pub const SDL_BLENDMODE_BLEND: Type = 1;
  #[doc = "< additive blending"]
  #[doc = "dstRGB = (srcRGB * srcA) + dstRGB"]
  #[doc = "dstA = dstA"]
  pub const SDL_BLENDMODE_ADD: Type = 2;
  #[doc = "< color modulate"]
  #[doc = "dstRGB = srcRGB * dstRGB"]
  #[doc = "dstA = dstA"]
  pub const SDL_BLENDMODE_MOD: Type = 4;
  pub const SDL_BLENDMODE_INVALID: Type = 2147483647;
}
pub mod SDL_BlendOperation {
  #[doc = "  \\brief The blend operation used when combining source and destination pixel components"]
  pub type Type = i32;
  #[doc = "< dst + src: supported by all renderers"]
  pub const SDL_BLENDOPERATION_ADD: Type = 1;
  #[doc = "< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES"]
  pub const SDL_BLENDOPERATION_SUBTRACT: Type = 2;
  #[doc = "< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES"]
  pub const SDL_BLENDOPERATION_REV_SUBTRACT: Type = 3;
  #[doc = "< min(dst, src) : supported by D3D11"]
  pub const SDL_BLENDOPERATION_MINIMUM: Type = 4;
  #[doc = "< max(dst, src) : supported by D3D11"]
  pub const SDL_BLENDOPERATION_MAXIMUM: Type = 5;
}
pub mod SDL_BlendFactor {
  #[doc = "  \\brief The normalized factor used to multiply pixel components"]
  pub type Type = i32;
  #[doc = "< 0, 0, 0, 0"]
  pub const SDL_BLENDFACTOR_ZERO: Type = 1;
  #[doc = "< 1, 1, 1, 1"]
  pub const SDL_BLENDFACTOR_ONE: Type = 2;
  #[doc = "< srcR, srcG, srcB, srcA"]
  pub const SDL_BLENDFACTOR_SRC_COLOR: Type = 3;
  #[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR: Type = 4;
  #[doc = "< srcA, srcA, srcA, srcA"]
  pub const SDL_BLENDFACTOR_SRC_ALPHA: Type = 5;
  #[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: Type = 6;
  #[doc = "< dstR, dstG, dstB, dstA"]
  pub const SDL_BLENDFACTOR_DST_COLOR: Type = 7;
  #[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR: Type = 8;
  #[doc = "< dstA, dstA, dstA, dstA"]
  pub const SDL_BLENDFACTOR_DST_ALPHA: Type = 9;
  #[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
  pub const SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA: Type = 10;
}
extern "C" {
  #[doc = "  \\brief Create a custom blend mode, which may or may not be supported by a given renderer"]
  #[doc = ""]
  #[doc = "  \\param srcColorFactor"]
  #[doc = "  \\param dstColorFactor"]
  #[doc = "  \\param colorOperation"]
  #[doc = "  \\param srcAlphaFactor"]
  #[doc = "  \\param dstAlphaFactor"]
  #[doc = "  \\param alphaOperation"]
  #[doc = ""]
  #[doc = "  The result of the blend mode operation will be:"]
  #[doc = "      dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor"]
  #[doc = "  and"]
  #[doc = "      dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor"]
  pub fn SDL_ComposeCustomBlendMode(
    srcColorFactor: SDL_BlendFactor::Type, dstColorFactor: SDL_BlendFactor::Type,
    colorOperation: SDL_BlendOperation::Type, srcAlphaFactor: SDL_BlendFactor::Type,
    dstAlphaFactor: SDL_BlendFactor::Type, alphaOperation: SDL_BlendOperation::Type,
  ) -> SDL_BlendMode::Type;
}
#[doc = " \\brief A collection of pixels used in software blitting."]
#[doc = ""]
#[doc = " \\note  This structure should be treated as read-only, except for \\c pixels,"]
#[doc = "        which, if not NULL, contains the raw pixel data for the surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Surface {
  #[doc = "< Read-only"]
  pub flags: Uint32,
  #[doc = "< Read-only"]
  pub format: *mut SDL_PixelFormat,
  #[doc = "< Read-only"]
  pub w: libc::c_int,
  #[doc = "< Read-only"]
  pub h: libc::c_int,
  #[doc = "< Read-only"]
  pub pitch: libc::c_int,
  #[doc = "< Read-write"]
  pub pixels: *mut libc::c_void,
  #[doc = "< Read-write"]
  pub userdata: *mut libc::c_void,
  #[doc = "< Read-only"]
  pub locked: libc::c_int,
  #[doc = "< Read-only"]
  pub lock_data: *mut libc::c_void,
  #[doc = "< Read-only"]
  pub clip_rect: SDL_Rect,
  #[doc = "< Private"]
  pub map: *mut SDL_BlitMap,
  #[doc = "< Read-mostly"]
  pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Surface>(),
    96usize,
    concat!("Size of: ", stringify!(SDL_Surface))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Surface>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Surface))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).format as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).w as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).h as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pitch as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(pitch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pixels as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(pixels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).userdata as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(userdata)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).locked as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(locked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).lock_data as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(lock_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).clip_rect as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(clip_rect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).map as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(map)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Surface>())).refcount as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Surface),
      "::",
      stringify!(refcount)
    )
  );
}
impl Default for SDL_Surface {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = " \\brief The type of function used for surface blitting functions."]
pub type SDL_blit = ::core::option::Option<
  unsafe extern "C" fn(
    src: *mut SDL_Surface,
    srcrect: *mut SDL_Rect,
    dst: *mut SDL_Surface,
    dstrect: *mut SDL_Rect,
  ) -> libc::c_int,
>;
pub mod SDL_YUV_CONVERSION_MODE {
  #[doc = " \\brief The formula used for converting between YUV and RGB"]
  pub type Type = i32;
  #[doc = "< Full range JPEG"]
  pub const SDL_YUV_CONVERSION_JPEG: Type = 0;
  #[doc = "< BT.601 (the default)"]
  pub const SDL_YUV_CONVERSION_BT601: Type = 1;
  #[doc = "< BT.709"]
  pub const SDL_YUV_CONVERSION_BT709: Type = 2;
  #[doc = "< BT.601 for SD content, BT.709 for HD content"]
  pub const SDL_YUV_CONVERSION_AUTOMATIC: Type = 3;
}
extern "C" {
  #[doc = "  Allocate and free an RGB surface."]
  #[doc = ""]
  #[doc = "  If the depth is 4 or 8 bits, an empty palette is allocated for the surface."]
  #[doc = "  If the depth is greater than 8 bits, the pixel format is set using the"]
  #[doc = "  flags \'[RGB]mask\'."]
  #[doc = ""]
  #[doc = "  If the function runs out of memory, it will return NULL."]
  #[doc = ""]
  #[doc = "  \\param flags The \\c flags are obsolete and should be set to 0."]
  #[doc = "  \\param width The width in pixels of the surface to create."]
  #[doc = "  \\param height The height in pixels of the surface to create."]
  #[doc = "  \\param depth The depth in bits of the surface to create."]
  #[doc = "  \\param Rmask The red mask of the surface to create."]
  #[doc = "  \\param Gmask The green mask of the surface to create."]
  #[doc = "  \\param Bmask The blue mask of the surface to create."]
  #[doc = "  \\param Amask The alpha mask of the surface to create."]
  pub fn SDL_CreateRGBSurface(
    flags: Uint32, width: libc::c_int, height: libc::c_int, depth: libc::c_int, Rmask: Uint32,
    Gmask: Uint32, Bmask: Uint32, Amask: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_CreateRGBSurfaceWithFormat(
    flags: Uint32, width: libc::c_int, height: libc::c_int, depth: libc::c_int, format: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_CreateRGBSurfaceFrom(
    pixels: *mut libc::c_void, width: libc::c_int, height: libc::c_int, depth: libc::c_int,
    pitch: libc::c_int, Rmask: Uint32, Gmask: Uint32, Bmask: Uint32, Amask: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_CreateRGBSurfaceWithFormatFrom(
    pixels: *mut libc::c_void, width: libc::c_int, height: libc::c_int, depth: libc::c_int,
    pitch: libc::c_int, format: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
  #[doc = "  \\brief Set the palette used by a surface."]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if the surface format doesn\'t use a palette."]
  #[doc = ""]
  #[doc = "  \\note A single palette can be shared with many surfaces."]
  pub fn SDL_SetSurfacePalette(surface: *mut SDL_Surface, palette: *mut SDL_Palette)
    -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets up a surface for directly accessing the pixels."]
  #[doc = ""]
  #[doc = "  Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write"]
  #[doc = "  to and read from \\c surface->pixels, using the pixel format stored in"]
  #[doc = "  \\c surface->format.  Once you are done accessing the surface, you should"]
  #[doc = "  use SDL_UnlockSurface() to release it."]
  #[doc = ""]
  #[doc = "  Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates"]
  #[doc = "  to 0, then you can read and write to the surface at any time, and the"]
  #[doc = "  pixel format of the surface will not change."]
  #[doc = ""]
  #[doc = "  No operating system or library calls should be made between lock/unlock"]
  #[doc = "  pairs, as critical system locks may be held during this time."]
  #[doc = ""]
  #[doc = "  SDL_LockSurface() returns 0, or -1 if the surface couldn\'t be locked."]
  #[doc = ""]
  #[doc = "  \\sa SDL_UnlockSurface()"]
  pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
  #[doc = " \\sa SDL_LockSurface()"]
  pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
  #[doc = "  Load a surface from a seekable SDL data stream (memory or file)."]
  #[doc = ""]
  #[doc = "  If \\c freesrc is non-zero, the stream will be closed after being read."]
  #[doc = ""]
  #[doc = "  The new surface should be freed with SDL_FreeSurface()."]
  #[doc = ""]
  #[doc = "  \\return the new surface, or NULL if there was an error."]
  pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: libc::c_int) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = "  Save a surface to a seekable SDL data stream (memory or file)."]
  #[doc = ""]
  #[doc = "  Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the"]
  #[doc = "  BMP directly. Other RGB formats with 8-bit or higher get converted to a"]
  #[doc = "  24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit"]
  #[doc = "  surface before they are saved. YUV and paletted 1-bit and 4-bit formats are"]
  #[doc = "  not supported."]
  #[doc = ""]
  #[doc = "  If \\c freedst is non-zero, the stream will be closed after being written."]
  #[doc = ""]
  #[doc = "  \\return 0 if successful or -1 if there was an error."]
  pub fn SDL_SaveBMP_RW(
    surface: *mut SDL_Surface, dst: *mut SDL_RWops, freedst: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the RLE acceleration hint for a surface."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid"]
  #[doc = ""]
  #[doc = "  \\note If RLE is enabled, colorkey and alpha blending blits are much faster,"]
  #[doc = "        but the surface must be locked before directly accessing the pixels."]
  pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, flag: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the color key (transparent pixel) in a blittable surface."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update"]
  #[doc = "  \\param flag Non-zero to enable colorkey and 0 to disable colorkey"]
  #[doc = "  \\param key The transparent pixel in the native surface format"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid"]
  #[doc = ""]
  #[doc = "  You can pass SDL_RLEACCEL to enable RLE accelerated blits."]
  pub fn SDL_SetColorKey(surface: *mut SDL_Surface, flag: libc::c_int, key: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Returns whether the surface has a color key"]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key"]
  pub fn SDL_HasColorKey(surface: *mut SDL_Surface) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Gets the color key (transparent pixel) in a blittable surface."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update"]
  #[doc = "  \\param key A pointer filled in with the transparent pixel in the native"]
  #[doc = "             surface format"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid or colorkey is not"]
  #[doc = "          enabled."]
  pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional color value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update."]
  #[doc = "  \\param r The red color value multiplied into blit operations."]
  #[doc = "  \\param g The green color value multiplied into blit operations."]
  #[doc = "  \\param b The blue color value multiplied into blit operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetSurfaceColorMod()"]
  pub fn SDL_SetSurfaceColorMod(
    surface: *mut SDL_Surface, r: Uint8, g: Uint8, b: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional color value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to query."]
  #[doc = "  \\param r A pointer filled in with the current red color value."]
  #[doc = "  \\param g A pointer filled in with the current green color value."]
  #[doc = "  \\param b A pointer filled in with the current blue color value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetSurfaceColorMod()"]
  pub fn SDL_GetSurfaceColorMod(
    surface: *mut SDL_Surface, r: *mut Uint8, g: *mut Uint8, b: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional alpha value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update."]
  #[doc = "  \\param alpha The alpha value multiplied into blit operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetSurfaceAlphaMod()"]
  pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional alpha value used in blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to query."]
  #[doc = "  \\param alpha A pointer filled in with the current alpha value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetSurfaceAlphaMod()"]
  pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the blend mode used for blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface The surface to update."]
  #[doc = "  \\param blendMode ::SDL_BlendMode to use for blit blending."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the parameters are not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetSurfaceBlendMode()"]
  pub fn SDL_SetSurfaceBlendMode(
    surface: *mut SDL_Surface, blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the blend mode used for blit operations."]
  #[doc = ""]
  #[doc = "  \\param surface   The surface to query."]
  #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the surface is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetSurfaceBlendMode()"]
  pub fn SDL_GetSurfaceBlendMode(
    surface: *mut SDL_Surface, blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Sets the clipping rectangle for the destination surface in a blit."]
  #[doc = ""]
  #[doc = "  If the clip rectangle is NULL, clipping will be disabled."]
  #[doc = ""]
  #[doc = "  If the clip rectangle doesn\'t intersect the surface, the function will"]
  #[doc = "  return SDL_FALSE and blits will be completely clipped.  Otherwise the"]
  #[doc = "  function returns SDL_TRUE and blits to the surface will be clipped to"]
  #[doc = "  the intersection of the surface area and the clipping rectangle."]
  #[doc = ""]
  #[doc = "  Note that blits are automatically clipped to the edges of the source"]
  #[doc = "  and destination surfaces."]
  pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Gets the clipping rectangle for the destination surface in a blit."]
  #[doc = ""]
  #[doc = "  \\c rect must be a pointer to a valid rectangle which will be filled"]
  #[doc = "  with the correct values."]
  pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
  pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = "  Creates a new surface of the specified format, and then copies and maps"]
  #[doc = "  the given surface to it so the blit of the converted surface will be as"]
  #[doc = "  fast as possible.  If this function fails, it returns NULL."]
  #[doc = ""]
  #[doc = "  The \\c flags parameter is passed to SDL_CreateRGBSurface() and has those"]
  #[doc = "  semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and"]
  #[doc = "  SDL will try to RLE accelerate colorkey and alpha blits in the resulting"]
  #[doc = "  surface."]
  pub fn SDL_ConvertSurface(
    src: *mut SDL_Surface, fmt: *const SDL_PixelFormat, flags: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  pub fn SDL_ConvertSurfaceFormat(
    src: *mut SDL_Surface, pixel_format: Uint32, flags: Uint32,
  ) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = " \\brief Copy a block of pixels of one format to another format"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if there was an error"]
  pub fn SDL_ConvertPixels(
    width: libc::c_int, height: libc::c_int, src_format: Uint32, src: *const libc::c_void,
    src_pitch: libc::c_int, dst_format: Uint32, dst: *mut libc::c_void, dst_pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Performs a fast fill of the given rectangle with \\c color."]
  #[doc = ""]
  #[doc = "  If \\c rect is NULL, the whole surface will be filled with \\c color."]
  #[doc = ""]
  #[doc = "  The color should be a pixel of the format used by the surface, and"]
  #[doc = "  can be generated by the SDL_MapRGB() function."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error."]
  pub fn SDL_FillRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32) -> libc::c_int;
}
extern "C" {
  pub fn SDL_FillRects(
    dst: *mut SDL_Surface, rects: *const SDL_Rect, count: libc::c_int, color: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is the public blit function, SDL_BlitSurface(), and it performs"]
  #[doc = "  rectangle validation and clipping before passing it to SDL_LowerBlit()"]
  pub fn SDL_UpperBlit(
    src: *mut SDL_Surface, srcrect: *const SDL_Rect, dst: *mut SDL_Surface, dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is a semi-private blit function and it performs low-level surface"]
  #[doc = "  blitting only."]
  pub fn SDL_LowerBlit(
    src: *mut SDL_Surface, srcrect: *mut SDL_Rect, dst: *mut SDL_Surface, dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Perform a fast, low quality, stretch blit between two surfaces of the"]
  #[doc = "         same pixel format."]
  #[doc = ""]
  #[doc = "  \\note This function uses a static buffer, and is not thread-safe."]
  pub fn SDL_SoftStretch(
    src: *mut SDL_Surface, srcrect: *const SDL_Rect, dst: *mut SDL_Surface,
    dstrect: *const SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is the public scaled blit function, SDL_BlitScaled(), and it performs"]
  #[doc = "  rectangle validation and clipping before passing it to SDL_LowerBlitScaled()"]
  pub fn SDL_UpperBlitScaled(
    src: *mut SDL_Surface, srcrect: *const SDL_Rect, dst: *mut SDL_Surface, dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  This is a semi-private blit function and it performs low-level surface"]
  #[doc = "  scaled blitting only."]
  pub fn SDL_LowerBlitScaled(
    src: *mut SDL_Surface, srcrect: *mut SDL_Rect, dst: *mut SDL_Surface, dstrect: *mut SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the YUV conversion mode"]
  pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE::Type);
}
extern "C" {
  #[doc = "  \\brief Get the YUV conversion mode"]
  pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE::Type;
}
extern "C" {
  #[doc = "  \\brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC"]
  pub fn SDL_GetYUVConversionModeForResolution(
    width: libc::c_int, height: libc::c_int,
  ) -> SDL_YUV_CONVERSION_MODE::Type;
}
#[doc = "  \\brief  The structure that defines a display mode"]
#[doc = ""]
#[doc = "  \\sa SDL_GetNumDisplayModes()"]
#[doc = "  \\sa SDL_GetDisplayMode()"]
#[doc = "  \\sa SDL_GetDesktopDisplayMode()"]
#[doc = "  \\sa SDL_GetCurrentDisplayMode()"]
#[doc = "  \\sa SDL_GetClosestDisplayMode()"]
#[doc = "  \\sa SDL_SetWindowDisplayMode()"]
#[doc = "  \\sa SDL_GetWindowDisplayMode()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_DisplayMode {
  #[doc = "< pixel format"]
  pub format: Uint32,
  #[doc = "< width, in screen coordinates"]
  pub w: libc::c_int,
  #[doc = "< height, in screen coordinates"]
  pub h: libc::c_int,
  #[doc = "< refresh rate (or zero for unspecified)"]
  pub refresh_rate: libc::c_int,
  #[doc = "< driver-specific data, initialize to 0"]
  pub driverdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DisplayMode>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_DisplayMode))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DisplayMode>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DisplayMode))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).format as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).w as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(w)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).h as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(h)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).refresh_rate as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(refresh_rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).driverdata as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayMode),
      "::",
      stringify!(driverdata)
    )
  );
}
impl Default for SDL_DisplayMode {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
  _unused: [u8; 0],
}
pub mod SDL_WindowFlags {
  #[doc = "  \\brief The flags on a window"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowFlags()"]
  pub type Type = i32;
  #[doc = "< fullscreen window"]
  pub const SDL_WINDOW_FULLSCREEN: Type = 1;
  #[doc = "< window usable with OpenGL context"]
  pub const SDL_WINDOW_OPENGL: Type = 2;
  #[doc = "< window is visible"]
  pub const SDL_WINDOW_SHOWN: Type = 4;
  #[doc = "< window is not visible"]
  pub const SDL_WINDOW_HIDDEN: Type = 8;
  #[doc = "< no window decoration"]
  pub const SDL_WINDOW_BORDERLESS: Type = 16;
  #[doc = "< window can be resized"]
  pub const SDL_WINDOW_RESIZABLE: Type = 32;
  #[doc = "< window is minimized"]
  pub const SDL_WINDOW_MINIMIZED: Type = 64;
  #[doc = "< window is maximized"]
  pub const SDL_WINDOW_MAXIMIZED: Type = 128;
  #[doc = "< window has grabbed input focus"]
  pub const SDL_WINDOW_INPUT_GRABBED: Type = 256;
  #[doc = "< window has input focus"]
  pub const SDL_WINDOW_INPUT_FOCUS: Type = 512;
  #[doc = "< window has mouse focus"]
  pub const SDL_WINDOW_MOUSE_FOCUS: Type = 1024;
  pub const SDL_WINDOW_FULLSCREEN_DESKTOP: Type = 4097;
  #[doc = "< window not created by SDL"]
  pub const SDL_WINDOW_FOREIGN: Type = 2048;
  #[doc = "< window should be created in high-DPI mode if supported."]
  #[doc = "On macOS NSHighResolutionCapable must be set true in the"]
  #[doc = "application\'s Info.plist for this to have any effect."]
  pub const SDL_WINDOW_ALLOW_HIGHDPI: Type = 8192;
  #[doc = "< window has mouse captured (unrelated to INPUT_GRABBED)"]
  pub const SDL_WINDOW_MOUSE_CAPTURE: Type = 16384;
  #[doc = "< window should always be above others"]
  pub const SDL_WINDOW_ALWAYS_ON_TOP: Type = 32768;
  #[doc = "< window should not be added to the taskbar"]
  pub const SDL_WINDOW_SKIP_TASKBAR: Type = 65536;
  #[doc = "< window should be treated as a utility window"]
  pub const SDL_WINDOW_UTILITY: Type = 131072;
  #[doc = "< window should be treated as a tooltip"]
  pub const SDL_WINDOW_TOOLTIP: Type = 262144;
  #[doc = "< window should be treated as a popup menu"]
  pub const SDL_WINDOW_POPUP_MENU: Type = 524288;
  #[doc = "< window usable for Vulkan surface"]
  pub const SDL_WINDOW_VULKAN: Type = 268435456;
}
pub mod SDL_WindowEventID {
  #[doc = "  \\brief Event subtype for window events"]
  pub type Type = i32;
  #[doc = "< Never used"]
  pub const SDL_WINDOWEVENT_NONE: Type = 0;
  #[doc = "< Window has been shown"]
  pub const SDL_WINDOWEVENT_SHOWN: Type = 1;
  #[doc = "< Window has been hidden"]
  pub const SDL_WINDOWEVENT_HIDDEN: Type = 2;
  #[doc = "< Window has been exposed and should be"]
  #[doc = "redrawn"]
  pub const SDL_WINDOWEVENT_EXPOSED: Type = 3;
  #[doc = "< Window has been moved to data1, data2"]
  pub const SDL_WINDOWEVENT_MOVED: Type = 4;
  #[doc = "< Window has been resized to data1xdata2"]
  pub const SDL_WINDOWEVENT_RESIZED: Type = 5;
  #[doc = "< The window size has changed, either as"]
  #[doc = "a result of an API call or through the"]
  #[doc = "system or user changing the window size."]
  pub const SDL_WINDOWEVENT_SIZE_CHANGED: Type = 6;
  #[doc = "< Window has been minimized"]
  pub const SDL_WINDOWEVENT_MINIMIZED: Type = 7;
  #[doc = "< Window has been maximized"]
  pub const SDL_WINDOWEVENT_MAXIMIZED: Type = 8;
  #[doc = "< Window has been restored to normal size"]
  #[doc = "and position"]
  pub const SDL_WINDOWEVENT_RESTORED: Type = 9;
  #[doc = "< Window has gained mouse focus"]
  pub const SDL_WINDOWEVENT_ENTER: Type = 10;
  #[doc = "< Window has lost mouse focus"]
  pub const SDL_WINDOWEVENT_LEAVE: Type = 11;
  #[doc = "< Window has gained keyboard focus"]
  pub const SDL_WINDOWEVENT_FOCUS_GAINED: Type = 12;
  #[doc = "< Window has lost keyboard focus"]
  pub const SDL_WINDOWEVENT_FOCUS_LOST: Type = 13;
  #[doc = "< The window manager requests that the window be closed"]
  pub const SDL_WINDOWEVENT_CLOSE: Type = 14;
  #[doc = "< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)"]
  pub const SDL_WINDOWEVENT_TAKE_FOCUS: Type = 15;
  #[doc = "< Window had a hit test that wasn\'t SDL_HITTEST_NORMAL."]
  pub const SDL_WINDOWEVENT_HIT_TEST: Type = 16;
}
pub mod SDL_DisplayEventID {
  #[doc = "  \\brief Event subtype for display events"]
  pub type Type = i32;
  #[doc = "< Never used"]
  pub const SDL_DISPLAYEVENT_NONE: Type = 0;
  #[doc = "< Display orientation has changed to data1"]
  pub const SDL_DISPLAYEVENT_ORIENTATION: Type = 1;
}
pub mod SDL_DisplayOrientation {
  pub type Type = i32;
  #[doc = "< The display orientation can\'t be determined"]
  pub const SDL_ORIENTATION_UNKNOWN: Type = 0;
  #[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
  pub const SDL_ORIENTATION_LANDSCAPE: Type = 1;
  #[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
  pub const SDL_ORIENTATION_LANDSCAPE_FLIPPED: Type = 2;
  #[doc = "< The display is in portrait mode"]
  pub const SDL_ORIENTATION_PORTRAIT: Type = 3;
  #[doc = "< The display is in portrait mode, upside down"]
  pub const SDL_ORIENTATION_PORTRAIT_FLIPPED: Type = 4;
}
#[doc = "  \\brief An opaque handle to an OpenGL context."]
pub type SDL_GLContext = *mut libc::c_void;
pub mod SDL_GLattr {
  #[doc = "  \\brief OpenGL configuration attributes"]
  pub type Type = i32;
  pub const SDL_GL_RED_SIZE: Type = 0;
  pub const SDL_GL_GREEN_SIZE: Type = 1;
  pub const SDL_GL_BLUE_SIZE: Type = 2;
  pub const SDL_GL_ALPHA_SIZE: Type = 3;
  pub const SDL_GL_BUFFER_SIZE: Type = 4;
  pub const SDL_GL_DOUBLEBUFFER: Type = 5;
  pub const SDL_GL_DEPTH_SIZE: Type = 6;
  pub const SDL_GL_STENCIL_SIZE: Type = 7;
  pub const SDL_GL_ACCUM_RED_SIZE: Type = 8;
  pub const SDL_GL_ACCUM_GREEN_SIZE: Type = 9;
  pub const SDL_GL_ACCUM_BLUE_SIZE: Type = 10;
  pub const SDL_GL_ACCUM_ALPHA_SIZE: Type = 11;
  pub const SDL_GL_STEREO: Type = 12;
  pub const SDL_GL_MULTISAMPLEBUFFERS: Type = 13;
  pub const SDL_GL_MULTISAMPLESAMPLES: Type = 14;
  pub const SDL_GL_ACCELERATED_VISUAL: Type = 15;
  pub const SDL_GL_RETAINED_BACKING: Type = 16;
  pub const SDL_GL_CONTEXT_MAJOR_VERSION: Type = 17;
  pub const SDL_GL_CONTEXT_MINOR_VERSION: Type = 18;
  pub const SDL_GL_CONTEXT_EGL: Type = 19;
  pub const SDL_GL_CONTEXT_FLAGS: Type = 20;
  pub const SDL_GL_CONTEXT_PROFILE_MASK: Type = 21;
  pub const SDL_GL_SHARE_WITH_CURRENT_CONTEXT: Type = 22;
  pub const SDL_GL_FRAMEBUFFER_SRGB_CAPABLE: Type = 23;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR: Type = 24;
  pub const SDL_GL_CONTEXT_RESET_NOTIFICATION: Type = 25;
  pub const SDL_GL_CONTEXT_NO_ERROR: Type = 26;
}
pub mod SDL_GLprofile {
  pub type Type = i32;
  pub const SDL_GL_CONTEXT_PROFILE_CORE: Type = 1;
  pub const SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: Type = 2;
  #[doc = "< GLX_CONTEXT_ES2_PROFILE_BIT_EXT"]
  pub const SDL_GL_CONTEXT_PROFILE_ES: Type = 4;
}
pub mod SDL_GLcontextFlag {
  pub type Type = i32;
  pub const SDL_GL_CONTEXT_DEBUG_FLAG: Type = 1;
  pub const SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: Type = 2;
  pub const SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: Type = 4;
  pub const SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: Type = 8;
}
pub mod SDL_GLcontextReleaseFlag {
  pub type Type = i32;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: Type = 0;
  pub const SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: Type = 1;
}
pub mod SDL_GLContextResetNotification {
  pub type Type = i32;
  pub const SDL_GL_CONTEXT_RESET_NO_NOTIFICATION: Type = 0;
  pub const SDL_GL_CONTEXT_RESET_LOSE_CONTEXT: Type = 1;
}
extern "C" {
  #[doc = "  \\brief Get the number of video drivers compiled into SDL"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetVideoDriver()"]
  pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the name of a built in video driver."]
  #[doc = ""]
  #[doc = "  \\note The video drivers are presented in the order in which they are"]
  #[doc = "        normally checked during initialization."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDrivers()"]
  pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Initialize the video subsystem, optionally specifying a video driver."]
  #[doc = ""]
  #[doc = "  \\param driver_name Initialize a specific driver by name, or NULL for the"]
  #[doc = "                     default video driver."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 on error"]
  #[doc = ""]
  #[doc = "  This function initializes the video subsystem; setting up a connection"]
  #[doc = "  to the window manager, etc, and determines the available display modes"]
  #[doc = "  and pixel formats, but does not initialize a window or graphics mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_VideoQuit()"]
  pub fn SDL_VideoInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Shuts down the video subsystem."]
  #[doc = ""]
  #[doc = "  This function closes all windows, and restores the original video mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_VideoInit()"]
  pub fn SDL_VideoQuit();
}
extern "C" {
  #[doc = "  \\brief Returns the name of the currently initialized video driver."]
  #[doc = ""]
  #[doc = "  \\return The name of the current video driver or NULL if no driver"]
  #[doc = "          has been initialized"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDrivers()"]
  #[doc = "  \\sa SDL_GetVideoDriver()"]
  pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Returns the number of available video displays."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetDisplayBounds()"]
  pub fn SDL_GetNumVideoDisplays() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the name of a display in UTF-8 encoding"]
  #[doc = ""]
  #[doc = "  \\return The name of a display, or NULL for an invalid display index."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  pub fn SDL_GetDisplayName(displayIndex: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the desktop area represented by a display, with the primary"]
  #[doc = "         display located at 0,0"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the index is out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  pub fn SDL_GetDisplayBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the usable desktop area represented by a display, with the"]
  #[doc = "         primary display located at 0,0"]
  #[doc = ""]
  #[doc = "  This is the same area as SDL_GetDisplayBounds() reports, but with portions"]
  #[doc = "  reserved by the system removed. For example, on Mac OS X, this subtracts"]
  #[doc = "  the area occupied by the menu bar and dock."]
  #[doc = ""]
  #[doc = "  Setting a window to be fullscreen generally bypasses these unusable areas,"]
  #[doc = "  so these are good guidelines for the maximum space available to a"]
  #[doc = "  non-fullscreen window."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the index is out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetDisplayBounds()"]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  pub fn SDL_GetDisplayUsableBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the dots/pixels-per-inch for a display"]
  #[doc = ""]
  #[doc = "  \\note Diagonal, horizontal and vertical DPI can all be optionally"]
  #[doc = "        returned if the parameter is non-NULL."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if no DPI information is available or the index is out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  pub fn SDL_GetDisplayDPI(
    displayIndex: libc::c_int, ddpi: *mut f32, hdpi: *mut f32, vdpi: *mut f32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the orientation of a display"]
  #[doc = ""]
  #[doc = "  \\return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn\'t available."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumVideoDisplays()"]
  pub fn SDL_GetDisplayOrientation(displayIndex: libc::c_int) -> SDL_DisplayOrientation::Type;
}
extern "C" {
  #[doc = "  \\brief Returns the number of available display modes."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetDisplayMode()"]
  pub fn SDL_GetNumDisplayModes(displayIndex: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about a specific display mode."]
  #[doc = ""]
  #[doc = "  \\note The display modes are sorted in this priority:"]
  #[doc = "        \\li bits per pixel -> more colors to fewer colors"]
  #[doc = "        \\li width -> largest to smallest"]
  #[doc = "        \\li height -> largest to smallest"]
  #[doc = "        \\li refresh rate -> highest to lowest"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumDisplayModes()"]
  pub fn SDL_GetDisplayMode(
    displayIndex: libc::c_int, modeIndex: libc::c_int, mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about the desktop display mode."]
  pub fn SDL_GetDesktopDisplayMode(
    displayIndex: libc::c_int, mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about the current display mode."]
  pub fn SDL_GetCurrentDisplayMode(
    displayIndex: libc::c_int, mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the closest match to the requested display mode."]
  #[doc = ""]
  #[doc = "  \\param displayIndex The index of display from which mode should be queried."]
  #[doc = "  \\param mode The desired display mode"]
  #[doc = "  \\param closest A pointer to a display mode to be filled in with the closest"]
  #[doc = "                 match of the available display modes."]
  #[doc = ""]
  #[doc = "  \\return The passed in value \\c closest, or NULL if no matching video mode"]
  #[doc = "          was available."]
  #[doc = ""]
  #[doc = "  The available display modes are scanned, and \\c closest is filled in with the"]
  #[doc = "  closest mode matching the requested mode and returned.  The mode format and"]
  #[doc = "  refresh_rate default to the desktop mode if they are 0.  The modes are"]
  #[doc = "  scanned with size being first priority, format being second priority, and"]
  #[doc = "  finally checking the refresh_rate.  If all the available modes are too"]
  #[doc = "  small, then NULL is returned."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetNumDisplayModes()"]
  #[doc = "  \\sa SDL_GetDisplayMode()"]
  pub fn SDL_GetClosestDisplayMode(
    displayIndex: libc::c_int, mode: *const SDL_DisplayMode, closest: *mut SDL_DisplayMode,
  ) -> *mut SDL_DisplayMode;
}
extern "C" {
  #[doc = "  \\brief Get the display index associated with a window."]
  #[doc = ""]
  #[doc = "  \\return the display index of the display containing the center of the"]
  #[doc = "          window, or -1 on error."]
  pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the display mode used when a fullscreen window is visible."]
  #[doc = ""]
  #[doc = "  By default the window\'s dimensions and the desktop format and refresh rate"]
  #[doc = "  are used."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the display mode should be set."]
  #[doc = "  \\param mode The mode to use, or NULL for the default mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the display mode failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowDisplayMode()"]
  #[doc = "  \\sa SDL_SetWindowFullscreen()"]
  pub fn SDL_SetWindowDisplayMode(
    window: *mut SDL_Window, mode: *const SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill in information about the display mode used when a fullscreen"]
  #[doc = "         window is visible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
  #[doc = "  \\sa SDL_SetWindowFullscreen()"]
  pub fn SDL_GetWindowDisplayMode(
    window: *mut SDL_Window, mode: *mut SDL_DisplayMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the pixel format associated with the window."]
  pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Create a window with the specified position, dimensions, and flags."]
  #[doc = ""]
  #[doc = "  \\param title The title of the window, in UTF-8 encoding."]
  #[doc = "  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param w     The width of the window, in screen coordinates."]
  #[doc = "  \\param h     The height of the window, in screen coordinates."]
  #[doc = "  \\param flags The flags for the window, a mask of any of the following:"]
  #[doc = "               ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,"]
  #[doc = "               ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,"]
  #[doc = "               ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,"]
  #[doc = "               ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,"]
  #[doc = "               ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN."]
  #[doc = ""]
  #[doc = "  \\return The created window, or NULL if window creation failed."]
  #[doc = ""]
  #[doc = "  If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size"]
  #[doc = "  in pixels may differ from its size in screen coordinates on platforms with"]
  #[doc = "  high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query"]
  #[doc = "  the client area\'s size in screen coordinates, and SDL_GL_GetDrawableSize(),"]
  #[doc = "  SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the"]
  #[doc = "  drawable size in pixels."]
  #[doc = ""]
  #[doc = "  If the window is created with any of the SDL_WINDOW_OPENGL or"]
  #[doc = "  SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function"]
  #[doc = "  (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the"]
  #[doc = "  corresponding UnloadLibrary function is called by SDL_DestroyWindow()."]
  #[doc = ""]
  #[doc = "  If SDL_WINDOW_VULKAN is specified and there isn\'t a working Vulkan driver,"]
  #[doc = "  SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail."]
  #[doc = ""]
  #[doc = "  \\note On non-Apple devices, SDL requires you to either not link to the"]
  #[doc = "        Vulkan loader or link to a dynamic library version. This limitation"]
  #[doc = "        may be removed in a future version of SDL."]
  #[doc = ""]
  #[doc = "  \\sa SDL_DestroyWindow()"]
  #[doc = "  \\sa SDL_GL_LoadLibrary()"]
  #[doc = "  \\sa SDL_Vulkan_LoadLibrary()"]
  pub fn SDL_CreateWindow(
    title: *const libc::c_char, x: libc::c_int, y: libc::c_int, w: libc::c_int, h: libc::c_int,
    flags: Uint32,
  ) -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Create an SDL window from an existing native window."]
  #[doc = ""]
  #[doc = "  \\param data A pointer to driver-dependent window creation data"]
  #[doc = ""]
  #[doc = "  \\return The created window, or NULL if window creation failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_DestroyWindow()"]
  pub fn SDL_CreateWindowFrom(data: *const libc::c_void) -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get the numeric ID of a window, for logging purposes."]
  pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Get a window from a stored ID, or NULL if it doesn\'t exist."]
  pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get the window flags."]
  pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Set the title of a window, in UTF-8 format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowTitle()"]
  pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char);
}
extern "C" {
  #[doc = "  \\brief Get the title of a window, in UTF-8 format."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowTitle()"]
  pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Set the icon for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the icon should be set."]
  #[doc = "  \\param icon The icon for the window."]
  pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
  #[doc = "  \\brief Associate an arbitrary named pointer with a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to associate with the pointer."]
  #[doc = "  \\param name     The name of the pointer."]
  #[doc = "  \\param userdata The associated pointer."]
  #[doc = ""]
  #[doc = "  \\return The previous value associated with \'name\'"]
  #[doc = ""]
  #[doc = "  \\note The name is case-sensitive."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowData()"]
  pub fn SDL_SetWindowData(
    window: *mut SDL_Window, name: *const libc::c_char, userdata: *mut libc::c_void,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Retrieve the data pointer associated with a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param name     The name of the pointer."]
  #[doc = ""]
  #[doc = "  \\return The value associated with \'name\'"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowData()"]
  pub fn SDL_GetWindowData(window: *mut SDL_Window, name: *const libc::c_char)
    -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Set the position of a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to reposition."]
  #[doc = "  \\param x        The x coordinate of the window in screen coordinates, or"]
  #[doc = "                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param y        The y coordinate of the window in screen coordinates, or"]
  #[doc = "                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = ""]
  #[doc = "  \\note The window coordinate origin is the upper left of the display."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowPosition()"]
  pub fn SDL_SetWindowPosition(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the position of a window."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param x        Pointer to variable for storing the x position, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = "  \\param y        Pointer to variable for storing the y position, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowPosition()"]
  pub fn SDL_GetWindowPosition(window: *mut SDL_Window, x: *mut libc::c_int, y: *mut libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Set the size of a window\'s client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to resize."]
  #[doc = "  \\param w        The width of the window, in screen coordinates. Must be >0."]
  #[doc = "  \\param h        The height of the window, in screen coordinates. Must be >0."]
  #[doc = ""]
  #[doc = "  \\note Fullscreen windows automatically match the size of the display mode,"]
  #[doc = "        and you should use SDL_SetWindowDisplayMode() to change their size."]
  #[doc = ""]
  #[doc = "  The window size in screen coordinates may differ from the size in pixels, if"]
  #[doc = "  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with"]
  #[doc = "  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or"]
  #[doc = "  SDL_GetRendererOutputSize() to get the real client area size in pixels."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSize()"]
  #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
  pub fn SDL_SetWindowSize(window: *mut SDL_Window, w: libc::c_int, h: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the size of a window\'s client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param w        Pointer to variable for storing the width, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = "  \\param h        Pointer to variable for storing the height, in screen"]
  #[doc = "                  coordinates. May be NULL."]
  #[doc = ""]
  #[doc = "  The window size in screen coordinates may differ from the size in pixels, if"]
  #[doc = "  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with"]
  #[doc = "  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or"]
  #[doc = "  SDL_GetRendererOutputSize() to get the real client area size in pixels."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowSize()"]
  pub fn SDL_GetWindowSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the size of a window\'s borders (decorations) around the client area."]
  #[doc = ""]
  #[doc = "  \\param window The window to query."]
  #[doc = "  \\param top Pointer to variable for storing the size of the top border. NULL is permitted."]
  #[doc = "  \\param left Pointer to variable for storing the size of the left border. NULL is permitted."]
  #[doc = "  \\param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted."]
  #[doc = "  \\param right Pointer to variable for storing the size of the right border. NULL is permitted."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if getting this information is not supported."]
  #[doc = ""]
  #[doc = "  \\note if this function fails (returns -1), the size values will be"]
  #[doc = "        initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as"]
  #[doc = "        if the window in question was borderless."]
  pub fn SDL_GetWindowBordersSize(
    window: *mut SDL_Window, top: *mut libc::c_int, left: *mut libc::c_int,
    bottom: *mut libc::c_int, right: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the minimum size of a window\'s client area."]
  #[doc = ""]
  #[doc = "  \\param window    The window to set a new minimum size."]
  #[doc = "  \\param min_w     The minimum width of the window, must be >0"]
  #[doc = "  \\param min_h     The minimum height of the window, must be >0"]
  #[doc = ""]
  #[doc = "  \\note You can\'t change the minimum size of a fullscreen window, it"]
  #[doc = "        automatically matches the size of the display mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMinimumSize()"]
  #[doc = "  \\sa SDL_SetWindowMaximumSize()"]
  pub fn SDL_SetWindowMinimumSize(window: *mut SDL_Window, min_w: libc::c_int, min_h: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the minimum size of a window\'s client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param w        Pointer to variable for storing the minimum width, may be NULL"]
  #[doc = "  \\param h        Pointer to variable for storing the minimum height, may be NULL"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMaximumSize()"]
  #[doc = "  \\sa SDL_SetWindowMinimumSize()"]
  pub fn SDL_GetWindowMinimumSize(
    window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int,
  );
}
extern "C" {
  #[doc = "  \\brief Set the maximum size of a window\'s client area."]
  #[doc = ""]
  #[doc = "  \\param window    The window to set a new maximum size."]
  #[doc = "  \\param max_w     The maximum width of the window, must be >0"]
  #[doc = "  \\param max_h     The maximum height of the window, must be >0"]
  #[doc = ""]
  #[doc = "  \\note You can\'t change the maximum size of a fullscreen window, it"]
  #[doc = "        automatically matches the size of the display mode."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMaximumSize()"]
  #[doc = "  \\sa SDL_SetWindowMinimumSize()"]
  pub fn SDL_SetWindowMaximumSize(window: *mut SDL_Window, max_w: libc::c_int, max_h: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Get the maximum size of a window\'s client area."]
  #[doc = ""]
  #[doc = "  \\param window   The window to query."]
  #[doc = "  \\param w        Pointer to variable for storing the maximum width, may be NULL"]
  #[doc = "  \\param h        Pointer to variable for storing the maximum height, may be NULL"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowMinimumSize()"]
  #[doc = "  \\sa SDL_SetWindowMaximumSize()"]
  pub fn SDL_GetWindowMaximumSize(
    window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int,
  );
}
extern "C" {
  #[doc = "  \\brief Set the border state of a window."]
  #[doc = ""]
  #[doc = "  This will add or remove the window\'s SDL_WINDOW_BORDERLESS flag and"]
  #[doc = "  add or remove the border from the actual window. This is a no-op if the"]
  #[doc = "  window\'s border already matches the requested state."]
  #[doc = ""]
  #[doc = "  \\param window The window of which to change the border state."]
  #[doc = "  \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border."]
  #[doc = ""]
  #[doc = "  \\note You can\'t change the border state of a fullscreen window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowFlags()"]
  pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool::Type);
}
extern "C" {
  #[doc = "  \\brief Set the user-resizable state of a window."]
  #[doc = ""]
  #[doc = "  This will add or remove the window\'s SDL_WINDOW_RESIZABLE flag and"]
  #[doc = "  allow/disallow user resizing of the window. This is a no-op if the"]
  #[doc = "  window\'s resizable state already matches the requested state."]
  #[doc = ""]
  #[doc = "  \\param window The window of which to change the resizable state."]
  #[doc = "  \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow."]
  #[doc = ""]
  #[doc = "  \\note You can\'t change the resizable state of a fullscreen window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowFlags()"]
  pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool::Type);
}
extern "C" {
  #[doc = "  \\brief Show a window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HideWindow()"]
  pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Hide a window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_ShowWindow()"]
  pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Raise a window above other windows and set the input focus."]
  pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Make a window as large as possible."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RestoreWindow()"]
  pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Minimize a window to an iconic representation."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RestoreWindow()"]
  pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Restore the size and position of a minimized or maximized window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MaximizeWindow()"]
  #[doc = "  \\sa SDL_MinimizeWindow()"]
  pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Set a window\'s fullscreen state."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the display mode failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowDisplayMode()"]
  #[doc = "  \\sa SDL_GetWindowDisplayMode()"]
  pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the SDL surface associated with the window."]
  #[doc = ""]
  #[doc = "  \\return The window\'s framebuffer surface, or NULL on error."]
  #[doc = ""]
  #[doc = "  A new surface will be created with the optimal format for the window,"]
  #[doc = "  if necessary. This surface will be freed when the window is destroyed."]
  #[doc = ""]
  #[doc = "  \\note You may not combine this with 3D or the rendering API on this window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_UpdateWindowSurface()"]
  #[doc = "  \\sa SDL_UpdateWindowSurfaceRects()"]
  pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
  #[doc = "  \\brief Copy the window surface to the screen."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSurface()"]
  #[doc = "  \\sa SDL_UpdateWindowSurfaceRects()"]
  pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Copy a number of rectangles on the window surface to the screen."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSurface()"]
  #[doc = "  \\sa SDL_UpdateWindowSurface()"]
  pub fn SDL_UpdateWindowSurfaceRects(
    window: *mut SDL_Window, rects: *const SDL_Rect, numrects: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set a window\'s input grab mode."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the input grab mode should be set."]
  #[doc = "  \\param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input."]
  #[doc = ""]
  #[doc = "  If the caller enables a grab while another window is currently grabbed,"]
  #[doc = "  the other window loses its grab in favor of the caller\'s window."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowGrab()"]
  pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool::Type);
}
extern "C" {
  #[doc = "  \\brief Get a window\'s input grab mode."]
  #[doc = ""]
  #[doc = "  \\return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowGrab()"]
  pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Get the window that currently has an input grab enabled."]
  #[doc = ""]
  #[doc = "  \\return This returns the window if input is grabbed, and NULL otherwise."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowGrab()"]
  pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Set the brightness (gamma correction) for a window."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the brightness isn\'t supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowBrightness()"]
  #[doc = "  \\sa SDL_SetWindowGammaRamp()"]
  pub fn SDL_SetWindowBrightness(window: *mut SDL_Window, brightness: f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the brightness (gamma correction) for a window."]
  #[doc = ""]
  #[doc = "  \\return The last brightness value passed to SDL_SetWindowBrightness()"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowBrightness()"]
  pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
  #[doc = "  \\brief Set the opacity for a window"]
  #[doc = ""]
  #[doc = "  \\param window The window which will be made transparent or opaque"]
  #[doc = "  \\param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be"]
  #[doc = "                 clamped internally between 0.0f and 1.0f."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the opacity isn\'t supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowOpacity()"]
  pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the opacity of a window."]
  #[doc = ""]
  #[doc = "  If transparency isn\'t supported on this platform, opacity will be reported"]
  #[doc = "  as 1.0f without error."]
  #[doc = ""]
  #[doc = "  \\param window The window in question."]
  #[doc = "  \\param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error (invalid window, etc)."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowOpacity()"]
  pub fn SDL_GetWindowOpacity(window: *mut SDL_Window, out_opacity: *mut f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)"]
  #[doc = ""]
  #[doc = "  \\param modal_window The window that should be modal"]
  #[doc = "  \\param parent_window The parent window"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 otherwise."]
  pub fn SDL_SetWindowModalFor(
    modal_window: *mut SDL_Window, parent_window: *mut SDL_Window,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Explicitly sets input focus to the window."]
  #[doc = ""]
  #[doc = "  You almost certainly want SDL_RaiseWindow() instead of this function. Use"]
  #[doc = "  this with caution, as you might give focus to a window that\'s completely"]
  #[doc = "  obscured by other windows."]
  #[doc = ""]
  #[doc = "  \\param window The window that should get the input focus"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 otherwise."]
  #[doc = "  \\sa SDL_RaiseWindow()"]
  pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the gamma ramp for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window for which the gamma ramp should be set."]
  #[doc = "  \\param red The translation table for the red channel, or NULL."]
  #[doc = "  \\param green The translation table for the green channel, or NULL."]
  #[doc = "  \\param blue The translation table for the blue channel, or NULL."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if gamma ramps are unsupported."]
  #[doc = ""]
  #[doc = "  Set the gamma translation table for the red, green, and blue channels"]
  #[doc = "  of the video hardware.  Each table is an array of 256 16-bit quantities,"]
  #[doc = "  representing a mapping between the input and output for that channel."]
  #[doc = "  The input is the index into the array, and the output is the 16-bit"]
  #[doc = "  gamma value at that index, scaled to the output color precision."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowGammaRamp()"]
  pub fn SDL_SetWindowGammaRamp(
    window: *mut SDL_Window, red: *const Uint16, green: *const Uint16, blue: *const Uint16,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the gamma ramp for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window from which the gamma ramp should be queried."]
  #[doc = "  \\param red   A pointer to a 256 element array of 16-bit quantities to hold"]
  #[doc = "               the translation table for the red channel, or NULL."]
  #[doc = "  \\param green A pointer to a 256 element array of 16-bit quantities to hold"]
  #[doc = "               the translation table for the green channel, or NULL."]
  #[doc = "  \\param blue  A pointer to a 256 element array of 16-bit quantities to hold"]
  #[doc = "               the translation table for the blue channel, or NULL."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if gamma ramps are unsupported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetWindowGammaRamp()"]
  pub fn SDL_GetWindowGammaRamp(
    window: *mut SDL_Window, red: *mut Uint16, green: *mut Uint16, blue: *mut Uint16,
  ) -> libc::c_int;
}
pub mod SDL_HitTestResult {
  #[doc = "  \\brief Possible return values from the SDL_HitTest callback."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HitTest"]
  pub type Type = i32;
  #[doc = "< Region is normal. No special properties."]
  pub const SDL_HITTEST_NORMAL: Type = 0;
  #[doc = "< Region can drag entire window."]
  pub const SDL_HITTEST_DRAGGABLE: Type = 1;
  pub const SDL_HITTEST_RESIZE_TOPLEFT: Type = 2;
  pub const SDL_HITTEST_RESIZE_TOP: Type = 3;
  pub const SDL_HITTEST_RESIZE_TOPRIGHT: Type = 4;
  pub const SDL_HITTEST_RESIZE_RIGHT: Type = 5;
  pub const SDL_HITTEST_RESIZE_BOTTOMRIGHT: Type = 6;
  pub const SDL_HITTEST_RESIZE_BOTTOM: Type = 7;
  pub const SDL_HITTEST_RESIZE_BOTTOMLEFT: Type = 8;
  pub const SDL_HITTEST_RESIZE_LEFT: Type = 9;
}
#[doc = "  \\brief Callback used for hit-testing."]
#[doc = ""]
#[doc = "  \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::core::option::Option<
  unsafe extern "C" fn(
    win: *mut SDL_Window,
    area: *const SDL_Point,
    data: *mut libc::c_void,
  ) -> SDL_HitTestResult::Type,
>;
extern "C" {
  #[doc = "  \\brief Provide a callback that decides if a window region has special properties."]
  #[doc = ""]
  #[doc = "  Normally windows are dragged and resized by decorations provided by the"]
  #[doc = "  system window manager (a title bar, borders, etc), but for some apps, it"]
  #[doc = "  makes sense to drag them from somewhere else inside the window itself; for"]
  #[doc = "  example, one might have a borderless window that wants to be draggable"]
  #[doc = "  from any part, or simulate its own title bar, etc."]
  #[doc = ""]
  #[doc = "  This function lets the app provide a callback that designates pieces of"]
  #[doc = "  a given window as special. This callback is run during event processing"]
  #[doc = "  if we need to tell the OS to treat a region of the window specially; the"]
  #[doc = "  use of this callback is known as \"hit testing.\""]
  #[doc = ""]
  #[doc = "  Mouse input may not be delivered to your application if it is within"]
  #[doc = "  a special area; the OS will often apply that input to moving the window or"]
  #[doc = "  resizing the window and not deliver it to the application."]
  #[doc = ""]
  #[doc = "  Specifying NULL for a callback disables hit-testing. Hit-testing is"]
  #[doc = "  disabled by default."]
  #[doc = ""]
  #[doc = "  Platforms that don\'t support this functionality will return -1"]
  #[doc = "  unconditionally, even if you\'re attempting to disable hit-testing."]
  #[doc = ""]
  #[doc = "  Your callback may fire at any time, and its firing does not indicate any"]
  #[doc = "  specific behavior (for example, on Windows, this certainly might fire"]
  #[doc = "  when the OS is deciding whether to drag your window, but it fires for lots"]
  #[doc = "  of other reasons, too, some unrelated to anything you probably care about"]
  #[doc = "  _and when the mouse isn\'t actually at the location it is testing_)."]
  #[doc = "  Since this can fire at any time, you should try to keep your callback"]
  #[doc = "  efficient, devoid of allocations, etc."]
  #[doc = ""]
  #[doc = "  \\param window The window to set hit-testing on."]
  #[doc = "  \\param callback The callback to call when doing a hit-test."]
  #[doc = "  \\param callback_data An app-defined void pointer passed to the callback."]
  #[doc = "  \\return 0 on success, -1 on error (including unsupported)."]
  pub fn SDL_SetWindowHitTest(
    window: *mut SDL_Window, callback: SDL_HitTest, callback_data: *mut libc::c_void,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Destroy a window."]
  pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Returns whether the screensaver is currently enabled (default off)."]
  #[doc = ""]
  #[doc = "  \\sa SDL_EnableScreenSaver()"]
  #[doc = "  \\sa SDL_DisableScreenSaver()"]
  pub fn SDL_IsScreenSaverEnabled() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Allow the screen to be blanked by a screensaver"]
  #[doc = ""]
  #[doc = "  \\sa SDL_IsScreenSaverEnabled()"]
  #[doc = "  \\sa SDL_DisableScreenSaver()"]
  pub fn SDL_EnableScreenSaver();
}
extern "C" {
  #[doc = "  \\brief Prevent the screen from being blanked by a screensaver"]
  #[doc = ""]
  #[doc = "  \\sa SDL_IsScreenSaverEnabled()"]
  #[doc = "  \\sa SDL_EnableScreenSaver()"]
  pub fn SDL_DisableScreenSaver();
}
extern "C" {
  #[doc = "  \\brief Dynamically load an OpenGL library."]
  #[doc = ""]
  #[doc = "  \\param path The platform dependent OpenGL library name, or NULL to open the"]
  #[doc = "              default OpenGL library."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the library couldn\'t be loaded."]
  #[doc = ""]
  #[doc = "  This should be done after initializing the video driver, but before"]
  #[doc = "  creating any OpenGL windows.  If no OpenGL library is loaded, the default"]
  #[doc = "  library will be loaded upon creation of the first OpenGL window."]
  #[doc = ""]
  #[doc = "  \\note If you do this, you need to retrieve all of the GL functions used in"]
  #[doc = "        your program from the dynamic library using SDL_GL_GetProcAddress()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_GetProcAddress()"]
  #[doc = "  \\sa SDL_GL_UnloadLibrary()"]
  pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the address of an OpenGL function."]
  pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_LoadLibrary()"]
  pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
  #[doc = "  \\brief Return true if an OpenGL extension is supported for the current"]
  #[doc = "         context."]
  pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Reset all previously set OpenGL context attributes to their default values"]
  pub fn SDL_GL_ResetAttributes();
}
extern "C" {
  #[doc = "  \\brief Set an OpenGL window attribute before window creation."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the attribute could not be set."]
  pub fn SDL_GL_SetAttribute(attr: SDL_GLattr::Type, value: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the actual value for an attribute from the current context."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the attribute could not be retrieved."]
  #[doc = "          The integer at \\c value will be modified in either case."]
  pub fn SDL_GL_GetAttribute(attr: SDL_GLattr::Type, value: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create an OpenGL context for use with an OpenGL window, and make it"]
  #[doc = "         current."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_DeleteContext()"]
  pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
  #[doc = "  \\brief Set up an OpenGL context for rendering into an OpenGL window."]
  #[doc = ""]
  #[doc = "  \\note The context must have been created with a compatible window."]
  pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the currently active OpenGL window."]
  pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get the currently active OpenGL context."]
  pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
  #[doc = "  \\brief Get the size of a window\'s underlying drawable in pixels (for use"]
  #[doc = "         with glViewport)."]
  #[doc = ""]
  #[doc = "  \\param window   Window from which the drawable size should be queried"]
  #[doc = "  \\param w        Pointer to variable for storing the width in pixels, may be NULL"]
  #[doc = "  \\param h        Pointer to variable for storing the height in pixels, may be NULL"]
  #[doc = ""]
  #[doc = " This may differ from SDL_GetWindowSize() if we\'re rendering to a high-DPI"]
  #[doc = " drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a"]
  #[doc = " platform with high-DPI support (Apple calls this \"Retina\"), and not disabled"]
  #[doc = " by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetWindowSize()"]
  #[doc = "  \\sa SDL_CreateWindow()"]
  pub fn SDL_GL_GetDrawableSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Set the swap interval for the current OpenGL context."]
  #[doc = ""]
  #[doc = "  \\param interval 0 for immediate updates, 1 for updates synchronized with the"]
  #[doc = "                  vertical retrace. If the system supports it, you may"]
  #[doc = "                  specify -1 to allow late swaps to happen immediately"]
  #[doc = "                  instead of waiting for the next retrace."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if setting the swap interval is not supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_GetSwapInterval()"]
  pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the swap interval for the current OpenGL context."]
  #[doc = ""]
  #[doc = "  \\return 0 if there is no vertical retrace synchronization, 1 if the buffer"]
  #[doc = "          swap is synchronized with the vertical retrace, and -1 if late"]
  #[doc = "          swaps happen immediately instead of waiting for the next retrace."]
  #[doc = "          If the system can\'t determine the swap interval, or there isn\'t a"]
  #[doc = "          valid current context, this will return 0 as a safe default."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_SetSwapInterval()"]
  pub fn SDL_GL_GetSwapInterval() -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Swap the OpenGL buffers for a window, if double-buffering is"]
  #[doc = "        supported."]
  pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
  #[doc = "  \\brief Delete an OpenGL context."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GL_CreateContext()"]
  pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
pub mod SDL_Scancode {
  #[doc = "  \\brief The SDL keyboard scancode representation."]
  #[doc = ""]
  #[doc = "  Values of this type are used to represent keyboard keys, among other places"]
  #[doc = "  in the \\link SDL_Keysym::scancode key.keysym.scancode \\endlink field of the"]
  #[doc = "  SDL_Event structure."]
  #[doc = ""]
  #[doc = "  The values in this enumeration are based on the USB usage page standard:"]
  #[doc = "  http://www.usb.org/developers/hidpage/Hut1_12v2.pdf"]
  pub type Type = i32;
  pub const SDL_SCANCODE_UNKNOWN: Type = 0;
  pub const SDL_SCANCODE_A: Type = 4;
  pub const SDL_SCANCODE_B: Type = 5;
  pub const SDL_SCANCODE_C: Type = 6;
  pub const SDL_SCANCODE_D: Type = 7;
  pub const SDL_SCANCODE_E: Type = 8;
  pub const SDL_SCANCODE_F: Type = 9;
  pub const SDL_SCANCODE_G: Type = 10;
  pub const SDL_SCANCODE_H: Type = 11;
  pub const SDL_SCANCODE_I: Type = 12;
  pub const SDL_SCANCODE_J: Type = 13;
  pub const SDL_SCANCODE_K: Type = 14;
  pub const SDL_SCANCODE_L: Type = 15;
  pub const SDL_SCANCODE_M: Type = 16;
  pub const SDL_SCANCODE_N: Type = 17;
  pub const SDL_SCANCODE_O: Type = 18;
  pub const SDL_SCANCODE_P: Type = 19;
  pub const SDL_SCANCODE_Q: Type = 20;
  pub const SDL_SCANCODE_R: Type = 21;
  pub const SDL_SCANCODE_S: Type = 22;
  pub const SDL_SCANCODE_T: Type = 23;
  pub const SDL_SCANCODE_U: Type = 24;
  pub const SDL_SCANCODE_V: Type = 25;
  pub const SDL_SCANCODE_W: Type = 26;
  pub const SDL_SCANCODE_X: Type = 27;
  pub const SDL_SCANCODE_Y: Type = 28;
  pub const SDL_SCANCODE_Z: Type = 29;
  pub const SDL_SCANCODE_1: Type = 30;
  pub const SDL_SCANCODE_2: Type = 31;
  pub const SDL_SCANCODE_3: Type = 32;
  pub const SDL_SCANCODE_4: Type = 33;
  pub const SDL_SCANCODE_5: Type = 34;
  pub const SDL_SCANCODE_6: Type = 35;
  pub const SDL_SCANCODE_7: Type = 36;
  pub const SDL_SCANCODE_8: Type = 37;
  pub const SDL_SCANCODE_9: Type = 38;
  pub const SDL_SCANCODE_0: Type = 39;
  pub const SDL_SCANCODE_RETURN: Type = 40;
  pub const SDL_SCANCODE_ESCAPE: Type = 41;
  pub const SDL_SCANCODE_BACKSPACE: Type = 42;
  pub const SDL_SCANCODE_TAB: Type = 43;
  pub const SDL_SCANCODE_SPACE: Type = 44;
  pub const SDL_SCANCODE_MINUS: Type = 45;
  pub const SDL_SCANCODE_EQUALS: Type = 46;
  pub const SDL_SCANCODE_LEFTBRACKET: Type = 47;
  pub const SDL_SCANCODE_RIGHTBRACKET: Type = 48;
  #[doc = "< Located at the lower left of the return"]
  #[doc = "   key on ISO keyboards and at the right end"]
  #[doc = "   of the QWERTY row on ANSI keyboards."]
  #[doc = "   Produces REVERSE SOLIDUS (backslash) and"]
  #[doc = "   VERTICAL LINE in a US layout, REVERSE"]
  #[doc = "   SOLIDUS and VERTICAL LINE in a UK Mac"]
  #[doc = "   layout, NUMBER SIGN and TILDE in a UK"]
  #[doc = "   Windows layout, DOLLAR SIGN and POUND SIGN"]
  #[doc = "   in a Swiss German layout, NUMBER SIGN and"]
  #[doc = "   APOSTROPHE in a German layout, GRAVE"]
  #[doc = "   ACCENT and POUND SIGN in a French Mac"]
  #[doc = "   layout, and ASTERISK and MICRO SIGN in a"]
  #[doc = "   French Windows layout."]
  pub const SDL_SCANCODE_BACKSLASH: Type = 49;
  #[doc = "< ISO USB keyboards actually use this code"]
  #[doc = "   instead of 49 for the same key, but all"]
  #[doc = "   OSes I\'ve seen treat the two codes"]
  #[doc = "   identically. So, as an implementor, unless"]
  #[doc = "   your keyboard generates both of those"]
  #[doc = "   codes and your OS treats them differently,"]
  #[doc = "   you should generate SDL_SCANCODE_BACKSLASH"]
  #[doc = "   instead of this code. As a user, you"]
  #[doc = "   should not rely on this code because SDL"]
  #[doc = "   will never generate it with most (all?)"]
  #[doc = "   keyboards."]
  pub const SDL_SCANCODE_NONUSHASH: Type = 50;
  pub const SDL_SCANCODE_SEMICOLON: Type = 51;
  pub const SDL_SCANCODE_APOSTROPHE: Type = 52;
  #[doc = "< Located in the top left corner (on both ANSI"]
  #[doc = "   and ISO keyboards). Produces GRAVE ACCENT and"]
  #[doc = "   TILDE in a US Windows layout and in US and UK"]
  #[doc = "   Mac layouts on ANSI keyboards, GRAVE ACCENT"]
  #[doc = "   and NOT SIGN in a UK Windows layout, SECTION"]
  #[doc = "   SIGN and PLUS-MINUS SIGN in US and UK Mac"]
  #[doc = "   layouts on ISO keyboards, SECTION SIGN and"]
  #[doc = "   DEGREE SIGN in a Swiss German layout (Mac:"]
  #[doc = "   only on ISO keyboards), CIRCUMFLEX ACCENT and"]
  #[doc = "   DEGREE SIGN in a German layout (Mac: only on"]
  #[doc = "   ISO keyboards), SUPERSCRIPT TWO and TILDE in a"]
  #[doc = "   French Windows layout, COMMERCIAL AT and"]
  #[doc = "   NUMBER SIGN in a French Mac layout on ISO"]
  #[doc = "   keyboards, and LESS-THAN SIGN and GREATER-THAN"]
  #[doc = "   SIGN in a Swiss German, German, or French Mac"]
  #[doc = "   layout on ANSI keyboards."]
  pub const SDL_SCANCODE_GRAVE: Type = 53;
  pub const SDL_SCANCODE_COMMA: Type = 54;
  pub const SDL_SCANCODE_PERIOD: Type = 55;
  pub const SDL_SCANCODE_SLASH: Type = 56;
  pub const SDL_SCANCODE_CAPSLOCK: Type = 57;
  pub const SDL_SCANCODE_F1: Type = 58;
  pub const SDL_SCANCODE_F2: Type = 59;
  pub const SDL_SCANCODE_F3: Type = 60;
  pub const SDL_SCANCODE_F4: Type = 61;
  pub const SDL_SCANCODE_F5: Type = 62;
  pub const SDL_SCANCODE_F6: Type = 63;
  pub const SDL_SCANCODE_F7: Type = 64;
  pub const SDL_SCANCODE_F8: Type = 65;
  pub const SDL_SCANCODE_F9: Type = 66;
  pub const SDL_SCANCODE_F10: Type = 67;
  pub const SDL_SCANCODE_F11: Type = 68;
  pub const SDL_SCANCODE_F12: Type = 69;
  pub const SDL_SCANCODE_PRINTSCREEN: Type = 70;
  pub const SDL_SCANCODE_SCROLLLOCK: Type = 71;
  pub const SDL_SCANCODE_PAUSE: Type = 72;
  #[doc = "< insert on PC, help on some Mac keyboards (but"]
  #[doc = "does send code 73, not 117)"]
  pub const SDL_SCANCODE_INSERT: Type = 73;
  pub const SDL_SCANCODE_HOME: Type = 74;
  pub const SDL_SCANCODE_PAGEUP: Type = 75;
  pub const SDL_SCANCODE_DELETE: Type = 76;
  pub const SDL_SCANCODE_END: Type = 77;
  pub const SDL_SCANCODE_PAGEDOWN: Type = 78;
  pub const SDL_SCANCODE_RIGHT: Type = 79;
  pub const SDL_SCANCODE_LEFT: Type = 80;
  pub const SDL_SCANCODE_DOWN: Type = 81;
  pub const SDL_SCANCODE_UP: Type = 82;
  #[doc = "< num lock on PC, clear on Mac keyboards"]
  pub const SDL_SCANCODE_NUMLOCKCLEAR: Type = 83;
  pub const SDL_SCANCODE_KP_DIVIDE: Type = 84;
  pub const SDL_SCANCODE_KP_MULTIPLY: Type = 85;
  pub const SDL_SCANCODE_KP_MINUS: Type = 86;
  pub const SDL_SCANCODE_KP_PLUS: Type = 87;
  pub const SDL_SCANCODE_KP_ENTER: Type = 88;
  pub const SDL_SCANCODE_KP_1: Type = 89;
  pub const SDL_SCANCODE_KP_2: Type = 90;
  pub const SDL_SCANCODE_KP_3: Type = 91;
  pub const SDL_SCANCODE_KP_4: Type = 92;
  pub const SDL_SCANCODE_KP_5: Type = 93;
  pub const SDL_SCANCODE_KP_6: Type = 94;
  pub const SDL_SCANCODE_KP_7: Type = 95;
  pub const SDL_SCANCODE_KP_8: Type = 96;
  pub const SDL_SCANCODE_KP_9: Type = 97;
  pub const SDL_SCANCODE_KP_0: Type = 98;
  pub const SDL_SCANCODE_KP_PERIOD: Type = 99;
  #[doc = "< This is the additional key that ISO"]
  #[doc = "   keyboards have over ANSI ones,"]
  #[doc = "   located between left shift and Y."]
  #[doc = "   Produces GRAVE ACCENT and TILDE in a"]
  #[doc = "   US or UK Mac layout, REVERSE SOLIDUS"]
  #[doc = "   (backslash) and VERTICAL LINE in a"]
  #[doc = "   US or UK Windows layout, and"]
  #[doc = "   LESS-THAN SIGN and GREATER-THAN SIGN"]
  #[doc = "   in a Swiss German, German, or French"]
  #[doc = "   layout."]
  pub const SDL_SCANCODE_NONUSBACKSLASH: Type = 100;
  #[doc = "< windows contextual menu, compose"]
  pub const SDL_SCANCODE_APPLICATION: Type = 101;
  #[doc = "< The USB document says this is a status flag,"]
  #[doc = "   not a physical key - but some Mac keyboards"]
  #[doc = "   do have a power key."]
  pub const SDL_SCANCODE_POWER: Type = 102;
  pub const SDL_SCANCODE_KP_EQUALS: Type = 103;
  pub const SDL_SCANCODE_F13: Type = 104;
  pub const SDL_SCANCODE_F14: Type = 105;
  pub const SDL_SCANCODE_F15: Type = 106;
  pub const SDL_SCANCODE_F16: Type = 107;
  pub const SDL_SCANCODE_F17: Type = 108;
  pub const SDL_SCANCODE_F18: Type = 109;
  pub const SDL_SCANCODE_F19: Type = 110;
  pub const SDL_SCANCODE_F20: Type = 111;
  pub const SDL_SCANCODE_F21: Type = 112;
  pub const SDL_SCANCODE_F22: Type = 113;
  pub const SDL_SCANCODE_F23: Type = 114;
  pub const SDL_SCANCODE_F24: Type = 115;
  pub const SDL_SCANCODE_EXECUTE: Type = 116;
  pub const SDL_SCANCODE_HELP: Type = 117;
  pub const SDL_SCANCODE_MENU: Type = 118;
  pub const SDL_SCANCODE_SELECT: Type = 119;
  pub const SDL_SCANCODE_STOP: Type = 120;
  #[doc = "< redo"]
  pub const SDL_SCANCODE_AGAIN: Type = 121;
  pub const SDL_SCANCODE_UNDO: Type = 122;
  pub const SDL_SCANCODE_CUT: Type = 123;
  pub const SDL_SCANCODE_COPY: Type = 124;
  pub const SDL_SCANCODE_PASTE: Type = 125;
  pub const SDL_SCANCODE_FIND: Type = 126;
  pub const SDL_SCANCODE_MUTE: Type = 127;
  pub const SDL_SCANCODE_VOLUMEUP: Type = 128;
  pub const SDL_SCANCODE_VOLUMEDOWN: Type = 129;
  pub const SDL_SCANCODE_KP_COMMA: Type = 133;
  pub const SDL_SCANCODE_KP_EQUALSAS400: Type = 134;
  #[doc = "< used on Asian keyboards, see"]
  #[doc = "footnotes in USB doc"]
  pub const SDL_SCANCODE_INTERNATIONAL1: Type = 135;
  pub const SDL_SCANCODE_INTERNATIONAL2: Type = 136;
  #[doc = "< Yen"]
  pub const SDL_SCANCODE_INTERNATIONAL3: Type = 137;
  pub const SDL_SCANCODE_INTERNATIONAL4: Type = 138;
  pub const SDL_SCANCODE_INTERNATIONAL5: Type = 139;
  pub const SDL_SCANCODE_INTERNATIONAL6: Type = 140;
  pub const SDL_SCANCODE_INTERNATIONAL7: Type = 141;
  pub const SDL_SCANCODE_INTERNATIONAL8: Type = 142;
  pub const SDL_SCANCODE_INTERNATIONAL9: Type = 143;
  #[doc = "< Hangul/English toggle"]
  pub const SDL_SCANCODE_LANG1: Type = 144;
  #[doc = "< Hanja conversion"]
  pub const SDL_SCANCODE_LANG2: Type = 145;
  #[doc = "< Katakana"]
  pub const SDL_SCANCODE_LANG3: Type = 146;
  #[doc = "< Hiragana"]
  pub const SDL_SCANCODE_LANG4: Type = 147;
  #[doc = "< Zenkaku/Hankaku"]
  pub const SDL_SCANCODE_LANG5: Type = 148;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG6: Type = 149;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG7: Type = 150;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG8: Type = 151;
  #[doc = "< reserved"]
  pub const SDL_SCANCODE_LANG9: Type = 152;
  #[doc = "< Erase-Eaze"]
  pub const SDL_SCANCODE_ALTERASE: Type = 153;
  pub const SDL_SCANCODE_SYSREQ: Type = 154;
  pub const SDL_SCANCODE_CANCEL: Type = 155;
  pub const SDL_SCANCODE_CLEAR: Type = 156;
  pub const SDL_SCANCODE_PRIOR: Type = 157;
  pub const SDL_SCANCODE_RETURN2: Type = 158;
  pub const SDL_SCANCODE_SEPARATOR: Type = 159;
  pub const SDL_SCANCODE_OUT: Type = 160;
  pub const SDL_SCANCODE_OPER: Type = 161;
  pub const SDL_SCANCODE_CLEARAGAIN: Type = 162;
  pub const SDL_SCANCODE_CRSEL: Type = 163;
  pub const SDL_SCANCODE_EXSEL: Type = 164;
  pub const SDL_SCANCODE_KP_00: Type = 176;
  pub const SDL_SCANCODE_KP_000: Type = 177;
  pub const SDL_SCANCODE_THOUSANDSSEPARATOR: Type = 178;
  pub const SDL_SCANCODE_DECIMALSEPARATOR: Type = 179;
  pub const SDL_SCANCODE_CURRENCYUNIT: Type = 180;
  pub const SDL_SCANCODE_CURRENCYSUBUNIT: Type = 181;
  pub const SDL_SCANCODE_KP_LEFTPAREN: Type = 182;
  pub const SDL_SCANCODE_KP_RIGHTPAREN: Type = 183;
  pub const SDL_SCANCODE_KP_LEFTBRACE: Type = 184;
  pub const SDL_SCANCODE_KP_RIGHTBRACE: Type = 185;
  pub const SDL_SCANCODE_KP_TAB: Type = 186;
  pub const SDL_SCANCODE_KP_BACKSPACE: Type = 187;
  pub const SDL_SCANCODE_KP_A: Type = 188;
  pub const SDL_SCANCODE_KP_B: Type = 189;
  pub const SDL_SCANCODE_KP_C: Type = 190;
  pub const SDL_SCANCODE_KP_D: Type = 191;
  pub const SDL_SCANCODE_KP_E: Type = 192;
  pub const SDL_SCANCODE_KP_F: Type = 193;
  pub const SDL_SCANCODE_KP_XOR: Type = 194;
  pub const SDL_SCANCODE_KP_POWER: Type = 195;
  pub const SDL_SCANCODE_KP_PERCENT: Type = 196;
  pub const SDL_SCANCODE_KP_LESS: Type = 197;
  pub const SDL_SCANCODE_KP_GREATER: Type = 198;
  pub const SDL_SCANCODE_KP_AMPERSAND: Type = 199;
  pub const SDL_SCANCODE_KP_DBLAMPERSAND: Type = 200;
  pub const SDL_SCANCODE_KP_VERTICALBAR: Type = 201;
  pub const SDL_SCANCODE_KP_DBLVERTICALBAR: Type = 202;
  pub const SDL_SCANCODE_KP_COLON: Type = 203;
  pub const SDL_SCANCODE_KP_HASH: Type = 204;
  pub const SDL_SCANCODE_KP_SPACE: Type = 205;
  pub const SDL_SCANCODE_KP_AT: Type = 206;
  pub const SDL_SCANCODE_KP_EXCLAM: Type = 207;
  pub const SDL_SCANCODE_KP_MEMSTORE: Type = 208;
  pub const SDL_SCANCODE_KP_MEMRECALL: Type = 209;
  pub const SDL_SCANCODE_KP_MEMCLEAR: Type = 210;
  pub const SDL_SCANCODE_KP_MEMADD: Type = 211;
  pub const SDL_SCANCODE_KP_MEMSUBTRACT: Type = 212;
  pub const SDL_SCANCODE_KP_MEMMULTIPLY: Type = 213;
  pub const SDL_SCANCODE_KP_MEMDIVIDE: Type = 214;
  pub const SDL_SCANCODE_KP_PLUSMINUS: Type = 215;
  pub const SDL_SCANCODE_KP_CLEAR: Type = 216;
  pub const SDL_SCANCODE_KP_CLEARENTRY: Type = 217;
  pub const SDL_SCANCODE_KP_BINARY: Type = 218;
  pub const SDL_SCANCODE_KP_OCTAL: Type = 219;
  pub const SDL_SCANCODE_KP_DECIMAL: Type = 220;
  pub const SDL_SCANCODE_KP_HEXADECIMAL: Type = 221;
  pub const SDL_SCANCODE_LCTRL: Type = 224;
  pub const SDL_SCANCODE_LSHIFT: Type = 225;
  #[doc = "< alt, option"]
  pub const SDL_SCANCODE_LALT: Type = 226;
  #[doc = "< windows, command (apple), meta"]
  pub const SDL_SCANCODE_LGUI: Type = 227;
  pub const SDL_SCANCODE_RCTRL: Type = 228;
  pub const SDL_SCANCODE_RSHIFT: Type = 229;
  #[doc = "< alt gr, option"]
  pub const SDL_SCANCODE_RALT: Type = 230;
  #[doc = "< windows, command (apple), meta"]
  pub const SDL_SCANCODE_RGUI: Type = 231;
  #[doc = "< I\'m not sure if this is really not covered"]
  #[doc = "   by any of the above, but since there\'s a"]
  #[doc = "   special KMOD_MODE for it I\'m adding it here"]
  pub const SDL_SCANCODE_MODE: Type = 257;
  pub const SDL_SCANCODE_AUDIONEXT: Type = 258;
  pub const SDL_SCANCODE_AUDIOPREV: Type = 259;
  pub const SDL_SCANCODE_AUDIOSTOP: Type = 260;
  pub const SDL_SCANCODE_AUDIOPLAY: Type = 261;
  pub const SDL_SCANCODE_AUDIOMUTE: Type = 262;
  pub const SDL_SCANCODE_MEDIASELECT: Type = 263;
  pub const SDL_SCANCODE_WWW: Type = 264;
  pub const SDL_SCANCODE_MAIL: Type = 265;
  pub const SDL_SCANCODE_CALCULATOR: Type = 266;
  pub const SDL_SCANCODE_COMPUTER: Type = 267;
  pub const SDL_SCANCODE_AC_SEARCH: Type = 268;
  pub const SDL_SCANCODE_AC_HOME: Type = 269;
  pub const SDL_SCANCODE_AC_BACK: Type = 270;
  pub const SDL_SCANCODE_AC_FORWARD: Type = 271;
  pub const SDL_SCANCODE_AC_STOP: Type = 272;
  pub const SDL_SCANCODE_AC_REFRESH: Type = 273;
  pub const SDL_SCANCODE_AC_BOOKMARKS: Type = 274;
  pub const SDL_SCANCODE_BRIGHTNESSDOWN: Type = 275;
  pub const SDL_SCANCODE_BRIGHTNESSUP: Type = 276;
  #[doc = "< display mirroring/dual display"]
  #[doc = "switch, video mode switch"]
  pub const SDL_SCANCODE_DISPLAYSWITCH: Type = 277;
  pub const SDL_SCANCODE_KBDILLUMTOGGLE: Type = 278;
  pub const SDL_SCANCODE_KBDILLUMDOWN: Type = 279;
  pub const SDL_SCANCODE_KBDILLUMUP: Type = 280;
  pub const SDL_SCANCODE_EJECT: Type = 281;
  pub const SDL_SCANCODE_SLEEP: Type = 282;
  pub const SDL_SCANCODE_APP1: Type = 283;
  pub const SDL_SCANCODE_APP2: Type = 284;
  pub const SDL_SCANCODE_AUDIOREWIND: Type = 285;
  pub const SDL_SCANCODE_AUDIOFASTFORWARD: Type = 286;
  #[doc = "< not a key, just marks the number of scancodes"]
  #[doc = "for array bounds"]
  pub const SDL_NUM_SCANCODES: Type = 512;
}
#[doc = "  \\brief The SDL virtual key representation."]
#[doc = ""]
#[doc = "  Values of this type are used to represent keyboard keys using the current"]
#[doc = "  layout of the keyboard.  These values include Unicode values representing"]
#[doc = "  the unmodified character that would be generated by pressing the key, or"]
#[doc = "  an SDLK_* constant for those keys that do not generate characters."]
#[doc = ""]
#[doc = "  A special exception is the number keys at the top of the keyboard which"]
#[doc = "  always map to SDLK_0...SDLK_9, regardless of layout."]
pub type SDL_Keycode = Sint32;
pub mod _bindgen_ty_7 {
  pub type Type = i32;
  pub const SDLK_UNKNOWN: Type = 0;
  pub const SDLK_RETURN: Type = 13;
  pub const SDLK_ESCAPE: Type = 27;
  pub const SDLK_BACKSPACE: Type = 8;
  pub const SDLK_TAB: Type = 9;
  pub const SDLK_SPACE: Type = 32;
  pub const SDLK_EXCLAIM: Type = 33;
  pub const SDLK_QUOTEDBL: Type = 34;
  pub const SDLK_HASH: Type = 35;
  pub const SDLK_PERCENT: Type = 37;
  pub const SDLK_DOLLAR: Type = 36;
  pub const SDLK_AMPERSAND: Type = 38;
  pub const SDLK_QUOTE: Type = 39;
  pub const SDLK_LEFTPAREN: Type = 40;
  pub const SDLK_RIGHTPAREN: Type = 41;
  pub const SDLK_ASTERISK: Type = 42;
  pub const SDLK_PLUS: Type = 43;
  pub const SDLK_COMMA: Type = 44;
  pub const SDLK_MINUS: Type = 45;
  pub const SDLK_PERIOD: Type = 46;
  pub const SDLK_SLASH: Type = 47;
  pub const SDLK_0: Type = 48;
  pub const SDLK_1: Type = 49;
  pub const SDLK_2: Type = 50;
  pub const SDLK_3: Type = 51;
  pub const SDLK_4: Type = 52;
  pub const SDLK_5: Type = 53;
  pub const SDLK_6: Type = 54;
  pub const SDLK_7: Type = 55;
  pub const SDLK_8: Type = 56;
  pub const SDLK_9: Type = 57;
  pub const SDLK_COLON: Type = 58;
  pub const SDLK_SEMICOLON: Type = 59;
  pub const SDLK_LESS: Type = 60;
  pub const SDLK_EQUALS: Type = 61;
  pub const SDLK_GREATER: Type = 62;
  pub const SDLK_QUESTION: Type = 63;
  pub const SDLK_AT: Type = 64;
  pub const SDLK_LEFTBRACKET: Type = 91;
  pub const SDLK_BACKSLASH: Type = 92;
  pub const SDLK_RIGHTBRACKET: Type = 93;
  pub const SDLK_CARET: Type = 94;
  pub const SDLK_UNDERSCORE: Type = 95;
  pub const SDLK_BACKQUOTE: Type = 96;
  pub const SDLK_a: Type = 97;
  pub const SDLK_b: Type = 98;
  pub const SDLK_c: Type = 99;
  pub const SDLK_d: Type = 100;
  pub const SDLK_e: Type = 101;
  pub const SDLK_f: Type = 102;
  pub const SDLK_g: Type = 103;
  pub const SDLK_h: Type = 104;
  pub const SDLK_i: Type = 105;
  pub const SDLK_j: Type = 106;
  pub const SDLK_k: Type = 107;
  pub const SDLK_l: Type = 108;
  pub const SDLK_m: Type = 109;
  pub const SDLK_n: Type = 110;
  pub const SDLK_o: Type = 111;
  pub const SDLK_p: Type = 112;
  pub const SDLK_q: Type = 113;
  pub const SDLK_r: Type = 114;
  pub const SDLK_s: Type = 115;
  pub const SDLK_t: Type = 116;
  pub const SDLK_u: Type = 117;
  pub const SDLK_v: Type = 118;
  pub const SDLK_w: Type = 119;
  pub const SDLK_x: Type = 120;
  pub const SDLK_y: Type = 121;
  pub const SDLK_z: Type = 122;
  pub const SDLK_CAPSLOCK: Type = 1073741881;
  pub const SDLK_F1: Type = 1073741882;
  pub const SDLK_F2: Type = 1073741883;
  pub const SDLK_F3: Type = 1073741884;
  pub const SDLK_F4: Type = 1073741885;
  pub const SDLK_F5: Type = 1073741886;
  pub const SDLK_F6: Type = 1073741887;
  pub const SDLK_F7: Type = 1073741888;
  pub const SDLK_F8: Type = 1073741889;
  pub const SDLK_F9: Type = 1073741890;
  pub const SDLK_F10: Type = 1073741891;
  pub const SDLK_F11: Type = 1073741892;
  pub const SDLK_F12: Type = 1073741893;
  pub const SDLK_PRINTSCREEN: Type = 1073741894;
  pub const SDLK_SCROLLLOCK: Type = 1073741895;
  pub const SDLK_PAUSE: Type = 1073741896;
  pub const SDLK_INSERT: Type = 1073741897;
  pub const SDLK_HOME: Type = 1073741898;
  pub const SDLK_PAGEUP: Type = 1073741899;
  pub const SDLK_DELETE: Type = 127;
  pub const SDLK_END: Type = 1073741901;
  pub const SDLK_PAGEDOWN: Type = 1073741902;
  pub const SDLK_RIGHT: Type = 1073741903;
  pub const SDLK_LEFT: Type = 1073741904;
  pub const SDLK_DOWN: Type = 1073741905;
  pub const SDLK_UP: Type = 1073741906;
  pub const SDLK_NUMLOCKCLEAR: Type = 1073741907;
  pub const SDLK_KP_DIVIDE: Type = 1073741908;
  pub const SDLK_KP_MULTIPLY: Type = 1073741909;
  pub const SDLK_KP_MINUS: Type = 1073741910;
  pub const SDLK_KP_PLUS: Type = 1073741911;
  pub const SDLK_KP_ENTER: Type = 1073741912;
  pub const SDLK_KP_1: Type = 1073741913;
  pub const SDLK_KP_2: Type = 1073741914;
  pub const SDLK_KP_3: Type = 1073741915;
  pub const SDLK_KP_4: Type = 1073741916;
  pub const SDLK_KP_5: Type = 1073741917;
  pub const SDLK_KP_6: Type = 1073741918;
  pub const SDLK_KP_7: Type = 1073741919;
  pub const SDLK_KP_8: Type = 1073741920;
  pub const SDLK_KP_9: Type = 1073741921;
  pub const SDLK_KP_0: Type = 1073741922;
  pub const SDLK_KP_PERIOD: Type = 1073741923;
  pub const SDLK_APPLICATION: Type = 1073741925;
  pub const SDLK_POWER: Type = 1073741926;
  pub const SDLK_KP_EQUALS: Type = 1073741927;
  pub const SDLK_F13: Type = 1073741928;
  pub const SDLK_F14: Type = 1073741929;
  pub const SDLK_F15: Type = 1073741930;
  pub const SDLK_F16: Type = 1073741931;
  pub const SDLK_F17: Type = 1073741932;
  pub const SDLK_F18: Type = 1073741933;
  pub const SDLK_F19: Type = 1073741934;
  pub const SDLK_F20: Type = 1073741935;
  pub const SDLK_F21: Type = 1073741936;
  pub const SDLK_F22: Type = 1073741937;
  pub const SDLK_F23: Type = 1073741938;
  pub const SDLK_F24: Type = 1073741939;
  pub const SDLK_EXECUTE: Type = 1073741940;
  pub const SDLK_HELP: Type = 1073741941;
  pub const SDLK_MENU: Type = 1073741942;
  pub const SDLK_SELECT: Type = 1073741943;
  pub const SDLK_STOP: Type = 1073741944;
  pub const SDLK_AGAIN: Type = 1073741945;
  pub const SDLK_UNDO: Type = 1073741946;
  pub const SDLK_CUT: Type = 1073741947;
  pub const SDLK_COPY: Type = 1073741948;
  pub const SDLK_PASTE: Type = 1073741949;
  pub const SDLK_FIND: Type = 1073741950;
  pub const SDLK_MUTE: Type = 1073741951;
  pub const SDLK_VOLUMEUP: Type = 1073741952;
  pub const SDLK_VOLUMEDOWN: Type = 1073741953;
  pub const SDLK_KP_COMMA: Type = 1073741957;
  pub const SDLK_KP_EQUALSAS400: Type = 1073741958;
  pub const SDLK_ALTERASE: Type = 1073741977;
  pub const SDLK_SYSREQ: Type = 1073741978;
  pub const SDLK_CANCEL: Type = 1073741979;
  pub const SDLK_CLEAR: Type = 1073741980;
  pub const SDLK_PRIOR: Type = 1073741981;
  pub const SDLK_RETURN2: Type = 1073741982;
  pub const SDLK_SEPARATOR: Type = 1073741983;
  pub const SDLK_OUT: Type = 1073741984;
  pub const SDLK_OPER: Type = 1073741985;
  pub const SDLK_CLEARAGAIN: Type = 1073741986;
  pub const SDLK_CRSEL: Type = 1073741987;
  pub const SDLK_EXSEL: Type = 1073741988;
  pub const SDLK_KP_00: Type = 1073742000;
  pub const SDLK_KP_000: Type = 1073742001;
  pub const SDLK_THOUSANDSSEPARATOR: Type = 1073742002;
  pub const SDLK_DECIMALSEPARATOR: Type = 1073742003;
  pub const SDLK_CURRENCYUNIT: Type = 1073742004;
  pub const SDLK_CURRENCYSUBUNIT: Type = 1073742005;
  pub const SDLK_KP_LEFTPAREN: Type = 1073742006;
  pub const SDLK_KP_RIGHTPAREN: Type = 1073742007;
  pub const SDLK_KP_LEFTBRACE: Type = 1073742008;
  pub const SDLK_KP_RIGHTBRACE: Type = 1073742009;
  pub const SDLK_KP_TAB: Type = 1073742010;
  pub const SDLK_KP_BACKSPACE: Type = 1073742011;
  pub const SDLK_KP_A: Type = 1073742012;
  pub const SDLK_KP_B: Type = 1073742013;
  pub const SDLK_KP_C: Type = 1073742014;
  pub const SDLK_KP_D: Type = 1073742015;
  pub const SDLK_KP_E: Type = 1073742016;
  pub const SDLK_KP_F: Type = 1073742017;
  pub const SDLK_KP_XOR: Type = 1073742018;
  pub const SDLK_KP_POWER: Type = 1073742019;
  pub const SDLK_KP_PERCENT: Type = 1073742020;
  pub const SDLK_KP_LESS: Type = 1073742021;
  pub const SDLK_KP_GREATER: Type = 1073742022;
  pub const SDLK_KP_AMPERSAND: Type = 1073742023;
  pub const SDLK_KP_DBLAMPERSAND: Type = 1073742024;
  pub const SDLK_KP_VERTICALBAR: Type = 1073742025;
  pub const SDLK_KP_DBLVERTICALBAR: Type = 1073742026;
  pub const SDLK_KP_COLON: Type = 1073742027;
  pub const SDLK_KP_HASH: Type = 1073742028;
  pub const SDLK_KP_SPACE: Type = 1073742029;
  pub const SDLK_KP_AT: Type = 1073742030;
  pub const SDLK_KP_EXCLAM: Type = 1073742031;
  pub const SDLK_KP_MEMSTORE: Type = 1073742032;
  pub const SDLK_KP_MEMRECALL: Type = 1073742033;
  pub const SDLK_KP_MEMCLEAR: Type = 1073742034;
  pub const SDLK_KP_MEMADD: Type = 1073742035;
  pub const SDLK_KP_MEMSUBTRACT: Type = 1073742036;
  pub const SDLK_KP_MEMMULTIPLY: Type = 1073742037;
  pub const SDLK_KP_MEMDIVIDE: Type = 1073742038;
  pub const SDLK_KP_PLUSMINUS: Type = 1073742039;
  pub const SDLK_KP_CLEAR: Type = 1073742040;
  pub const SDLK_KP_CLEARENTRY: Type = 1073742041;
  pub const SDLK_KP_BINARY: Type = 1073742042;
  pub const SDLK_KP_OCTAL: Type = 1073742043;
  pub const SDLK_KP_DECIMAL: Type = 1073742044;
  pub const SDLK_KP_HEXADECIMAL: Type = 1073742045;
  pub const SDLK_LCTRL: Type = 1073742048;
  pub const SDLK_LSHIFT: Type = 1073742049;
  pub const SDLK_LALT: Type = 1073742050;
  pub const SDLK_LGUI: Type = 1073742051;
  pub const SDLK_RCTRL: Type = 1073742052;
  pub const SDLK_RSHIFT: Type = 1073742053;
  pub const SDLK_RALT: Type = 1073742054;
  pub const SDLK_RGUI: Type = 1073742055;
  pub const SDLK_MODE: Type = 1073742081;
  pub const SDLK_AUDIONEXT: Type = 1073742082;
  pub const SDLK_AUDIOPREV: Type = 1073742083;
  pub const SDLK_AUDIOSTOP: Type = 1073742084;
  pub const SDLK_AUDIOPLAY: Type = 1073742085;
  pub const SDLK_AUDIOMUTE: Type = 1073742086;
  pub const SDLK_MEDIASELECT: Type = 1073742087;
  pub const SDLK_WWW: Type = 1073742088;
  pub const SDLK_MAIL: Type = 1073742089;
  pub const SDLK_CALCULATOR: Type = 1073742090;
  pub const SDLK_COMPUTER: Type = 1073742091;
  pub const SDLK_AC_SEARCH: Type = 1073742092;
  pub const SDLK_AC_HOME: Type = 1073742093;
  pub const SDLK_AC_BACK: Type = 1073742094;
  pub const SDLK_AC_FORWARD: Type = 1073742095;
  pub const SDLK_AC_STOP: Type = 1073742096;
  pub const SDLK_AC_REFRESH: Type = 1073742097;
  pub const SDLK_AC_BOOKMARKS: Type = 1073742098;
  pub const SDLK_BRIGHTNESSDOWN: Type = 1073742099;
  pub const SDLK_BRIGHTNESSUP: Type = 1073742100;
  pub const SDLK_DISPLAYSWITCH: Type = 1073742101;
  pub const SDLK_KBDILLUMTOGGLE: Type = 1073742102;
  pub const SDLK_KBDILLUMDOWN: Type = 1073742103;
  pub const SDLK_KBDILLUMUP: Type = 1073742104;
  pub const SDLK_EJECT: Type = 1073742105;
  pub const SDLK_SLEEP: Type = 1073742106;
  pub const SDLK_APP1: Type = 1073742107;
  pub const SDLK_APP2: Type = 1073742108;
  pub const SDLK_AUDIOREWIND: Type = 1073742109;
  pub const SDLK_AUDIOFASTFORWARD: Type = 1073742110;
}
pub mod SDL_Keymod {
  #[doc = " \\brief Enumeration of valid key mods (possibly OR\'d together)."]
  pub type Type = i32;
  pub const KMOD_NONE: Type = 0;
  pub const KMOD_LSHIFT: Type = 1;
  pub const KMOD_RSHIFT: Type = 2;
  pub const KMOD_LCTRL: Type = 64;
  pub const KMOD_RCTRL: Type = 128;
  pub const KMOD_LALT: Type = 256;
  pub const KMOD_RALT: Type = 512;
  pub const KMOD_LGUI: Type = 1024;
  pub const KMOD_RGUI: Type = 2048;
  pub const KMOD_NUM: Type = 4096;
  pub const KMOD_CAPS: Type = 8192;
  pub const KMOD_MODE: Type = 16384;
  pub const KMOD_RESERVED: Type = 32768;
}
#[doc = "  \\brief The SDL keysym structure, used in key events."]
#[doc = ""]
#[doc = "  \\note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_Keysym {
  #[doc = "< SDL physical key code - see ::SDL_Scancode for details"]
  pub scancode: SDL_Scancode::Type,
  #[doc = "< SDL virtual key code - see ::SDL_Keycode for details"]
  pub sym: SDL_Keycode,
  #[doc = "< current key modifiers"]
  pub mod_: Uint16,
  pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Keysym>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_Keysym))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Keysym>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_Keysym))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).scancode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(scancode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).sym as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(sym)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).mod_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(mod_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).unused as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Keysym),
      "::",
      stringify!(unused)
    )
  );
}
impl Default for SDL_Keysym {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[doc = "  \\brief Get the window which currently has keyboard focus."]
  pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Get a snapshot of the current state of the keyboard."]
  #[doc = ""]
  #[doc = "  \\param numkeys if non-NULL, receives the length of the returned array."]
  #[doc = ""]
  #[doc = "  \\return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values."]
  #[doc = ""]
  #[doc = "  \\b Example:"]
  #[doc = "  \\code"]
  #[doc = "  const Uint8 *state = SDL_GetKeyboardState(NULL);"]
  #[doc = "  if ( state[SDL_SCANCODE_RETURN] )   {"]
  #[doc = "      printf(\"<RETURN> is pressed.\\n\");"]
  #[doc = "  }"]
  #[doc = "  \\endcode"]
  pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const Uint8;
}
extern "C" {
  #[doc = "  \\brief Get the current key modifier state for the keyboard."]
  pub fn SDL_GetModState() -> SDL_Keymod::Type;
}
extern "C" {
  #[doc = "  \\brief Set the current key modifier state for the keyboard."]
  #[doc = ""]
  #[doc = "  \\note This does not change the keyboard state, only the key modifier flags."]
  pub fn SDL_SetModState(modstate: SDL_Keymod::Type);
}
extern "C" {
  #[doc = "  \\brief Get the key code corresponding to the given scancode according"]
  #[doc = "         to the current keyboard layout."]
  #[doc = ""]
  #[doc = "  See ::SDL_Keycode for details."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetKeyName()"]
  pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode::Type) -> SDL_Keycode;
}
extern "C" {
  #[doc = "  \\brief Get the scancode corresponding to the given key code according to the"]
  #[doc = "         current keyboard layout."]
  #[doc = ""]
  #[doc = "  See ::SDL_Scancode for details."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetScancodeName()"]
  pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode::Type;
}
extern "C" {
  #[doc = "  \\brief Get a human-readable name for a scancode."]
  #[doc = ""]
  #[doc = "  \\return A pointer to the name for the scancode."]
  #[doc = "          If the scancode doesn\'t have a name, this function returns"]
  #[doc = "          an empty string (\"\")."]
  #[doc = ""]
  #[doc = "  \\sa SDL_Scancode"]
  pub fn SDL_GetScancodeName(scancode: SDL_Scancode::Type) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get a scancode from a human-readable name"]
  #[doc = ""]
  #[doc = "  \\return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn\'t recognized"]
  #[doc = ""]
  #[doc = "  \\sa SDL_Scancode"]
  pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode::Type;
}
extern "C" {
  #[doc = "  \\brief Get a human-readable name for a key."]
  #[doc = ""]
  #[doc = "  \\return A pointer to a UTF-8 string that stays valid at least until the next"]
  #[doc = "          call to this function. If you need it around any longer, you must"]
  #[doc = "          copy it.  If the key doesn\'t have a name, this function returns an"]
  #[doc = "          empty string (\"\")."]
  #[doc = ""]
  #[doc = "  \\sa SDL_Keycode"]
  pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get a key code from a human-readable name"]
  #[doc = ""]
  #[doc = "  \\return key code, or SDLK_UNKNOWN if the name wasn\'t recognized"]
  #[doc = ""]
  #[doc = "  \\sa SDL_Keycode"]
  pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
extern "C" {
  #[doc = "  \\brief Start accepting Unicode text input events."]
  #[doc = "         This function will show the on-screen keyboard if supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StopTextInput()"]
  #[doc = "  \\sa SDL_SetTextInputRect()"]
  #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
  pub fn SDL_StartTextInput();
}
extern "C" {
  #[doc = "  \\brief Return whether or not Unicode text input events are enabled."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StartTextInput()"]
  #[doc = "  \\sa SDL_StopTextInput()"]
  pub fn SDL_IsTextInputActive() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Stop receiving any text input events."]
  #[doc = "         This function will hide the on-screen keyboard if supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StartTextInput()"]
  #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
  pub fn SDL_StopTextInput();
}
extern "C" {
  #[doc = "  \\brief Set the rectangle used to type Unicode text inputs."]
  #[doc = "         This is used as a hint for IME and on-screen keyboard placement."]
  #[doc = ""]
  #[doc = "  \\sa SDL_StartTextInput()"]
  pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Returns whether the platform has some screen keyboard support."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if some keyboard support is available else SDL_FALSE."]
  #[doc = ""]
  #[doc = "  \\note Not all screen keyboard functions are supported on all platforms."]
  #[doc = ""]
  #[doc = "  \\sa SDL_IsScreenKeyboardShown()"]
  pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Returns whether the screen keyboard is shown for given window."]
  #[doc = ""]
  #[doc = "  \\param window The window for which screen keyboard should be queried."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if screen keyboard is shown else SDL_FALSE."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HasScreenKeyboardSupport()"]
  pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
  _unused: [u8; 0],
}
pub mod SDL_SystemCursor {
  #[doc = " \\brief Cursor types for SDL_CreateSystemCursor()."]
  pub type Type = i32;
  #[doc = "< Arrow"]
  pub const SDL_SYSTEM_CURSOR_ARROW: Type = 0;
  #[doc = "< I-beam"]
  pub const SDL_SYSTEM_CURSOR_IBEAM: Type = 1;
  #[doc = "< Wait"]
  pub const SDL_SYSTEM_CURSOR_WAIT: Type = 2;
  #[doc = "< Crosshair"]
  pub const SDL_SYSTEM_CURSOR_CROSSHAIR: Type = 3;
  #[doc = "< Small wait cursor (or Wait if not available)"]
  pub const SDL_SYSTEM_CURSOR_WAITARROW: Type = 4;
  #[doc = "< Double arrow pointing northwest and southeast"]
  pub const SDL_SYSTEM_CURSOR_SIZENWSE: Type = 5;
  #[doc = "< Double arrow pointing northeast and southwest"]
  pub const SDL_SYSTEM_CURSOR_SIZENESW: Type = 6;
  #[doc = "< Double arrow pointing west and east"]
  pub const SDL_SYSTEM_CURSOR_SIZEWE: Type = 7;
  #[doc = "< Double arrow pointing north and south"]
  pub const SDL_SYSTEM_CURSOR_SIZENS: Type = 8;
  #[doc = "< Four pointed arrow pointing north, south, east, and west"]
  pub const SDL_SYSTEM_CURSOR_SIZEALL: Type = 9;
  #[doc = "< Slashed circle or crossbones"]
  pub const SDL_SYSTEM_CURSOR_NO: Type = 10;
  #[doc = "< Hand"]
  pub const SDL_SYSTEM_CURSOR_HAND: Type = 11;
  pub const SDL_NUM_SYSTEM_CURSORS: Type = 12;
}
pub mod SDL_MouseWheelDirection {
  #[doc = " \\brief Scroll direction types for the Scroll event"]
  pub type Type = i32;
  #[doc = "< The scroll direction is normal"]
  pub const SDL_MOUSEWHEEL_NORMAL: Type = 0;
  #[doc = "< The scroll direction is flipped / natural"]
  pub const SDL_MOUSEWHEEL_FLIPPED: Type = 1;
}
extern "C" {
  #[doc = "  \\brief Get the window which currently has mouse focus."]
  pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
  #[doc = "  \\brief Retrieve the current state of the mouse."]
  #[doc = ""]
  #[doc = "  The current button state is returned as a button bitmask, which can"]
  #[doc = "  be tested using the SDL_BUTTON(X) macros, and x and y are set to the"]
  #[doc = "  mouse cursor position relative to the focus window for the currently"]
  #[doc = "  selected mouse.  You can pass NULL for either x or y."]
  pub fn SDL_GetMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Get the current state of the mouse, in relation to the desktop"]
  #[doc = ""]
  #[doc = "  This works just like SDL_GetMouseState(), but the coordinates will be"]
  #[doc = "  reported relative to the top-left of the desktop. This can be useful if"]
  #[doc = "  you need to track the mouse outside of a specific window and"]
  #[doc = "  SDL_CaptureMouse() doesn\'t fit your needs. For example, it could be"]
  #[doc = "  useful if you need to track the mouse while dragging a window, where"]
  #[doc = "  coordinates relative to a window might not be in sync at all times."]
  #[doc = ""]
  #[doc = "  \\note SDL_GetMouseState() returns the mouse position as SDL understands"]
  #[doc = "        it from the last pump of the event queue. This function, however,"]
  #[doc = "        queries the OS for the current mouse position, and as such, might"]
  #[doc = "        be a slightly less efficient function. Unless you know what you\'re"]
  #[doc = "        doing and have a good reason to use this function, you probably want"]
  #[doc = "        SDL_GetMouseState() instead."]
  #[doc = ""]
  #[doc = "  \\param x Returns the current X coord, relative to the desktop. Can be NULL."]
  #[doc = "  \\param y Returns the current Y coord, relative to the desktop. Can be NULL."]
  #[doc = "  \\return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetMouseState"]
  pub fn SDL_GetGlobalMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Retrieve the relative state of the mouse."]
  #[doc = ""]
  #[doc = "  The current button state is returned as a button bitmask, which can"]
  #[doc = "  be tested using the SDL_BUTTON(X) macros, and x and y are set to the"]
  #[doc = "  mouse deltas since the last call to SDL_GetRelativeMouseState()."]
  pub fn SDL_GetRelativeMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = "  \\brief Moves the mouse to the given position within the window."]
  #[doc = ""]
  #[doc = "  \\param window The window to move the mouse into, or NULL for the current mouse focus"]
  #[doc = "  \\param x The x coordinate within the window"]
  #[doc = "  \\param y The y coordinate within the window"]
  #[doc = ""]
  #[doc = "  \\note This function generates a mouse motion event"]
  pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Moves the mouse to the given position in global screen space."]
  #[doc = ""]
  #[doc = "  \\param x The x coordinate"]
  #[doc = "  \\param y The y coordinate"]
  #[doc = "  \\return 0 on success, -1 on error (usually: unsupported by a platform)."]
  #[doc = ""]
  #[doc = "  \\note This function generates a mouse motion event"]
  pub fn SDL_WarpMouseGlobal(x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set relative mouse mode."]
  #[doc = ""]
  #[doc = "  \\param enabled Whether or not to enable relative mode"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if relative mode is not supported."]
  #[doc = ""]
  #[doc = "  While the mouse is in relative mode, the cursor is hidden, and the"]
  #[doc = "  driver will try to report continuous motion in the current window."]
  #[doc = "  Only relative motion events will be delivered, the mouse position"]
  #[doc = "  will not change."]
  #[doc = ""]
  #[doc = "  \\note This function will flush any pending mouse motion."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRelativeMouseMode()"]
  pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool::Type) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Capture the mouse, to track input outside an SDL window."]
  #[doc = ""]
  #[doc = "  \\param enabled Whether or not to enable capturing"]
  #[doc = ""]
  #[doc = "  Capturing enables your app to obtain mouse events globally, instead of"]
  #[doc = "  just within your window. Not all video targets support this function."]
  #[doc = "  When capturing is enabled, the current window will get all mouse events,"]
  #[doc = "  but unlike relative mode, no change is made to the cursor and it is"]
  #[doc = "  not restrained to your window."]
  #[doc = ""]
  #[doc = "  This function may also deny mouse input to other windows--both those in"]
  #[doc = "  your application and others on the system--so you should use this"]
  #[doc = "  function sparingly, and in small bursts. For example, you might want to"]
  #[doc = "  track the mouse while the user is dragging something, until the user"]
  #[doc = "  releases a mouse button. It is not recommended that you capture the mouse"]
  #[doc = "  for long periods of time, such as the entire time your app is running."]
  #[doc = ""]
  #[doc = "  While captured, mouse events still report coordinates relative to the"]
  #[doc = "  current (foreground) window, but those coordinates may be outside the"]
  #[doc = "  bounds of the window (including negative values). Capturing is only"]
  #[doc = "  allowed for the foreground window. If the window loses focus while"]
  #[doc = "  capturing, the capture will be disabled automatically."]
  #[doc = ""]
  #[doc = "  While capturing is enabled, the current window will have the"]
  #[doc = "  SDL_WINDOW_MOUSE_CAPTURE flag set."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if not supported."]
  pub fn SDL_CaptureMouse(enabled: SDL_bool::Type) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Query whether relative mouse mode is enabled."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetRelativeMouseMode()"]
  pub fn SDL_GetRelativeMouseMode() -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Create a cursor, using the specified bitmap data and"]
  #[doc = "         mask (in MSB format)."]
  #[doc = ""]
  #[doc = "  The cursor width must be a multiple of 8 bits."]
  #[doc = ""]
  #[doc = "  The cursor is created in black and white according to the following:"]
  #[doc = "  <table>"]
  #[doc = "  <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>"]
  #[doc = "  <tr><td>  0   </td><td>  1   </td><td> White </td></tr>"]
  #[doc = "  <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>"]
  #[doc = "  <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>"]
  #[doc = "  <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black"]
  #[doc = "                                         if not. </td></tr>"]
  #[doc = "  </table>"]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreeCursor()"]
  pub fn SDL_CreateCursor(
    data: *const Uint8, mask: *const Uint8, w: libc::c_int, h: libc::c_int, hot_x: libc::c_int,
    hot_y: libc::c_int,
  ) -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Create a color cursor."]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreeCursor()"]
  pub fn SDL_CreateColorCursor(
    surface: *mut SDL_Surface, hot_x: libc::c_int, hot_y: libc::c_int,
  ) -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Create a system cursor."]
  #[doc = ""]
  #[doc = "  \\sa SDL_FreeCursor()"]
  pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor::Type) -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Set the active cursor."]
  pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
  #[doc = "  \\brief Return the active cursor."]
  pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Return the default cursor."]
  pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
  #[doc = "  \\brief Frees a cursor created with SDL_CreateCursor() or similar functions."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateCursor()"]
  #[doc = "  \\sa SDL_CreateColorCursor()"]
  #[doc = "  \\sa SDL_CreateSystemCursor()"]
  pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
  #[doc = "  \\brief Toggle whether or not the cursor is shown."]
  #[doc = ""]
  #[doc = "  \\param toggle 1 to show the cursor, 0 to hide it, -1 to query the current"]
  #[doc = "                state."]
  #[doc = ""]
  #[doc = "  \\return 1 if the cursor is shown, or 0 if the cursor is hidden."]
  pub fn SDL_ShowCursor(toggle: libc::c_int) -> libc::c_int;
}
#[doc = " The joystick structure used to identify an SDL joystick"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
  _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoystickGUID {
  pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoystickGUID>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoystickGUID))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoystickGUID>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_JoystickGUID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoystickGUID>())).data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoystickGUID),
      "::",
      stringify!(data)
    )
  );
}
#[doc = " This is a unique ID for a joystick for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application. If the joystick is"]
#[doc = " disconnected and reconnected, it will get a new ID."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_JoystickID = Sint32;
pub mod SDL_JoystickType {
  pub type Type = i32;
  pub const SDL_JOYSTICK_TYPE_UNKNOWN: Type = 0;
  pub const SDL_JOYSTICK_TYPE_GAMECONTROLLER: Type = 1;
  pub const SDL_JOYSTICK_TYPE_WHEEL: Type = 2;
  pub const SDL_JOYSTICK_TYPE_ARCADE_STICK: Type = 3;
  pub const SDL_JOYSTICK_TYPE_FLIGHT_STICK: Type = 4;
  pub const SDL_JOYSTICK_TYPE_DANCE_PAD: Type = 5;
  pub const SDL_JOYSTICK_TYPE_GUITAR: Type = 6;
  pub const SDL_JOYSTICK_TYPE_DRUM_KIT: Type = 7;
  pub const SDL_JOYSTICK_TYPE_ARCADE_PAD: Type = 8;
  pub const SDL_JOYSTICK_TYPE_THROTTLE: Type = 9;
}
pub mod SDL_JoystickPowerLevel {
  pub type Type = i32;
  pub const SDL_JOYSTICK_POWER_UNKNOWN: Type = -1;
  pub const SDL_JOYSTICK_POWER_EMPTY: Type = 0;
  pub const SDL_JOYSTICK_POWER_LOW: Type = 1;
  pub const SDL_JOYSTICK_POWER_MEDIUM: Type = 2;
  pub const SDL_JOYSTICK_POWER_FULL: Type = 3;
  pub const SDL_JOYSTICK_POWER_WIRED: Type = 4;
  pub const SDL_JOYSTICK_POWER_MAX: Type = 5;
}
extern "C" {
  #[doc = " Locking for multi-threaded access to the joystick API"]
  #[doc = ""]
  #[doc = " If you are using the joystick API or handling events from multiple threads"]
  #[doc = " you should use these locking functions to protect access to the joysticks."]
  #[doc = ""]
  #[doc = " In particular, you are guaranteed that the joystick list won\'t change, so"]
  #[doc = " the API functions that take a joystick index will be valid, and joystick"]
  #[doc = " and game controller events will not be delivered."]
  pub fn SDL_LockJoysticks();
}
extern "C" {
  pub fn SDL_UnlockJoysticks();
}
extern "C" {
  #[doc = "  Count the number of joysticks attached to the system right now"]
  pub fn SDL_NumJoysticks() -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the implementation dependent name of a joystick."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If no name can be found, this function returns NULL."]
  pub fn SDL_JoystickNameForIndex(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the player index of a joystick, or -1 if it\'s not available"]
  #[doc = "  This can be called before any joysticks are opened."]
  pub fn SDL_JoystickGetDevicePlayerIndex(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Return the GUID for the joystick at this index"]
  #[doc = "  This can be called before any joysticks are opened."]
  pub fn SDL_JoystickGetDeviceGUID(device_index: libc::c_int) -> SDL_JoystickGUID;
}
extern "C" {
  #[doc = "  Get the USB vendor ID of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the vendor ID isn\'t available this function returns 0."]
  pub fn SDL_JoystickGetDeviceVendor(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  #[doc = "  Get the USB product ID of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the product ID isn\'t available this function returns 0."]
  pub fn SDL_JoystickGetDeviceProduct(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  #[doc = "  Get the product version of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the product version isn\'t available this function returns 0."]
  pub fn SDL_JoystickGetDeviceProductVersion(device_index: libc::c_int) -> Uint16;
}
extern "C" {
  #[doc = "  Get the type of a joystick, if available."]
  #[doc = "  This can be called before any joysticks are opened."]
  pub fn SDL_JoystickGetDeviceType(device_index: libc::c_int) -> SDL_JoystickType::Type;
}
extern "C" {
  #[doc = "  Get the instance ID of a joystick."]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If the index is out of range, this function will return -1."]
  pub fn SDL_JoystickGetDeviceInstanceID(device_index: libc::c_int) -> SDL_JoystickID;
}
extern "C" {
  #[doc = "  Open a joystick for use."]
  #[doc = "  The index passed as an argument refers to the N\'th joystick on the system."]
  #[doc = "  This index is not the value which will identify this joystick in future"]
  #[doc = "  joystick events.  The joystick\'s instance id (::SDL_JoystickID) will be used"]
  #[doc = "  there instead."]
  #[doc = ""]
  #[doc = "  \\return A joystick identifier, or NULL if an error occurred."]
  pub fn SDL_JoystickOpen(device_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
  #[doc = " Return the SDL_Joystick associated with an instance id."]
  pub fn SDL_JoystickFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
  #[doc = "  Return the name for this currently opened joystick."]
  #[doc = "  If no name can be found, this function returns NULL."]
  pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the player index of an opened joystick, or -1 if it\'s not available"]
  #[doc = ""]
  #[doc = "  For XInput controllers this returns the XInput user index."]
  pub fn SDL_JoystickGetPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Return the GUID for this opened joystick"]
  pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
  #[doc = "  Get the USB vendor ID of an opened joystick, if available."]
  #[doc = "  If the vendor ID isn\'t available this function returns 0."]
  pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  #[doc = "  Get the USB product ID of an opened joystick, if available."]
  #[doc = "  If the product ID isn\'t available this function returns 0."]
  pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  #[doc = "  Get the product version of an opened joystick, if available."]
  #[doc = "  If the product version isn\'t available this function returns 0."]
  pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
  #[doc = "  Get the type of an opened joystick."]
  pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick) -> SDL_JoystickType::Type;
}
extern "C" {
  #[doc = "  Return a string representation for this guid. pszGUID must point to at least 33 bytes"]
  #[doc = "  (32 for the string plus a NULL terminator)."]
  pub fn SDL_JoystickGetGUIDString(
    guid: SDL_JoystickGUID, pszGUID: *mut libc::c_char, cbGUID: libc::c_int,
  );
}
extern "C" {
  #[doc = "  Convert a string into a joystick guid"]
  pub fn SDL_JoystickGetGUIDFromString(pchGUID: *const libc::c_char) -> SDL_JoystickGUID;
}
extern "C" {
  #[doc = "  Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not."]
  pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the instance ID of an opened joystick or -1 if the joystick is invalid."]
  pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
  #[doc = "  Get the number of general axis controls on a joystick."]
  pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of trackballs on a joystick."]
  #[doc = ""]
  #[doc = "  Joystick trackballs have only relative motion events associated"]
  #[doc = "  with them and their state cannot be polled."]
  pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of POV hats on a joystick."]
  pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of buttons on a joystick."]
  pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  Update the current state of the open joysticks."]
  #[doc = ""]
  #[doc = "  This is called automatically by the event loop if any joystick"]
  #[doc = "  events are enabled."]
  pub fn SDL_JoystickUpdate();
}
extern "C" {
  #[doc = "  Enable/disable joystick event polling."]
  #[doc = ""]
  #[doc = "  If joystick events are disabled, you must call SDL_JoystickUpdate()"]
  #[doc = "  yourself and check the state of the joystick when you want joystick"]
  #[doc = "  information."]
  #[doc = ""]
  #[doc = "  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
  pub fn SDL_JoystickEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the current state of an axis control on a joystick."]
  #[doc = ""]
  #[doc = "  The state is a value ranging from -32768 to 32767."]
  #[doc = ""]
  #[doc = "  The axis indices start at index 0."]
  pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
extern "C" {
  #[doc = "  Get the initial state of an axis control on a joystick."]
  #[doc = ""]
  #[doc = "  The state is a value ranging from -32768 to 32767."]
  #[doc = ""]
  #[doc = "  The axis indices start at index 0."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not."]
  pub fn SDL_JoystickGetAxisInitialState(
    joystick: *mut SDL_Joystick, axis: libc::c_int, state: *mut Sint16,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the current state of a POV hat on a joystick."]
  #[doc = ""]
  #[doc = "  The hat indices start at index 0."]
  #[doc = ""]
  #[doc = "  \\return The return value is one of the following positions:"]
  #[doc = "           - ::SDL_HAT_CENTERED"]
  #[doc = "           - ::SDL_HAT_UP"]
  #[doc = "           - ::SDL_HAT_RIGHT"]
  #[doc = "           - ::SDL_HAT_DOWN"]
  #[doc = "           - ::SDL_HAT_LEFT"]
  #[doc = "           - ::SDL_HAT_RIGHTUP"]
  #[doc = "           - ::SDL_HAT_RIGHTDOWN"]
  #[doc = "           - ::SDL_HAT_LEFTUP"]
  #[doc = "           - ::SDL_HAT_LEFTDOWN"]
  pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
extern "C" {
  #[doc = "  Get the ball axis change since the last poll."]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if you passed it invalid parameters."]
  #[doc = ""]
  #[doc = "  The ball indices start at index 0."]
  pub fn SDL_JoystickGetBall(
    joystick: *mut SDL_Joystick, ball: libc::c_int, dx: *mut libc::c_int, dy: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the current state of a button on a joystick."]
  #[doc = ""]
  #[doc = "  The button indices start at index 0."]
  pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> Uint8;
}
extern "C" {
  #[doc = "  Trigger a rumble effect"]
  #[doc = "  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling."]
  #[doc = ""]
  #[doc = "  \\param joystick The joystick to vibrate"]
  #[doc = "  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param duration_ms The duration of the rumble effect, in milliseconds"]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if rumble isn\'t supported on this joystick"]
  pub fn SDL_JoystickRumble(
    joystick: *mut SDL_Joystick, low_frequency_rumble: Uint16, high_frequency_rumble: Uint16,
    duration_ms: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Close a joystick previously opened with SDL_JoystickOpen()."]
  pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
  #[doc = "  Return the battery level of this joystick"]
  pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick)
    -> SDL_JoystickPowerLevel::Type;
}
#[doc = " The gamecontroller structure used to identify an SDL game controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_GameController {
  _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
pub mod SDL_GameControllerBindType {
  pub type Type = i32;
  pub const SDL_CONTROLLER_BINDTYPE_NONE: Type = 0;
  pub const SDL_CONTROLLER_BINDTYPE_BUTTON: Type = 1;
  pub const SDL_CONTROLLER_BINDTYPE_AXIS: Type = 2;
  pub const SDL_CONTROLLER_BINDTYPE_HAT: Type = 3;
}
#[doc = "  Get the SDL joystick layer binding for this controller button/axis mapping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
  pub bindType: SDL_GameControllerBindType::Type,
  pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
  pub button: libc::c_int,
  pub axis: libc::c_int,
  pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
  pub hat: libc::c_int,
  pub hat_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hat)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>())).hat_mask
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hat_mask)
    )
  );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).button as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).axis as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).hat as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
      "::",
      stringify!(hat)
    )
  );
}
impl Default for SDL_GameControllerButtonBind__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_GameControllerButtonBind__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_GameControllerButtonBind__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
  assert_eq!(
    ::core::mem::size_of::<SDL_GameControllerButtonBind>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_GameControllerButtonBind>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).bindType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind),
      "::",
      stringify!(bindType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).value as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_GameControllerButtonBind),
      "::",
      stringify!(value)
    )
  );
}
impl Default for SDL_GameControllerButtonBind {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_GameControllerButtonBind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_GameControllerButtonBind {{ bindType: {:?}, value: {:?} }}",
      self.bindType, self.value
    )
  }
}
extern "C" {
  #[doc = "  Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()"]
  #[doc = "  A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt"]
  #[doc = ""]
  #[doc = "  If \\c freerw is non-zero, the stream will be closed after being read."]
  #[doc = ""]
  #[doc = " \\return number of mappings added, -1 on error"]
  pub fn SDL_GameControllerAddMappingsFromRW(
    rw: *mut SDL_RWops, freerw: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Add or update an existing mapping configuration"]
  #[doc = ""]
  #[doc = " \\return 1 if mapping is added, 0 if updated, -1 on error"]
  pub fn SDL_GameControllerAddMapping(mappingString: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the number of mappings installed"]
  #[doc = ""]
  #[doc = "  \\return the number of mappings"]
  pub fn SDL_GameControllerNumMappings() -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the mapping at a particular index."]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range."]
  pub fn SDL_GameControllerMappingForIndex(mapping_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Get a mapping string for a GUID"]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
  pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Get a mapping string for an open GameController"]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
  pub fn SDL_GameControllerMapping(gamecontroller: *mut SDL_GameController) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Is the joystick on this index supported by the game controller interface?"]
  pub fn SDL_IsGameController(joystick_index: libc::c_int) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the implementation dependent name of a game controller."]
  #[doc = "  This can be called before any controllers are opened."]
  #[doc = "  If no name can be found, this function returns NULL."]
  pub fn SDL_GameControllerNameForIndex(joystick_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the mapping of a game controller."]
  #[doc = "  This can be called before any controllers are opened."]
  #[doc = ""]
  #[doc = "  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
  pub fn SDL_GameControllerMappingForDeviceIndex(joystick_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  #[doc = "  Open a game controller for use."]
  #[doc = "  The index passed as an argument refers to the N\'th game controller on the system."]
  #[doc = "  This index is not the value which will identify this controller in future"]
  #[doc = "  controller events.  The joystick\'s instance id (::SDL_JoystickID) will be"]
  #[doc = "  used there instead."]
  #[doc = ""]
  #[doc = "  \\return A controller identifier, or NULL if an error occurred."]
  pub fn SDL_GameControllerOpen(joystick_index: libc::c_int) -> *mut SDL_GameController;
}
extern "C" {
  #[doc = " Return the SDL_GameController associated with an instance id."]
  pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_GameController;
}
extern "C" {
  #[doc = "  Return the name for this currently opened controller"]
  pub fn SDL_GameControllerName(gamecontroller: *mut SDL_GameController) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the player index of an opened game controller, or -1 if it\'s not available"]
  #[doc = ""]
  #[doc = "  For XInput controllers this returns the XInput user index."]
  pub fn SDL_GameControllerGetPlayerIndex(gamecontroller: *mut SDL_GameController) -> libc::c_int;
}
extern "C" {
  #[doc = "  Get the USB vendor ID of an opened controller, if available."]
  #[doc = "  If the vendor ID isn\'t available this function returns 0."]
  pub fn SDL_GameControllerGetVendor(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  #[doc = "  Get the USB product ID of an opened controller, if available."]
  #[doc = "  If the product ID isn\'t available this function returns 0."]
  pub fn SDL_GameControllerGetProduct(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  #[doc = "  Get the product version of an opened controller, if available."]
  #[doc = "  If the product version isn\'t available this function returns 0."]
  pub fn SDL_GameControllerGetProductVersion(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
  #[doc = "  Returns SDL_TRUE if the controller has been opened and currently connected,"]
  #[doc = "  or SDL_FALSE if it has not."]
  pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Get the underlying joystick object used by a controller"]
  pub fn SDL_GameControllerGetJoystick(
    gamecontroller: *mut SDL_GameController,
  ) -> *mut SDL_Joystick;
}
extern "C" {
  #[doc = "  Enable/disable controller event polling."]
  #[doc = ""]
  #[doc = "  If controller events are disabled, you must call SDL_GameControllerUpdate()"]
  #[doc = "  yourself and check the state of the controller when you want controller"]
  #[doc = "  information."]
  #[doc = ""]
  #[doc = "  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
  pub fn SDL_GameControllerEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  Update the current state of the open game controllers."]
  #[doc = ""]
  #[doc = "  This is called automatically by the event loop if any game controller"]
  #[doc = "  events are enabled."]
  pub fn SDL_GameControllerUpdate();
}
pub mod SDL_GameControllerAxis {
  #[doc = "  The list of axes available from a controller"]
  #[doc = ""]
  #[doc = "  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,"]
  #[doc = "  and are centered within ~8000 of zero, though advanced UI will allow users to set"]
  #[doc = "  or autodetect the dead zone, which varies between controllers."]
  #[doc = ""]
  #[doc = "  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX."]
  pub type Type = i32;
  pub const SDL_CONTROLLER_AXIS_INVALID: Type = -1;
  pub const SDL_CONTROLLER_AXIS_LEFTX: Type = 0;
  pub const SDL_CONTROLLER_AXIS_LEFTY: Type = 1;
  pub const SDL_CONTROLLER_AXIS_RIGHTX: Type = 2;
  pub const SDL_CONTROLLER_AXIS_RIGHTY: Type = 3;
  pub const SDL_CONTROLLER_AXIS_TRIGGERLEFT: Type = 4;
  pub const SDL_CONTROLLER_AXIS_TRIGGERRIGHT: Type = 5;
  pub const SDL_CONTROLLER_AXIS_MAX: Type = 6;
}
extern "C" {
  #[doc = "  turn this string into a axis mapping"]
  pub fn SDL_GameControllerGetAxisFromString(
    pchString: *const libc::c_char,
  ) -> SDL_GameControllerAxis::Type;
}
extern "C" {
  #[doc = "  turn this axis enum into a string mapping"]
  pub fn SDL_GameControllerGetStringForAxis(
    axis: SDL_GameControllerAxis::Type,
  ) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
  pub fn SDL_GameControllerGetBindForAxis(
    gamecontroller: *mut SDL_GameController, axis: SDL_GameControllerAxis::Type,
  ) -> SDL_GameControllerButtonBind;
}
extern "C" {
  #[doc = "  Get the current state of an axis control on a game controller."]
  #[doc = ""]
  #[doc = "  The state is a value ranging from -32768 to 32767 (except for the triggers,"]
  #[doc = "  which range from 0 to 32767)."]
  #[doc = ""]
  #[doc = "  The axis indices start at index 0."]
  pub fn SDL_GameControllerGetAxis(
    gamecontroller: *mut SDL_GameController, axis: SDL_GameControllerAxis::Type,
  ) -> Sint16;
}
pub mod SDL_GameControllerButton {
  #[doc = "  The list of buttons available from a controller"]
  pub type Type = i32;
  pub const SDL_CONTROLLER_BUTTON_INVALID: Type = -1;
  pub const SDL_CONTROLLER_BUTTON_A: Type = 0;
  pub const SDL_CONTROLLER_BUTTON_B: Type = 1;
  pub const SDL_CONTROLLER_BUTTON_X: Type = 2;
  pub const SDL_CONTROLLER_BUTTON_Y: Type = 3;
  pub const SDL_CONTROLLER_BUTTON_BACK: Type = 4;
  pub const SDL_CONTROLLER_BUTTON_GUIDE: Type = 5;
  pub const SDL_CONTROLLER_BUTTON_START: Type = 6;
  pub const SDL_CONTROLLER_BUTTON_LEFTSTICK: Type = 7;
  pub const SDL_CONTROLLER_BUTTON_RIGHTSTICK: Type = 8;
  pub const SDL_CONTROLLER_BUTTON_LEFTSHOULDER: Type = 9;
  pub const SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: Type = 10;
  pub const SDL_CONTROLLER_BUTTON_DPAD_UP: Type = 11;
  pub const SDL_CONTROLLER_BUTTON_DPAD_DOWN: Type = 12;
  pub const SDL_CONTROLLER_BUTTON_DPAD_LEFT: Type = 13;
  pub const SDL_CONTROLLER_BUTTON_DPAD_RIGHT: Type = 14;
  pub const SDL_CONTROLLER_BUTTON_MAX: Type = 15;
}
extern "C" {
  #[doc = "  turn this string into a button mapping"]
  pub fn SDL_GameControllerGetButtonFromString(
    pchString: *const libc::c_char,
  ) -> SDL_GameControllerButton::Type;
}
extern "C" {
  #[doc = "  turn this button enum into a string mapping"]
  pub fn SDL_GameControllerGetStringForButton(
    button: SDL_GameControllerButton::Type,
  ) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
  pub fn SDL_GameControllerGetBindForButton(
    gamecontroller: *mut SDL_GameController, button: SDL_GameControllerButton::Type,
  ) -> SDL_GameControllerButtonBind;
}
extern "C" {
  #[doc = "  Get the current state of a button on a game controller."]
  #[doc = ""]
  #[doc = "  The button indices start at index 0."]
  pub fn SDL_GameControllerGetButton(
    gamecontroller: *mut SDL_GameController, button: SDL_GameControllerButton::Type,
  ) -> Uint8;
}
extern "C" {
  #[doc = "  Trigger a rumble effect"]
  #[doc = "  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling."]
  #[doc = ""]
  #[doc = "  \\param gamecontroller The controller to vibrate"]
  #[doc = "  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF"]
  #[doc = "  \\param duration_ms The duration of the rumble effect, in milliseconds"]
  #[doc = ""]
  #[doc = "  \\return 0, or -1 if rumble isn\'t supported on this joystick"]
  pub fn SDL_GameControllerRumble(
    gamecontroller: *mut SDL_GameController, low_frequency_rumble: Uint16,
    high_frequency_rumble: Uint16, duration_ms: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Close a controller previously opened with SDL_GameControllerOpen()."]
  pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_Finger {
  pub id: SDL_FingerID,
  pub x: f32,
  pub y: f32,
  pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Finger>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_Finger))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Finger>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Finger))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).id as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).x as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).y as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Finger>())).pressure as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Finger),
      "::",
      stringify!(pressure)
    )
  );
}
extern "C" {
  #[doc = "  \\brief Get the number of registered touch devices."]
  pub fn SDL_GetNumTouchDevices() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the touch ID with the given index, or 0 if the index is invalid."]
  pub fn SDL_GetTouchDevice(index: libc::c_int) -> SDL_TouchID;
}
extern "C" {
  #[doc = "  \\brief Get the number of active fingers for a given touch device."]
  pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the finger object of the given touch, with the given index."]
  pub fn SDL_GetTouchFinger(touchID: SDL_TouchID, index: libc::c_int) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
  #[doc = "  \\brief Begin Recording a gesture on the specified touch, or all touches (-1)"]
  #[doc = ""]
  #[doc = ""]
  pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Save all currently loaded Dollar Gesture templates"]
  #[doc = ""]
  #[doc = ""]
  pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Save a currently loaded Dollar Gesture template"]
  #[doc = ""]
  #[doc = ""]
  pub fn SDL_SaveDollarTemplate(gestureId: SDL_GestureID, dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Load Dollar Gesture templates from a file"]
  #[doc = ""]
  #[doc = ""]
  pub fn SDL_LoadDollarTemplates(touchId: SDL_TouchID, src: *mut SDL_RWops) -> libc::c_int;
}
pub mod SDL_EventType {
  #[doc = " \\brief The types of events that can be delivered."]
  pub type Type = i32;
  #[doc = "< Unused (do not remove)"]
  pub const SDL_FIRSTEVENT: Type = 0;
  #[doc = "< User-requested quit"]
  pub const SDL_QUIT: Type = 256;
  #[doc = "< The application is being terminated by the OS"]
  #[doc = "Called on iOS in applicationWillTerminate()"]
  #[doc = "Called on Android in onDestroy()"]
  pub const SDL_APP_TERMINATING: Type = 257;
  #[doc = "< The application is low on memory, free memory if possible."]
  #[doc = "Called on iOS in applicationDidReceiveMemoryWarning()"]
  #[doc = "Called on Android in onLowMemory()"]
  pub const SDL_APP_LOWMEMORY: Type = 258;
  #[doc = "< The application is about to enter the background"]
  #[doc = "Called on iOS in applicationWillResignActive()"]
  #[doc = "Called on Android in onPause()"]
  pub const SDL_APP_WILLENTERBACKGROUND: Type = 259;
  #[doc = "< The application did enter the background and may not get CPU for some time"]
  #[doc = "Called on iOS in applicationDidEnterBackground()"]
  #[doc = "Called on Android in onPause()"]
  pub const SDL_APP_DIDENTERBACKGROUND: Type = 260;
  #[doc = "< The application is about to enter the foreground"]
  #[doc = "Called on iOS in applicationWillEnterForeground()"]
  #[doc = "Called on Android in onResume()"]
  pub const SDL_APP_WILLENTERFOREGROUND: Type = 261;
  #[doc = "< The application is now interactive"]
  #[doc = "Called on iOS in applicationDidBecomeActive()"]
  #[doc = "Called on Android in onResume()"]
  pub const SDL_APP_DIDENTERFOREGROUND: Type = 262;
  #[doc = "< Display state change"]
  pub const SDL_DISPLAYEVENT: Type = 336;
  #[doc = "< Window state change"]
  pub const SDL_WINDOWEVENT: Type = 512;
  #[doc = "< System specific event"]
  pub const SDL_SYSWMEVENT: Type = 513;
  #[doc = "< Key pressed"]
  pub const SDL_KEYDOWN: Type = 768;
  #[doc = "< Key released"]
  pub const SDL_KEYUP: Type = 769;
  #[doc = "< Keyboard text editing (composition)"]
  pub const SDL_TEXTEDITING: Type = 770;
  #[doc = "< Keyboard text input"]
  pub const SDL_TEXTINPUT: Type = 771;
  #[doc = "< Keymap changed due to a system event such as an"]
  #[doc = "input language or keyboard layout change."]
  pub const SDL_KEYMAPCHANGED: Type = 772;
  #[doc = "< Mouse moved"]
  pub const SDL_MOUSEMOTION: Type = 1024;
  #[doc = "< Mouse button pressed"]
  pub const SDL_MOUSEBUTTONDOWN: Type = 1025;
  #[doc = "< Mouse button released"]
  pub const SDL_MOUSEBUTTONUP: Type = 1026;
  #[doc = "< Mouse wheel motion"]
  pub const SDL_MOUSEWHEEL: Type = 1027;
  #[doc = "< Joystick axis motion"]
  pub const SDL_JOYAXISMOTION: Type = 1536;
  #[doc = "< Joystick trackball motion"]
  pub const SDL_JOYBALLMOTION: Type = 1537;
  #[doc = "< Joystick hat position change"]
  pub const SDL_JOYHATMOTION: Type = 1538;
  #[doc = "< Joystick button pressed"]
  pub const SDL_JOYBUTTONDOWN: Type = 1539;
  #[doc = "< Joystick button released"]
  pub const SDL_JOYBUTTONUP: Type = 1540;
  #[doc = "< A new joystick has been inserted into the system"]
  pub const SDL_JOYDEVICEADDED: Type = 1541;
  #[doc = "< An opened joystick has been removed"]
  pub const SDL_JOYDEVICEREMOVED: Type = 1542;
  #[doc = "< Game controller axis motion"]
  pub const SDL_CONTROLLERAXISMOTION: Type = 1616;
  #[doc = "< Game controller button pressed"]
  pub const SDL_CONTROLLERBUTTONDOWN: Type = 1617;
  #[doc = "< Game controller button released"]
  pub const SDL_CONTROLLERBUTTONUP: Type = 1618;
  #[doc = "< A new Game controller has been inserted into the system"]
  pub const SDL_CONTROLLERDEVICEADDED: Type = 1619;
  #[doc = "< An opened Game controller has been removed"]
  pub const SDL_CONTROLLERDEVICEREMOVED: Type = 1620;
  #[doc = "< The controller mapping was updated"]
  pub const SDL_CONTROLLERDEVICEREMAPPED: Type = 1621;
  pub const SDL_FINGERDOWN: Type = 1792;
  pub const SDL_FINGERUP: Type = 1793;
  pub const SDL_FINGERMOTION: Type = 1794;
  pub const SDL_DOLLARGESTURE: Type = 2048;
  pub const SDL_DOLLARRECORD: Type = 2049;
  pub const SDL_MULTIGESTURE: Type = 2050;
  #[doc = "< The clipboard changed"]
  pub const SDL_CLIPBOARDUPDATE: Type = 2304;
  #[doc = "< The system requests a file open"]
  pub const SDL_DROPFILE: Type = 4096;
  #[doc = "< text/plain drag-and-drop event"]
  pub const SDL_DROPTEXT: Type = 4097;
  #[doc = "< A new set of drops is beginning (NULL filename)"]
  pub const SDL_DROPBEGIN: Type = 4098;
  #[doc = "< Current set of drops is now complete (NULL filename)"]
  pub const SDL_DROPCOMPLETE: Type = 4099;
  #[doc = "< A new audio device is available"]
  pub const SDL_AUDIODEVICEADDED: Type = 4352;
  #[doc = "< An audio device has been removed."]
  pub const SDL_AUDIODEVICEREMOVED: Type = 4353;
  #[doc = "< A sensor was updated"]
  pub const SDL_SENSORUPDATE: Type = 4608;
  #[doc = "< The render targets have been reset and their contents need to be updated"]
  pub const SDL_RENDER_TARGETS_RESET: Type = 8192;
  #[doc = "< The device has been reset and all textures need to be recreated"]
  pub const SDL_RENDER_DEVICE_RESET: Type = 8193;
  #[doc = " Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,"]
  #[doc = "  and should be allocated with SDL_RegisterEvents()"]
  pub const SDL_USEREVENT: Type = 32768;
  #[doc = "  This last event is only for bounding internal arrays"]
  pub const SDL_LASTEVENT: Type = 65535;
}
#[doc = "  \\brief Fields shared by every event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_CommonEvent {
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_CommonEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_CommonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_CommonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_CommonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_CommonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_CommonEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[doc = "  \\brief Display state change event data (event.display.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_DisplayEvent {
  #[doc = "< ::SDL_DISPLAYEVENT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The associated display index"]
  pub display: Uint32,
  #[doc = "< ::SDL_DisplayEventID"]
  pub event: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< event dependent data"]
  pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DisplayEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_DisplayEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DisplayEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_DisplayEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).display as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).event as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DisplayEvent),
      "::",
      stringify!(data1)
    )
  );
}
#[doc = "  \\brief Window state change event data (event.window.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_WindowEvent {
  #[doc = "< ::SDL_WINDOWEVENT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The associated window"]
  pub windowID: Uint32,
  #[doc = "< ::SDL_WindowEventID"]
  pub event: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< event dependent data"]
  pub data1: Sint32,
  #[doc = "< event dependent data"]
  pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowEvent>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_WindowEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_WindowEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).event as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data2 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowEvent),
      "::",
      stringify!(data2)
    )
  );
}
#[doc = "  \\brief Keyboard button event structure (event.key.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_KeyboardEvent {
  #[doc = "< ::SDL_KEYDOWN or ::SDL_KEYUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with keyboard focus, if any"]
  pub windowID: Uint32,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  #[doc = "< Non-zero if this is a key repeat"]
  pub repeat: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The key that was pressed or released"]
  pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_KeyboardEvent>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_KeyboardEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_KeyboardEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).state as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).repeat as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(repeat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).keysym as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_KeyboardEvent),
      "::",
      stringify!(keysym)
    )
  );
}
impl Default for SDL_KeyboardEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief Keyboard text editing event structure (event.edit.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TextEditingEvent {
  #[doc = "< ::SDL_TEXTEDITING"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with keyboard focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The editing text"]
  pub text: [libc::c_char; 32usize],
  #[doc = "< The start cursor of selected editing text"]
  pub start: Sint32,
  #[doc = "< The length of selected editing text"]
  pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TextEditingEvent>(),
    52usize,
    concat!("Size of: ", stringify!(SDL_TextEditingEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TextEditingEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).text as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(text)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).start as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(start)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).length as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextEditingEvent),
      "::",
      stringify!(length)
    )
  );
}
#[doc = "  \\brief Keyboard text input event structure (event.text.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TextInputEvent {
  #[doc = "< ::SDL_TEXTINPUT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with keyboard focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The input text"]
  pub text: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TextInputEvent>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_TextInputEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TextInputEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_TextInputEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).text as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TextInputEvent),
      "::",
      stringify!(text)
    )
  );
}
#[doc = "  \\brief Mouse motion event structure (event.motion.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseMotionEvent {
  #[doc = "< ::SDL_MOUSEMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with mouse focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
  pub which: Uint32,
  #[doc = "< The current button state"]
  pub state: Uint32,
  #[doc = "< X coordinate, relative to window"]
  pub x: Sint32,
  #[doc = "< Y coordinate, relative to window"]
  pub y: Sint32,
  #[doc = "< The relative motion in the X direction"]
  pub xrel: Sint32,
  #[doc = "< The relative motion in the Y direction"]
  pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseMotionEvent>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseMotionEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).state as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).xrel as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(xrel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).yrel as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseMotionEvent),
      "::",
      stringify!(yrel)
    )
  );
}
#[doc = "  \\brief Mouse button event structure (event.button.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseButtonEvent {
  #[doc = "< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with mouse focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
  pub which: Uint32,
  #[doc = "< The mouse button index"]
  pub button: Uint8,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  #[doc = "< 1 for single-click, 2 for double-click, etc."]
  pub clicks: Uint8,
  pub padding1: Uint8,
  #[doc = "< X coordinate, relative to window"]
  pub x: Sint32,
  #[doc = "< Y coordinate, relative to window"]
  pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseButtonEvent>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).button as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).state as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).clicks as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(clicks)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).padding1 as *const _ as usize },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).x as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).y as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseButtonEvent),
      "::",
      stringify!(y)
    )
  );
}
#[doc = "  \\brief Mouse wheel event structure (event.wheel.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MouseWheelEvent {
  #[doc = "< ::SDL_MOUSEWHEEL"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The window with mouse focus, if any"]
  pub windowID: Uint32,
  #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
  pub which: Uint32,
  #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
  pub x: Sint32,
  #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
  pub y: Sint32,
  #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
  pub direction: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MouseWheelEvent>(),
    28usize,
    concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MouseWheelEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).which as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).x as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).y as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).direction as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MouseWheelEvent),
      "::",
      stringify!(direction)
    )
  );
}
#[doc = "  \\brief Joystick axis motion event structure (event.jaxis.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyAxisEvent {
  #[doc = "< ::SDL_JOYAXISMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick axis index"]
  pub axis: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The axis value (range: -32768 to 32767)"]
  pub value: Sint16,
  pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyAxisEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyAxisEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).axis as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding4 as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyAxisEvent),
      "::",
      stringify!(padding4)
    )
  );
}
#[doc = "  \\brief Joystick trackball motion event structure (event.jball.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyBallEvent {
  #[doc = "< ::SDL_JOYBALLMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick trackball index"]
  pub ball: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The relative motion in the X direction"]
  pub xrel: Sint16,
  #[doc = "< The relative motion in the Y direction"]
  pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyBallEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_JoyBallEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyBallEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).ball as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(ball)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).xrel as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(xrel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).yrel as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyBallEvent),
      "::",
      stringify!(yrel)
    )
  );
}
#[doc = "  \\brief Joystick hat position change event structure (event.jhat.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyHatEvent {
  #[doc = "< ::SDL_JOYHATMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick hat index"]
  pub hat: Uint8,
  #[doc = "< The hat position value."]
  #[doc = "   \\sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP"]
  #[doc = "   \\sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT"]
  #[doc = "   \\sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN"]
  #[doc = ""]
  #[doc = "   Note that zero means the POV is centered."]
  pub value: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyHatEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoyHatEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyHatEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).hat as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(hat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).value as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyHatEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[doc = "  \\brief Joystick button event structure (event.jbutton.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyButtonEvent {
  #[doc = "< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The joystick button index"]
  pub button: Uint8,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyButtonEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).button as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).state as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyButtonEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[doc = "  \\brief Joystick device event structure (event.jdevice.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_JoyDeviceEvent {
  #[doc = "< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED event"]
  pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_JoyDeviceEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_JoyDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_JoyDeviceEvent),
      "::",
      stringify!(which)
    )
  );
}
#[doc = "  \\brief Game controller axis motion event structure (event.caxis.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerAxisEvent {
  #[doc = "< ::SDL_CONTROLLERAXISMOTION"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The controller axis (SDL_GameControllerAxis)"]
  pub axis: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
  #[doc = "< The axis value (range: -32768 to 32767)"]
  pub value: Sint16,
  pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerAxisEvent>(),
    20usize,
    concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerAxisEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).axis as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding4 as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerAxisEvent),
      "::",
      stringify!(padding4)
    )
  );
}
#[doc = "  \\brief Game controller button event structure (event.cbutton.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerButtonEvent {
  #[doc = "< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick instance id"]
  pub which: SDL_JoystickID,
  #[doc = "< The controller button (SDL_GameControllerButton)"]
  pub button: Uint8,
  #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
  pub state: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerButtonEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerButtonEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).timestamp as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).button as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).state as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding1 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding2 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerButtonEvent),
      "::",
      stringify!(padding2)
    )
  );
}
#[doc = "  \\brief Controller device event structure (event.cdevice.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_ControllerDeviceEvent {
  #[doc = "< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event"]
  pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_ControllerDeviceEvent>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_ControllerDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).timestamp as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_ControllerDeviceEvent),
      "::",
      stringify!(which)
    )
  );
}
#[doc = "  \\brief Audio device event structure (event.adevice.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_AudioDeviceEvent {
  #[doc = "< ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event"]
  pub which: Uint32,
  #[doc = "< zero if an output device, non-zero if a capture device."]
  pub iscapture: Uint8,
  pub padding1: Uint8,
  pub padding2: Uint8,
  pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_AudioDeviceEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_AudioDeviceEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).iscapture as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(iscapture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding1 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding3 as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_AudioDeviceEvent),
      "::",
      stringify!(padding3)
    )
  );
}
#[doc = "  \\brief Touch finger event structure (event.tfinger.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_TouchFingerEvent {
  #[doc = "< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The touch device id"]
  pub touchId: SDL_TouchID,
  pub fingerId: SDL_FingerID,
  #[doc = "< Normalized in the range 0...1"]
  pub x: f32,
  #[doc = "< Normalized in the range 0...1"]
  pub y: f32,
  #[doc = "< Normalized in the range -1...1"]
  pub dx: f32,
  #[doc = "< Normalized in the range -1...1"]
  pub dy: f32,
  #[doc = "< Normalized in the range 0...1"]
  pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_TouchFingerEvent>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_TouchFingerEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).fingerId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(fingerId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dx as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(dx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dy as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(dy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).pressure as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_TouchFingerEvent),
      "::",
      stringify!(pressure)
    )
  );
}
#[doc = "  \\brief Multiple Finger Gesture Event (event.mgesture.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MultiGestureEvent {
  #[doc = "< ::SDL_MULTIGESTURE"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The touch device id"]
  pub touchId: SDL_TouchID,
  pub dTheta: f32,
  pub dDist: f32,
  pub x: f32,
  pub y: f32,
  pub numFingers: Uint16,
  pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MultiGestureEvent>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MultiGestureEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dTheta as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(dTheta)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dDist as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(dDist)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).numFingers as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(numFingers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).padding as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MultiGestureEvent),
      "::",
      stringify!(padding)
    )
  );
}
#[doc = " \\brief Dollar Gesture Event (event.dgesture.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_DollarGestureEvent {
  #[doc = "< ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The touch device id"]
  pub touchId: SDL_TouchID,
  pub gestureId: SDL_GestureID,
  pub numFingers: Uint32,
  pub error: f32,
  #[doc = "< Normalized center of gesture"]
  pub x: f32,
  #[doc = "< Normalized center of gesture"]
  pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DollarGestureEvent>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DollarGestureEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).touchId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(touchId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).gestureId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(gestureId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).numFingers as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(numFingers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).error as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).x as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).y as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DollarGestureEvent),
      "::",
      stringify!(y)
    )
  );
}
#[doc = "  \\brief An event used to request a file open by the system (event.drop.*)"]
#[doc = "         This event is enabled by default, you can disable it with SDL_EventState()."]
#[doc = "  \\note If this event is enabled, you must free the filename in the event."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_DropEvent {
  #[doc = "< ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The file name, which should be freed with SDL_free(), is NULL on begin/complete"]
  pub file: *mut libc::c_char,
  #[doc = "< The window that was dropped on, if any"]
  pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_DropEvent>(),
    24usize,
    concat!("Size of: ", stringify!(SDL_DropEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_DropEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_DropEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).file as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(file)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).windowID as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_DropEvent),
      "::",
      stringify!(windowID)
    )
  );
}
impl Default for SDL_DropEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief Sensor event structure (event.sensor.*)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_SensorEvent {
  #[doc = "< ::SDL_SENSORUPDATE"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The instance ID of the sensor"]
  pub which: Sint32,
  #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData()"]
  pub data: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SensorEvent>(),
    36usize,
    concat!("Size of: ", stringify!(SDL_SensorEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SensorEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_SensorEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).which as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(which)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).data as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SensorEvent),
      "::",
      stringify!(data)
    )
  );
}
#[doc = "  \\brief The \"quit requested\" event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_QuitEvent {
  #[doc = "< ::SDL_QUIT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_QuitEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_QuitEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_QuitEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_QuitEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_QuitEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_QuitEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[doc = "  \\brief OS Specific event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_OSEvent {
  #[doc = "< ::SDL_QUIT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_OSEvent>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_OSEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_OSEvent>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_OSEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_OSEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_OSEvent),
      "::",
      stringify!(timestamp)
    )
  );
}
#[doc = "  \\brief A user-defined event type (event.user.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_UserEvent {
  #[doc = "< ::SDL_USEREVENT through ::SDL_LASTEVENT-1"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< The associated window if any"]
  pub windowID: Uint32,
  #[doc = "< User defined event code"]
  pub code: Sint32,
  #[doc = "< User defined data pointer"]
  pub data1: *mut libc::c_void,
  #[doc = "< User defined data pointer"]
  pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_UserEvent>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_UserEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_UserEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_UserEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).windowID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(windowID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).code as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(code)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_UserEvent),
      "::",
      stringify!(data2)
    )
  );
}
impl Default for SDL_UserEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief A video driver dependent system event (event.syswm.*)"]
#[doc = "         This event is disabled by default, you can enable it with SDL_EventState()"]
#[doc = ""]
#[doc = "  \\note If you want to use this event, you should include SDL_syswm.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMEvent {
  #[doc = "< ::SDL_SYSWMEVENT"]
  pub type_: Uint32,
  #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
  pub timestamp: Uint32,
  #[doc = "< driver dependent data, defined in SDL_syswm.h"]
  pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMEvent>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_SysWMEvent))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMEvent>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_SysWMEvent))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).timestamp as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).msg as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMEvent),
      "::",
      stringify!(msg)
    )
  );
}
impl Default for SDL_SysWMEvent {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief General event structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
  #[doc = "< Event type, shared with all events"]
  pub type_: Uint32,
  #[doc = "< Common event data"]
  pub common: SDL_CommonEvent,
  #[doc = "< Window event data"]
  pub display: SDL_DisplayEvent,
  #[doc = "< Window event data"]
  pub window: SDL_WindowEvent,
  #[doc = "< Keyboard event data"]
  pub key: SDL_KeyboardEvent,
  #[doc = "< Text editing event data"]
  pub edit: SDL_TextEditingEvent,
  #[doc = "< Text input event data"]
  pub text: SDL_TextInputEvent,
  #[doc = "< Mouse motion event data"]
  pub motion: SDL_MouseMotionEvent,
  #[doc = "< Mouse button event data"]
  pub button: SDL_MouseButtonEvent,
  #[doc = "< Mouse wheel event data"]
  pub wheel: SDL_MouseWheelEvent,
  #[doc = "< Joystick axis event data"]
  pub jaxis: SDL_JoyAxisEvent,
  #[doc = "< Joystick ball event data"]
  pub jball: SDL_JoyBallEvent,
  #[doc = "< Joystick hat event data"]
  pub jhat: SDL_JoyHatEvent,
  #[doc = "< Joystick button event data"]
  pub jbutton: SDL_JoyButtonEvent,
  #[doc = "< Joystick device change event data"]
  pub jdevice: SDL_JoyDeviceEvent,
  #[doc = "< Game Controller axis event data"]
  pub caxis: SDL_ControllerAxisEvent,
  #[doc = "< Game Controller button event data"]
  pub cbutton: SDL_ControllerButtonEvent,
  #[doc = "< Game Controller device event data"]
  pub cdevice: SDL_ControllerDeviceEvent,
  #[doc = "< Audio device event data"]
  pub adevice: SDL_AudioDeviceEvent,
  #[doc = "< Sensor event data"]
  pub sensor: SDL_SensorEvent,
  #[doc = "< Quit request event data"]
  pub quit: SDL_QuitEvent,
  #[doc = "< Custom event data"]
  pub user: SDL_UserEvent,
  #[doc = "< System dependent window event data"]
  pub syswm: SDL_SysWMEvent,
  #[doc = "< Touch finger event data"]
  pub tfinger: SDL_TouchFingerEvent,
  #[doc = "< Gesture event data"]
  pub mgesture: SDL_MultiGestureEvent,
  #[doc = "< Gesture event data"]
  pub dgesture: SDL_DollarGestureEvent,
  #[doc = "< Drag and drop event data"]
  pub drop: SDL_DropEvent,
  pub padding: [Uint8; 56usize],
  _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
  assert_eq!(
    ::core::mem::size_of::<SDL_Event>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_Event))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_Event>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_Event))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).common as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(common)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).display as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(display)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).window as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).key as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(key)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).edit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(edit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).text as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(text)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).motion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(motion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).button as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).wheel as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(wheel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jaxis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jaxis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jball as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jball)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jhat as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jhat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).jdevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(jdevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).caxis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(caxis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).cbutton as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(cbutton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).cdevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(cdevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).adevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(adevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).sensor as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(sensor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).quit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(quit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).user as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(user)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).syswm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(syswm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).tfinger as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(tfinger)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).mgesture as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(mgesture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).dgesture as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(dgesture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).drop as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(drop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_Event>())).padding as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_Event),
      "::",
      stringify!(padding)
    )
  );
}
impl Default for SDL_Event {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_Event {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_Event {{ union }}")
  }
}
extern "C" {
  #[doc = "  Pumps the event loop, gathering events from the input devices."]
  #[doc = ""]
  #[doc = "  This function updates the event queue and internal input device state."]
  #[doc = ""]
  #[doc = "  This should only be run in the thread that sets the video mode."]
  pub fn SDL_PumpEvents();
}
pub mod SDL_eventaction {
  pub type Type = i32;
  pub const SDL_ADDEVENT: Type = 0;
  pub const SDL_PEEKEVENT: Type = 1;
  pub const SDL_GETEVENT: Type = 2;
}
extern "C" {
  #[doc = "  Checks the event queue for messages and optionally returns them."]
  #[doc = ""]
  #[doc = "  If \\c action is ::SDL_ADDEVENT, up to \\c numevents events will be added to"]
  #[doc = "  the back of the event queue."]
  #[doc = ""]
  #[doc = "  If \\c action is ::SDL_PEEKEVENT, up to \\c numevents events at the front"]
  #[doc = "  of the event queue, within the specified minimum and maximum type,"]
  #[doc = "  will be returned and will not be removed from the queue."]
  #[doc = ""]
  #[doc = "  If \\c action is ::SDL_GETEVENT, up to \\c numevents events at the front"]
  #[doc = "  of the event queue, within the specified minimum and maximum type,"]
  #[doc = "  will be returned and will be removed from the queue."]
  #[doc = ""]
  #[doc = "  \\return The number of events actually stored, or -1 if there was an error."]
  #[doc = ""]
  #[doc = "  This function is thread-safe."]
  pub fn SDL_PeepEvents(
    events: *mut SDL_Event, numevents: libc::c_int, action: SDL_eventaction::Type, minType: Uint32,
    maxType: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Checks to see if certain event types are in the event queue."]
  pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool::Type;
}
extern "C" {
  pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  This function clears events from the event queue"]
  #[doc = "  This function only affects currently queued events. If you want to make"]
  #[doc = "  sure that all pending OS events are flushed, you can call SDL_PumpEvents()"]
  #[doc = "  on the main thread immediately before the flush call."]
  pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
  pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
  #[doc = "  \\brief Polls for currently pending events."]
  #[doc = ""]
  #[doc = "  \\return 1 if there are any pending events, or 0 if there are none available."]
  #[doc = ""]
  #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
  #[doc = "               stored in that area."]
  pub fn SDL_PollEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Waits indefinitely for the next available event."]
  #[doc = ""]
  #[doc = "  \\return 1, or 0 if there was an error while waiting for events."]
  #[doc = ""]
  #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
  #[doc = "               stored in that area."]
  pub fn SDL_WaitEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Waits until the specified timeout (in milliseconds) for the next"]
  #[doc = "         available event."]
  #[doc = ""]
  #[doc = "  \\return 1, or 0 if there was an error while waiting for events."]
  #[doc = ""]
  #[doc = "  \\param event If not NULL, the next event is removed from the queue and"]
  #[doc = "               stored in that area."]
  #[doc = "  \\param timeout The timeout (in milliseconds) to wait for next event."]
  pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeout: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Add an event to the event queue."]
  #[doc = ""]
  #[doc = "  \\return 1 on success, 0 if the event was filtered, or -1 if the event queue"]
  #[doc = "          was full or there was some other error."]
  pub fn SDL_PushEvent(event: *mut SDL_Event) -> libc::c_int;
}
pub type SDL_EventFilter = ::core::option::Option<
  unsafe extern "C" fn(userdata: *mut libc::c_void, event: *mut SDL_Event) -> libc::c_int,
>;
extern "C" {
  #[doc = "  Sets up a filter to process all events before they change internal state and"]
  #[doc = "  are posted to the internal event queue."]
  #[doc = ""]
  #[doc = "  The filter is prototyped as:"]
  #[doc = "  \\code"]
  #[doc = "      int SDL_EventFilter(void *userdata, SDL_Event * event);"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  If the filter returns 1, then the event will be added to the internal queue."]
  #[doc = "  If it returns 0, then the event will be dropped from the queue, but the"]
  #[doc = "  internal state will still be updated.  This allows selective filtering of"]
  #[doc = "  dynamically arriving events."]
  #[doc = ""]
  #[doc = "  \\warning  Be very careful of what you do in the event filter function, as"]
  #[doc = "            it may run in a different thread!"]
  #[doc = ""]
  #[doc = "  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The"]
  #[doc = "  event filter is only called when the window manager desires to close the"]
  #[doc = "  application window.  If the event filter returns 1, then the window will"]
  #[doc = "  be closed, otherwise the window will remain open if possible."]
  #[doc = ""]
  #[doc = "  If the quit event is generated by an interrupt signal, it will bypass the"]
  #[doc = "  internal queue and be delivered to the application at the next event poll."]
  pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  Return the current event filter - can be used to \"chain\" filters."]
  #[doc = "  If there is no event filter set, this function returns SDL_FALSE."]
  pub fn SDL_GetEventFilter(
    filter: *mut SDL_EventFilter, userdata: *mut *mut libc::c_void,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  Add a function which is called when an event is added to the queue."]
  pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  Remove an event watch function added with SDL_AddEventWatch()"]
  pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  Run the filter function on the current event queue, removing any"]
  #[doc = "  events for which the filter returns 0."]
  pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "  This function allows you to set the state of processing certain events."]
  #[doc = "   - If \\c state is set to ::SDL_IGNORE, that event will be automatically"]
  #[doc = "     dropped from the event queue and will not be filtered."]
  #[doc = "   - If \\c state is set to ::SDL_ENABLE, that event will be processed"]
  #[doc = "     normally."]
  #[doc = "   - If \\c state is set to ::SDL_QUERY, SDL_EventState() will return the"]
  #[doc = "     current processing state of the specified event."]
  pub fn SDL_EventState(type_: Uint32, state: libc::c_int) -> Uint8;
}
extern "C" {
  #[doc = "  This function allocates a set of user-defined events, and returns"]
  #[doc = "  the beginning event number for that set of events."]
  #[doc = ""]
  #[doc = "  If there aren\'t enough user-defined events left, this function"]
  #[doc = "  returns (Uint32)-1"]
  pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
extern "C" {
  #[doc = " \\brief Get the path where the application resides."]
  #[doc = ""]
  #[doc = " Get the \"base path\". This is the directory where the application was run"]
  #[doc = "  from, which is probably the installation directory, and may or may not"]
  #[doc = "  be the process\'s current working directory."]
  #[doc = ""]
  #[doc = " This returns an absolute path in UTF-8 encoding, and is guaranteed to"]
  #[doc = "  end with a path separator (\'\\\\\' on Windows, \'/\' most other places)."]
  #[doc = ""]
  #[doc = " The pointer returned by this function is owned by you. Please call"]
  #[doc = "  SDL_free() on the pointer when you are done with it, or it will be a"]
  #[doc = "  memory leak. This is not necessarily a fast call, though, so you should"]
  #[doc = "  call this once near startup and save the string if you need it."]
  #[doc = ""]
  #[doc = " Some platforms can\'t determine the application\'s path, and on other"]
  #[doc = "  platforms, this might be meaningless. In such cases, this function will"]
  #[doc = "  return NULL."]
  #[doc = ""]
  #[doc = "  \\return String of base dir in UTF-8 encoding, or NULL on error."]
  #[doc = ""]
  #[doc = " \\sa SDL_GetPrefPath"]
  pub fn SDL_GetBasePath() -> *mut libc::c_char;
}
extern "C" {
  #[doc = " \\brief Get the user-and-app-specific path where files can be written."]
  #[doc = ""]
  #[doc = " Get the \"pref dir\". This is meant to be where users can write personal"]
  #[doc = "  files (preferences and save games, etc) that are specific to your"]
  #[doc = "  application. This directory is unique per user, per application."]
  #[doc = ""]
  #[doc = " This function will decide the appropriate location in the native filesystem,"]
  #[doc = "  create the directory if necessary, and return a string of the absolute"]
  #[doc = "  path to the directory in UTF-8 encoding."]
  #[doc = ""]
  #[doc = " On Windows, the string might look like:"]
  #[doc = "  \"C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\\""]
  #[doc = ""]
  #[doc = " On Linux, the string might look like:"]
  #[doc = "  \"/home/bob/.local/share/My Program Name/\""]
  #[doc = ""]
  #[doc = " On Mac OS X, the string might look like:"]
  #[doc = "  \"/Users/bob/Library/Application Support/My Program Name/\""]
  #[doc = ""]
  #[doc = " (etc.)"]
  #[doc = ""]
  #[doc = " You specify the name of your organization (if it\'s not a real organization,"]
  #[doc = "  your name or an Internet domain you own might do) and the name of your"]
  #[doc = "  application. These should be untranslated proper names."]
  #[doc = ""]
  #[doc = " Both the org and app strings may become part of a directory name, so"]
  #[doc = "  please follow these rules:"]
  #[doc = ""]
  #[doc = "    - Try to use the same org string (including case-sensitivity) for"]
  #[doc = "      all your applications that use this function."]
  #[doc = "    - Always use a unique app string for each one, and make sure it never"]
  #[doc = "      changes for an app once you\'ve decided on it."]
  #[doc = "    - Unicode characters are legal, as long as it\'s UTF-8 encoded, but..."]
  #[doc = "    - ...only use letters, numbers, and spaces. Avoid punctuation like"]
  #[doc = "      \"Game Name 2: Bad Guy\'s Revenge!\" ... \"Game Name 2\" is sufficient."]
  #[doc = ""]
  #[doc = " This returns an absolute path in UTF-8 encoding, and is guaranteed to"]
  #[doc = "  end with a path separator (\'\\\\\' on Windows, \'/\' most other places)."]
  #[doc = ""]
  #[doc = " The pointer returned by this function is owned by you. Please call"]
  #[doc = "  SDL_free() on the pointer when you are done with it, or it will be a"]
  #[doc = "  memory leak. This is not necessarily a fast call, though, so you should"]
  #[doc = "  call this once near startup and save the string if you need it."]
  #[doc = ""]
  #[doc = " You should assume the path returned by this function is the only safe"]
  #[doc = "  place to write files (and that SDL_GetBasePath(), while it might be"]
  #[doc = "  writable, or even the parent of the returned path, aren\'t where you"]
  #[doc = "  should be writing things)."]
  #[doc = ""]
  #[doc = " Some platforms can\'t determine the pref path, and on other"]
  #[doc = "  platforms, this might be meaningless. In such cases, this function will"]
  #[doc = "  return NULL."]
  #[doc = ""]
  #[doc = "   \\param org The name of your organization."]
  #[doc = "   \\param app The name of your application."]
  #[doc = "  \\return UTF-8 string of user dir in platform-dependent notation. NULL"]
  #[doc = "          if there\'s a problem (creating directory failed, etc)."]
  #[doc = ""]
  #[doc = " \\sa SDL_GetBasePath"]
  pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char) -> *mut libc::c_char;
}
#[doc = "  \\typedef SDL_Haptic"]
#[doc = ""]
#[doc = "  \\brief The haptic structure used to identify an SDL haptic."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticOpen"]
#[doc = "  \\sa SDL_HapticOpenFromJoystick"]
#[doc = "  \\sa SDL_HapticClose"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Haptic {
  _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
#[doc = "  \\brief Structure that represents a haptic direction."]
#[doc = ""]
#[doc = "  This is the direction where the force comes from,"]
#[doc = "  instead of the direction in which the force is exerted."]
#[doc = ""]
#[doc = "  Directions can be specified by:"]
#[doc = "   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates."]
#[doc = "   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates."]
#[doc = "   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates."]
#[doc = ""]
#[doc = "  Cardinal directions of the haptic device are relative to the positioning"]
#[doc = "  of the device.  North is considered to be away from the user."]
#[doc = ""]
#[doc = "  The following diagram represents the cardinal directions:"]
#[doc = "  \\verbatim"]
#[doc = ".--."]
#[doc = "|__| .-------."]
#[doc = "|=.| |.-----.|"]
#[doc = "|--| ||     ||"]
#[doc = "|  | |\'-----\'|"]
#[doc = "|__|~\')_____(\'"]
#[doc = "[ COMPUTER ]"]
#[doc = ""]
#[doc = ""]
#[doc = "North (0,-1)"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|"]
#[doc = "(-1,0)  West <----[ HAPTIC ]----> East (1,0)"]
#[doc = "|"]
#[doc = "|"]
#[doc = "v"]
#[doc = "South (0,1)"]
#[doc = ""]
#[doc = ""]
#[doc = "[ USER ]"]
#[doc = "\\|||/"]
#[doc = "(o o)"]
#[doc = "---ooO-(_)-Ooo---"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a"]
#[doc = "  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses"]
#[doc = "  the first \\c dir parameter.  The cardinal directions would be:"]
#[doc = "   - North: 0 (0 degrees)"]
#[doc = "   - East: 9000 (90 degrees)"]
#[doc = "   - South: 18000 (180 degrees)"]
#[doc = "   - West: 27000 (270 degrees)"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions"]
#[doc = "  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses"]
#[doc = "  the first three \\c dir parameters.  The cardinal directions would be:"]
#[doc = "   - North:  0,-1, 0"]
#[doc = "   - East:   1, 0, 0"]
#[doc = "   - South:  0, 1, 0"]
#[doc = "   - West:  -1, 0, 0"]
#[doc = ""]
#[doc = "  The Z axis represents the height of the effect if supported, otherwise"]
#[doc = "  it\'s unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you"]
#[doc = "  can use any multiple you want, only the direction matters."]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations."]
#[doc = "  The first two \\c dir parameters are used.  The \\c dir parameters are as"]
#[doc = "  follows (all values are in hundredths of degrees):"]
#[doc = "   - Degrees from (1, 0) rotated towards (0, 1)."]
#[doc = "   - Degrees towards (0, 0, 1) (device needs at least 3 axes)."]
#[doc = ""]
#[doc = ""]
#[doc = "  Example of force coming from the south with all encodings (force coming"]
#[doc = "  from the south means the user will have to pull the stick to counteract):"]
#[doc = "  \\code"]
#[doc = "  SDL_HapticDirection direction;"]
#[doc = ""]
#[doc = "  // Cartesian directions"]
#[doc = "  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding."]
#[doc = "  direction.dir[0] = 0; // X position"]
#[doc = "  direction.dir[1] = 1; // Y position"]
#[doc = "  // Assuming the device has 2 axes, we don\'t need to specify third parameter."]
#[doc = ""]
#[doc = "  // Polar directions"]
#[doc = "  direction.type = SDL_HAPTIC_POLAR; // We\'ll be using polar direction encoding."]
#[doc = "  direction.dir[0] = 18000; // Polar only uses first parameter"]
#[doc = ""]
#[doc = "  // Spherical coordinates"]
#[doc = "  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding"]
#[doc = "  direction.dir[0] = 9000; // Since we only have two axes we don\'t need more parameters."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_POLAR"]
#[doc = "  \\sa SDL_HAPTIC_CARTESIAN"]
#[doc = "  \\sa SDL_HAPTIC_SPHERICAL"]
#[doc = "  \\sa SDL_HapticEffect"]
#[doc = "  \\sa SDL_HapticNumAxes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticDirection {
  #[doc = "< The type of encoding."]
  pub type_: Uint8,
  #[doc = "< The encoded direction."]
  pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticDirection>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_HapticDirection))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticDirection>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticDirection))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticDirection),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).dir as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticDirection),
      "::",
      stringify!(dir)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Constant effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect."]
#[doc = ""]
#[doc = "  A constant effect applies a constant force in the specified direction"]
#[doc = "  to the joystick."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CONSTANT"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticConstant {
  #[doc = "< ::SDL_HAPTIC_CONSTANT"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Strength of the constant effect."]
  pub level: Sint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticConstant>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_HapticConstant))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticConstant>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticConstant))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).level as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_length as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_level as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_length as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_level as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticConstant),
      "::",
      stringify!(fade_level)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Periodic effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SINE"]
#[doc = "   - ::SDL_HAPTIC_LEFTRIGHT"]
#[doc = "   - ::SDL_HAPTIC_TRIANGLE"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = ""]
#[doc = "  A periodic effect consists in a wave-shaped effect that repeats itself"]
#[doc = "  over time.  The type determines the shape of the wave and the parameters"]
#[doc = "  determine the dimensions of the wave."]
#[doc = ""]
#[doc = "  Phase is given by hundredth of a degree meaning that giving the phase a value"]
#[doc = "  of 9000 will displace it 25% of its period.  Here are sample values:"]
#[doc = "   -     0: No phase displacement."]
#[doc = "   -  9000: Displaced 25% of its period."]
#[doc = "   - 18000: Displaced 50% of its period."]
#[doc = "   - 27000: Displaced 75% of its period."]
#[doc = "   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred."]
#[doc = ""]
#[doc = "  Examples:"]
#[doc = "  \\verbatim"]
#[doc = "SDL_HAPTIC_SINE"]
#[doc = "__      __      __      __"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SQUARE"]
#[doc = "__    __    __    __    __"]
#[doc = "|  |  |  |  |  |  |  |  |  |"]
#[doc = "|  |__|  |__|  |__|  |__|  |"]
#[doc = ""]
#[doc = "SDL_HAPTIC_TRIANGLE"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHUP"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "\\  |\\  |\\  |\\  |\\  |\\  |\\  |"]
#[doc = "\\ | \\ | \\ | \\ | \\ | \\ | \\ |"]
#[doc = "\\|  \\|  \\|  \\|  \\|  \\|  \\|"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_SINE"]
#[doc = "  \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = "  \\sa SDL_HAPTIC_TRIANGLE"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticPeriodic {
  #[doc = "< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,"]
  #[doc = "::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or"]
  #[doc = "::SDL_HAPTIC_SAWTOOTHDOWN"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Period of the wave."]
  pub period: Uint16,
  #[doc = "< Peak value; if negative, equivalent to 180 degrees extra phase shift."]
  pub magnitude: Sint16,
  #[doc = "< Mean value of the wave."]
  pub offset: Sint16,
  #[doc = "< Positive phase shift given by hundredth of a degree."]
  pub phase: Uint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticPeriodic>(),
    48usize,
    concat!("Size of: ", stringify!(SDL_HapticPeriodic))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticPeriodic>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).period as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(period)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).magnitude as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(magnitude)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).offset as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).phase as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(phase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_length as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_level as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_length as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_level as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticPeriodic),
      "::",
      stringify!(fade_level)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Condition effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SPRING: Effect based on axes position."]
#[doc = "   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity."]
#[doc = "   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration."]
#[doc = "   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement."]
#[doc = ""]
#[doc = "  Direction is handled by condition internals instead of a direction member."]
#[doc = "  The condition effect specific members have three parameters.  The first"]
#[doc = "  refers to the X axis, the second refers to the Y axis and the third"]
#[doc = "  refers to the Z axis.  The right terms refer to the positive side of the"]
#[doc = "  axis and the left terms refer to the negative side of the axis.  Please"]
#[doc = "  refer to the ::SDL_HapticDirection diagram for which side is positive and"]
#[doc = "  which is negative."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticDirection"]
#[doc = "  \\sa SDL_HAPTIC_SPRING"]
#[doc = "  \\sa SDL_HAPTIC_DAMPER"]
#[doc = "  \\sa SDL_HAPTIC_INERTIA"]
#[doc = "  \\sa SDL_HAPTIC_FRICTION"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticCondition {
  #[doc = "< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,"]
  #[doc = "::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect - Not used ATM."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Level when joystick is to the positive side; max 0xFFFF."]
  pub right_sat: [Uint16; 3usize],
  #[doc = "< Level when joystick is to the negative side; max 0xFFFF."]
  pub left_sat: [Uint16; 3usize],
  #[doc = "< How fast to increase the force towards the positive side."]
  pub right_coeff: [Sint16; 3usize],
  #[doc = "< How fast to increase the force towards the negative side."]
  pub left_coeff: [Sint16; 3usize],
  #[doc = "< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered."]
  pub deadband: [Uint16; 3usize],
  #[doc = "< Position of the dead zone."]
  pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticCondition>(),
    68usize,
    concat!("Size of: ", stringify!(SDL_HapticCondition))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticCondition>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticCondition))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_sat as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(right_sat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_sat as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(left_sat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_coeff as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(right_coeff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_coeff as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(left_coeff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).deadband as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(deadband)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).center as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCondition),
      "::",
      stringify!(center)
    )
  );
}
#[doc = "  \\brief A structure containing a template for a Ramp effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect."]
#[doc = ""]
#[doc = "  The ramp effect starts at start strength and ends at end strength."]
#[doc = "  It augments in linear fashion.  If you use attack and fade with a ramp"]
#[doc = "  the effects get added to the ramp effect making the effect become"]
#[doc = "  quadratic instead of linear."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_RAMP"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticRamp {
  #[doc = "< ::SDL_HAPTIC_RAMP"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Beginning strength level."]
  pub start: Sint16,
  #[doc = "< Ending strength level."]
  pub end: Sint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticRamp>(),
    44usize,
    concat!("Size of: ", stringify!(SDL_HapticRamp))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticRamp>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticRamp))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).start as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(start)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).end as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(end)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_length as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_level as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_length as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_level as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticRamp),
      "::",
      stringify!(fade_level)
    )
  );
}
#[doc = " \\brief A structure containing a template for a Left/Right effect."]
#[doc = ""]
#[doc = " This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect."]
#[doc = ""]
#[doc = " The Left/Right effect is used to explicitly control the large and small"]
#[doc = " motors, commonly found in modern game controllers. The small (right) motor"]
#[doc = " is high frequency, and the large (left) motor is low frequency."]
#[doc = ""]
#[doc = " \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = " \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_HapticLeftRight {
  #[doc = "< ::SDL_HAPTIC_LEFTRIGHT"]
  pub type_: Uint16,
  #[doc = "< Duration of the effect in milliseconds."]
  pub length: Uint32,
  #[doc = "< Control of the large controller motor."]
  pub large_magnitude: Uint16,
  #[doc = "< Control of the small controller motor."]
  pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticLeftRight>(),
    12usize,
    concat!("Size of: ", stringify!(SDL_HapticLeftRight))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticLeftRight>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).length as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_HapticLeftRight>())).large_magnitude as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(large_magnitude)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_HapticLeftRight>())).small_magnitude as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticLeftRight),
      "::",
      stringify!(small_magnitude)
    )
  );
}
#[doc = "  \\brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  A custom force feedback effect is much like a periodic effect, where the"]
#[doc = "  application can define its exact shape.  You will have to allocate the"]
#[doc = "  data yourself.  Data should consist of channels * samples Uint16 samples."]
#[doc = ""]
#[doc = "  If channels is one, the effect is rotated using the defined direction."]
#[doc = "  Otherwise it uses the samples in data for the different axes."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CUSTOM"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_HapticCustom {
  #[doc = "< ::SDL_HAPTIC_CUSTOM"]
  pub type_: Uint16,
  #[doc = "< Direction of the effect."]
  pub direction: SDL_HapticDirection,
  #[doc = "< Duration of the effect."]
  pub length: Uint32,
  #[doc = "< Delay before starting the effect."]
  pub delay: Uint16,
  #[doc = "< Button that triggers the effect."]
  pub button: Uint16,
  #[doc = "< How soon it can be triggered again after button."]
  pub interval: Uint16,
  #[doc = "< Axes to use, minimum of one."]
  pub channels: Uint8,
  #[doc = "< Sample periods."]
  pub period: Uint16,
  #[doc = "< Amount of samples."]
  pub samples: Uint16,
  #[doc = "< Should contain channels*samples items."]
  pub data: *mut Uint16,
  #[doc = "< Duration of the attack."]
  pub attack_length: Uint16,
  #[doc = "< Level at the start of the attack."]
  pub attack_level: Uint16,
  #[doc = "< Duration of the fade."]
  pub fade_length: Uint16,
  #[doc = "< Level at the end of the fade."]
  pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticCustom>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_HapticCustom))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticCustom>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_HapticCustom))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).direction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(direction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).length as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).delay as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(delay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).button as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(button)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).interval as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(interval)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).channels as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).period as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(period)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).samples as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).data as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_length as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(attack_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_level as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(attack_level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_length as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(fade_length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_level as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticCustom),
      "::",
      stringify!(fade_level)
    )
  );
}
impl Default for SDL_HapticCustom {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = "  \\brief The generic template for any haptic effect."]
#[doc = ""]
#[doc = "  All values max at 32767 (0x7FFF).  Signed values also can be negative."]
#[doc = "  Time values unless specified otherwise are in milliseconds."]
#[doc = ""]
#[doc = "  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767"]
#[doc = "  value.  Neither delay, interval, attack_length nor fade_length support"]
#[doc = "  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends."]
#[doc = ""]
#[doc = "  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of"]
#[doc = "  ::SDL_HAPTIC_INFINITY."]
#[doc = ""]
#[doc = "  Button triggers may not be supported on all devices, it is advised to not"]
#[doc = "  use them if possible.  Buttons start at index 1 instead of index 0 like"]
#[doc = "  the joystick."]
#[doc = ""]
#[doc = "  If both attack_length and fade_level are 0, the envelope is not used,"]
#[doc = "  otherwise both values are used."]
#[doc = ""]
#[doc = "  Common parts:"]
#[doc = "  \\code"]
#[doc = "  // Replay - All effects have this"]
#[doc = "  Uint32 length;        // Duration of effect (ms)."]
#[doc = "  Uint16 delay;         // Delay before starting effect."]
#[doc = ""]
#[doc = "  // Trigger - All effects have this"]
#[doc = "  Uint16 button;        // Button that triggers effect."]
#[doc = "  Uint16 interval;      // How soon before effect can be triggered again."]
#[doc = ""]
#[doc = "  // Envelope - All effects except condition effects have this"]
#[doc = "  Uint16 attack_length; // Duration of the attack (ms)."]
#[doc = "  Uint16 attack_level;  // Level at the start of the attack."]
#[doc = "  Uint16 fade_length;   // Duration of the fade out (ms)."]
#[doc = "  Uint16 fade_level;    // Level at the end of the fade."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = ""]
#[doc = "  Here we have an example of a constant effect evolution in time:"]
#[doc = "  \\verbatim"]
#[doc = "Strength"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|    effect level -->  _________________"]
#[doc = "|                     /                 \\"]
#[doc = "|                    /                   \\"]
#[doc = "|                   /                     \\"]
#[doc = "|                  /                       \\"]
#[doc = "| attack_level --> |                        \\"]
#[doc = "|                  |                        |  <---  fade_level"]
#[doc = "|"]
#[doc = "+--------------------------------------------------> Time"]
#[doc = "[--]                 [---]"]
#[doc = "attack_length        fade_length"]
#[doc = ""]
#[doc = "[------------------][-----------------------]"]
#[doc = "delay               length"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  Note either the attack_level or the fade_level may be above the actual"]
#[doc = "  effect level."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticConstant"]
#[doc = "  \\sa SDL_HapticPeriodic"]
#[doc = "  \\sa SDL_HapticCondition"]
#[doc = "  \\sa SDL_HapticRamp"]
#[doc = "  \\sa SDL_HapticLeftRight"]
#[doc = "  \\sa SDL_HapticCustom"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
  #[doc = "< Effect type."]
  pub type_: Uint16,
  #[doc = "< Constant effect."]
  pub constant: SDL_HapticConstant,
  #[doc = "< Periodic effect."]
  pub periodic: SDL_HapticPeriodic,
  #[doc = "< Condition effect."]
  pub condition: SDL_HapticCondition,
  #[doc = "< Ramp effect."]
  pub ramp: SDL_HapticRamp,
  #[doc = "< Left/Right effect."]
  pub leftright: SDL_HapticLeftRight,
  #[doc = "< Custom effect."]
  pub custom: SDL_HapticCustom,
  _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
  assert_eq!(
    ::core::mem::size_of::<SDL_HapticEffect>(),
    72usize,
    concat!("Size of: ", stringify!(SDL_HapticEffect))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_HapticEffect>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_HapticEffect))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).constant as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(constant)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).periodic as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(periodic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).condition as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(condition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).ramp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(ramp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).leftright as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(leftright)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).custom as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_HapticEffect),
      "::",
      stringify!(custom)
    )
  );
}
impl Default for SDL_HapticEffect {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_HapticEffect {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_HapticEffect {{ union }}")
  }
}
extern "C" {
  #[doc = "  \\brief Count the number of haptic devices attached to the system."]
  #[doc = ""]
  #[doc = "  \\return Number of haptic devices detected on the system."]
  pub fn SDL_NumHaptics() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the implementation dependent name of a haptic device."]
  #[doc = ""]
  #[doc = "  This can be called before any joysticks are opened."]
  #[doc = "  If no name can be found, this function returns NULL."]
  #[doc = ""]
  #[doc = "  \\param device_index Index of the device to get its name."]
  #[doc = "  \\return Name of the device or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_NumHaptics"]
  pub fn SDL_HapticName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Opens a haptic device for use."]
  #[doc = ""]
  #[doc = "  The index passed as an argument refers to the N\'th haptic device on this"]
  #[doc = "  system."]
  #[doc = ""]
  #[doc = "  When opening a haptic device, its gain will be set to maximum and"]
  #[doc = "  autocenter will be disabled.  To modify these values use"]
  #[doc = "  SDL_HapticSetGain() and SDL_HapticSetAutocenter()."]
  #[doc = ""]
  #[doc = "  \\param device_index Index of the device to open."]
  #[doc = "  \\return Device identifier or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticIndex"]
  #[doc = "  \\sa SDL_HapticOpenFromMouse"]
  #[doc = "  \\sa SDL_HapticOpenFromJoystick"]
  #[doc = "  \\sa SDL_HapticClose"]
  #[doc = "  \\sa SDL_HapticSetGain"]
  #[doc = "  \\sa SDL_HapticSetAutocenter"]
  #[doc = "  \\sa SDL_HapticPause"]
  #[doc = "  \\sa SDL_HapticStopAll"]
  pub fn SDL_HapticOpen(device_index: libc::c_int) -> *mut SDL_Haptic;
}
extern "C" {
  #[doc = "  \\brief Checks if the haptic device at index has been opened."]
  #[doc = ""]
  #[doc = "  \\param device_index Index to check to see if it has been opened."]
  #[doc = "  \\return 1 if it has been opened or 0 if it hasn\'t."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticIndex"]
  pub fn SDL_HapticOpened(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Gets the index of a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to get the index of."]
  #[doc = "  \\return The index of the haptic device or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticOpened"]
  pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Gets whether or not the current mouse has haptic capabilities."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn\'t."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpenFromMouse"]
  pub fn SDL_MouseIsHaptic() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Tries to open a haptic device from the current mouse."]
  #[doc = ""]
  #[doc = "  \\return The haptic device identifier or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_MouseIsHaptic"]
  #[doc = "  \\sa SDL_HapticOpen"]
  pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
  #[doc = "  \\brief Checks to see if a joystick has haptic features."]
  #[doc = ""]
  #[doc = "  \\param joystick Joystick to test for haptic capabilities."]
  #[doc = "  \\return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn\'t"]
  #[doc = "          or -1 if an error occurred."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpenFromJoystick"]
  pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Opens a haptic device for use from a joystick device."]
  #[doc = ""]
  #[doc = "  You must still close the haptic device separately.  It will not be closed"]
  #[doc = "  with the joystick."]
  #[doc = ""]
  #[doc = "  When opening from a joystick you should first close the haptic device before"]
  #[doc = "  closing the joystick device.  If not, on some implementations the haptic"]
  #[doc = "  device will also get unallocated and you\'ll be unable to use force feedback"]
  #[doc = "  on that device."]
  #[doc = ""]
  #[doc = "  \\param joystick Joystick to create a haptic device from."]
  #[doc = "  \\return A valid haptic device identifier on success or NULL on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticClose"]
  pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
  #[doc = "  \\brief Closes a haptic device previously opened with SDL_HapticOpen()."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to close."]
  pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
  #[doc = "  \\brief Returns the number of effects a haptic device can store."]
  #[doc = ""]
  #[doc = "  On some platforms this isn\'t fully supported, and therefore is an"]
  #[doc = "  approximation.  Always check to see if your created effect was actually"]
  #[doc = "  created and do not rely solely on SDL_HapticNumEffects()."]
  #[doc = ""]
  #[doc = "  \\param haptic The haptic device to query effect max."]
  #[doc = "  \\return The number of effects the haptic device can store or"]
  #[doc = "          -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNumEffectsPlaying"]
  #[doc = "  \\sa SDL_HapticQuery"]
  pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Returns the number of effects a haptic device can play at the same"]
  #[doc = "         time."]
  #[doc = ""]
  #[doc = "  This is not supported on all platforms, but will always return a value."]
  #[doc = "  Added here for the sake of completeness."]
  #[doc = ""]
  #[doc = "  \\param haptic The haptic device to query maximum playing effects."]
  #[doc = "  \\return The number of effects the haptic device can play at the same time"]
  #[doc = "          or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNumEffects"]
  #[doc = "  \\sa SDL_HapticQuery"]
  pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Gets the haptic device\'s supported features in bitwise manner."]
  #[doc = ""]
  #[doc = "  Example:"]
  #[doc = "  \\code"]
  #[doc = "  if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {"]
  #[doc = "      printf(\"We have constant haptic effect!\\n\");"]
  #[doc = "  }"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  \\param haptic The haptic device to query."]
  #[doc = "  \\return Haptic features in bitwise manner (OR\'d)."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNumEffects"]
  #[doc = "  \\sa SDL_HapticEffectSupported"]
  pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> libc::c_uint;
}
extern "C" {
  #[doc = "  \\brief Gets the number of haptic axes the device has."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticDirection"]
  pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Checks to see if effect is supported by haptic."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to check on."]
  #[doc = "  \\param effect Effect to check to see if it is supported."]
  #[doc = "  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn\'t or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticQuery"]
  #[doc = "  \\sa SDL_HapticNewEffect"]
  pub fn SDL_HapticEffectSupported(
    haptic: *mut SDL_Haptic, effect: *mut SDL_HapticEffect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Creates a new haptic effect on the device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to create the effect on."]
  #[doc = "  \\param effect Properties of the effect to create."]
  #[doc = "  \\return The identifier of the effect on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticUpdateEffect"]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  pub fn SDL_HapticNewEffect(haptic: *mut SDL_Haptic, effect: *mut SDL_HapticEffect)
    -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Updates the properties of an effect."]
  #[doc = ""]
  #[doc = "  Can be used dynamically, although behavior when dynamically changing"]
  #[doc = "  direction may be strange.  Specifically the effect may reupload itself"]
  #[doc = "  and start playing from the start.  You cannot change the type either when"]
  #[doc = "  running SDL_HapticUpdateEffect()."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device that has the effect."]
  #[doc = "  \\param effect Identifier of the effect to update."]
  #[doc = "  \\param data New effect properties to use."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNewEffect"]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  pub fn SDL_HapticUpdateEffect(
    haptic: *mut SDL_Haptic, effect: libc::c_int, data: *mut SDL_HapticEffect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Runs the haptic effect on its associated haptic device."]
  #[doc = ""]
  #[doc = "  If iterations are ::SDL_HAPTIC_INFINITY, it\'ll run the effect over and over"]
  #[doc = "  repeating the envelope (attack and fade) every time.  If you only want the"]
  #[doc = "  effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect\'s length"]
  #[doc = "  parameter."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to run the effect on."]
  #[doc = "  \\param effect Identifier of the haptic effect to run."]
  #[doc = "  \\param iterations Number of iterations to run the effect. Use"]
  #[doc = "         ::SDL_HAPTIC_INFINITY for infinity."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticStopEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  #[doc = "  \\sa SDL_HapticGetEffectStatus"]
  pub fn SDL_HapticRunEffect(
    haptic: *mut SDL_Haptic, effect: libc::c_int, iterations: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Stops the haptic effect on its associated haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to stop the effect on."]
  #[doc = "  \\param effect Identifier of the effect to stop."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticDestroyEffect"]
  pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Destroys a haptic effect on the device."]
  #[doc = ""]
  #[doc = "  This will stop the effect if it\'s running.  Effects are automatically"]
  #[doc = "  destroyed when the device is closed."]
  #[doc = ""]
  #[doc = "  \\param haptic Device to destroy the effect on."]
  #[doc = "  \\param effect Identifier of the effect to destroy."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticNewEffect"]
  pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
extern "C" {
  #[doc = "  \\brief Gets the status of the current effect on the haptic device."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_STATUS feature."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to query the effect status on."]
  #[doc = "  \\param effect Identifier of the effect to query its status."]
  #[doc = "  \\return 0 if it isn\'t playing, 1 if it is playing or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRunEffect"]
  #[doc = "  \\sa SDL_HapticStopEffect"]
  pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the global gain of the device."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_GAIN feature."]
  #[doc = ""]
  #[doc = "  The user may specify the maximum gain by setting the environment variable"]
  #[doc = "  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to"]
  #[doc = "  SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the"]
  #[doc = "  maximum."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to set the gain on."]
  #[doc = "  \\param gain Value to set the gain to, should be between 0 and 100."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticQuery"]
  pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Sets the global autocenter of the device."]
  #[doc = ""]
  #[doc = "  Autocenter should be between 0 and 100.  Setting it to 0 will disable"]
  #[doc = "  autocentering."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_AUTOCENTER feature."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to set autocentering on."]
  #[doc = "  \\param autocenter Value to set autocenter to, 0 disables autocentering."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticQuery"]
  pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Pauses a haptic device."]
  #[doc = ""]
  #[doc = "  Device must support the ::SDL_HAPTIC_PAUSE feature.  Call"]
  #[doc = "  SDL_HapticUnpause() to resume playback."]
  #[doc = ""]
  #[doc = "  Do not modify the effects nor add new ones while the device is paused."]
  #[doc = "  That can cause all sorts of weird errors."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to pause."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticUnpause"]
  pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Unpauses a haptic device."]
  #[doc = ""]
  #[doc = "  Call to unpause after SDL_HapticPause()."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to unpause."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticPause"]
  pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Stops all the currently playing effects on a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to stop."]
  #[doc = "  \\return 0 on success or -1 on error."]
  pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Checks to see if rumble is supported on a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to check to see if it supports rumble."]
  #[doc = "  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn\'t or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRumbleInit"]
  #[doc = "  \\sa SDL_HapticRumblePlay"]
  #[doc = "  \\sa SDL_HapticRumbleStop"]
  pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Initializes the haptic device for simple rumble playback."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to initialize for simple rumble playback."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticOpen"]
  #[doc = "  \\sa SDL_HapticRumbleSupported"]
  #[doc = "  \\sa SDL_HapticRumblePlay"]
  #[doc = "  \\sa SDL_HapticRumbleStop"]
  pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Runs simple rumble on a haptic device"]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic device to play rumble effect on."]
  #[doc = "  \\param strength Strength of the rumble to play as a 0-1 float value."]
  #[doc = "  \\param length Length of the rumble to play in milliseconds."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRumbleSupported"]
  #[doc = "  \\sa SDL_HapticRumbleInit"]
  #[doc = "  \\sa SDL_HapticRumbleStop"]
  pub fn SDL_HapticRumblePlay(
    haptic: *mut SDL_Haptic, strength: f32, length: Uint32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Stops the simple rumble on a haptic device."]
  #[doc = ""]
  #[doc = "  \\param haptic Haptic to stop the rumble on."]
  #[doc = "  \\return 0 on success or -1 on error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_HapticRumbleSupported"]
  #[doc = "  \\sa SDL_HapticRumbleInit"]
  #[doc = "  \\sa SDL_HapticRumblePlay"]
  pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> libc::c_int;
}
pub mod SDL_HintPriority {
  #[doc = "  \\brief  An enumeration of hint priorities"]
  pub type Type = i32;
  pub const SDL_HINT_DEFAULT: Type = 0;
  pub const SDL_HINT_NORMAL: Type = 1;
  pub const SDL_HINT_OVERRIDE: Type = 2;
}
extern "C" {
  #[doc = "  \\brief Set a hint with a specific priority"]
  #[doc = ""]
  #[doc = "  The priority controls the behavior when setting a hint that already"]
  #[doc = "  has a value.  Hints will replace existing hints of their priority and"]
  #[doc = "  lower.  Environment variables are considered to have override priority."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
  pub fn SDL_SetHintWithPriority(
    name: *const libc::c_char, value: *const libc::c_char, priority: SDL_HintPriority::Type,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Set a hint with normal priority"]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
  pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Get a hint"]
  #[doc = ""]
  #[doc = "  \\return The string value of a hint variable."]
  pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get a hint"]
  #[doc = ""]
  #[doc = "  \\return The boolean value of a hint variable."]
  pub fn SDL_GetHintBoolean(
    name: *const libc::c_char, default_value: SDL_bool::Type,
  ) -> SDL_bool::Type;
}
#[doc = " \\brief type definition of the hint callback function."]
pub type SDL_HintCallback = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    name: *const libc::c_char,
    oldValue: *const libc::c_char,
    newValue: *const libc::c_char,
  ),
>;
extern "C" {
  #[doc = "  \\brief Add a function to watch a particular hint"]
  #[doc = ""]
  #[doc = "  \\param name The hint to watch"]
  #[doc = "  \\param callback The function to call when the hint value changes"]
  #[doc = "  \\param userdata A pointer to pass to the callback function"]
  pub fn SDL_AddHintCallback(
    name: *const libc::c_char, callback: SDL_HintCallback, userdata: *mut libc::c_void,
  );
}
extern "C" {
  #[doc = "  \\brief Remove a function watching a particular hint"]
  #[doc = ""]
  #[doc = "  \\param name The hint being watched"]
  #[doc = "  \\param callback The function being called when the hint value changes"]
  #[doc = "  \\param userdata A pointer being passed to the callback function"]
  pub fn SDL_DelHintCallback(
    name: *const libc::c_char, callback: SDL_HintCallback, userdata: *mut libc::c_void,
  );
}
extern "C" {
  #[doc = "  \\brief  Clear all hints"]
  #[doc = ""]
  #[doc = "  This function is called during SDL_Quit() to free stored hints."]
  pub fn SDL_ClearHints();
}
extern "C" {
  #[doc = "  This function dynamically loads a shared object and returns a pointer"]
  #[doc = "  to the object handle (or NULL if there was an error)."]
  #[doc = "  The \'sofile\' parameter is a system dependent name of the object file."]
  pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  Given an object handle, this function looks up the address of the"]
  #[doc = "  named function in the shared object and returns it.  This address"]
  #[doc = "  is no longer valid after calling SDL_UnloadObject()."]
  pub fn SDL_LoadFunction(
    handle: *mut libc::c_void, name: *const libc::c_char,
  ) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  Unload a shared object from memory."]
  pub fn SDL_UnloadObject(handle: *mut libc::c_void);
}
pub mod _bindgen_ty_8 {
  #[doc = "  \\brief The predefined log categories"]
  #[doc = ""]
  #[doc = "  By default the application category is enabled at the INFO level,"]
  #[doc = "  the assert category is enabled at the WARN level, test is enabled"]
  #[doc = "  at the VERBOSE level and all other categories are enabled at the"]
  #[doc = "  CRITICAL level."]
  pub type Type = i32;
  pub const SDL_LOG_CATEGORY_APPLICATION: Type = 0;
  pub const SDL_LOG_CATEGORY_ERROR: Type = 1;
  pub const SDL_LOG_CATEGORY_ASSERT: Type = 2;
  pub const SDL_LOG_CATEGORY_SYSTEM: Type = 3;
  pub const SDL_LOG_CATEGORY_AUDIO: Type = 4;
  pub const SDL_LOG_CATEGORY_VIDEO: Type = 5;
  pub const SDL_LOG_CATEGORY_RENDER: Type = 6;
  pub const SDL_LOG_CATEGORY_INPUT: Type = 7;
  pub const SDL_LOG_CATEGORY_TEST: Type = 8;
  pub const SDL_LOG_CATEGORY_RESERVED1: Type = 9;
  pub const SDL_LOG_CATEGORY_RESERVED2: Type = 10;
  pub const SDL_LOG_CATEGORY_RESERVED3: Type = 11;
  pub const SDL_LOG_CATEGORY_RESERVED4: Type = 12;
  pub const SDL_LOG_CATEGORY_RESERVED5: Type = 13;
  pub const SDL_LOG_CATEGORY_RESERVED6: Type = 14;
  pub const SDL_LOG_CATEGORY_RESERVED7: Type = 15;
  pub const SDL_LOG_CATEGORY_RESERVED8: Type = 16;
  pub const SDL_LOG_CATEGORY_RESERVED9: Type = 17;
  pub const SDL_LOG_CATEGORY_RESERVED10: Type = 18;
  pub const SDL_LOG_CATEGORY_CUSTOM: Type = 19;
}
pub mod SDL_LogPriority {
  #[doc = "  \\brief The predefined log priorities"]
  pub type Type = i32;
  pub const SDL_LOG_PRIORITY_VERBOSE: Type = 1;
  pub const SDL_LOG_PRIORITY_DEBUG: Type = 2;
  pub const SDL_LOG_PRIORITY_INFO: Type = 3;
  pub const SDL_LOG_PRIORITY_WARN: Type = 4;
  pub const SDL_LOG_PRIORITY_ERROR: Type = 5;
  pub const SDL_LOG_PRIORITY_CRITICAL: Type = 6;
  pub const SDL_NUM_LOG_PRIORITIES: Type = 7;
}
extern "C" {
  #[doc = "  \\brief Set the priority of all log categories"]
  pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority::Type);
}
extern "C" {
  #[doc = "  \\brief Set the priority of a particular log category"]
  pub fn SDL_LogSetPriority(category: libc::c_int, priority: SDL_LogPriority::Type);
}
extern "C" {
  #[doc = "  \\brief Get the priority of a particular log category"]
  pub fn SDL_LogGetPriority(category: libc::c_int) -> SDL_LogPriority::Type;
}
extern "C" {
  #[doc = "  \\brief Reset all priorities to default."]
  #[doc = ""]
  #[doc = "  \\note This is called in SDL_Quit()."]
  pub fn SDL_LogResetPriorities();
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO"]
  pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_VERBOSE"]
  pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_DEBUG"]
  pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_INFO"]
  pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_WARN"]
  pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_ERROR"]
  pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_CRITICAL"]
  pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
  #[doc = "  \\brief Log a message with the specified category and priority."]
  pub fn SDL_LogMessage(
    category: libc::c_int, priority: SDL_LogPriority::Type, fmt: *const libc::c_char, ...
  );
}
extern "C" {
  #[doc = "  \\brief Log a message with the specified category and priority."]
  pub fn SDL_LogMessageV(
    category: libc::c_int, priority: SDL_LogPriority::Type, fmt: *const libc::c_char, ap: va_list,
  );
}
#[doc = "  \\brief The prototype for the log output function"]
pub type SDL_LogOutputFunction = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    category: libc::c_int,
    priority: SDL_LogPriority::Type,
    message: *const libc::c_char,
  ),
>;
extern "C" {
  #[doc = "  \\brief Get the current log output function."]
  pub fn SDL_LogGetOutputFunction(
    callback: *mut SDL_LogOutputFunction, userdata: *mut *mut libc::c_void,
  );
}
extern "C" {
  #[doc = "  \\brief This function allows you to replace the default log output"]
  #[doc = "         function with one of your own."]
  pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
pub mod SDL_MessageBoxFlags {
  #[doc = " \\brief SDL_MessageBox flags. If supported will display warning icon, etc."]
  pub type Type = i32;
  #[doc = "< error dialog"]
  pub const SDL_MESSAGEBOX_ERROR: Type = 16;
  #[doc = "< warning dialog"]
  pub const SDL_MESSAGEBOX_WARNING: Type = 32;
  #[doc = "< informational dialog"]
  pub const SDL_MESSAGEBOX_INFORMATION: Type = 64;
}
pub mod SDL_MessageBoxButtonFlags {
  #[doc = " \\brief Flags for SDL_MessageBoxButtonData."]
  pub type Type = i32;
  #[doc = "< Marks the default button when return is hit"]
  pub const SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT: Type = 1;
  #[doc = "< Marks the default button when escape is hit"]
  pub const SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT: Type = 2;
}
#[doc = "  \\brief Individual button data."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxButtonData {
  #[doc = "< ::SDL_MessageBoxButtonFlags"]
  pub flags: Uint32,
  #[doc = "< User defined button id (value returned via SDL_ShowMessageBox)"]
  pub buttonid: libc::c_int,
  #[doc = "< The UTF-8 button text"]
  pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxButtonData>(),
    16usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxButtonData>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).buttonid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(buttonid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).text as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxButtonData),
      "::",
      stringify!(text)
    )
  );
}
impl Default for SDL_MessageBoxButtonData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[doc = " \\brief RGB value used in a message box color scheme"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxColor {
  pub r: Uint8,
  pub g: Uint8,
  pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxColor>(),
    3usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxColor))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxColor>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColor),
      "::",
      stringify!(b)
    )
  );
}
pub mod SDL_MessageBoxColorType {
  pub type Type = i32;
  pub const SDL_MESSAGEBOX_COLOR_BACKGROUND: Type = 0;
  pub const SDL_MESSAGEBOX_COLOR_TEXT: Type = 1;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_BORDER: Type = 2;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND: Type = 3;
  pub const SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED: Type = 4;
  pub const SDL_MESSAGEBOX_COLOR_MAX: Type = 5;
}
#[doc = " \\brief A set of colors to use for message box dialogs"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxColorScheme {
  pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxColorScheme>(),
    15usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxColorScheme>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColorScheme>())).colors as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxColorScheme),
      "::",
      stringify!(colors)
    )
  );
}
#[doc = "  \\brief MessageBox structure containing title, text, window, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_MessageBoxData {
  #[doc = "< ::SDL_MessageBoxFlags"]
  pub flags: Uint32,
  #[doc = "< Parent window, can be NULL"]
  pub window: *mut SDL_Window,
  #[doc = "< UTF-8 title"]
  pub title: *const libc::c_char,
  #[doc = "< UTF-8 message text"]
  pub message: *const libc::c_char,
  pub numbuttons: libc::c_int,
  pub buttons: *const SDL_MessageBoxButtonData,
  #[doc = "< ::SDL_MessageBoxColorScheme, can be NULL to use system settings"]
  pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
  assert_eq!(
    ::core::mem::size_of::<SDL_MessageBoxData>(),
    56usize,
    concat!("Size of: ", stringify!(SDL_MessageBoxData))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_MessageBoxData>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_MessageBoxData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).window as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).title as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(title)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).message as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).numbuttons as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(numbuttons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).buttons as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(buttons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).colorScheme as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_MessageBoxData),
      "::",
      stringify!(colorScheme)
    )
  );
}
impl Default for SDL_MessageBoxData {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  #[doc = "  \\brief Create a modal message box."]
  #[doc = ""]
  #[doc = "  \\param messageboxdata The SDL_MessageBoxData structure with title, text, etc."]
  #[doc = "  \\param buttonid The pointer to which user id of hit button should be copied."]
  #[doc = ""]
  #[doc = "  \\return -1 on error, otherwise 0 and buttonid contains user id of button"]
  #[doc = "          hit or -1 if dialog was closed."]
  #[doc = ""]
  #[doc = "  \\note This function should be called on the thread that created the parent"]
  #[doc = "        window, or on the main thread if the messagebox has no parent.  It will"]
  #[doc = "        block execution of that thread until the user clicks a button or"]
  #[doc = "        closes the messagebox."]
  pub fn SDL_ShowMessageBox(
    messageboxdata: *const SDL_MessageBoxData, buttonid: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a simple modal message box"]
  #[doc = ""]
  #[doc = "  \\param flags    ::SDL_MessageBoxFlags"]
  #[doc = "  \\param title    UTF-8 title text"]
  #[doc = "  \\param message  UTF-8 message text"]
  #[doc = "  \\param window   The parent window, or NULL for no parent"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_ShowMessageBox"]
  pub fn SDL_ShowSimpleMessageBox(
    flags: Uint32, title: *const libc::c_char, message: *const libc::c_char,
    window: *mut SDL_Window,
  ) -> libc::c_int;
}
pub mod SDL_PowerState {
  #[doc = "  \\brief The basic state for the system\'s power supply."]
  pub type Type = i32;
  #[doc = "< cannot determine power status"]
  pub const SDL_POWERSTATE_UNKNOWN: Type = 0;
  #[doc = "< Not plugged in, running on the battery"]
  pub const SDL_POWERSTATE_ON_BATTERY: Type = 1;
  #[doc = "< Plugged in, no battery available"]
  pub const SDL_POWERSTATE_NO_BATTERY: Type = 2;
  #[doc = "< Plugged in, charging battery"]
  pub const SDL_POWERSTATE_CHARGING: Type = 3;
  #[doc = "< Plugged in, battery charged"]
  pub const SDL_POWERSTATE_CHARGED: Type = 4;
}
extern "C" {
  #[doc = "  \\brief Get the current power supply details."]
  #[doc = ""]
  #[doc = "  \\param secs Seconds of battery life left. You can pass a NULL here if"]
  #[doc = "              you don\'t care. Will return -1 if we can\'t determine a"]
  #[doc = "              value, or we\'re not running on a battery."]
  #[doc = ""]
  #[doc = "  \\param pct Percentage of battery life left, between 0 and 100. You can"]
  #[doc = "             pass a NULL here if you don\'t care. Will return -1 if we"]
  #[doc = "             can\'t determine a value, or we\'re not running on a battery."]
  #[doc = ""]
  #[doc = "  \\return The state of the battery (if any)."]
  pub fn SDL_GetPowerInfo(secs: *mut libc::c_int, pct: *mut libc::c_int) -> SDL_PowerState::Type;
}
pub mod SDL_RendererFlags {
  #[doc = "  \\brief Flags used when creating a rendering context"]
  pub type Type = i32;
  #[doc = "< The renderer is a software fallback"]
  pub const SDL_RENDERER_SOFTWARE: Type = 1;
  #[doc = "< The renderer uses hardware"]
  #[doc = "acceleration"]
  pub const SDL_RENDERER_ACCELERATED: Type = 2;
  #[doc = "< Present is synchronized"]
  #[doc = "with the refresh rate"]
  pub const SDL_RENDERER_PRESENTVSYNC: Type = 4;
  #[doc = "< The renderer supports"]
  #[doc = "rendering to texture"]
  pub const SDL_RENDERER_TARGETTEXTURE: Type = 8;
}
#[doc = "  \\brief Information on the capabilities of a render driver or context."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_RendererInfo {
  #[doc = "< The name of the renderer"]
  pub name: *const libc::c_char,
  #[doc = "< Supported ::SDL_RendererFlags"]
  pub flags: Uint32,
  #[doc = "< The number of available texture formats"]
  pub num_texture_formats: Uint32,
  #[doc = "< The available texture formats"]
  pub texture_formats: [Uint32; 16usize],
  #[doc = "< The maximum texture width"]
  pub max_texture_width: libc::c_int,
  #[doc = "< The maximum texture height"]
  pub max_texture_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
  assert_eq!(
    ::core::mem::size_of::<SDL_RendererInfo>(),
    88usize,
    concat!("Size of: ", stringify!(SDL_RendererInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_RendererInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_RendererInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RendererInfo>())).num_texture_formats as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(num_texture_formats)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).texture_formats as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(texture_formats)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_width as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(max_texture_width)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_height as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_RendererInfo),
      "::",
      stringify!(max_texture_height)
    )
  );
}
impl Default for SDL_RendererInfo {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub mod SDL_TextureAccess {
  #[doc = "  \\brief The access pattern allowed for a texture."]
  pub type Type = i32;
  #[doc = "< Changes rarely, not lockable"]
  pub const SDL_TEXTUREACCESS_STATIC: Type = 0;
  #[doc = "< Changes frequently, lockable"]
  pub const SDL_TEXTUREACCESS_STREAMING: Type = 1;
  #[doc = "< Texture can be used as a render target"]
  pub const SDL_TEXTUREACCESS_TARGET: Type = 2;
}
pub mod SDL_TextureModulate {
  #[doc = "  \\brief The texture channel modulation used in SDL_RenderCopy()."]
  pub type Type = i32;
  #[doc = "< No modulation"]
  pub const SDL_TEXTUREMODULATE_NONE: Type = 0;
  #[doc = "< srcC = srcC * color"]
  pub const SDL_TEXTUREMODULATE_COLOR: Type = 1;
  #[doc = "< srcA = srcA * alpha"]
  pub const SDL_TEXTUREMODULATE_ALPHA: Type = 2;
}
pub mod SDL_RendererFlip {
  #[doc = "  \\brief Flip constants for SDL_RenderCopyEx"]
  pub type Type = i32;
  #[doc = "< Do not flip"]
  pub const SDL_FLIP_NONE: Type = 0;
  #[doc = "< flip horizontally"]
  pub const SDL_FLIP_HORIZONTAL: Type = 1;
  #[doc = "< flip vertically"]
  pub const SDL_FLIP_VERTICAL: Type = 2;
}
#[doc = "  \\brief A structure representing rendering state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Renderer {
  _unused: [u8; 0],
}
#[doc = "  \\brief An efficient driver-specific representation of pixel data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Texture {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "  \\brief Get the number of 2D rendering drivers available for the current"]
  #[doc = "         display."]
  #[doc = ""]
  #[doc = "  A render driver is a set of code that handles rendering and texture"]
  #[doc = "  management on a particular display.  Normally there is only one, but"]
  #[doc = "  some drivers may have several available with different capabilities."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRenderDriverInfo()"]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get information about a specific 2D rendering driver for the current"]
  #[doc = "         display."]
  #[doc = ""]
  #[doc = "  \\param index The index of the driver to query information about."]
  #[doc = "  \\param info  A pointer to an SDL_RendererInfo struct to be filled with"]
  #[doc = "               information on the rendering driver."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, -1 if the index was out of range."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  pub fn SDL_GetRenderDriverInfo(index: libc::c_int, info: *mut SDL_RendererInfo) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a window and default renderer"]
  #[doc = ""]
  #[doc = "  \\param width    The width of the window"]
  #[doc = "  \\param height   The height of the window"]
  #[doc = "  \\param window_flags The flags used to create the window"]
  #[doc = "  \\param window   A pointer filled with the window, or NULL on error"]
  #[doc = "  \\param renderer A pointer filled with the renderer, or NULL on error"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_CreateWindowAndRenderer(
    width: libc::c_int, height: libc::c_int, window_flags: Uint32, window: *mut *mut SDL_Window,
    renderer: *mut *mut SDL_Renderer,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a 2D rendering context for a window."]
  #[doc = ""]
  #[doc = "  \\param window The window where rendering is displayed."]
  #[doc = "  \\param index    The index of the rendering driver to initialize, or -1 to"]
  #[doc = "                  initialize the first one supporting the requested flags."]
  #[doc = "  \\param flags    ::SDL_RendererFlags."]
  #[doc = ""]
  #[doc = "  \\return A valid rendering context or NULL if there was an error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateSoftwareRenderer()"]
  #[doc = "  \\sa SDL_GetRendererInfo()"]
  #[doc = "  \\sa SDL_DestroyRenderer()"]
  pub fn SDL_CreateRenderer(
    window: *mut SDL_Window, index: libc::c_int, flags: Uint32,
  ) -> *mut SDL_Renderer;
}
extern "C" {
  #[doc = "  \\brief Create a 2D software rendering context for a surface."]
  #[doc = ""]
  #[doc = "  \\param surface The surface where rendering is done."]
  #[doc = ""]
  #[doc = "  \\return A valid rendering context or NULL if there was an error."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  #[doc = "  \\sa SDL_DestroyRenderer()"]
  pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
  #[doc = "  \\brief Get the renderer associated with a window."]
  pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
  #[doc = "  \\brief Get information about a rendering context."]
  pub fn SDL_GetRendererInfo(
    renderer: *mut SDL_Renderer, info: *mut SDL_RendererInfo,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the output size in pixels of a rendering context."]
  pub fn SDL_GetRendererOutputSize(
    renderer: *mut SDL_Renderer, w: *mut libc::c_int, h: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Create a texture for a rendering context."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer."]
  #[doc = "  \\param format The format of the texture."]
  #[doc = "  \\param access One of the enumerated values in ::SDL_TextureAccess."]
  #[doc = "  \\param w      The width of the texture in pixels."]
  #[doc = "  \\param h      The height of the texture in pixels."]
  #[doc = ""]
  #[doc = "  \\return The created texture is returned, or NULL if no rendering context was"]
  #[doc = "          active,  the format was unsupported, or the width or height were out"]
  #[doc = "          of range."]
  #[doc = ""]
  #[doc = "  \\note The contents of the texture are not defined at creation."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueryTexture()"]
  #[doc = "  \\sa SDL_UpdateTexture()"]
  #[doc = "  \\sa SDL_DestroyTexture()"]
  pub fn SDL_CreateTexture(
    renderer: *mut SDL_Renderer, format: Uint32, access: libc::c_int, w: libc::c_int,
    h: libc::c_int,
  ) -> *mut SDL_Texture;
}
extern "C" {
  #[doc = "  \\brief Create a texture from an existing surface."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer."]
  #[doc = "  \\param surface The surface containing pixel data used to fill the texture."]
  #[doc = ""]
  #[doc = "  \\return The created texture is returned, or NULL on error."]
  #[doc = ""]
  #[doc = "  \\note The surface is not modified or freed by this function."]
  #[doc = ""]
  #[doc = "  \\sa SDL_QueryTexture()"]
  #[doc = "  \\sa SDL_DestroyTexture()"]
  pub fn SDL_CreateTextureFromSurface(
    renderer: *mut SDL_Renderer, surface: *mut SDL_Surface,
  ) -> *mut SDL_Texture;
}
extern "C" {
  #[doc = "  \\brief Query the attributes of a texture"]
  #[doc = ""]
  #[doc = "  \\param texture A texture to be queried."]
  #[doc = "  \\param format  A pointer filled in with the raw format of the texture.  The"]
  #[doc = "                 actual format may differ, but pixel transfers will use this"]
  #[doc = "                 format."]
  #[doc = "  \\param access  A pointer filled in with the actual access to the texture."]
  #[doc = "  \\param w       A pointer filled in with the width of the texture in pixels."]
  #[doc = "  \\param h       A pointer filled in with the height of the texture in pixels."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  pub fn SDL_QueryTexture(
    texture: *mut SDL_Texture, format: *mut Uint32, access: *mut libc::c_int, w: *mut libc::c_int,
    h: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional color value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to update."]
  #[doc = "  \\param r       The red color value multiplied into copy operations."]
  #[doc = "  \\param g       The green color value multiplied into copy operations."]
  #[doc = "  \\param b       The blue color value multiplied into copy operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or color modulation"]
  #[doc = "          is not supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetTextureColorMod()"]
  pub fn SDL_SetTextureColorMod(
    texture: *mut SDL_Texture, r: Uint8, g: Uint8, b: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional color value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to query."]
  #[doc = "  \\param r         A pointer filled in with the current red color value."]
  #[doc = "  \\param g         A pointer filled in with the current green color value."]
  #[doc = "  \\param b         A pointer filled in with the current blue color value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetTextureColorMod()"]
  pub fn SDL_GetTextureColorMod(
    texture: *mut SDL_Texture, r: *mut Uint8, g: *mut Uint8, b: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set an additional alpha value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to update."]
  #[doc = "  \\param alpha     The alpha value multiplied into copy operations."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or alpha modulation"]
  #[doc = "          is not supported."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetTextureAlphaMod()"]
  pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the additional alpha value used in render copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to query."]
  #[doc = "  \\param alpha     A pointer filled in with the current alpha value."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetTextureAlphaMod()"]
  pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the blend mode used for texture copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture The texture to update."]
  #[doc = "  \\param blendMode ::SDL_BlendMode to use for texture blending."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or the blend mode is"]
  #[doc = "          not supported."]
  #[doc = ""]
  #[doc = "  \\note If the blend mode is not supported, the closest supported mode is"]
  #[doc = "        chosen."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetTextureBlendMode()"]
  pub fn SDL_SetTextureBlendMode(
    texture: *mut SDL_Texture, blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the blend mode used for texture copy operations."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to query."]
  #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetTextureBlendMode()"]
  pub fn SDL_GetTextureBlendMode(
    texture: *mut SDL_Texture, blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Update the given texture rectangle with new pixel data."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to update"]
  #[doc = "  \\param rect      A pointer to the rectangle of pixels to update, or NULL to"]
  #[doc = "                   update the entire texture."]
  #[doc = "  \\param pixels    The raw pixel data in the format of the texture."]
  #[doc = "  \\param pitch     The number of bytes in a row of pixel data, including padding between lines."]
  #[doc = ""]
  #[doc = "  The pixel data must be in the format of the texture. The pixel format can be"]
  #[doc = "  queried with SDL_QueryTexture."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\note This is a fairly slow function."]
  pub fn SDL_UpdateTexture(
    texture: *mut SDL_Texture, rect: *const SDL_Rect, pixels: *const libc::c_void,
    pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to update"]
  #[doc = "  \\param rect      A pointer to the rectangle of pixels to update, or NULL to"]
  #[doc = "                   update the entire texture."]
  #[doc = "  \\param Yplane    The raw pixel data for the Y plane."]
  #[doc = "  \\param Ypitch    The number of bytes between rows of pixel data for the Y plane."]
  #[doc = "  \\param Uplane    The raw pixel data for the U plane."]
  #[doc = "  \\param Upitch    The number of bytes between rows of pixel data for the U plane."]
  #[doc = "  \\param Vplane    The raw pixel data for the V plane."]
  #[doc = "  \\param Vpitch    The number of bytes between rows of pixel data for the V plane."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid."]
  #[doc = ""]
  #[doc = "  \\note You can use SDL_UpdateTexture() as long as your pixel data is"]
  #[doc = "        a contiguous block of Y and U/V planes in the proper order, but"]
  #[doc = "        this function is available if your pixel data is not contiguous."]
  pub fn SDL_UpdateYUVTexture(
    texture: *mut SDL_Texture, rect: *const SDL_Rect, Yplane: *const Uint8, Ypitch: libc::c_int,
    Uplane: *const Uint8, Upitch: libc::c_int, Vplane: *const Uint8, Vpitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Lock a portion of the texture for write-only pixel access."]
  #[doc = ""]
  #[doc = "  \\param texture   The texture to lock for access, which was created with"]
  #[doc = "                   ::SDL_TEXTUREACCESS_STREAMING."]
  #[doc = "  \\param rect      A pointer to the rectangle to lock for access. If the rect"]
  #[doc = "                   is NULL, the entire texture will be locked."]
  #[doc = "  \\param pixels    This is filled in with a pointer to the locked pixels,"]
  #[doc = "                   appropriately offset by the locked area."]
  #[doc = "  \\param pitch     This is filled in with the pitch of the locked pixels."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING."]
  #[doc = ""]
  #[doc = "  \\sa SDL_UnlockTexture()"]
  pub fn SDL_LockTexture(
    texture: *mut SDL_Texture, rect: *const SDL_Rect, pixels: *mut *mut libc::c_void,
    pitch: *mut libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Unlock a texture, uploading the changes to video memory, if needed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_LockTexture()"]
  pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
  #[doc = " \\brief Determines whether a window supports the use of render targets"]
  #[doc = ""]
  #[doc = " \\param renderer The renderer that will be checked"]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if supported, SDL_FALSE if not."]
  pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Set a texture as the current rendering target."]
  #[doc = ""]
  #[doc = " \\param renderer The renderer."]
  #[doc = " \\param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target"]
  #[doc = ""]
  #[doc = " \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRenderTarget()"]
  pub fn SDL_SetRenderTarget(renderer: *mut SDL_Renderer, texture: *mut SDL_Texture)
    -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get the current render target or NULL for the default render target."]
  #[doc = ""]
  #[doc = " \\return The current render target"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetRenderTarget()"]
  pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
  #[doc = "  \\brief Set device independent resolution for rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which resolution should be set."]
  #[doc = "  \\param w      The width of the logical resolution"]
  #[doc = "  \\param h      The height of the logical resolution"]
  #[doc = ""]
  #[doc = "  This function uses the viewport and scaling functionality to allow a fixed logical"]
  #[doc = "  resolution for rendering, regardless of the actual output resolution.  If the actual"]
  #[doc = "  output resolution doesn\'t have the same aspect ratio the output rendering will be"]
  #[doc = "  centered within the output display."]
  #[doc = ""]
  #[doc = "  If the output display is a window, mouse events in the window will be filtered"]
  #[doc = "  and scaled so they seem to arrive within the logical resolution."]
  #[doc = ""]
  #[doc = "  \\note If this function results in scaling or subpixel drawing by the"]
  #[doc = "        rendering backend, it will be handled using the appropriate"]
  #[doc = "        quality hints."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetLogicalSize()"]
  #[doc = "  \\sa SDL_RenderSetScale()"]
  #[doc = "  \\sa SDL_RenderSetViewport()"]
  pub fn SDL_RenderSetLogicalSize(
    renderer: *mut SDL_Renderer, w: libc::c_int, h: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get device independent resolution for rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which resolution should be queried."]
  #[doc = "  \\param w      A pointer filled with the width of the logical resolution"]
  #[doc = "  \\param h      A pointer filled with the height of the logical resolution"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  pub fn SDL_RenderGetLogicalSize(
    renderer: *mut SDL_Renderer, w: *mut libc::c_int, h: *mut libc::c_int,
  );
}
extern "C" {
  #[doc = "  \\brief Set whether to force integer scales for resolution-independent rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which integer scaling should be set."]
  #[doc = "  \\param enable   Enable or disable integer scaling"]
  #[doc = ""]
  #[doc = "  This function restricts the logical viewport to integer values - that is, when"]
  #[doc = "  a resolution is between two multiples of a logical size, the viewport size is"]
  #[doc = "  rounded down to the lower multiple."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  pub fn SDL_RenderSetIntegerScale(
    renderer: *mut SDL_Renderer, enable: SDL_bool::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get whether integer scales are forced for resolution-independent rendering"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which integer scaling should be queried."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetIntegerScale()"]
  pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Set the drawing area for rendering on the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which the drawing area should be set."]
  #[doc = "  \\param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target."]
  #[doc = ""]
  #[doc = "  The x,y of the viewport rect represents the origin for rendering."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\note If the window associated with the renderer is resized, the viewport is automatically reset."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetViewport()"]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  pub fn SDL_RenderSetViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the drawing area for the current target."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetViewport()"]
  pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Set the clip rectangle for the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which clip rectangle should be set."]
  #[doc = "  \\param rect   A pointer to the rectangle to set as the clip rectangle, or"]
  #[doc = "                NULL to disable clipping."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetClipRect()"]
  pub fn SDL_RenderSetClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the clip rectangle for the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which clip rectangle should be queried."]
  #[doc = "  \\param rect   A pointer filled in with the current clip rectangle, or"]
  #[doc = "                an empty rectangle if clipping is disabled."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetClipRect()"]
  pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
  #[doc = "  \\brief Get whether clipping is enabled on the given renderer."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which clip state should be queried."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetClipRect()"]
  pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "  \\brief Set the drawing scale for rendering on the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which the drawing scale should be set."]
  #[doc = "  \\param scaleX The horizontal scaling factor"]
  #[doc = "  \\param scaleY The vertical scaling factor"]
  #[doc = ""]
  #[doc = "  The drawing coordinates are scaled by the x/y scaling factors"]
  #[doc = "  before they are used by the renderer.  This allows resolution"]
  #[doc = "  independent drawing with a single coordinate system."]
  #[doc = ""]
  #[doc = "  \\note If this results in scaling or subpixel drawing by the"]
  #[doc = "        rendering backend, it will be handled using the appropriate"]
  #[doc = "        quality hints.  For best results use integer scaling factors."]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetScale()"]
  #[doc = "  \\sa SDL_RenderSetLogicalSize()"]
  pub fn SDL_RenderSetScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the drawing scale for the current target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which drawing scale should be queried."]
  #[doc = "  \\param scaleX A pointer filled in with the horizontal scaling factor"]
  #[doc = "  \\param scaleY A pointer filled in with the vertical scaling factor"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderSetScale()"]
  pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
  #[doc = "  \\brief Set the color used for drawing operations (Rect, Line and Clear)."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which drawing color should be set."]
  #[doc = "  \\param r The red value used to draw on the rendering target."]
  #[doc = "  \\param g The green value used to draw on the rendering target."]
  #[doc = "  \\param b The blue value used to draw on the rendering target."]
  #[doc = "  \\param a The alpha value used to draw on the rendering target, usually"]
  #[doc = "           ::SDL_ALPHA_OPAQUE (255)."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_SetRenderDrawColor(
    renderer: *mut SDL_Renderer, r: Uint8, g: Uint8, b: Uint8, a: Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the color used for drawing operations (Rect, Line and Clear)."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which drawing color should be queried."]
  #[doc = "  \\param r A pointer to the red value used to draw on the rendering target."]
  #[doc = "  \\param g A pointer to the green value used to draw on the rendering target."]
  #[doc = "  \\param b A pointer to the blue value used to draw on the rendering target."]
  #[doc = "  \\param a A pointer to the alpha value used to draw on the rendering target,"]
  #[doc = "           usually ::SDL_ALPHA_OPAQUE (255)."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_GetRenderDrawColor(
    renderer: *mut SDL_Renderer, r: *mut Uint8, g: *mut Uint8, b: *mut Uint8, a: *mut Uint8,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Set the blend mode used for drawing operations (Fill and Line)."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer for which blend mode should be set."]
  #[doc = "  \\param blendMode ::SDL_BlendMode to use for blending."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\note If the blend mode is not supported, the closest supported mode is"]
  #[doc = "        chosen."]
  #[doc = ""]
  #[doc = "  \\sa SDL_GetRenderDrawBlendMode()"]
  pub fn SDL_SetRenderDrawBlendMode(
    renderer: *mut SDL_Renderer, blendMode: SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the blend mode used for drawing operations."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which blend mode should be queried."]
  #[doc = "  \\param blendMode A pointer filled in with the current blend mode."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  #[doc = ""]
  #[doc = "  \\sa SDL_SetRenderDrawBlendMode()"]
  pub fn SDL_GetRenderDrawBlendMode(
    renderer: *mut SDL_Renderer, blendMode: *mut SDL_BlendMode::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Clear the current rendering target with the drawing color"]
  #[doc = ""]
  #[doc = "  This function clears the entire rendering target, ignoring the viewport and"]
  #[doc = "  the clip rectangle."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a point on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw a point."]
  #[doc = "  \\param x The x coordinate of the point."]
  #[doc = "  \\param y The y coordinate of the point."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderDrawPoint(
    renderer: *mut SDL_Renderer, x: libc::c_int, y: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw multiple points on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw multiple points."]
  #[doc = "  \\param points The points to draw"]
  #[doc = "  \\param count The number of points to draw"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderDrawPoints(
    renderer: *mut SDL_Renderer, points: *const SDL_Point, count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a line on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw a line."]
  #[doc = "  \\param x1 The x coordinate of the start point."]
  #[doc = "  \\param y1 The y coordinate of the start point."]
  #[doc = "  \\param x2 The x coordinate of the end point."]
  #[doc = "  \\param y2 The y coordinate of the end point."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderDrawLine(
    renderer: *mut SDL_Renderer, x1: libc::c_int, y1: libc::c_int, x2: libc::c_int, y2: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a series of connected lines on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw multiple lines."]
  #[doc = "  \\param points The points along the lines"]
  #[doc = "  \\param count The number of points, drawing count-1 lines"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderDrawLines(
    renderer: *mut SDL_Renderer, points: *const SDL_Point, count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw a rectangle on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw a rectangle."]
  #[doc = "  \\param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderDrawRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Draw some number of rectangles on the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should draw multiple rectangles."]
  #[doc = "  \\param rects A pointer to an array of destination rectangles."]
  #[doc = "  \\param count The number of rectangles."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderDrawRects(
    renderer: *mut SDL_Renderer, rects: *const SDL_Rect, count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill a rectangle on the current rendering target with the drawing color."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should fill a rectangle."]
  #[doc = "  \\param rect A pointer to the destination rectangle, or NULL for the entire"]
  #[doc = "              rendering target."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Fill some number of rectangles on the current rendering target with the drawing color."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should fill multiple rectangles."]
  #[doc = "  \\param rects A pointer to an array of destination rectangles."]
  #[doc = "  \\param count The number of rectangles."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderFillRects(
    renderer: *mut SDL_Renderer, rects: *const SDL_Rect, count: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Copy a portion of the texture to the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
  #[doc = "  \\param texture The source texture."]
  #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
  #[doc = "                   texture."]
  #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
  #[doc = "                   entire rendering target."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderCopy(
    renderer: *mut SDL_Renderer, texture: *mut SDL_Texture, srcrect: *const SDL_Rect,
    dstrect: *const SDL_Rect,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer which should copy parts of a texture."]
  #[doc = "  \\param texture The source texture."]
  #[doc = "  \\param srcrect   A pointer to the source rectangle, or NULL for the entire"]
  #[doc = "                   texture."]
  #[doc = "  \\param dstrect   A pointer to the destination rectangle, or NULL for the"]
  #[doc = "                   entire rendering target."]
  #[doc = "  \\param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction"]
  #[doc = "  \\param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2)."]
  #[doc = "  \\param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 on error"]
  pub fn SDL_RenderCopyEx(
    renderer: *mut SDL_Renderer, texture: *mut SDL_Texture, srcrect: *const SDL_Rect,
    dstrect: *const SDL_Rect, angle: f64, center: *const SDL_Point, flip: SDL_RendererFlip::Type,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Read pixels from the current rendering target."]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer from which pixels should be read."]
  #[doc = "  \\param rect   A pointer to the rectangle to read, or NULL for the entire"]
  #[doc = "                render target."]
  #[doc = "  \\param format The desired format of the pixel data, or 0 to use the format"]
  #[doc = "                of the rendering target"]
  #[doc = "  \\param pixels A pointer to be filled in with the pixel data"]
  #[doc = "  \\param pitch  The pitch of the pixels parameter."]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if pixel reading is not supported."]
  #[doc = ""]
  #[doc = "  \\warning This is a very slow operation, and should not be used frequently."]
  pub fn SDL_RenderReadPixels(
    renderer: *mut SDL_Renderer, rect: *const SDL_Rect, format: Uint32, pixels: *mut libc::c_void,
    pitch: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Update the screen with rendering performed."]
  pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
  #[doc = "  \\brief Destroy the specified texture."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateTexture()"]
  #[doc = "  \\sa SDL_CreateTextureFromSurface()"]
  pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
  #[doc = "  \\brief Destroy the rendering context for a window and free associated"]
  #[doc = "         textures."]
  #[doc = ""]
  #[doc = "  \\sa SDL_CreateRenderer()"]
  pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
  #[doc = "  \\brief Bind the texture to the current OpenGL/ES/ES2 context for use with"]
  #[doc = "         OpenGL instructions."]
  #[doc = ""]
  #[doc = "  \\param texture  The SDL texture to bind"]
  #[doc = "  \\param texw     A pointer to a float that will be filled with the texture width"]
  #[doc = "  \\param texh     A pointer to a float that will be filled with the texture height"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the operation is not supported"]
  pub fn SDL_GL_BindTexture(
    texture: *mut SDL_Texture, texw: *mut f32, texh: *mut f32,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Unbind a texture from the current OpenGL/ES/ES2 context."]
  #[doc = ""]
  #[doc = "  \\param texture  The SDL texture to unbind"]
  #[doc = ""]
  #[doc = "  \\return 0 on success, or -1 if the operation is not supported"]
  pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the CAMetalLayer associated with the given Metal renderer"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer to query"]
  #[doc = ""]
  #[doc = "  \\return CAMetalLayer* on success, or NULL if the renderer isn\'t a Metal renderer"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetMetalCommandEncoder()"]
  pub fn SDL_RenderGetMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
  #[doc = "  \\brief Get the Metal command encoder for the current frame"]
  #[doc = ""]
  #[doc = "  \\param renderer The renderer to query"]
  #[doc = ""]
  #[doc = "  \\return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn\'t a Metal renderer"]
  #[doc = ""]
  #[doc = "  \\sa SDL_RenderGetMetalLayer()"]
  pub fn SDL_RenderGetMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
#[doc = "  \\brief SDL_sensor.h"]
#[doc = ""]
#[doc = "  In order to use these functions, SDL_Init() must have been called"]
#[doc = "  with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system"]
#[doc = "  for sensors, and load appropriate drivers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Sensor {
  _unused: [u8; 0],
}
pub type SDL_Sensor = _SDL_Sensor;
#[doc = " This is a unique ID for a sensor for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_SensorID = Sint32;
pub mod SDL_SensorType {
  pub type Type = i32;
  #[doc = "< Returned for an invalid sensor"]
  pub const SDL_SENSOR_INVALID: Type = -1;
  #[doc = "< Unknown sensor type"]
  pub const SDL_SENSOR_UNKNOWN: Type = 0;
  #[doc = "< Accelerometer"]
  pub const SDL_SENSOR_ACCEL: Type = 1;
  #[doc = "< Gyroscope"]
  pub const SDL_SENSOR_GYRO: Type = 2;
}
extern "C" {
  #[doc = "  \\brief Count the number of sensors attached to the system right now"]
  pub fn SDL_NumSensors() -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the implementation dependent name of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor name, or NULL if device_index is out of range."]
  pub fn SDL_SensorGetDeviceName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor type, or SDL_SENSOR_INVALID if device_index is out of range."]
  pub fn SDL_SensorGetDeviceType(device_index: libc::c_int) -> SDL_SensorType::Type;
}
extern "C" {
  #[doc = "  \\brief Get the platform dependent type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor platform dependent type, or -1 if device_index is out of range."]
  pub fn SDL_SensorGetDeviceNonPortableType(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the instance ID of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor instance ID, or -1 if device_index is out of range."]
  pub fn SDL_SensorGetDeviceInstanceID(device_index: libc::c_int) -> SDL_SensorID;
}
extern "C" {
  #[doc = "  \\brief Open a sensor for use."]
  #[doc = ""]
  #[doc = "  The index passed as an argument refers to the N\'th sensor on the system."]
  #[doc = ""]
  #[doc = "  \\return A sensor identifier, or NULL if an error occurred."]
  pub fn SDL_SensorOpen(device_index: libc::c_int) -> *mut SDL_Sensor;
}
extern "C" {
  #[doc = " Return the SDL_Sensor associated with an instance id."]
  pub fn SDL_SensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
  #[doc = "  \\brief Get the implementation dependent name of a sensor."]
  #[doc = ""]
  #[doc = "  \\return The sensor name, or NULL if the sensor is NULL."]
  pub fn SDL_SensorGetName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL."]
  pub fn SDL_SensorGetType(sensor: *mut SDL_Sensor) -> SDL_SensorType::Type;
}
extern "C" {
  #[doc = "  \\brief Get the platform dependent type of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor platform dependent type, or -1 if the sensor is NULL."]
  pub fn SDL_SensorGetNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
extern "C" {
  #[doc = "  \\brief Get the instance ID of a sensor."]
  #[doc = ""]
  #[doc = "  This can be called before any sensors are opened."]
  #[doc = ""]
  #[doc = "  \\return The sensor instance ID, or -1 if the sensor is NULL."]
  pub fn SDL_SensorGetInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
  #[doc = "  Get the current state of an opened sensor."]
  #[doc = ""]
  #[doc = "  The number of values and interpretation of the data is sensor dependent."]
  #[doc = ""]
  #[doc = "  \\param sensor The sensor to query"]
  #[doc = "  \\param data A pointer filled with the current sensor state"]
  #[doc = "  \\param num_values The number of values to write to data"]
  #[doc = ""]
  #[doc = "  \\return 0 or -1 if an error occurred."]
  pub fn SDL_SensorGetData(
    sensor: *mut SDL_Sensor, data: *mut f32, num_values: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = "  Close a sensor previously opened with SDL_SensorOpen()"]
  pub fn SDL_SensorClose(sensor: *mut SDL_Sensor);
}
extern "C" {
  #[doc = "  Update the current state of the open sensors."]
  #[doc = ""]
  #[doc = "  This is called automatically by the event loop if sensor events are enabled."]
  #[doc = ""]
  #[doc = "  This needs to be called from the thread that initialized the sensor subsystem."]
  pub fn SDL_SensorUpdate();
}
extern "C" {
  #[doc = "  \\brief Create a window that can be shaped with the specified position, dimensions, and flags."]
  #[doc = ""]
  #[doc = "  \\param title The title of the window, in UTF-8 encoding."]
  #[doc = "  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
  #[doc = "               ::SDL_WINDOWPOS_UNDEFINED."]
  #[doc = "  \\param w     The width of the window."]
  #[doc = "  \\param h     The height of the window."]
  #[doc = "  \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:"]
  #[doc = "               ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,"]
  #[doc = "               ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,"]
  #[doc = "               ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,"]
  #[doc = "       ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset."]
  #[doc = ""]
  #[doc = "  \\return The window created, or NULL if window creation failed."]
  #[doc = ""]
  #[doc = "  \\sa SDL_DestroyWindow()"]
  pub fn SDL_CreateShapedWindow(
    title: *const libc::c_char, x: libc::c_uint, y: libc::c_uint, w: libc::c_uint, h: libc::c_uint,
    flags: Uint32,
  ) -> *mut SDL_Window;
}
extern "C" {
  #[doc = " \\brief Return whether the given window is a shaped window."]
  #[doc = ""]
  #[doc = " \\param window The window to query for being shaped."]
  #[doc = ""]
  #[doc = " \\return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL."]
  #[doc = ""]
  #[doc = " \\sa SDL_CreateShapedWindow"]
  pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool::Type;
}
pub mod WindowShapeMode {
  #[doc = " \\brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union."]
  pub type Type = i32;
  #[doc = " \\brief The default mode, a binarized alpha cutoff of 1."]
  pub const ShapeModeDefault: Type = 0;
  #[doc = " \\brief A binarized alpha cutoff with a given integer value."]
  pub const ShapeModeBinarizeAlpha: Type = 1;
  #[doc = " \\brief A binarized alpha cutoff with a given integer value, but with the opposite comparison."]
  pub const ShapeModeReverseBinarizeAlpha: Type = 2;
  #[doc = " \\brief A color key is applied."]
  pub const ShapeModeColorKey: Type = 3;
}
#[doc = " \\brief A union containing parameters for shaped windows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
  #[doc = " \\brief A cutoff alpha value for binarization of the window shape\'s alpha channel."]
  pub binarizationCutoff: Uint8,
  pub colorKey: SDL_Color,
  _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowShapeParams>(),
    4usize,
    concat!("Size of: ", stringify!(SDL_WindowShapeParams))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowShapeParams>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_WindowShapeParams>())).binarizationCutoff as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeParams),
      "::",
      stringify!(binarizationCutoff)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeParams>())).colorKey as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeParams),
      "::",
      stringify!(colorKey)
    )
  );
}
impl Default for SDL_WindowShapeParams {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_WindowShapeParams {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_WindowShapeParams {{ union }}")
  }
}
#[doc = " \\brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
  #[doc = " \\brief The mode of these window-shape parameters."]
  pub mode: WindowShapeMode::Type,
  #[doc = " \\brief Window-shape parameters."]
  pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
  assert_eq!(
    ::core::mem::size_of::<SDL_WindowShapeMode>(),
    8usize,
    concat!("Size of: ", stringify!(SDL_WindowShapeMode))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_WindowShapeMode>(),
    4usize,
    concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).mode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeMode),
      "::",
      stringify!(mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).parameters as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_WindowShapeMode),
      "::",
      stringify!(parameters)
    )
  );
}
impl Default for SDL_WindowShapeMode {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_WindowShapeMode {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_WindowShapeMode {{ mode: {:?}, parameters: {:?} }}",
      self.mode, self.parameters
    )
  }
}
extern "C" {
  #[doc = " \\brief Set the shape and parameters of a shaped window."]
  #[doc = ""]
  #[doc = " \\param window The shaped window whose parameters should be set."]
  #[doc = " \\param shape A surface encoding the desired shape for the window."]
  #[doc = " \\param shape_mode The parameters to set for the shaped window."]
  #[doc = ""]
  #[doc = " \\return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW"]
  #[doc = "           if the SDL_Window given does not reference a valid shaped window."]
  #[doc = ""]
  #[doc = " \\sa SDL_WindowShapeMode"]
  #[doc = " \\sa SDL_GetShapedWindowMode."]
  pub fn SDL_SetWindowShape(
    window: *mut SDL_Window, shape: *mut SDL_Surface, shape_mode: *mut SDL_WindowShapeMode,
  ) -> libc::c_int;
}
extern "C" {
  #[doc = " \\brief Get the shape parameters of a shaped window."]
  #[doc = ""]
  #[doc = " \\param window The shaped window whose parameters should be retrieved."]
  #[doc = " \\param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape."]
  #[doc = ""]
  #[doc = " \\return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode"]
  #[doc = "           data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if"]
  #[doc = "           the SDL_Window given is a shapeable window currently lacking a shape."]
  #[doc = ""]
  #[doc = " \\sa SDL_WindowShapeMode"]
  #[doc = " \\sa SDL_SetWindowShape"]
  pub fn SDL_GetShapedWindowMode(
    window: *mut SDL_Window, shape_mode: *mut SDL_WindowShapeMode,
  ) -> libc::c_int;
}
#[doc = "\\brief Set a function that is called for every windows message, before TranslateMessage()"]
pub type SDL_WindowsMessageHook = ::core::option::Option<
  unsafe extern "C" fn(
    userdata: *mut libc::c_void,
    hWnd: *mut libc::c_void,
    message: libc::c_uint,
    wParam: Uint64,
    lParam: Sint64,
  ),
>;
extern "C" {
  pub fn SDL_SetWindowsMessageHook(callback: SDL_WindowsMessageHook, userdata: *mut libc::c_void);
}
extern "C" {
  #[doc = "\\brief Returns the D3D9 adapter index that matches the specified display index."]
  #[doc = ""]
  #[doc = "This adapter index can be passed to IDirect3D9::CreateDevice and controls"]
  #[doc = "on which monitor a full screen application will appear."]
  pub fn SDL_Direct3D9GetAdapterIndex(displayIndex: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDirect3DDevice9 {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = "\\brief Returns the D3D device associated with a renderer, or NULL if it\'s not a D3D renderer."]
  #[doc = ""]
  #[doc = "Once you are done using the device, you should release it to avoid a resource leak."]
  pub fn SDL_RenderGetD3D9Device(renderer: *mut SDL_Renderer) -> *mut IDirect3DDevice9;
}
extern "C" {
  #[doc = "\\brief Returns the DXGI Adapter and Output indices for the specified display index."]
  #[doc = ""]
  #[doc = "These can be passed to EnumAdapters and EnumOutputs respectively to get the objects"]
  #[doc = "required to create a DX10 or DX11 device and swap chain."]
  pub fn SDL_DXGIGetOutputInfo(
    displayIndex: libc::c_int, adapterIndex: *mut libc::c_int, outputIndex: *mut libc::c_int,
  ) -> SDL_bool::Type;
}
extern "C" {
  #[doc = "\\brief Return true if the current device is a tablet."]
  pub fn SDL_IsTablet() -> SDL_bool::Type;
}
extern "C" {
  #[doc = " \\brief Get the number of milliseconds since the SDL library initialization."]
  #[doc = ""]
  #[doc = " \\note This value wraps if the program runs for more than ~49 days."]
  pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
  #[doc = " \\brief Get the current value of the high resolution counter"]
  pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
  #[doc = " \\brief Get the count per second of the high resolution counter"]
  pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
  #[doc = " \\brief Wait a specified number of milliseconds before returning."]
  pub fn SDL_Delay(ms: Uint32);
}
#[doc = "  Function prototype for the timer callback function."]
#[doc = ""]
#[doc = "  The callback function is passed the current timer interval and returns"]
#[doc = "  the next timer interval.  If the returned value is the same as the one"]
#[doc = "  passed in, the periodic alarm continues, otherwise a new alarm is"]
#[doc = "  scheduled.  If the callback returns 0, the periodic alarm is cancelled."]
pub type SDL_TimerCallback = ::core::option::Option<
  unsafe extern "C" fn(interval: Uint32, param: *mut libc::c_void) -> Uint32,
>;
#[doc = " Definition of the timer ID type."]
pub type SDL_TimerID = libc::c_int;
extern "C" {
  #[doc = " \\brief Add a new timer to the pool of timers already running."]
  #[doc = ""]
  #[doc = " \\return A timer ID, or 0 when an error occurs."]
  pub fn SDL_AddTimer(
    interval: Uint32, callback: SDL_TimerCallback, param: *mut libc::c_void,
  ) -> SDL_TimerID;
}
extern "C" {
  #[doc = " \\brief Remove a timer knowing its ID."]
  #[doc = ""]
  #[doc = " \\return A boolean value indicating success or failure."]
  #[doc = ""]
  #[doc = " \\warning It is not safe to remove a timer multiple times."]
  pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool::Type;
}
#[doc = "  \\brief Information the version of SDL in use."]
#[doc = ""]
#[doc = "  Represents the library\'s version as three levels: major revision"]
#[doc = "  (increments with massive changes, additions, and enhancements),"]
#[doc = "  minor revision (increments with backwards-compatible changes to the"]
#[doc = "  major revision), and patchlevel (increments with fixes to the minor"]
#[doc = "  revision)."]
#[doc = ""]
#[doc = "  \\sa SDL_VERSION"]
#[doc = "  \\sa SDL_GetVersion"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_version {
  #[doc = "< major version"]
  pub major: Uint8,
  #[doc = "< minor version"]
  pub minor: Uint8,
  #[doc = "< update version"]
  pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
  assert_eq!(
    ::core::mem::size_of::<SDL_version>(),
    3usize,
    concat!("Size of: ", stringify!(SDL_version))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_version>(),
    1usize,
    concat!("Alignment of ", stringify!(SDL_version))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).major as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(major)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).minor as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(minor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_version>())).patch as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_version),
      "::",
      stringify!(patch)
    )
  );
}
extern "C" {
  #[doc = "  \\brief Get the version of SDL that is linked against your program."]
  #[doc = ""]
  #[doc = "  If you are linking to SDL dynamically, then it is possible that the"]
  #[doc = "  current version will be different than the version you compiled against."]
  #[doc = "  This function returns the current version, while SDL_VERSION() is a"]
  #[doc = "  macro that tells you what version you compiled with."]
  #[doc = ""]
  #[doc = "  \\code"]
  #[doc = "  SDL_version compiled;"]
  #[doc = "  SDL_version linked;"]
  #[doc = ""]
  #[doc = "  SDL_VERSION(&compiled);"]
  #[doc = "  SDL_GetVersion(&linked);"]
  #[doc = "  printf(\"We compiled against SDL version %d.%d.%d ...\\n\","]
  #[doc = "         compiled.major, compiled.minor, compiled.patch);"]
  #[doc = "  printf(\"But we linked against SDL version %d.%d.%d.\\n\","]
  #[doc = "         linked.major, linked.minor, linked.patch);"]
  #[doc = "  \\endcode"]
  #[doc = ""]
  #[doc = "  This function may be called safely at any time, even before SDL_Init()."]
  #[doc = ""]
  #[doc = "  \\sa SDL_VERSION"]
  pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
  #[doc = "  \\brief Get the code revision of SDL that is linked against your program."]
  #[doc = ""]
  #[doc = "  Returns an arbitrary string (a hash value) uniquely identifying the"]
  #[doc = "  exact revision of the SDL library in use, and is only useful in comparing"]
  #[doc = "  against other revisions. It is NOT an incrementing number."]
  pub fn SDL_GetRevision() -> *const libc::c_char;
}
extern "C" {
  #[doc = "  \\brief Get the revision number of SDL that is linked against your program."]
  #[doc = ""]
  #[doc = "  Returns a number uniquely identifying the exact revision of the SDL"]
  #[doc = "  library in use. It is an incrementing number based on commits to"]
  #[doc = "  hg.libsdl.org."]
  pub fn SDL_GetRevisionNumber() -> libc::c_int;
}
extern "C" {
  #[doc = "  This function initializes  the subsystems specified by \\c flags"]
  pub fn SDL_Init(flags: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  This function initializes specific SDL subsystems"]
  #[doc = ""]
  #[doc = "  Subsystem initialization is ref-counted, you must call"]
  #[doc = "  SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly"]
  #[doc = "  shutdown a subsystem manually (or call SDL_Quit() to force shutdown)."]
  #[doc = "  If a subsystem is already loaded then this call will"]
  #[doc = "  increase the ref-count and return."]
  pub fn SDL_InitSubSystem(flags: Uint32) -> libc::c_int;
}
extern "C" {
  #[doc = "  This function cleans up specific SDL subsystems"]
  pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
  #[doc = "  This function returns a mask of the specified subsystems which have"]
  #[doc = "  previously been initialized."]
  #[doc = ""]
  #[doc = "  If \\c flags is 0, it returns a mask of all initialized subsystems."]
  pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
  #[doc = "  This function cleans up all initialized subsystems. You should"]
  #[doc = "  call it upon all exit conditions."]
  pub fn SDL_Quit();
}
pub mod _EXCEPTION_DISPOSITION {
  pub type Type = i32;
  pub const ExceptionContinueExecution: Type = 0;
  pub const ExceptionContinueSearch: Type = 1;
  pub const ExceptionNestedException: Type = 2;
  pub const ExceptionCollidedUnwind: Type = 3;
}
pub use self::_EXCEPTION_DISPOSITION::Type as EXCEPTION_DISPOSITION;
extern "C" {
  pub fn __C_specific_handler(
    ExceptionRecord: *mut _EXCEPTION_RECORD, EstablisherFrame: *mut libc::c_void,
    ContextRecord: *mut _CONTEXT, DispatcherContext: *mut _DISPATCHER_CONTEXT,
  ) -> EXCEPTION_DISPOSITION;
}
extern "C" {
  pub fn _exception_code() -> libc::c_ulong;
}
extern "C" {
  pub fn _exception_info() -> *mut libc::c_void;
}
extern "C" {
  pub fn _abnormal_termination() -> libc::c_int;
}
pub type ULONG = libc::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = libc::c_ushort;
pub type PUSHORT = *mut USHORT;
pub type UCHAR = libc::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type PSZ = *mut libc::c_char;
pub type DWORD = libc::c_ulong;
pub type BOOL = libc::c_int;
pub type BYTE = libc::c_uchar;
pub type WORD = libc::c_ushort;
pub type FLOAT = f32;
pub type PFLOAT = *mut FLOAT;
pub type PBOOL = *mut BOOL;
pub type LPBOOL = *mut BOOL;
pub type PBYTE = *mut BYTE;
pub type LPBYTE = *mut BYTE;
pub type PINT = *mut libc::c_int;
pub type LPINT = *mut libc::c_int;
pub type PWORD = *mut WORD;
pub type LPWORD = *mut WORD;
pub type LPLONG = *mut libc::c_long;
pub type PDWORD = *mut DWORD;
pub type LPDWORD = *mut DWORD;
pub type LPVOID = *mut libc::c_void;
pub type LPCVOID = *const libc::c_void;
pub type INT = libc::c_int;
pub type UINT = libc::c_uint;
pub type PUINT = *mut libc::c_uint;
extern "C" {
  pub fn __pctype_func() -> *const libc::c_ushort;
}
extern "C" {
  pub fn __pwctype_func() -> *const wctype_t;
}
extern "C" {
  pub fn iswalnum(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswalpha(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswascii(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswblank(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswcntrl(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswdigit(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswgraph(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswlower(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswprint(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswpunct(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswspace(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswupper(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn iswxdigit(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn __iswcsymf(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn __iswcsym(_C: wint_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
  pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
  pub fn iswctype(_C: wint_t, _Type: wctype_t) -> libc::c_int;
}
extern "C" {
  pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
  pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
  pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isleadbyte(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isleadbyte_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> libc::c_int;
}
extern "C" {
  pub fn _isctype(_C: libc::c_int, _Type: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isctype_l(_C: libc::c_int, _Type: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isalpha(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isalpha_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isupper(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isupper_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn islower(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _islower_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isdigit(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isdigit_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isxdigit(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isxdigit_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isspace(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isspace_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn ispunct(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _ispunct_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isblank(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isblank_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isalnum(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isalnum_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isprint(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isprint_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn isgraph(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _isgraph_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn iscntrl(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _iscntrl_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn toupper(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn tolower(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _tolower(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _tolower_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn _toupper(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn _toupper_l(_C: libc::c_int, _Locale: _locale_t) -> libc::c_int;
}
extern "C" {
  pub fn __isascii(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn __toascii(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn __iscsymf(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn __iscsym(_C: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn ___mb_cur_max_func() -> libc::c_int;
}
extern "C" {
  pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> libc::c_int;
}
pub type POINTER_64_INT = libc::c_ulonglong;
pub type INT8 = libc::c_schar;
pub type PINT8 = *mut libc::c_schar;
pub type INT16 = libc::c_short;
pub type PINT16 = *mut libc::c_short;
pub type INT32 = libc::c_int;
pub type PINT32 = *mut libc::c_int;
pub type INT64 = libc::c_longlong;
pub type PINT64 = *mut libc::c_longlong;
pub type UINT8 = libc::c_uchar;
pub type PUINT8 = *mut libc::c_uchar;
pub type UINT16 = libc::c_ushort;
pub type PUINT16 = *mut libc::c_ushort;
pub type UINT32 = libc::c_uint;
pub type PUINT32 = *mut libc::c_uint;
pub type UINT64 = libc::c_ulonglong;
pub type PUINT64 = *mut libc::c_ulonglong;
pub type LONG32 = libc::c_int;
pub type PLONG32 = *mut libc::c_int;
pub type ULONG32 = libc::c_uint;
pub type PULONG32 = *mut libc::c_uint;
pub type DWORD32 = libc::c_uint;
pub type PDWORD32 = *mut libc::c_uint;
pub type INT_PTR = libc::c_longlong;
pub type PINT_PTR = *mut libc::c_longlong;
pub type UINT_PTR = libc::c_ulonglong;
pub type PUINT_PTR = *mut libc::c_ulonglong;
pub type LONG_PTR = libc::c_longlong;
pub type PLONG_PTR = *mut libc::c_longlong;
pub type ULONG_PTR = libc::c_ulonglong;
pub type PULONG_PTR = *mut libc::c_ulonglong;
pub type SHANDLE_PTR = libc::c_longlong;
pub type HANDLE_PTR = libc::c_ulonglong;
pub type UHALF_PTR = libc::c_uint;
pub type PUHALF_PTR = *mut libc::c_uint;
pub type HALF_PTR = libc::c_int;
pub type PHALF_PTR = *mut libc::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = libc::c_longlong;
pub type PLONG64 = *mut libc::c_longlong;
pub type ULONG64 = libc::c_ulonglong;
pub type PULONG64 = *mut libc::c_ulonglong;
pub type DWORD64 = libc::c_ulonglong;
pub type PDWORD64 = *mut libc::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type PVOID = *mut libc::c_void;
pub type CHAR = libc::c_char;
pub type SHORT = libc::c_short;
pub type LONG = libc::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type PCZPCWSTR = *const PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type LPCWCHAR = *const WCHAR;
pub type PCWCHAR = *const WCHAR;
pub type LPCUWCHAR = *const WCHAR;
pub type PCUWCHAR = *const WCHAR;
pub type UCSCHAR = libc::c_ulong;
pub type PUCSCHAR = *mut UCSCHAR;
pub type PCUCSCHAR = *const UCSCHAR;
pub type PUCSSTR = *mut UCSCHAR;
pub type PUUCSSTR = *mut UCSCHAR;
pub type PCUCSSTR = *const UCSCHAR;
pub type PCUUCSSTR = *const UCSCHAR;
pub type PUUCSCHAR = *mut UCSCHAR;
pub type PCUUCSCHAR = *const UCSCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PCZPCSTR = *const PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = libc::c_char;
pub type PTCHAR = *mut libc::c_char;
pub type TBYTE = libc::c_uchar;
pub type PTBYTE = *mut libc::c_uchar;
pub type LPTCH = LPCH;
pub type PTCH = LPCH;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESSOR_NUMBER {
  pub Group: WORD,
  pub Number: BYTE,
  pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__PROCESSOR_NUMBER() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESSOR_NUMBER>(),
    4usize,
    concat!("Size of: ", stringify!(_PROCESSOR_NUMBER))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESSOR_NUMBER>(),
    2usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_NUMBER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_NUMBER>())).Group as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_NUMBER),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_NUMBER>())).Number as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_NUMBER),
      "::",
      stringify!(Number)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_NUMBER>())).Reserved as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_NUMBER),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GROUP_AFFINITY {
  pub Mask: KAFFINITY,
  pub Group: WORD,
  pub Reserved: [WORD; 3usize],
}
#[test]
fn bindgen_test_layout__GROUP_AFFINITY() {
  assert_eq!(
    ::core::mem::size_of::<_GROUP_AFFINITY>(),
    16usize,
    concat!("Size of: ", stringify!(_GROUP_AFFINITY))
  );
  assert_eq!(
    ::core::mem::align_of::<_GROUP_AFFINITY>(),
    8usize,
    concat!("Alignment of ", stringify!(_GROUP_AFFINITY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GROUP_AFFINITY>())).Mask as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GROUP_AFFINITY>())).Group as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GROUP_AFFINITY>())).Reserved as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut libc::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = BYTE;
pub type FSHORT = WORD;
pub type FLONG = DWORD;
pub type HRESULT = libc::c_long;
pub type CCHAR = libc::c_char;
pub type LCID = DWORD;
pub type PLCID = PDWORD;
pub type LANGID = WORD;
pub mod COMPARTMENT_ID {
  pub type Type = i32;
  pub const UNSPECIFIED_COMPARTMENT_ID: Type = 0;
  pub const DEFAULT_COMPARTMENT_ID: Type = 1;
}
pub type PCOMPARTMENT_ID = *mut COMPARTMENT_ID::Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FLOAT128 {
  pub LowPart: libc::c_longlong,
  pub HighPart: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__FLOAT128() {
  assert_eq!(
    ::core::mem::size_of::<_FLOAT128>(),
    16usize,
    concat!("Size of: ", stringify!(_FLOAT128))
  );
  assert_eq!(
    ::core::mem::align_of::<_FLOAT128>(),
    8usize,
    concat!("Alignment of ", stringify!(_FLOAT128))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FLOAT128>())).LowPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLOAT128),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FLOAT128>())).HighPart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLOAT128),
      "::",
      stringify!(HighPart)
    )
  );
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = libc::c_longlong;
pub type ULONGLONG = libc::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
  pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
  pub u: _LARGE_INTEGER__bindgen_ty_2,
  pub QuadPart: LONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(HighPart)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(HighPart)
    )
  );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
  assert_eq!(
    ::core::mem::size_of::<_LARGE_INTEGER>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER))
  );
  assert_eq!(
    ::core::mem::align_of::<_LARGE_INTEGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER>())).u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER>())).QuadPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER),
      "::",
      stringify!(QuadPart)
    )
  );
}
impl Default for _LARGE_INTEGER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _LARGE_INTEGER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_LARGE_INTEGER {{ union }}")
  }
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
  pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
  pub u: _ULARGE_INTEGER__bindgen_ty_2,
  pub QuadPart: ULONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
  pub LowPart: DWORD,
  pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(HighPart)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
  pub LowPart: DWORD,
  pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(HighPart)
    )
  );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
  assert_eq!(
    ::core::mem::size_of::<_ULARGE_INTEGER>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER))
  );
  assert_eq!(
    ::core::mem::align_of::<_ULARGE_INTEGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ULARGE_INTEGER>())).u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ULARGE_INTEGER>())).QuadPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER),
      "::",
      stringify!(QuadPart)
    )
  );
}
impl Default for _ULARGE_INTEGER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ULARGE_INTEGER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_ULARGE_INTEGER {{ union }}")
  }
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
pub type RTL_REFERENCE_COUNT32 = LONG;
pub type PRTL_REFERENCE_COUNT32 = *mut LONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LUID {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
  assert_eq!(
    ::core::mem::size_of::<_LUID>(),
    8usize,
    concat!("Size of: ", stringify!(_LUID))
  );
  assert_eq!(
    ::core::mem::align_of::<_LUID>(),
    4usize,
    concat!("Alignment of ", stringify!(_LUID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LUID>())).LowPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LUID>())).HighPart as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID),
      "::",
      stringify!(HighPart)
    )
  );
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
extern "C" {
  pub fn _rotl8(Value: libc::c_uchar, Shift: libc::c_uchar) -> libc::c_uchar;
}
extern "C" {
  pub fn _rotl16(Value: libc::c_ushort, Shift: libc::c_uchar) -> libc::c_ushort;
}
extern "C" {
  pub fn _rotr8(Value: libc::c_uchar, Shift: libc::c_uchar) -> libc::c_uchar;
}
extern "C" {
  pub fn _rotr16(Value: libc::c_ushort, Shift: libc::c_uchar) -> libc::c_ushort;
}
extern "C" {
  pub fn _rotl(Value: libc::c_uint, Shift: libc::c_int) -> libc::c_uint;
}
extern "C" {
  pub fn _rotl64(Value: libc::c_ulonglong, Shift: libc::c_int) -> libc::c_ulonglong;
}
extern "C" {
  pub fn _rotr(Value: libc::c_uint, Shift: libc::c_int) -> libc::c_uint;
}
extern "C" {
  pub fn _rotr64(Value: libc::c_ulonglong, Shift: libc::c_int) -> libc::c_ulonglong;
}
pub type BOOLEAN = BYTE;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _LIST_ENTRY {
  pub Flink: *mut _LIST_ENTRY,
  pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_LIST_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_LIST_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_LIST_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_LIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LIST_ENTRY>())).Flink as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LIST_ENTRY),
      "::",
      stringify!(Flink)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LIST_ENTRY>())).Blink as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LIST_ENTRY),
      "::",
      stringify!(Blink)
    )
  );
}
impl Default for _LIST_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SINGLE_LIST_ENTRY {
  pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_SINGLE_LIST_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_SINGLE_LIST_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SINGLE_LIST_ENTRY>())).Next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SINGLE_LIST_ENTRY),
      "::",
      stringify!(Next)
    )
  );
}
impl Default for _SINGLE_LIST_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct LIST_ENTRY32 {
  pub Flink: DWORD,
  pub Blink: DWORD,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY32() {
  assert_eq!(
    ::core::mem::size_of::<LIST_ENTRY32>(),
    8usize,
    concat!("Size of: ", stringify!(LIST_ENTRY32))
  );
  assert_eq!(
    ::core::mem::align_of::<LIST_ENTRY32>(),
    4usize,
    concat!("Alignment of ", stringify!(LIST_ENTRY32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<LIST_ENTRY32>())).Flink as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(LIST_ENTRY32),
      "::",
      stringify!(Flink)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<LIST_ENTRY32>())).Blink as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(LIST_ENTRY32),
      "::",
      stringify!(Blink)
    )
  );
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct LIST_ENTRY64 {
  pub Flink: ULONGLONG,
  pub Blink: ULONGLONG,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY64() {
  assert_eq!(
    ::core::mem::size_of::<LIST_ENTRY64>(),
    16usize,
    concat!("Size of: ", stringify!(LIST_ENTRY64))
  );
  assert_eq!(
    ::core::mem::align_of::<LIST_ENTRY64>(),
    8usize,
    concat!("Alignment of ", stringify!(LIST_ENTRY64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<LIST_ENTRY64>())).Flink as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(LIST_ENTRY64),
      "::",
      stringify!(Flink)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<LIST_ENTRY64>())).Blink as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(LIST_ENTRY64),
      "::",
      stringify!(Blink)
    )
  );
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GUID {
  pub Data1: libc::c_ulong,
  pub Data2: libc::c_ushort,
  pub Data3: libc::c_ushort,
  pub Data4: [libc::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
  assert_eq!(
    ::core::mem::size_of::<_GUID>(),
    16usize,
    concat!("Size of: ", stringify!(_GUID))
  );
  assert_eq!(
    ::core::mem::align_of::<_GUID>(),
    4usize,
    concat!("Alignment of ", stringify!(_GUID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GUID>())).Data1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GUID>())).Data2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GUID>())).Data3 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GUID>())).Data4 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data4)
    )
  );
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type LPIID = *mut IID;
pub type CLSID = GUID;
pub type LPCLSID = *mut CLSID;
pub type FMTID = GUID;
pub type LPFMTID = *mut FMTID;
extern "C" {
  pub fn _errno() -> *mut libc::c_int;
}
extern "C" {
  pub fn _set_errno(_Value: libc::c_int) -> errno_t;
}
extern "C" {
  pub fn _get_errno(_Value: *mut libc::c_int) -> errno_t;
}
extern "C" {
  pub fn __doserrno() -> *mut libc::c_ulong;
}
extern "C" {
  pub fn _set_doserrno(_Value: libc::c_ulong) -> errno_t;
}
extern "C" {
  pub fn _get_doserrno(_Value: *mut libc::c_ulong) -> errno_t;
}
extern "C" {
  pub fn memchr(
    _Buf: *const libc::c_void, _Val: libc::c_int, _MaxCount: libc::c_ulonglong,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn memcmp(
    _Buf1: *const libc::c_void, _Buf2: *const libc::c_void, _Size: libc::c_ulonglong,
  ) -> libc::c_int;
}
extern "C" {
  pub fn memcpy(
    _Dst: *mut libc::c_void, _Src: *const libc::c_void, _Size: libc::c_ulonglong,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn memmove(
    _Dst: *mut libc::c_void, _Src: *const libc::c_void, _Size: libc::c_ulonglong,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn memset(
    _Dst: *mut libc::c_void, _Val: libc::c_int, _Size: libc::c_ulonglong,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn strchr(_Str: *const libc::c_char, _Val: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn strrchr(_Str: *const libc::c_char, _Ch: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn strstr(_Str: *const libc::c_char, _SubStr: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn wcschr(_Str: *const libc::c_ushort, _Ch: libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
  pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _memicmp(
    _Buf1: *const libc::c_void, _Buf2: *const libc::c_void, _Size: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _memicmp_l(
    _Buf1: *const libc::c_void, _Buf2: *const libc::c_void, _Size: usize, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn memccpy(
    _Dst: *mut libc::c_void, _Src: *const libc::c_void, _Val: libc::c_int, _Size: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn memicmp(
    _Buf1: *const libc::c_void, _Buf2: *const libc::c_void, _Size: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wcscat_s(
    _Destination: *mut wchar_t, _SizeInWords: rsize_t, _Source: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn wcscpy_s(
    _Destination: *mut wchar_t, _SizeInWords: rsize_t, _Source: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn wcsncat_s(
    _Destination: *mut wchar_t, _SizeInWords: rsize_t, _Source: *const wchar_t, _MaxCount: rsize_t,
  ) -> errno_t;
}
extern "C" {
  pub fn wcsncpy_s(
    _Destination: *mut wchar_t, _SizeInWords: rsize_t, _Source: *const wchar_t, _MaxCount: rsize_t,
  ) -> errno_t;
}
extern "C" {
  pub fn wcstok_s(
    _String: *mut wchar_t, _Delimiter: *const wchar_t, _Context: *mut *mut wchar_t,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcscmp(_String1: *const libc::c_ushort, _String2: *const libc::c_ushort) -> libc::c_int;
}
extern "C" {
  pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
  pub fn wcslen(_String: *const libc::c_ushort) -> libc::c_ulonglong;
}
extern "C" {
  pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
  pub fn wcsncat(
    _Destination: *mut wchar_t, _Source: *const wchar_t, _Count: usize,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsncmp(
    _String1: *const libc::c_ushort, _String2: *const libc::c_ushort, _MaxCount: libc::c_ulonglong,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wcsncpy(
    _Destination: *mut wchar_t, _Source: *const wchar_t, _Count: usize,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
  pub fn wcstok(
    _String: *mut wchar_t, _Delimiter: *const wchar_t, _Context: *mut *mut wchar_t,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcserror(_ErrorNumber: libc::c_int) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcserror_s(
    _Buffer: *mut wchar_t, _SizeInWords: usize, _ErrorNumber: libc::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn __wcserror_s(
    _Buffer: *mut wchar_t, _SizeInWords: usize, _ErrorMessage: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn _wcsicmp_l(
    _String1: *const wchar_t, _String2: *const wchar_t, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsnicmp(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsnicmp_l(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsnset_s(
    _Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t, _MaxCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
  pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
  pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
  pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
  pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
  pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
  pub fn _wcsxfrm_l(
    _Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize, _Locale: _locale_t,
  ) -> usize;
}
extern "C" {
  pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn _wcscoll_l(
    _String1: *const wchar_t, _String2: *const wchar_t, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn _wcsicoll_l(
    _String1: *const wchar_t, _String2: *const wchar_t, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsncoll(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsncoll_l(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsnicoll(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _wcsnicoll_l(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn wcsnicmp(
    _String1: *const wchar_t, _String2: *const wchar_t, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> libc::c_int;
}
extern "C" {
  pub fn strcpy_s(
    _Destination: *mut libc::c_char, _SizeInBytes: rsize_t, _Source: *const libc::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn strcat_s(
    _Destination: *mut libc::c_char, _SizeInBytes: rsize_t, _Source: *const libc::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn strerror_s(
    _Buffer: *mut libc::c_char, _SizeInBytes: usize, _ErrorNumber: libc::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn strncat_s(
    _Destination: *mut libc::c_char, _SizeInBytes: rsize_t, _Source: *const libc::c_char,
    _MaxCount: rsize_t,
  ) -> errno_t;
}
extern "C" {
  pub fn strncpy_s(
    _Destination: *mut libc::c_char, _SizeInBytes: rsize_t, _Source: *const libc::c_char,
    _MaxCount: rsize_t,
  ) -> errno_t;
}
extern "C" {
  pub fn strtok_s(
    _String: *mut libc::c_char, _Delimiter: *const libc::c_char, _Context: *mut *mut libc::c_char,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn _memccpy(
    _Dst: *mut libc::c_void, _Src: *const libc::c_void, _Val: libc::c_int, _MaxCount: usize,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn strcat(_Destination: *mut libc::c_char, _Source: *const libc::c_char)
    -> *mut libc::c_char;
}
extern "C" {
  pub fn strcmp(_Str1: *const libc::c_char, _Str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn _strcmpi(_String1: *const libc::c_char, _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn strcoll(_String1: *const libc::c_char, _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn _strcoll_l(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn strcpy(_Destination: *mut libc::c_char, _Source: *const libc::c_char)
    -> *mut libc::c_char;
}
extern "C" {
  pub fn strcspn(_Str: *const libc::c_char, _Control: *const libc::c_char) -> libc::c_ulonglong;
}
extern "C" {
  pub fn _strdup(_Source: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strerror(_ErrorMessage: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strerror_s(
    _Buffer: *mut libc::c_char, _SizeInBytes: usize, _ErrorMessage: *const libc::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn strerror(_ErrorMessage: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn _stricmp(_String1: *const libc::c_char, _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn _stricoll(_String1: *const libc::c_char, _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn _stricoll_l(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _stricmp_l(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn strlen(_Str: *const libc::c_char) -> libc::c_ulonglong;
}
extern "C" {
  pub fn _strlwr_s(_String: *mut libc::c_char, _Size: usize) -> errno_t;
}
extern "C" {
  pub fn _strlwr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strlwr_s_l(_String: *mut libc::c_char, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
  pub fn _strlwr_l(_String: *mut libc::c_char, _Locale: _locale_t) -> *mut libc::c_char;
}
extern "C" {
  pub fn strncat(
    _Destination: *mut libc::c_char, _Source: *const libc::c_char, _Count: libc::c_ulonglong,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn strncmp(
    _Str1: *const libc::c_char, _Str2: *const libc::c_char, _MaxCount: libc::c_ulonglong,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _strnicmp(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _strnicmp_l(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
    _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _strnicoll(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _strnicoll_l(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
    _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _strncoll(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn _strncoll_l(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
    _Locale: _locale_t,
  ) -> libc::c_int;
}
extern "C" {
  pub fn __strncnt(_String: *const libc::c_char, _Count: usize) -> usize;
}
extern "C" {
  pub fn strncpy(
    _Destination: *mut libc::c_char, _Source: *const libc::c_char, _Count: libc::c_ulonglong,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn strnlen(_String: *const libc::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
  pub fn _strnset_s(
    _String: *mut libc::c_char, _SizeInBytes: usize, _Value: libc::c_int, _MaxCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn _strnset(
    _Destination: *mut libc::c_char, _Value: libc::c_int, _Count: usize,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn strpbrk(_Str: *const libc::c_char, _Control: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strrev(_Str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strset_s(
    _Destination: *mut libc::c_char, _DestinationSize: usize, _Value: libc::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _strset(_Destination: *mut libc::c_char, _Value: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn strspn(_Str: *const libc::c_char, _Control: *const libc::c_char) -> libc::c_ulonglong;
}
extern "C" {
  pub fn strtok(_String: *mut libc::c_char, _Delimiter: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strupr_s(_String: *mut libc::c_char, _Size: usize) -> errno_t;
}
extern "C" {
  pub fn _strupr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn _strupr_s_l(_String: *mut libc::c_char, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
  pub fn _strupr_l(_String: *mut libc::c_char, _Locale: _locale_t) -> *mut libc::c_char;
}
extern "C" {
  pub fn strxfrm(
    _Destination: *mut libc::c_char, _Source: *const libc::c_char, _MaxCount: libc::c_ulonglong,
  ) -> libc::c_ulonglong;
}
extern "C" {
  pub fn _strxfrm_l(
    _Destination: *mut libc::c_char, _Source: *const libc::c_char, _MaxCount: usize,
    _Locale: _locale_t,
  ) -> usize;
}
extern "C" {
  pub fn strdup(_String: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn strcmpi(_String1: *const libc::c_char, _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn stricmp(_String1: *const libc::c_char, _String2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
  pub fn strlwr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn strnicmp(
    _String1: *const libc::c_char, _String2: *const libc::c_char, _MaxCount: usize,
  ) -> libc::c_int;
}
extern "C" {
  pub fn strnset(
    _String: *mut libc::c_char, _Value: libc::c_int, _MaxCount: usize,
  ) -> *mut libc::c_char;
}
extern "C" {
  pub fn strrev(_String: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
  pub fn strset(_String: *mut libc::c_char, _Value: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
  pub fn strupr(_String: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _OBJECTID {
  pub Lineage: GUID,
  pub Uniquifier: DWORD,
}
#[test]
fn bindgen_test_layout__OBJECTID() {
  assert_eq!(
    ::core::mem::size_of::<_OBJECTID>(),
    20usize,
    concat!("Size of: ", stringify!(_OBJECTID))
  );
  assert_eq!(
    ::core::mem::align_of::<_OBJECTID>(),
    4usize,
    concat!("Alignment of ", stringify!(_OBJECTID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OBJECTID>())).Lineage as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECTID),
      "::",
      stringify!(Lineage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OBJECTID>())).Uniquifier as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECTID),
      "::",
      stringify!(Uniquifier)
    )
  );
}
pub type OBJECTID = _OBJECTID;
pub type PEXCEPTION_ROUTINE =
  ::core::option::Option<unsafe extern "C" fn() -> EXCEPTION_DISPOSITION>;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _M128A {
  pub Low: ULONGLONG,
  pub High: LONGLONG,
}
#[test]
fn bindgen_test_layout__M128A() {
  assert_eq!(
    ::core::mem::size_of::<_M128A>(),
    16usize,
    concat!("Size of: ", stringify!(_M128A))
  );
  assert_eq!(
    ::core::mem::align_of::<_M128A>(),
    16usize,
    concat!("Alignment of ", stringify!(_M128A))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_M128A>())).Low as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_M128A),
      "::",
      stringify!(Low)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_M128A>())).High as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_M128A),
      "::",
      stringify!(High)
    )
  );
}
pub type M128A = _M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _XSAVE_FORMAT {
  pub ControlWord: WORD,
  pub StatusWord: WORD,
  pub TagWord: BYTE,
  pub Reserved1: BYTE,
  pub ErrorOpcode: WORD,
  pub ErrorOffset: DWORD,
  pub ErrorSelector: WORD,
  pub Reserved2: WORD,
  pub DataOffset: DWORD,
  pub DataSelector: WORD,
  pub Reserved3: WORD,
  pub MxCsr: DWORD,
  pub MxCsr_Mask: DWORD,
  pub FloatRegisters: [M128A; 8usize],
  pub XmmRegisters: [M128A; 16usize],
  pub Reserved4: [BYTE; 96usize],
}
#[test]
fn bindgen_test_layout__XSAVE_FORMAT() {
  assert_eq!(
    ::core::mem::size_of::<_XSAVE_FORMAT>(),
    512usize,
    concat!("Size of: ", stringify!(_XSAVE_FORMAT))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSAVE_FORMAT>(),
    16usize,
    concat!("Alignment of ", stringify!(_XSAVE_FORMAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).ControlWord as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(ControlWord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).StatusWord as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(StatusWord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).TagWord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(TagWord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).Reserved1 as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).ErrorOpcode as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(ErrorOpcode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).ErrorOffset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(ErrorOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).ErrorSelector as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(ErrorSelector)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).Reserved2 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).DataOffset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(DataOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).DataSelector as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(DataSelector)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).Reserved3 as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).MxCsr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(MxCsr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).MxCsr_Mask as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(MxCsr_Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).FloatRegisters as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(FloatRegisters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).XmmRegisters as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(XmmRegisters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_FORMAT>())).Reserved4 as *const _ as usize },
    416usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_FORMAT),
      "::",
      stringify!(Reserved4)
    )
  );
}
impl Default for _XSAVE_FORMAT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _XSAVE_FORMAT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_XSAVE_FORMAT {{ ControlWord: {:?}, StatusWord: {:?}, TagWord: {:?}, Reserved1: {:?}, ErrorOpcode: {:?}, ErrorOffset: {:?}, ErrorSelector: {:?}, Reserved2: {:?}, DataOffset: {:?}, DataSelector: {:?}, Reserved3: {:?}, MxCsr: {:?}, MxCsr_Mask: {:?}, FloatRegisters: {:?}, XmmRegisters: {:?}, Reserved4: [...] }}" , self . ControlWord , self . StatusWord , self . TagWord , self . Reserved1 , self . ErrorOpcode , self . ErrorOffset , self . ErrorSelector , self . Reserved2 , self . DataOffset , self . DataSelector , self . Reserved3 , self . MxCsr , self . MxCsr_Mask , self . FloatRegisters , self . XmmRegisters )
  }
}
impl ::core::cmp::PartialEq for _XSAVE_FORMAT {
  fn eq(&self, other: &_XSAVE_FORMAT) -> bool {
    self.ControlWord == other.ControlWord
      && self.StatusWord == other.StatusWord
      && self.TagWord == other.TagWord
      && self.Reserved1 == other.Reserved1
      && self.ErrorOpcode == other.ErrorOpcode
      && self.ErrorOffset == other.ErrorOffset
      && self.ErrorSelector == other.ErrorSelector
      && self.Reserved2 == other.Reserved2
      && self.DataOffset == other.DataOffset
      && self.DataSelector == other.DataSelector
      && self.Reserved3 == other.Reserved3
      && self.MxCsr == other.MxCsr
      && self.MxCsr_Mask == other.MxCsr_Mask
      && self.FloatRegisters == other.FloatRegisters
      && self.XmmRegisters == other.XmmRegisters
      && &self.Reserved4[..] == &other.Reserved4[..]
  }
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _XSAVE_AREA_HEADER {
  pub Mask: DWORD64,
  pub CompactionMask: DWORD64,
  pub Reserved2: [DWORD64; 6usize],
}
#[test]
fn bindgen_test_layout__XSAVE_AREA_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_XSAVE_AREA_HEADER>(),
    64usize,
    concat!("Size of: ", stringify!(_XSAVE_AREA_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSAVE_AREA_HEADER>(),
    8usize,
    concat!("Alignment of ", stringify!(_XSAVE_AREA_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_AREA_HEADER>())).Mask as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_AREA_HEADER),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_AREA_HEADER>())).CompactionMask as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_AREA_HEADER),
      "::",
      stringify!(CompactionMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_AREA_HEADER>())).Reserved2 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_AREA_HEADER),
      "::",
      stringify!(Reserved2)
    )
  );
}
pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _XSAVE_AREA {
  pub LegacyState: XSAVE_FORMAT,
  pub Header: XSAVE_AREA_HEADER,
}
#[test]
fn bindgen_test_layout__XSAVE_AREA() {
  assert_eq!(
    ::core::mem::size_of::<_XSAVE_AREA>(),
    576usize,
    concat!("Size of: ", stringify!(_XSAVE_AREA))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSAVE_AREA>(),
    16usize,
    concat!("Alignment of ", stringify!(_XSAVE_AREA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_AREA>())).LegacyState as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_AREA),
      "::",
      stringify!(LegacyState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSAVE_AREA>())).Header as *const _ as usize },
    512usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSAVE_AREA),
      "::",
      stringify!(Header)
    )
  );
}
impl Default for _XSAVE_AREA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _XSAVE_AREA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_XSAVE_AREA {{ LegacyState: {:?}, Header: {:?} }}",
      self.LegacyState, self.Header
    )
  }
}
impl ::core::cmp::PartialEq for _XSAVE_AREA {
  fn eq(&self, other: &_XSAVE_AREA) -> bool {
    self.LegacyState == other.LegacyState && self.Header == other.Header
  }
}
pub type XSAVE_AREA = _XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _XSTATE_CONTEXT {
  pub Mask: DWORD64,
  pub Length: DWORD,
  pub Reserved1: DWORD,
  pub Area: PXSAVE_AREA,
  pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__XSTATE_CONTEXT() {
  assert_eq!(
    ::core::mem::size_of::<_XSTATE_CONTEXT>(),
    32usize,
    concat!("Size of: ", stringify!(_XSTATE_CONTEXT))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSTATE_CONTEXT>(),
    8usize,
    concat!("Alignment of ", stringify!(_XSTATE_CONTEXT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONTEXT>())).Mask as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONTEXT),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONTEXT>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONTEXT),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONTEXT>())).Reserved1 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONTEXT),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONTEXT>())).Area as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONTEXT),
      "::",
      stringify!(Area)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONTEXT>())).Buffer as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONTEXT),
      "::",
      stringify!(Buffer)
    )
  );
}
impl Default for _XSTATE_CONTEXT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type XSTATE_CONTEXT = _XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCOPE_TABLE_AMD64 {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_AMD64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCOPE_TABLE_AMD64__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).BeginAddress as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64() {
  assert_eq!(
    ::core::mem::size_of::<_SCOPE_TABLE_AMD64>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCOPE_TABLE_AMD64>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_AMD64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCOPE_TABLE_AMD64>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCOPE_TABLE_AMD64>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE_AMD64 = *mut _SCOPE_TABLE_AMD64;
extern "C" {
  pub fn _bittest(Base: *const libc::c_long, Offset: libc::c_long) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittestandcomplement(Base: *mut libc::c_long, Offset: libc::c_long) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittestandset(Base: *mut libc::c_long, Offset: libc::c_long) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittestandreset(Base: *mut libc::c_long, Offset: libc::c_long) -> libc::c_uchar;
}
extern "C" {
  pub fn _interlockedbittestandset(Base: *mut libc::c_long, Offset: libc::c_long) -> libc::c_uchar;
}
extern "C" {
  pub fn _interlockedbittestandreset(
    Base: *mut libc::c_long, Offset: libc::c_long,
  ) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittest64(Base: *const libc::c_longlong, Offset: libc::c_longlong) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittestandcomplement64(
    Base: *mut libc::c_longlong, Offset: libc::c_longlong,
  ) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittestandset64(Base: *mut libc::c_longlong, Offset: libc::c_longlong) -> libc::c_uchar;
}
extern "C" {
  pub fn _bittestandreset64(Base: *mut libc::c_longlong, Offset: libc::c_longlong)
    -> libc::c_uchar;
}
extern "C" {
  pub fn _interlockedbittestandset64(
    Base: *mut libc::c_longlong, Offset: libc::c_longlong,
  ) -> libc::c_uchar;
}
extern "C" {
  pub fn _interlockedbittestandreset64(
    Base: *mut libc::c_longlong, Offset: libc::c_longlong,
  ) -> libc::c_uchar;
}
extern "C" {
  pub fn _BitScanForward(Index: *mut libc::c_ulong, Mask: libc::c_ulong) -> libc::c_uchar;
}
extern "C" {
  pub fn _BitScanReverse(Index: *mut libc::c_ulong, Mask: libc::c_ulong) -> libc::c_uchar;
}
extern "C" {
  pub fn _BitScanForward64(Index: *mut libc::c_ulong, Mask: libc::c_ulonglong) -> libc::c_uchar;
}
extern "C" {
  pub fn _BitScanReverse64(Index: *mut libc::c_ulong, Mask: libc::c_ulonglong) -> libc::c_uchar;
}
extern "C" {
  pub fn _InterlockedIncrement16(Addend: *mut libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _InterlockedDecrement16(Addend: *mut libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _InterlockedCompareExchange16(
    Destination: *mut libc::c_short, ExChange: libc::c_short, Comperand: libc::c_short,
  ) -> libc::c_short;
}
extern "C" {
  pub fn _InterlockedAnd(Destination: *mut libc::c_long, Value: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedOr(Destination: *mut libc::c_long, Value: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedXor(Destination: *mut libc::c_long, Value: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedAnd64(
    Destination: *mut libc::c_longlong, Value: libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedOr64(
    Destination: *mut libc::c_longlong, Value: libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedXor64(
    Destination: *mut libc::c_longlong, Value: libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedIncrement(Addend: *mut libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedDecrement(Addend: *mut libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedExchange(Target: *mut libc::c_long, Value: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedExchangeAdd(Addend: *mut libc::c_long, Value: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedCompareExchange(
    Destination: *mut libc::c_long, ExChange: libc::c_long, Comperand: libc::c_long,
  ) -> libc::c_long;
}
extern "C" {
  pub fn _InterlockedIncrement64(Addend: *mut libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedDecrement64(Addend: *mut libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedExchange64(
    Target: *mut libc::c_longlong, Value: libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedExchangeAdd64(
    Addend: *mut libc::c_longlong, Value: libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedCompareExchange64(
    Destination: *mut libc::c_longlong, ExChange: libc::c_longlong, Comperand: libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _InterlockedCompareExchange128(
    Destination: *mut libc::c_longlong, ExchangeHigh: libc::c_longlong,
    ExchangeLow: libc::c_longlong, ComparandResult: *mut libc::c_longlong,
  ) -> libc::c_uchar;
}
extern "C" {
  pub fn _InterlockedCompareExchangePointer(
    Destination: *mut *mut libc::c_void, Exchange: *mut libc::c_void, Comperand: *mut libc::c_void,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn _InterlockedExchangePointer(
    Target: *mut *mut libc::c_void, Value: *mut libc::c_void,
  ) -> *mut libc::c_void;
}
extern "C" {
  pub fn _InterlockedExchange8(Target: *mut libc::c_char, Value: libc::c_char) -> libc::c_char;
}
extern "C" {
  pub fn _InterlockedExchange16(
    Destination: *mut libc::c_short, ExChange: libc::c_short,
  ) -> libc::c_short;
}
extern "C" {
  pub fn _InterlockedExchangeAdd8(_Addend: *mut libc::c_char, _Value: libc::c_char)
    -> libc::c_char;
}
extern "C" {
  pub fn _InterlockedAnd8(Destination: *mut libc::c_char, Value: libc::c_char) -> libc::c_char;
}
extern "C" {
  pub fn _InterlockedOr8(Destination: *mut libc::c_char, Value: libc::c_char) -> libc::c_char;
}
extern "C" {
  pub fn _InterlockedXor8(Destination: *mut libc::c_char, Value: libc::c_char) -> libc::c_char;
}
extern "C" {
  pub fn _InterlockedAnd16(Destination: *mut libc::c_short, Value: libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _InterlockedOr16(Destination: *mut libc::c_short, Value: libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn _InterlockedXor16(Destination: *mut libc::c_short, Value: libc::c_short) -> libc::c_short;
}
extern "C" {
  pub fn __cpuidex(CPUInfo: *mut libc::c_int, Function: libc::c_int, SubLeaf: libc::c_int);
}
extern "C" {
  pub fn _mm_clflush(Address: *const libc::c_void);
}
extern "C" {
  pub fn _ReadWriteBarrier();
}
extern "C" {
  pub fn __faststorefence();
}
extern "C" {
  pub fn _mm_lfence();
}
extern "C" {
  pub fn _mm_mfence();
}
extern "C" {
  pub fn _mm_sfence();
}
extern "C" {
  pub fn _mm_pause();
}
extern "C" {
  pub fn _mm_prefetch(a: *const libc::c_char, sel: libc::c_int);
}
extern "C" {
  pub fn _m_prefetchw(Source: *const libc::c_void);
}
extern "C" {
  pub fn _mm_getcsr() -> libc::c_uint;
}
extern "C" {
  pub fn _mm_setcsr(MxCsr: libc::c_uint);
}
extern "C" {
  pub fn __getcallerseflags() -> libc::c_uint;
}
extern "C" {
  pub fn __segmentlimit(Selector: DWORD) -> DWORD;
}
extern "C" {
  pub fn __readpmc(Counter: DWORD) -> DWORD64;
}
extern "C" {
  pub fn __rdtsc() -> libc::c_ulonglong;
}
extern "C" {
  pub fn __movsb(Destination: PBYTE, Source: *const BYTE, Count: SIZE_T);
}
extern "C" {
  pub fn __movsw(Destination: PWORD, Source: *const WORD, Count: SIZE_T);
}
extern "C" {
  pub fn __movsd(Destination: PDWORD, Source: *const DWORD, Count: SIZE_T);
}
extern "C" {
  pub fn __movsq(Destination: PDWORD64, Source: *const DWORD64, Count: SIZE_T);
}
extern "C" {
  pub fn __stosb(Destination: *mut libc::c_uchar, Value: libc::c_uchar, Count: libc::c_ulonglong);
}
extern "C" {
  pub fn __stosw(Destination: PWORD, Value: WORD, Count: SIZE_T);
}
extern "C" {
  pub fn __stosd(Destination: PDWORD, Value: DWORD, Count: SIZE_T);
}
extern "C" {
  pub fn __stosq(Destination: PDWORD64, Value: DWORD64, Count: SIZE_T);
}
extern "C" {
  pub fn __mulh(Multiplier: libc::c_longlong, Multiplicand: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
  pub fn __umulh(
    Multiplier: libc::c_ulonglong, Multiplicand: libc::c_ulonglong,
  ) -> libc::c_ulonglong;
}
extern "C" {
  pub fn __popcnt64(operand: libc::c_ulonglong) -> libc::c_ulonglong;
}
extern "C" {
  pub fn __shiftleft128(
    LowPart: libc::c_ulonglong, HighPart: libc::c_ulonglong, Shift: libc::c_uchar,
  ) -> libc::c_ulonglong;
}
extern "C" {
  pub fn __shiftright128(
    LowPart: libc::c_ulonglong, HighPart: libc::c_ulonglong, Shift: libc::c_uchar,
  ) -> libc::c_ulonglong;
}
extern "C" {
  pub fn _mul128(
    Multiplier: libc::c_longlong, Multiplicand: libc::c_longlong,
    HighProduct: *mut libc::c_longlong,
  ) -> libc::c_longlong;
}
extern "C" {
  pub fn _umul128(
    Multiplier: libc::c_ulonglong, Multiplicand: libc::c_ulonglong,
    HighProduct: *mut libc::c_ulonglong,
  ) -> libc::c_ulonglong;
}
extern "C" {
  pub fn __readgsbyte(Offset: libc::c_ulong) -> libc::c_uchar;
}
extern "C" {
  pub fn __readgsword(Offset: libc::c_ulong) -> libc::c_ushort;
}
extern "C" {
  pub fn __readgsdword(Offset: libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
  pub fn __readgsqword(Offset: libc::c_ulong) -> libc::c_ulonglong;
}
extern "C" {
  pub fn __writegsbyte(Offset: DWORD, Data: BYTE);
}
extern "C" {
  pub fn __writegsword(Offset: DWORD, Data: WORD);
}
extern "C" {
  pub fn __writegsdword(Offset: DWORD, Data: DWORD);
}
extern "C" {
  pub fn __writegsqword(Offset: DWORD, Data: DWORD64);
}
extern "C" {
  pub fn __incgsbyte(Offset: DWORD);
}
extern "C" {
  pub fn __addgsbyte(Offset: DWORD, Value: BYTE);
}
extern "C" {
  pub fn __incgsword(Offset: DWORD);
}
extern "C" {
  pub fn __addgsword(Offset: DWORD, Value: WORD);
}
extern "C" {
  pub fn __incgsdword(Offset: DWORD);
}
extern "C" {
  pub fn __addgsdword(Offset: DWORD, Value: DWORD);
}
extern "C" {
  pub fn __incgsqword(Offset: DWORD);
}
extern "C" {
  pub fn __addgsqword(Offset: DWORD, Value: DWORD64);
}
pub type XMM_SAVE_AREA32 = XSAVE_FORMAT;
pub type PXMM_SAVE_AREA32 = *mut XSAVE_FORMAT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
  pub P1Home: DWORD64,
  pub P2Home: DWORD64,
  pub P3Home: DWORD64,
  pub P4Home: DWORD64,
  pub P5Home: DWORD64,
  pub P6Home: DWORD64,
  pub ContextFlags: DWORD,
  pub MxCsr: DWORD,
  pub SegCs: WORD,
  pub SegDs: WORD,
  pub SegEs: WORD,
  pub SegFs: WORD,
  pub SegGs: WORD,
  pub SegSs: WORD,
  pub EFlags: DWORD,
  pub Dr0: DWORD64,
  pub Dr1: DWORD64,
  pub Dr2: DWORD64,
  pub Dr3: DWORD64,
  pub Dr6: DWORD64,
  pub Dr7: DWORD64,
  pub Rax: DWORD64,
  pub Rcx: DWORD64,
  pub Rdx: DWORD64,
  pub Rbx: DWORD64,
  pub Rsp: DWORD64,
  pub Rbp: DWORD64,
  pub Rsi: DWORD64,
  pub Rdi: DWORD64,
  pub R8: DWORD64,
  pub R9: DWORD64,
  pub R10: DWORD64,
  pub R11: DWORD64,
  pub R12: DWORD64,
  pub R13: DWORD64,
  pub R14: DWORD64,
  pub R15: DWORD64,
  pub Rip: DWORD64,
  pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
  pub VectorRegister: [M128A; 26usize],
  pub VectorControl: DWORD64,
  pub DebugControl: DWORD64,
  pub LastBranchToRip: DWORD64,
  pub LastBranchFromRip: DWORD64,
  pub LastExceptionToRip: DWORD64,
  pub LastExceptionFromRip: DWORD64,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
  pub FltSave: XMM_SAVE_AREA32,
  pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u128; 32usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
  pub Header: [M128A; 2usize],
  pub Legacy: [M128A; 8usize],
  pub Xmm0: M128A,
  pub Xmm1: M128A,
  pub Xmm2: M128A,
  pub Xmm3: M128A,
  pub Xmm4: M128A,
  pub Xmm5: M128A,
  pub Xmm6: M128A,
  pub Xmm7: M128A,
  pub Xmm8: M128A,
  pub Xmm9: M128A,
  pub Xmm10: M128A,
  pub Xmm11: M128A,
  pub Xmm12: M128A,
  pub Xmm13: M128A,
  pub Xmm14: M128A,
  pub Xmm15: M128A,
}
#[test]
fn bindgen_test_layout__CONTEXT__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
    416usize,
    concat!(
      "Size of: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Alignment of ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Legacy as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Legacy)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm0 as *const _ as usize
    },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm1 as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm2 as *const _ as usize
    },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm3 as *const _ as usize
    },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm4 as *const _ as usize
    },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm5 as *const _ as usize
    },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm6 as *const _ as usize
    },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm7 as *const _ as usize
    },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm8 as *const _ as usize
    },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm9 as *const _ as usize
    },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm10 as *const _ as usize
    },
    320usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm11 as *const _ as usize
    },
    336usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm12 as *const _ as usize
    },
    352usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm13 as *const _ as usize
    },
    368usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm14 as *const _ as usize
    },
    384usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm15 as *const _ as usize
    },
    400usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm15)
    )
  );
}
#[test]
fn bindgen_test_layout__CONTEXT__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_CONTEXT__bindgen_ty_1>(),
    512usize,
    concat!("Size of: ", stringify!(_CONTEXT__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONTEXT__bindgen_ty_1>(),
    16usize,
    concat!("Alignment of ", stringify!(_CONTEXT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT__bindgen_ty_1>())).FltSave as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT__bindgen_ty_1),
      "::",
      stringify!(FltSave)
    )
  );
}
impl Default for _CONTEXT__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CONTEXT__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_CONTEXT__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__CONTEXT() {
  assert_eq!(
    ::core::mem::size_of::<_CONTEXT>(),
    1232usize,
    concat!("Size of: ", stringify!(_CONTEXT))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONTEXT>(),
    16usize,
    concat!("Alignment of ", stringify!(_CONTEXT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).P1Home as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(P1Home)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).P2Home as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(P2Home)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).P3Home as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(P3Home)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).P4Home as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(P4Home)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).P5Home as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(P5Home)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).P6Home as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(P6Home)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).ContextFlags as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(ContextFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).MxCsr as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(MxCsr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).SegCs as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(SegCs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).SegDs as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(SegDs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).SegEs as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(SegEs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).SegFs as *const _ as usize },
    62usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(SegFs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).SegGs as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(SegGs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).SegSs as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(SegSs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).EFlags as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(EFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Dr0 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Dr0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Dr1 as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Dr1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Dr2 as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Dr2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Dr3 as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Dr3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Dr6 as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Dr6)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Dr7 as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Dr7)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rax as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rcx as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rcx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rdx as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rdx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rbx as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rbx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rsp as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rsp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rbp as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rbp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rsi as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rsi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rdi as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rdi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R8 as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R8)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R9 as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R9)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R10 as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R10)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R11 as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R11)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R12 as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R12)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R13 as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R13)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R14 as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R14)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).R15 as *const _ as usize },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(R15)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).Rip as *const _ as usize },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(Rip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).VectorRegister as *const _ as usize },
    768usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(VectorRegister)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).VectorControl as *const _ as usize },
    1184usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(VectorControl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).DebugControl as *const _ as usize },
    1192usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(DebugControl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).LastBranchToRip as *const _ as usize },
    1200usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(LastBranchToRip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).LastBranchFromRip as *const _ as usize },
    1208usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(LastBranchFromRip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).LastExceptionToRip as *const _ as usize },
    1216usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(LastExceptionToRip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONTEXT>())).LastExceptionFromRip as *const _ as usize },
    1224usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONTEXT),
      "::",
      stringify!(LastExceptionFromRip)
    )
  );
}
impl Default for _CONTEXT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CONTEXT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_CONTEXT {{ P1Home: {:?}, P2Home: {:?}, P3Home: {:?}, P4Home: {:?}, P5Home: {:?}, P6Home: {:?}, ContextFlags: {:?}, MxCsr: {:?}, SegCs: {:?}, SegDs: {:?}, SegEs: {:?}, SegFs: {:?}, SegGs: {:?}, SegSs: {:?}, EFlags: {:?}, Dr0: {:?}, Dr1: {:?}, Dr2: {:?}, Dr3: {:?}, Dr6: {:?}, Dr7: {:?}, Rax: {:?}, Rcx: {:?}, Rdx: {:?}, Rbx: {:?}, Rsp: {:?}, Rbp: {:?}, Rsi: {:?}, Rdi: {:?}, R8: {:?}, R9: {:?}, R10: {:?}, R11: {:?}, R12: {:?}, R13: {:?}, R14: {:?}, R15: {:?}, Rip: {:?}, __bindgen_anon_1: {:?}, VectorRegister: {:?}, VectorControl: {:?}, DebugControl: {:?}, LastBranchToRip: {:?}, LastBranchFromRip: {:?}, LastExceptionToRip: {:?}, LastExceptionFromRip: {:?} }}" , self . P1Home , self . P2Home , self . P3Home , self . P4Home , self . P5Home , self . P6Home , self . ContextFlags , self . MxCsr , self . SegCs , self . SegDs , self . SegEs , self . SegFs , self . SegGs , self . SegSs , self . EFlags , self . Dr0 , self . Dr1 , self . Dr2 , self . Dr3 , self . Dr6 , self . Dr7 , self . Rax , self . Rcx , self . Rdx , self . Rbx , self . Rsp , self . Rbp , self . Rsi , self . Rdi , self . R8 , self . R9 , self . R10 , self . R11 , self . R12 , self . R13 , self . R14 , self . R15 , self . Rip , self . __bindgen_anon_1 , self . VectorRegister , self . VectorControl , self . DebugControl , self . LastBranchToRip , self . LastBranchFromRip , self . LastExceptionToRip , self . LastExceptionFromRip )
  }
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
pub type RUNTIME_FUNCTION = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PRUNTIME_FUNCTION = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type SCOPE_TABLE = SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE = *mut SCOPE_TABLE_AMD64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UNWIND_HISTORY_TABLE_ENTRY {
  pub ImageBase: DWORD64,
  pub FunctionEntry: PRUNTIME_FUNCTION,
}
#[test]
fn bindgen_test_layout__UNWIND_HISTORY_TABLE_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_UNWIND_HISTORY_TABLE_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_UNWIND_HISTORY_TABLE_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_UNWIND_HISTORY_TABLE_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_UNWIND_HISTORY_TABLE_ENTRY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE_ENTRY>())).ImageBase as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE_ENTRY),
      "::",
      stringify!(ImageBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE_ENTRY>())).FunctionEntry as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE_ENTRY),
      "::",
      stringify!(FunctionEntry)
    )
  );
}
impl Default for _UNWIND_HISTORY_TABLE_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UNWIND_HISTORY_TABLE_ENTRY = _UNWIND_HISTORY_TABLE_ENTRY;
pub type PUNWIND_HISTORY_TABLE_ENTRY = *mut _UNWIND_HISTORY_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UNWIND_HISTORY_TABLE {
  pub Count: DWORD,
  pub LocalHint: BYTE,
  pub GlobalHint: BYTE,
  pub Search: BYTE,
  pub Once: BYTE,
  pub LowAddress: DWORD64,
  pub HighAddress: DWORD64,
  pub Entry: [UNWIND_HISTORY_TABLE_ENTRY; 12usize],
}
#[test]
fn bindgen_test_layout__UNWIND_HISTORY_TABLE() {
  assert_eq!(
    ::core::mem::size_of::<_UNWIND_HISTORY_TABLE>(),
    216usize,
    concat!("Size of: ", stringify!(_UNWIND_HISTORY_TABLE))
  );
  assert_eq!(
    ::core::mem::align_of::<_UNWIND_HISTORY_TABLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_UNWIND_HISTORY_TABLE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).LocalHint as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(LocalHint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).GlobalHint as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(GlobalHint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).Search as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(Search)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).Once as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(Once)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).LowAddress as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(LowAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).HighAddress as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(HighAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNWIND_HISTORY_TABLE>())).Entry as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNWIND_HISTORY_TABLE),
      "::",
      stringify!(Entry)
    )
  );
}
impl Default for _UNWIND_HISTORY_TABLE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UNWIND_HISTORY_TABLE = _UNWIND_HISTORY_TABLE;
pub type PUNWIND_HISTORY_TABLE = *mut _UNWIND_HISTORY_TABLE;
pub type GET_RUNTIME_FUNCTION_CALLBACK = ::core::option::Option<
  unsafe extern "C" fn(ControlPc: DWORD64, Context: PVOID) -> PRUNTIME_FUNCTION,
>;
pub type PGET_RUNTIME_FUNCTION_CALLBACK = GET_RUNTIME_FUNCTION_CALLBACK;
pub type OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = ::core::option::Option<
  unsafe extern "C" fn(
    Process: HANDLE,
    TableAddress: PVOID,
    Entries: PDWORD,
    Functions: *mut PRUNTIME_FUNCTION,
  ) -> DWORD,
>;
pub type POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _DISPATCHER_CONTEXT {
  pub ControlPc: DWORD64,
  pub ImageBase: DWORD64,
  pub FunctionEntry: PRUNTIME_FUNCTION,
  pub EstablisherFrame: DWORD64,
  pub TargetIp: DWORD64,
  pub ContextRecord: PCONTEXT,
  pub LanguageHandler: PEXCEPTION_ROUTINE,
  pub HandlerData: PVOID,
  pub HistoryTable: PUNWIND_HISTORY_TABLE,
  pub ScopeIndex: DWORD,
  pub Fill0: DWORD,
}
#[test]
fn bindgen_test_layout__DISPATCHER_CONTEXT() {
  assert_eq!(
    ::core::mem::size_of::<_DISPATCHER_CONTEXT>(),
    80usize,
    concat!("Size of: ", stringify!(_DISPATCHER_CONTEXT))
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPATCHER_CONTEXT>(),
    8usize,
    concat!("Alignment of ", stringify!(_DISPATCHER_CONTEXT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).ControlPc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(ControlPc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).ImageBase as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(ImageBase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).FunctionEntry as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(FunctionEntry)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).EstablisherFrame as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(EstablisherFrame)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).TargetIp as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(TargetIp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).ContextRecord as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(ContextRecord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).LanguageHandler as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(LanguageHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).HandlerData as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(HandlerData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).HistoryTable as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(HistoryTable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).ScopeIndex as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(ScopeIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPATCHER_CONTEXT>())).Fill0 as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPATCHER_CONTEXT),
      "::",
      stringify!(Fill0)
    )
  );
}
impl Default for _DISPATCHER_CONTEXT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DISPATCHER_CONTEXT = _DISPATCHER_CONTEXT;
pub type PDISPATCHER_CONTEXT = *mut _DISPATCHER_CONTEXT;
pub type PEXCEPTION_FILTER = ::core::option::Option<
  unsafe extern "C" fn(
    ExceptionPointers: *mut _EXCEPTION_POINTERS,
    EstablisherFrame: PVOID,
  ) -> LONG,
>;
pub type PTERMINATION_HANDLER = ::core::option::Option<
  unsafe extern "C" fn(_abnormal_termination: BOOLEAN, EstablisherFrame: PVOID),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS {
  pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1,
  pub __bindgen_anon_2: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1 {
  pub FloatingContext: [PM128A; 16usize],
  pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1 {
  pub Xmm0: PM128A,
  pub Xmm1: PM128A,
  pub Xmm2: PM128A,
  pub Xmm3: PM128A,
  pub Xmm4: PM128A,
  pub Xmm5: PM128A,
  pub Xmm6: PM128A,
  pub Xmm7: PM128A,
  pub Xmm8: PM128A,
  pub Xmm9: PM128A,
  pub Xmm10: PM128A,
  pub Xmm11: PM128A,
  pub Xmm12: PM128A,
  pub Xmm13: PM128A,
  pub Xmm14: PM128A,
  pub Xmm15: PM128A,
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>(),
    128usize,
    concat!(
      "Size of: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm0
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm1
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm2
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm3
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm4
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm5
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm6
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm7
        as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm7)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm8
        as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm9
        as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm10
        as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm11
        as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm12
        as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm13
        as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm14
        as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>())).Xmm15
        as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Xmm15)
    )
  );
}
impl Default for _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1>(),
    128usize,
    concat!(
      "Size of: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1>())).FloatingContext
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1),
      "::",
      stringify!(FloatingContext)
    )
  );
}
impl Default for _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1 {{ union }}"
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2 {
  pub IntegerContext: [PDWORD64; 16usize],
  pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1,
  _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1 {
  pub Rax: PDWORD64,
  pub Rcx: PDWORD64,
  pub Rdx: PDWORD64,
  pub Rbx: PDWORD64,
  pub Rsp: PDWORD64,
  pub Rbp: PDWORD64,
  pub Rsi: PDWORD64,
  pub Rdi: PDWORD64,
  pub R8: PDWORD64,
  pub R9: PDWORD64,
  pub R10: PDWORD64,
  pub R11: PDWORD64,
  pub R12: PDWORD64,
  pub R13: PDWORD64,
  pub R14: PDWORD64,
  pub R15: PDWORD64,
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>(),
    128usize,
    concat!(
      "Size of: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rax
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rax)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rcx
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rcx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rdx
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rdx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rbx
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rbx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rsp
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rsp)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rbp
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rbp)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rsi
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rsi)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).Rdi
        as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Rdi)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R8
        as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R9
        as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R10
        as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R11
        as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R12
        as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R13
        as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R14
        as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>())).R15
        as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(R15)
    )
  );
}
impl Default for _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2>(),
    128usize,
    concat!(
      "Size of: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2>())).IntegerContext
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2),
      "::",
      stringify!(IntegerContext)
    )
  );
}
impl Default for _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS() {
  assert_eq!(
    ::core::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS>(),
    256usize,
    concat!("Size of: ", stringify!(_KNONVOLATILE_CONTEXT_POINTERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS>(),
    8usize,
    concat!("Alignment of ", stringify!(_KNONVOLATILE_CONTEXT_POINTERS))
  );
}
impl Default for _KNONVOLATILE_CONTEXT_POINTERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _KNONVOLATILE_CONTEXT_POINTERS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_KNONVOLATILE_CONTEXT_POINTERS {{ __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?} }}",
      self.__bindgen_anon_1, self.__bindgen_anon_2
    )
  }
}
pub type KNONVOLATILE_CONTEXT_POINTERS = _KNONVOLATILE_CONTEXT_POINTERS;
pub type PKNONVOLATILE_CONTEXT_POINTERS = *mut _KNONVOLATILE_CONTEXT_POINTERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCOPE_TABLE_ARM {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_ARM__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCOPE_TABLE_ARM__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM() {
  assert_eq!(
    ::core::mem::size_of::<_SCOPE_TABLE_ARM>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCOPE_TABLE_ARM>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCOPE_TABLE_ARM>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCOPE_TABLE_ARM>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_ARM = _SCOPE_TABLE_ARM;
pub type PSCOPE_TABLE_ARM = *mut _SCOPE_TABLE_ARM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCOPE_TABLE_ARM64 {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_ARM64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCOPE_TABLE_ARM64__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).BeginAddress as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64() {
  assert_eq!(
    ::core::mem::size_of::<_SCOPE_TABLE_ARM64>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCOPE_TABLE_ARM64>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCOPE_TABLE_ARM64>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCOPE_TABLE_ARM64>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_ARM64 = _SCOPE_TABLE_ARM64;
pub type PSCOPE_TABLE_ARM64 = *mut _SCOPE_TABLE_ARM64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
  pub X19: PDWORD64,
  pub X20: PDWORD64,
  pub X21: PDWORD64,
  pub X22: PDWORD64,
  pub X23: PDWORD64,
  pub X24: PDWORD64,
  pub X25: PDWORD64,
  pub X26: PDWORD64,
  pub X27: PDWORD64,
  pub X28: PDWORD64,
  pub Fp: PDWORD64,
  pub Lr: PDWORD64,
  pub D8: PDWORD64,
  pub D9: PDWORD64,
  pub D10: PDWORD64,
  pub D11: PDWORD64,
  pub D12: PDWORD64,
  pub D13: PDWORD64,
  pub D14: PDWORD64,
  pub D15: PDWORD64,
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS_ARM64() {
  assert_eq!(
    ::core::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>(),
    160usize,
    concat!(
      "Size of: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X19 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X19)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X20 as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X20)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X21 as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X21)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X22 as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X22)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X23 as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X23)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X24 as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X24)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X25 as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X25)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X26 as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X26)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X27 as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X27)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X28 as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(X28)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).Fp as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(Fp)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).Lr as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(Lr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D8 as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D9 as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D9)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D10 as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D10)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D11 as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D12 as *const _ as usize
    },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D13 as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D14 as *const _ as usize
    },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D15 as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
      "::",
      stringify!(D15)
    )
  );
}
impl Default for _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type KNONVOLATILE_CONTEXT_POINTERS_ARM64 = _KNONVOLATILE_CONTEXT_POINTERS_ARM64;
pub type PKNONVOLATILE_CONTEXT_POINTERS_ARM64 = *mut _KNONVOLATILE_CONTEXT_POINTERS_ARM64;
extern "C" {
  pub fn __int2c();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDT_ENTRY {
  pub LimitLow: WORD,
  pub BaseLow: WORD,
  pub HighWord: _LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDT_ENTRY__bindgen_ty_1 {
  pub Bytes: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
  pub Bits: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  pub BaseMid: BYTE,
  pub Flags1: BYTE,
  pub Flags2: BYTE,
  pub BaseHi: BYTE,
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseMid as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(BaseMid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags1 as *const _
        as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags2 as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseHi as *const _
        as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(BaseHi)
    )
  );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
    )
  );
}
impl _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
  #[inline]
  pub fn BaseMid(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_BaseMid(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn Type(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
  }
  #[inline]
  pub fn set_Type(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 5u8, val as u64)
    }
  }
  #[inline]
  pub fn Dpl(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
  }
  #[inline]
  pub fn set_Dpl(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(13usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn Pres(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Pres(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(15usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn LimitHi(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
  }
  #[inline]
  pub fn set_LimitHi(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn Sys(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Sys(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(20usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved_0(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved_0(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(21usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Default_Big(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Default_Big(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(22usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Granularity(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Granularity(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(23usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn BaseHi(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_BaseHi(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(24usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    BaseMid: DWORD, Type: DWORD, Dpl: DWORD, Pres: DWORD, LimitHi: DWORD, Sys: DWORD,
    Reserved_0: DWORD, Default_Big: DWORD, Granularity: DWORD, BaseHi: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let BaseMid: u32 = unsafe { ::core::mem::transmute(BaseMid) };
      BaseMid as u64
    });
    __bindgen_bitfield_unit.set(8usize, 5u8, {
      let Type: u32 = unsafe { ::core::mem::transmute(Type) };
      Type as u64
    });
    __bindgen_bitfield_unit.set(13usize, 2u8, {
      let Dpl: u32 = unsafe { ::core::mem::transmute(Dpl) };
      Dpl as u64
    });
    __bindgen_bitfield_unit.set(15usize, 1u8, {
      let Pres: u32 = unsafe { ::core::mem::transmute(Pres) };
      Pres as u64
    });
    __bindgen_bitfield_unit.set(16usize, 4u8, {
      let LimitHi: u32 = unsafe { ::core::mem::transmute(LimitHi) };
      LimitHi as u64
    });
    __bindgen_bitfield_unit.set(20usize, 1u8, {
      let Sys: u32 = unsafe { ::core::mem::transmute(Sys) };
      Sys as u64
    });
    __bindgen_bitfield_unit.set(21usize, 1u8, {
      let Reserved_0: u32 = unsafe { ::core::mem::transmute(Reserved_0) };
      Reserved_0 as u64
    });
    __bindgen_bitfield_unit.set(22usize, 1u8, {
      let Default_Big: u32 = unsafe { ::core::mem::transmute(Default_Big) };
      Default_Big as u64
    });
    __bindgen_bitfield_unit.set(23usize, 1u8, {
      let Granularity: u32 = unsafe { ::core::mem::transmute(Granularity) };
      Granularity as u64
    });
    __bindgen_bitfield_unit.set(24usize, 8u8, {
      let BaseHi: u32 = unsafe { ::core::mem::transmute(BaseHi) };
      BaseHi as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_LDT_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_LDT_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_LDT_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_LDT_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LDT_ENTRY__bindgen_ty_1>())).Bytes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1),
      "::",
      stringify!(Bytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LDT_ENTRY__bindgen_ty_1>())).Bits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY__bindgen_ty_1),
      "::",
      stringify!(Bits)
    )
  );
}
impl Default for _LDT_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _LDT_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_LDT_ENTRY__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__LDT_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_LDT_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_LDT_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_LDT_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_LDT_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LDT_ENTRY>())).LimitLow as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY),
      "::",
      stringify!(LimitLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LDT_ENTRY>())).BaseLow as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY),
      "::",
      stringify!(BaseLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LDT_ENTRY>())).HighWord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDT_ENTRY),
      "::",
      stringify!(HighWord)
    )
  );
}
impl Default for _LDT_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _LDT_ENTRY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_LDT_ENTRY {{ LimitLow: {:?}, BaseLow: {:?}, HighWord: {:?} }}",
      self.LimitLow, self.BaseLow, self.HighWord
    )
  }
}
pub type LDT_ENTRY = _LDT_ENTRY;
pub type PLDT_ENTRY = *mut _LDT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_FLOATING_SAVE_AREA {
  pub ControlWord: DWORD,
  pub StatusWord: DWORD,
  pub TagWord: DWORD,
  pub ErrorOffset: DWORD,
  pub ErrorSelector: DWORD,
  pub DataOffset: DWORD,
  pub DataSelector: DWORD,
  pub RegisterArea: [BYTE; 80usize],
  pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__WOW64_FLOATING_SAVE_AREA() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_FLOATING_SAVE_AREA>(),
    112usize,
    concat!("Size of: ", stringify!(_WOW64_FLOATING_SAVE_AREA))
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_FLOATING_SAVE_AREA>(),
    4usize,
    concat!("Alignment of ", stringify!(_WOW64_FLOATING_SAVE_AREA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).ControlWord as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(ControlWord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).StatusWord as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(StatusWord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).TagWord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(TagWord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).ErrorOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(ErrorOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).ErrorSelector as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(ErrorSelector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).DataOffset as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(DataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).DataSelector as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(DataSelector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).RegisterArea as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(RegisterArea)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).Cr0NpxState as *const _ as usize
    },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_FLOATING_SAVE_AREA),
      "::",
      stringify!(Cr0NpxState)
    )
  );
}
impl Default for _WOW64_FLOATING_SAVE_AREA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WOW64_FLOATING_SAVE_AREA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_WOW64_FLOATING_SAVE_AREA {{ ControlWord: {:?}, StatusWord: {:?}, TagWord: {:?}, ErrorOffset: {:?}, ErrorSelector: {:?}, DataOffset: {:?}, DataSelector: {:?}, RegisterArea: [...], Cr0NpxState: {:?} }}" , self . ControlWord , self . StatusWord , self . TagWord , self . ErrorOffset , self . ErrorSelector , self . DataOffset , self . DataSelector , self . Cr0NpxState )
  }
}
impl ::core::cmp::PartialEq for _WOW64_FLOATING_SAVE_AREA {
  fn eq(&self, other: &_WOW64_FLOATING_SAVE_AREA) -> bool {
    self.ControlWord == other.ControlWord
      && self.StatusWord == other.StatusWord
      && self.TagWord == other.TagWord
      && self.ErrorOffset == other.ErrorOffset
      && self.ErrorSelector == other.ErrorSelector
      && self.DataOffset == other.DataOffset
      && self.DataSelector == other.DataSelector
      && &self.RegisterArea[..] == &other.RegisterArea[..]
      && self.Cr0NpxState == other.Cr0NpxState
  }
}
pub type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA;
pub type PWOW64_FLOATING_SAVE_AREA = *mut WOW64_FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_CONTEXT {
  pub ContextFlags: DWORD,
  pub Dr0: DWORD,
  pub Dr1: DWORD,
  pub Dr2: DWORD,
  pub Dr3: DWORD,
  pub Dr6: DWORD,
  pub Dr7: DWORD,
  pub FloatSave: WOW64_FLOATING_SAVE_AREA,
  pub SegGs: DWORD,
  pub SegFs: DWORD,
  pub SegEs: DWORD,
  pub SegDs: DWORD,
  pub Edi: DWORD,
  pub Esi: DWORD,
  pub Ebx: DWORD,
  pub Edx: DWORD,
  pub Ecx: DWORD,
  pub Eax: DWORD,
  pub Ebp: DWORD,
  pub Eip: DWORD,
  pub SegCs: DWORD,
  pub EFlags: DWORD,
  pub Esp: DWORD,
  pub SegSs: DWORD,
  pub ExtendedRegisters: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout__WOW64_CONTEXT() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_CONTEXT>(),
    716usize,
    concat!("Size of: ", stringify!(_WOW64_CONTEXT))
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_CONTEXT>(),
    4usize,
    concat!("Alignment of ", stringify!(_WOW64_CONTEXT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).ContextFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(ContextFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Dr0 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Dr0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Dr1 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Dr1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Dr2 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Dr2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Dr3 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Dr3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Dr6 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Dr6)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Dr7 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Dr7)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).FloatSave as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(FloatSave)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).SegGs as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(SegGs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).SegFs as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(SegFs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).SegEs as *const _ as usize },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(SegEs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).SegDs as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(SegDs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Edi as *const _ as usize },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Edi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Esi as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Esi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Ebx as *const _ as usize },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Ebx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Edx as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Edx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Ecx as *const _ as usize },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Ecx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Eax as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Eax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Ebp as *const _ as usize },
    180usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Ebp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Eip as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Eip)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).SegCs as *const _ as usize },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(SegCs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).EFlags as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(EFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).Esp as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(Esp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).SegSs as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(SegSs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_CONTEXT>())).ExtendedRegisters as *const _ as usize },
    204usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_CONTEXT),
      "::",
      stringify!(ExtendedRegisters)
    )
  );
}
impl Default for _WOW64_CONTEXT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WOW64_CONTEXT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_WOW64_CONTEXT {{ ContextFlags: {:?}, Dr0: {:?}, Dr1: {:?}, Dr2: {:?}, Dr3: {:?}, Dr6: {:?}, Dr7: {:?}, FloatSave: {:?}, SegGs: {:?}, SegFs: {:?}, SegEs: {:?}, SegDs: {:?}, Edi: {:?}, Esi: {:?}, Ebx: {:?}, Edx: {:?}, Ecx: {:?}, Eax: {:?}, Ebp: {:?}, Eip: {:?}, SegCs: {:?}, EFlags: {:?}, Esp: {:?}, SegSs: {:?}, ExtendedRegisters: [...] }}" , self . ContextFlags , self . Dr0 , self . Dr1 , self . Dr2 , self . Dr3 , self . Dr6 , self . Dr7 , self . FloatSave , self . SegGs , self . SegFs , self . SegEs , self . SegDs , self . Edi , self . Esi , self . Ebx , self . Edx , self . Ecx , self . Eax , self . Ebp , self . Eip , self . SegCs , self . EFlags , self . Esp , self . SegSs )
  }
}
impl ::core::cmp::PartialEq for _WOW64_CONTEXT {
  fn eq(&self, other: &_WOW64_CONTEXT) -> bool {
    self.ContextFlags == other.ContextFlags
      && self.Dr0 == other.Dr0
      && self.Dr1 == other.Dr1
      && self.Dr2 == other.Dr2
      && self.Dr3 == other.Dr3
      && self.Dr6 == other.Dr6
      && self.Dr7 == other.Dr7
      && self.FloatSave == other.FloatSave
      && self.SegGs == other.SegGs
      && self.SegFs == other.SegFs
      && self.SegEs == other.SegEs
      && self.SegDs == other.SegDs
      && self.Edi == other.Edi
      && self.Esi == other.Esi
      && self.Ebx == other.Ebx
      && self.Edx == other.Edx
      && self.Ecx == other.Ecx
      && self.Eax == other.Eax
      && self.Ebp == other.Ebp
      && self.Eip == other.Eip
      && self.SegCs == other.SegCs
      && self.EFlags == other.EFlags
      && self.Esp == other.Esp
      && self.SegSs == other.SegSs
      && &self.ExtendedRegisters[..] == &other.ExtendedRegisters[..]
  }
}
pub type WOW64_CONTEXT = _WOW64_CONTEXT;
pub type PWOW64_CONTEXT = *mut WOW64_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_LDT_ENTRY {
  pub LimitLow: WORD,
  pub BaseLow: WORD,
  pub HighWord: _WOW64_LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WOW64_LDT_ENTRY__bindgen_ty_1 {
  pub Bytes: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
  pub Bits: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  pub BaseMid: BYTE,
  pub Flags1: BYTE,
  pub Flags2: BYTE,
  pub BaseHi: BYTE,
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseMid as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(BaseMid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags1 as *const _
        as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags2 as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseHi as *const _
        as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(BaseHi)
    )
  );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
    )
  );
}
impl _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
  #[inline]
  pub fn BaseMid(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_BaseMid(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn Type(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
  }
  #[inline]
  pub fn set_Type(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 5u8, val as u64)
    }
  }
  #[inline]
  pub fn Dpl(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
  }
  #[inline]
  pub fn set_Dpl(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(13usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn Pres(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Pres(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(15usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn LimitHi(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
  }
  #[inline]
  pub fn set_LimitHi(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn Sys(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Sys(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(20usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved_0(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved_0(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(21usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Default_Big(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Default_Big(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(22usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Granularity(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Granularity(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(23usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn BaseHi(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_BaseHi(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(24usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    BaseMid: DWORD, Type: DWORD, Dpl: DWORD, Pres: DWORD, LimitHi: DWORD, Sys: DWORD,
    Reserved_0: DWORD, Default_Big: DWORD, Granularity: DWORD, BaseHi: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let BaseMid: u32 = unsafe { ::core::mem::transmute(BaseMid) };
      BaseMid as u64
    });
    __bindgen_bitfield_unit.set(8usize, 5u8, {
      let Type: u32 = unsafe { ::core::mem::transmute(Type) };
      Type as u64
    });
    __bindgen_bitfield_unit.set(13usize, 2u8, {
      let Dpl: u32 = unsafe { ::core::mem::transmute(Dpl) };
      Dpl as u64
    });
    __bindgen_bitfield_unit.set(15usize, 1u8, {
      let Pres: u32 = unsafe { ::core::mem::transmute(Pres) };
      Pres as u64
    });
    __bindgen_bitfield_unit.set(16usize, 4u8, {
      let LimitHi: u32 = unsafe { ::core::mem::transmute(LimitHi) };
      LimitHi as u64
    });
    __bindgen_bitfield_unit.set(20usize, 1u8, {
      let Sys: u32 = unsafe { ::core::mem::transmute(Sys) };
      Sys as u64
    });
    __bindgen_bitfield_unit.set(21usize, 1u8, {
      let Reserved_0: u32 = unsafe { ::core::mem::transmute(Reserved_0) };
      Reserved_0 as u64
    });
    __bindgen_bitfield_unit.set(22usize, 1u8, {
      let Default_Big: u32 = unsafe { ::core::mem::transmute(Default_Big) };
      Default_Big as u64
    });
    __bindgen_bitfield_unit.set(23usize, 1u8, {
      let Granularity: u32 = unsafe { ::core::mem::transmute(Granularity) };
      Granularity as u64
    });
    __bindgen_bitfield_unit.set(24usize, 8u8, {
      let BaseHi: u32 = unsafe { ::core::mem::transmute(BaseHi) };
      BaseHi as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1>())).Bytes as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1),
      "::",
      stringify!(Bytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1>())).Bits as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1),
      "::",
      stringify!(Bits)
    )
  );
}
impl Default for _WOW64_LDT_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WOW64_LDT_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_WOW64_LDT_ENTRY__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_LDT_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_WOW64_LDT_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_LDT_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_WOW64_LDT_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_LDT_ENTRY>())).LimitLow as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY),
      "::",
      stringify!(LimitLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_LDT_ENTRY>())).BaseLow as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY),
      "::",
      stringify!(BaseLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WOW64_LDT_ENTRY>())).HighWord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_LDT_ENTRY),
      "::",
      stringify!(HighWord)
    )
  );
}
impl Default for _WOW64_LDT_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WOW64_LDT_ENTRY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_WOW64_LDT_ENTRY {{ LimitLow: {:?}, BaseLow: {:?}, HighWord: {:?} }}",
      self.LimitLow, self.BaseLow, self.HighWord
    )
  }
}
pub type WOW64_LDT_ENTRY = _WOW64_LDT_ENTRY;
pub type PWOW64_LDT_ENTRY = *mut _WOW64_LDT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
  pub Selector: DWORD,
  pub Descriptor: WOW64_LDT_ENTRY,
}
#[test]
fn bindgen_test_layout__WOW64_DESCRIPTOR_TABLE_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_DESCRIPTOR_TABLE_ENTRY>(),
    12usize,
    concat!("Size of: ", stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_DESCRIPTOR_TABLE_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_DESCRIPTOR_TABLE_ENTRY>())).Selector as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY),
      "::",
      stringify!(Selector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WOW64_DESCRIPTOR_TABLE_ENTRY>())).Descriptor as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY),
      "::",
      stringify!(Descriptor)
    )
  );
}
impl Default for _WOW64_DESCRIPTOR_TABLE_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WOW64_DESCRIPTOR_TABLE_ENTRY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_WOW64_DESCRIPTOR_TABLE_ENTRY {{ Selector: {:?}, Descriptor: {:?} }}",
      self.Selector, self.Descriptor
    )
  }
}
pub type WOW64_DESCRIPTOR_TABLE_ENTRY = _WOW64_DESCRIPTOR_TABLE_ENTRY;
pub type PWOW64_DESCRIPTOR_TABLE_ENTRY = *mut _WOW64_DESCRIPTOR_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _EXCEPTION_RECORD {
  pub ExceptionCode: DWORD,
  pub ExceptionFlags: DWORD,
  pub ExceptionRecord: *mut _EXCEPTION_RECORD,
  pub ExceptionAddress: PVOID,
  pub NumberParameters: DWORD,
  pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_EXCEPTION_RECORD>(),
    152usize,
    concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXCEPTION_RECORD>(),
    8usize,
    concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD>())).ExceptionCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD),
      "::",
      stringify!(ExceptionCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD>())).ExceptionFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD),
      "::",
      stringify!(ExceptionFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD>())).ExceptionRecord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD),
      "::",
      stringify!(ExceptionRecord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD>())).ExceptionAddress as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD),
      "::",
      stringify!(ExceptionAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD>())).NumberParameters as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD),
      "::",
      stringify!(NumberParameters)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD>())).ExceptionInformation as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD),
      "::",
      stringify!(ExceptionInformation)
    )
  );
}
impl Default for _EXCEPTION_RECORD {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _EXCEPTION_RECORD32 {
  pub ExceptionCode: DWORD,
  pub ExceptionFlags: DWORD,
  pub ExceptionRecord: DWORD,
  pub ExceptionAddress: DWORD,
  pub NumberParameters: DWORD,
  pub ExceptionInformation: [DWORD; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD32() {
  assert_eq!(
    ::core::mem::size_of::<_EXCEPTION_RECORD32>(),
    80usize,
    concat!("Size of: ", stringify!(_EXCEPTION_RECORD32))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXCEPTION_RECORD32>(),
    4usize,
    concat!("Alignment of ", stringify!(_EXCEPTION_RECORD32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD32),
      "::",
      stringify!(ExceptionCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD32),
      "::",
      stringify!(ExceptionFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionRecord as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD32),
      "::",
      stringify!(ExceptionRecord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionAddress as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD32),
      "::",
      stringify!(ExceptionAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD32>())).NumberParameters as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD32),
      "::",
      stringify!(NumberParameters)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionInformation as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD32),
      "::",
      stringify!(ExceptionInformation)
    )
  );
}
pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _EXCEPTION_RECORD64 {
  pub ExceptionCode: DWORD,
  pub ExceptionFlags: DWORD,
  pub ExceptionRecord: DWORD64,
  pub ExceptionAddress: DWORD64,
  pub NumberParameters: DWORD,
  pub __unusedAlignment: DWORD,
  pub ExceptionInformation: [DWORD64; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD64() {
  assert_eq!(
    ::core::mem::size_of::<_EXCEPTION_RECORD64>(),
    152usize,
    concat!("Size of: ", stringify!(_EXCEPTION_RECORD64))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXCEPTION_RECORD64>(),
    8usize,
    concat!("Alignment of ", stringify!(_EXCEPTION_RECORD64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(ExceptionCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(ExceptionFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionRecord as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(ExceptionRecord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionAddress as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(ExceptionAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).NumberParameters as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(NumberParameters)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).__unusedAlignment as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(__unusedAlignment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionInformation as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_RECORD64),
      "::",
      stringify!(ExceptionInformation)
    )
  );
}
pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _EXCEPTION_POINTERS {
  pub ExceptionRecord: PEXCEPTION_RECORD,
  pub ContextRecord: PCONTEXT,
}
#[test]
fn bindgen_test_layout__EXCEPTION_POINTERS() {
  assert_eq!(
    ::core::mem::size_of::<_EXCEPTION_POINTERS>(),
    16usize,
    concat!("Size of: ", stringify!(_EXCEPTION_POINTERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXCEPTION_POINTERS>(),
    8usize,
    concat!("Alignment of ", stringify!(_EXCEPTION_POINTERS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_POINTERS>())).ExceptionRecord as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_POINTERS),
      "::",
      stringify!(ExceptionRecord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXCEPTION_POINTERS>())).ContextRecord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_POINTERS),
      "::",
      stringify!(ContextRecord)
    )
  );
}
impl Default for _EXCEPTION_POINTERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GENERIC_MAPPING {
  pub GenericRead: ACCESS_MASK,
  pub GenericWrite: ACCESS_MASK,
  pub GenericExecute: ACCESS_MASK,
  pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
  assert_eq!(
    ::core::mem::size_of::<_GENERIC_MAPPING>(),
    16usize,
    concat!("Size of: ", stringify!(_GENERIC_MAPPING))
  );
  assert_eq!(
    ::core::mem::align_of::<_GENERIC_MAPPING>(),
    4usize,
    concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GENERIC_MAPPING>())).GenericRead as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericRead)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GENERIC_MAPPING>())).GenericWrite as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericWrite)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GENERIC_MAPPING>())).GenericExecute as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericExecute)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GENERIC_MAPPING>())).GenericAll as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericAll)
    )
  );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _LUID_AND_ATTRIBUTES {
  pub Luid: LUID,
  pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
  assert_eq!(
    ::core::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
    12usize,
    concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES))
  );
  assert_eq!(
    ::core::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
    4usize,
    concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LUID_AND_ATTRIBUTES>())).Luid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID_AND_ATTRIBUTES),
      "::",
      stringify!(Luid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LUID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID_AND_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SID_IDENTIFIER_AUTHORITY {
  pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
  assert_eq!(
    ::core::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
    6usize,
    concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
  );
  assert_eq!(
    ::core::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
    1usize,
    concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID_IDENTIFIER_AUTHORITY>())).Value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_IDENTIFIER_AUTHORITY),
      "::",
      stringify!(Value)
    )
  );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SID {
  pub Revision: BYTE,
  pub SubAuthorityCount: BYTE,
  pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
  pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
  assert_eq!(
    ::core::mem::size_of::<_SID>(),
    12usize,
    concat!("Size of: ", stringify!(_SID))
  );
  assert_eq!(
    ::core::mem::align_of::<_SID>(),
    4usize,
    concat!("Alignment of ", stringify!(_SID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID>())).SubAuthorityCount as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(SubAuthorityCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID>())).IdentifierAuthority as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(IdentifierAuthority)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID>())).SubAuthority as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(SubAuthority)
    )
  );
}
pub type SID = _SID;
pub type PISID = *mut _SID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_SID {
  pub Sid: SID,
  pub Buffer: [BYTE; 68usize],
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_SID() {
  assert_eq!(
    ::core::mem::size_of::<_SE_SID>(),
    68usize,
    concat!("Size of: ", stringify!(_SE_SID))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_SID>(),
    4usize,
    concat!("Alignment of ", stringify!(_SE_SID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_SID>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SID),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_SID>())).Buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SID),
      "::",
      stringify!(Buffer)
    )
  );
}
impl Default for _SE_SID {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SE_SID {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_SE_SID {{ union }}")
  }
}
pub type SE_SID = _SE_SID;
pub type PSE_SID = *mut _SE_SID;
pub mod _SID_NAME_USE {
  pub type Type = i32;
  pub const SidTypeUser: Type = 1;
  pub const SidTypeGroup: Type = 2;
  pub const SidTypeDomain: Type = 3;
  pub const SidTypeAlias: Type = 4;
  pub const SidTypeWellKnownGroup: Type = 5;
  pub const SidTypeDeletedAccount: Type = 6;
  pub const SidTypeInvalid: Type = 7;
  pub const SidTypeUnknown: Type = 8;
  pub const SidTypeComputer: Type = 9;
  pub const SidTypeLabel: Type = 10;
  pub const SidTypeLogonSession: Type = 11;
}
pub use self::_SID_NAME_USE::Type as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SID_AND_ATTRIBUTES {
  pub Sid: PSID,
  pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES() {
  assert_eq!(
    ::core::mem::size_of::<_SID_AND_ATTRIBUTES>(),
    16usize,
    concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES))
  );
  assert_eq!(
    ::core::mem::align_of::<_SID_AND_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID_AND_ATTRIBUTES>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
}
impl Default for _SID_AND_ATTRIBUTES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type PSID_AND_ATTRIBUTES_ARRAY = *mut SID_AND_ATTRIBUTES_ARRAY;
pub type SID_HASH_ENTRY = ULONG_PTR;
pub type PSID_HASH_ENTRY = *mut ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SID_AND_ATTRIBUTES_HASH {
  pub SidCount: DWORD,
  pub SidAttr: PSID_AND_ATTRIBUTES,
  pub Hash: [SID_HASH_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES_HASH() {
  assert_eq!(
    ::core::mem::size_of::<_SID_AND_ATTRIBUTES_HASH>(),
    272usize,
    concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES_HASH))
  );
  assert_eq!(
    ::core::mem::align_of::<_SID_AND_ATTRIBUTES_HASH>(),
    8usize,
    concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES_HASH))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(SidCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidAttr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(SidAttr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).Hash as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(Hash)
    )
  );
}
impl Default for _SID_AND_ATTRIBUTES_HASH {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
pub mod WELL_KNOWN_SID_TYPE {
  pub type Type = i32;
  pub const WinNullSid: Type = 0;
  pub const WinWorldSid: Type = 1;
  pub const WinLocalSid: Type = 2;
  pub const WinCreatorOwnerSid: Type = 3;
  pub const WinCreatorGroupSid: Type = 4;
  pub const WinCreatorOwnerServerSid: Type = 5;
  pub const WinCreatorGroupServerSid: Type = 6;
  pub const WinNtAuthoritySid: Type = 7;
  pub const WinDialupSid: Type = 8;
  pub const WinNetworkSid: Type = 9;
  pub const WinBatchSid: Type = 10;
  pub const WinInteractiveSid: Type = 11;
  pub const WinServiceSid: Type = 12;
  pub const WinAnonymousSid: Type = 13;
  pub const WinProxySid: Type = 14;
  pub const WinEnterpriseControllersSid: Type = 15;
  pub const WinSelfSid: Type = 16;
  pub const WinAuthenticatedUserSid: Type = 17;
  pub const WinRestrictedCodeSid: Type = 18;
  pub const WinTerminalServerSid: Type = 19;
  pub const WinRemoteLogonIdSid: Type = 20;
  pub const WinLogonIdsSid: Type = 21;
  pub const WinLocalSystemSid: Type = 22;
  pub const WinLocalServiceSid: Type = 23;
  pub const WinNetworkServiceSid: Type = 24;
  pub const WinBuiltinDomainSid: Type = 25;
  pub const WinBuiltinAdministratorsSid: Type = 26;
  pub const WinBuiltinUsersSid: Type = 27;
  pub const WinBuiltinGuestsSid: Type = 28;
  pub const WinBuiltinPowerUsersSid: Type = 29;
  pub const WinBuiltinAccountOperatorsSid: Type = 30;
  pub const WinBuiltinSystemOperatorsSid: Type = 31;
  pub const WinBuiltinPrintOperatorsSid: Type = 32;
  pub const WinBuiltinBackupOperatorsSid: Type = 33;
  pub const WinBuiltinReplicatorSid: Type = 34;
  pub const WinBuiltinPreWindows2000CompatibleAccessSid: Type = 35;
  pub const WinBuiltinRemoteDesktopUsersSid: Type = 36;
  pub const WinBuiltinNetworkConfigurationOperatorsSid: Type = 37;
  pub const WinAccountAdministratorSid: Type = 38;
  pub const WinAccountGuestSid: Type = 39;
  pub const WinAccountKrbtgtSid: Type = 40;
  pub const WinAccountDomainAdminsSid: Type = 41;
  pub const WinAccountDomainUsersSid: Type = 42;
  pub const WinAccountDomainGuestsSid: Type = 43;
  pub const WinAccountComputersSid: Type = 44;
  pub const WinAccountControllersSid: Type = 45;
  pub const WinAccountCertAdminsSid: Type = 46;
  pub const WinAccountSchemaAdminsSid: Type = 47;
  pub const WinAccountEnterpriseAdminsSid: Type = 48;
  pub const WinAccountPolicyAdminsSid: Type = 49;
  pub const WinAccountRasAndIasServersSid: Type = 50;
  pub const WinNTLMAuthenticationSid: Type = 51;
  pub const WinDigestAuthenticationSid: Type = 52;
  pub const WinSChannelAuthenticationSid: Type = 53;
  pub const WinThisOrganizationSid: Type = 54;
  pub const WinOtherOrganizationSid: Type = 55;
  pub const WinBuiltinIncomingForestTrustBuildersSid: Type = 56;
  pub const WinBuiltinPerfMonitoringUsersSid: Type = 57;
  pub const WinBuiltinPerfLoggingUsersSid: Type = 58;
  pub const WinBuiltinAuthorizationAccessSid: Type = 59;
  pub const WinBuiltinTerminalServerLicenseServersSid: Type = 60;
  pub const WinBuiltinDCOMUsersSid: Type = 61;
  pub const WinBuiltinIUsersSid: Type = 62;
  pub const WinIUserSid: Type = 63;
  pub const WinBuiltinCryptoOperatorsSid: Type = 64;
  pub const WinUntrustedLabelSid: Type = 65;
  pub const WinLowLabelSid: Type = 66;
  pub const WinMediumLabelSid: Type = 67;
  pub const WinHighLabelSid: Type = 68;
  pub const WinSystemLabelSid: Type = 69;
  pub const WinWriteRestrictedCodeSid: Type = 70;
  pub const WinCreatorOwnerRightsSid: Type = 71;
  pub const WinCacheablePrincipalsGroupSid: Type = 72;
  pub const WinNonCacheablePrincipalsGroupSid: Type = 73;
  pub const WinEnterpriseReadonlyControllersSid: Type = 74;
  pub const WinAccountReadonlyControllersSid: Type = 75;
  pub const WinBuiltinEventLogReadersGroup: Type = 76;
  pub const WinNewEnterpriseReadonlyControllersSid: Type = 77;
  pub const WinBuiltinCertSvcDComAccessGroup: Type = 78;
  pub const WinMediumPlusLabelSid: Type = 79;
  pub const WinLocalLogonSid: Type = 80;
  pub const WinConsoleLogonSid: Type = 81;
  pub const WinThisOrganizationCertificateSid: Type = 82;
  pub const WinApplicationPackageAuthoritySid: Type = 83;
  pub const WinBuiltinAnyPackageSid: Type = 84;
  pub const WinCapabilityInternetClientSid: Type = 85;
  pub const WinCapabilityInternetClientServerSid: Type = 86;
  pub const WinCapabilityPrivateNetworkClientServerSid: Type = 87;
  pub const WinCapabilityPicturesLibrarySid: Type = 88;
  pub const WinCapabilityVideosLibrarySid: Type = 89;
  pub const WinCapabilityMusicLibrarySid: Type = 90;
  pub const WinCapabilityDocumentsLibrarySid: Type = 91;
  pub const WinCapabilitySharedUserCertificatesSid: Type = 92;
  pub const WinCapabilityEnterpriseAuthenticationSid: Type = 93;
  pub const WinCapabilityRemovableStorageSid: Type = 94;
  pub const WinBuiltinRDSRemoteAccessServersSid: Type = 95;
  pub const WinBuiltinRDSEndpointServersSid: Type = 96;
  pub const WinBuiltinRDSManagementServersSid: Type = 97;
  pub const WinUserModeDriversSid: Type = 98;
  pub const WinBuiltinHyperVAdminsSid: Type = 99;
  pub const WinAccountCloneableControllersSid: Type = 100;
  pub const WinBuiltinAccessControlAssistanceOperatorsSid: Type = 101;
  pub const WinBuiltinRemoteManagementUsersSid: Type = 102;
  pub const WinAuthenticationAuthorityAssertedSid: Type = 103;
  pub const WinAuthenticationServiceAssertedSid: Type = 104;
  pub const WinLocalAccountSid: Type = 105;
  pub const WinLocalAccountAndAdministratorSid: Type = 106;
  pub const WinAccountProtectedUsersSid: Type = 107;
  pub const WinCapabilityAppointmentsSid: Type = 108;
  pub const WinCapabilityContactsSid: Type = 109;
  pub const WinAccountDefaultSystemManagedSid: Type = 110;
  pub const WinBuiltinDefaultSystemManagedGroupSid: Type = 111;
  pub const WinBuiltinStorageReplicaAdminsSid: Type = 112;
  pub const WinAccountKeyAdminsSid: Type = 113;
  pub const WinAccountEnterpriseKeyAdminsSid: Type = 114;
  pub const WinAuthenticationKeyTrustSid: Type = 115;
  pub const WinAuthenticationKeyPropertyMFASid: Type = 116;
  pub const WinAuthenticationKeyPropertyAttestationSid: Type = 117;
  pub const WinAuthenticationFreshKeyAuthSid: Type = 118;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACL {
  pub AclRevision: BYTE,
  pub Sbz1: BYTE,
  pub AclSize: WORD,
  pub AceCount: WORD,
  pub Sbz2: WORD,
}
#[test]
fn bindgen_test_layout__ACL() {
  assert_eq!(
    ::core::mem::size_of::<_ACL>(),
    8usize,
    concat!("Size of: ", stringify!(_ACL))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACL>(),
    2usize,
    concat!("Alignment of ", stringify!(_ACL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL>())).AclRevision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AclRevision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL>())).AclSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AclSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL>())).AceCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL>())).Sbz2 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(Sbz2)
    )
  );
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACE_HEADER {
  pub AceType: BYTE,
  pub AceFlags: BYTE,
  pub AceSize: WORD,
}
#[test]
fn bindgen_test_layout__ACE_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_ACE_HEADER>(),
    4usize,
    concat!("Size of: ", stringify!(_ACE_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACE_HEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(_ACE_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACE_HEADER>())).AceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACE_HEADER>())).AceFlags as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACE_HEADER>())).AceSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceSize)
    )
  );
}
pub type ACE_HEADER = _ACE_HEADER;
pub type PACE_HEADER = *mut ACE_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_ALLOWED_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_ALLOWED_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_ACCESS_ALLOWED_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_ALLOWED_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE;
pub type PACCESS_ALLOWED_ACE = *mut ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_DENIED_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_DENIED_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_ACCESS_DENIED_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_DENIED_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_DENIED_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE;
pub type PACCESS_DENIED_ACE = *mut ACCESS_DENIED_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_AUDIT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_AUDIT_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_AUDIT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
pub type PSYSTEM_AUDIT_ACE = *mut SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_ALARM_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_ALARM_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_ALARM_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
pub type PSYSTEM_ALARM_ACE = *mut SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_RESOURCE_ATTRIBUTE_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub type PSYSTEM_RESOURCE_ATTRIBUTE_ACE = *mut _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_SCOPED_POLICY_ID_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
pub type PSYSTEM_SCOPED_POLICY_ID_ACE = *mut _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_MANDATORY_LABEL_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
pub type PSYSTEM_MANDATORY_LABEL_ACE = *mut _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESS_TRUST_LABEL_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub type PSYSTEM_PROCESS_TRUST_LABEL_ACE = *mut _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ACCESS_FILTER_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
pub type PSYSTEM_ACCESS_FILTER_ACE = *mut _SYSTEM_ACCESS_FILTER_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_ALLOWED_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_ALLOWED_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_ACCESS_ALLOWED_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_ALLOWED_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_ALLOWED_OBJECT_ACE = _ACCESS_ALLOWED_OBJECT_ACE;
pub type PACCESS_ALLOWED_OBJECT_ACE = *mut _ACCESS_ALLOWED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_DENIED_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_DENIED_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_ACCESS_DENIED_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_DENIED_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_DENIED_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_DENIED_OBJECT_ACE = _ACCESS_DENIED_OBJECT_ACE;
pub type PACCESS_DENIED_OBJECT_ACE = *mut _ACCESS_DENIED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_AUDIT_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).InheritedObjectType as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE;
pub type PSYSTEM_AUDIT_OBJECT_ACE = *mut _SYSTEM_AUDIT_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_ALARM_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).InheritedObjectType as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE;
pub type PSYSTEM_ALARM_OBJECT_ACE = *mut _SYSTEM_ALARM_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_ALLOWED_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_CALLBACK_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_ALLOWED_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_ACCESS_ALLOWED_CALLBACK_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_ALLOWED_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_ALLOWED_CALLBACK_ACE = _ACCESS_ALLOWED_CALLBACK_ACE;
pub type PACCESS_ALLOWED_CALLBACK_ACE = *mut _ACCESS_ALLOWED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_DENIED_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_CALLBACK_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_DENIED_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_ACCESS_DENIED_CALLBACK_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_DENIED_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_DENIED_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_DENIED_CALLBACK_ACE = _ACCESS_DENIED_CALLBACK_ACE;
pub type PACCESS_DENIED_CALLBACK_ACE = *mut _ACCESS_DENIED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_AUDIT_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_ACE = *mut _SYSTEM_AUDIT_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_ALARM_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE;
pub type PSYSTEM_ALARM_CALLBACK_ACE = *mut _SYSTEM_ALARM_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).ObjectType as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).InheritedObjectType
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub type PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = *mut _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).ObjectType as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).InheritedObjectType
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type ACCESS_DENIED_CALLBACK_OBJECT_ACE = _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub type PACCESS_DENIED_CALLBACK_OBJECT_ACE = *mut _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = *mut _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = *mut _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub mod _ACL_INFORMATION_CLASS {
  pub type Type = i32;
  pub const AclRevisionInformation: Type = 1;
  pub const AclSizeInformation: Type = 2;
}
pub use self::_ACL_INFORMATION_CLASS::Type as ACL_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACL_REVISION_INFORMATION {
  pub AclRevision: DWORD,
}
#[test]
fn bindgen_test_layout__ACL_REVISION_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACL_REVISION_INFORMATION>(),
    4usize,
    concat!("Size of: ", stringify!(_ACL_REVISION_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACL_REVISION_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACL_REVISION_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACL_REVISION_INFORMATION>())).AclRevision as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL_REVISION_INFORMATION),
      "::",
      stringify!(AclRevision)
    )
  );
}
pub type ACL_REVISION_INFORMATION = _ACL_REVISION_INFORMATION;
pub type PACL_REVISION_INFORMATION = *mut ACL_REVISION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACL_SIZE_INFORMATION {
  pub AceCount: DWORD,
  pub AclBytesInUse: DWORD,
  pub AclBytesFree: DWORD,
}
#[test]
fn bindgen_test_layout__ACL_SIZE_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACL_SIZE_INFORMATION>(),
    12usize,
    concat!("Size of: ", stringify!(_ACL_SIZE_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACL_SIZE_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACL_SIZE_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL_SIZE_INFORMATION>())).AceCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL_SIZE_INFORMATION),
      "::",
      stringify!(AceCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACL_SIZE_INFORMATION>())).AclBytesInUse as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL_SIZE_INFORMATION),
      "::",
      stringify!(AclBytesInUse)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACL_SIZE_INFORMATION>())).AclBytesFree as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL_SIZE_INFORMATION),
      "::",
      stringify!(AclBytesFree)
    )
  );
}
pub type ACL_SIZE_INFORMATION = _ACL_SIZE_INFORMATION;
pub type PACL_SIZE_INFORMATION = *mut ACL_SIZE_INFORMATION;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut WORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
  pub Revision: BYTE,
  pub Sbz1: BYTE,
  pub Control: SECURITY_DESCRIPTOR_CONTROL,
  pub Owner: DWORD,
  pub Group: DWORD,
  pub Sacl: DWORD,
  pub Dacl: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR_RELATIVE() {
  assert_eq!(
    ::core::mem::size_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
    20usize,
    concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Revision as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Control as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Owner as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Owner)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Group as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sacl as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Sacl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Dacl as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Dacl)
    )
  );
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
pub type PISECURITY_DESCRIPTOR_RELATIVE = *mut _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SECURITY_DESCRIPTOR {
  pub Revision: BYTE,
  pub Sbz1: BYTE,
  pub Control: SECURITY_DESCRIPTOR_CONTROL,
  pub Owner: PSID,
  pub Group: PSID,
  pub Sacl: PACL,
  pub Dacl: PACL,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<_SECURITY_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_SECURITY_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Control as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Owner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Group as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Sacl as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Sacl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_DESCRIPTOR>())).Dacl as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Dacl)
    )
  );
}
impl Default for _SECURITY_DESCRIPTOR {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
pub type PISECURITY_DESCRIPTOR = *mut _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
  pub Size: DWORD,
  pub ConstraintMask: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_OBJECT_AI_PARAMS() {
  assert_eq!(
    ::core::mem::size_of::<_SECURITY_OBJECT_AI_PARAMS>(),
    8usize,
    concat!("Size of: ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
  );
  assert_eq!(
    ::core::mem::align_of::<_SECURITY_OBJECT_AI_PARAMS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_OBJECT_AI_PARAMS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).ConstraintMask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_OBJECT_AI_PARAMS),
      "::",
      stringify!(ConstraintMask)
    )
  );
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
pub type PSECURITY_OBJECT_AI_PARAMS = *mut _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _OBJECT_TYPE_LIST {
  pub Level: WORD,
  pub Sbz: WORD,
  pub ObjectType: *mut GUID,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE_LIST() {
  assert_eq!(
    ::core::mem::size_of::<_OBJECT_TYPE_LIST>(),
    16usize,
    concat!("Size of: ", stringify!(_OBJECT_TYPE_LIST))
  );
  assert_eq!(
    ::core::mem::align_of::<_OBJECT_TYPE_LIST>(),
    8usize,
    concat!("Alignment of ", stringify!(_OBJECT_TYPE_LIST))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OBJECT_TYPE_LIST>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OBJECT_TYPE_LIST>())).Sbz as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(Sbz)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OBJECT_TYPE_LIST>())).ObjectType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(ObjectType)
    )
  );
}
impl Default for _OBJECT_TYPE_LIST {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST;
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
pub mod _AUDIT_EVENT_TYPE {
  pub type Type = i32;
  pub const AuditEventObjectAccess: Type = 0;
  pub const AuditEventDirectoryServiceAccess: Type = 1;
}
pub use self::_AUDIT_EVENT_TYPE::Type as AUDIT_EVENT_TYPE;
pub type PAUDIT_EVENT_TYPE = *mut _AUDIT_EVENT_TYPE::Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PRIVILEGE_SET {
  pub PrivilegeCount: DWORD,
  pub Control: DWORD,
  pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
  assert_eq!(
    ::core::mem::size_of::<_PRIVILEGE_SET>(),
    20usize,
    concat!("Size of: ", stringify!(_PRIVILEGE_SET))
  );
  assert_eq!(
    ::core::mem::align_of::<_PRIVILEGE_SET>(),
    4usize,
    concat!("Alignment of ", stringify!(_PRIVILEGE_SET))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PRIVILEGE_SET>())).PrivilegeCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(PrivilegeCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PRIVILEGE_SET>())).Control as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PRIVILEGE_SET>())).Privilege as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(Privilege)
    )
  );
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub mod _ACCESS_REASON_TYPE {
  pub type Type = i32;
  pub const AccessReasonNone: Type = 0;
  pub const AccessReasonAllowedAce: Type = 65536;
  pub const AccessReasonDeniedAce: Type = 131072;
  pub const AccessReasonAllowedParentAce: Type = 196608;
  pub const AccessReasonDeniedParentAce: Type = 262144;
  pub const AccessReasonNotGrantedByCape: Type = 327680;
  pub const AccessReasonNotGrantedByParentCape: Type = 393216;
  pub const AccessReasonNotGrantedToAppContainer: Type = 458752;
  pub const AccessReasonMissingPrivilege: Type = 1048576;
  pub const AccessReasonFromPrivilege: Type = 2097152;
  pub const AccessReasonIntegrityLevel: Type = 3145728;
  pub const AccessReasonOwnership: Type = 4194304;
  pub const AccessReasonNullDacl: Type = 5242880;
  pub const AccessReasonEmptyDacl: Type = 6291456;
  pub const AccessReasonNoSD: Type = 7340032;
  pub const AccessReasonNoGrant: Type = 8388608;
  pub const AccessReasonTrustLabel: Type = 9437184;
  pub const AccessReasonFilterAce: Type = 10485760;
}
pub use self::_ACCESS_REASON_TYPE::Type as ACCESS_REASON_TYPE;
pub type ACCESS_REASON = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACCESS_REASONS {
  pub Data: [ACCESS_REASON; 32usize],
}
#[test]
fn bindgen_test_layout__ACCESS_REASONS() {
  assert_eq!(
    ::core::mem::size_of::<_ACCESS_REASONS>(),
    128usize,
    concat!("Size of: ", stringify!(_ACCESS_REASONS))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACCESS_REASONS>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_REASONS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ACCESS_REASONS>())).Data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_REASONS),
      "::",
      stringify!(Data)
    )
  );
}
pub type ACCESS_REASONS = _ACCESS_REASONS;
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SE_SECURITY_DESCRIPTOR {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__SE_SECURITY_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<_SE_SECURITY_DESCRIPTOR>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_SECURITY_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).SecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(SecurityDescriptor)
    )
  );
}
impl Default for _SE_SECURITY_DESCRIPTOR {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SE_ACCESS_REQUEST {
  pub Size: DWORD,
  pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
  pub DesiredAccess: ACCESS_MASK,
  pub PreviouslyGrantedAccess: ACCESS_MASK,
  pub PrincipalSelfSid: PSID,
  pub GenericMapping: PGENERIC_MAPPING,
  pub ObjectTypeListCount: DWORD,
  pub ObjectTypeList: POBJECT_TYPE_LIST,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REQUEST() {
  assert_eq!(
    ::core::mem::size_of::<_SE_ACCESS_REQUEST>(),
    56usize,
    concat!("Size of: ", stringify!(_SE_ACCESS_REQUEST))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_ACCESS_REQUEST>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_ACCESS_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).SeSecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(SeSecurityDescriptor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).DesiredAccess as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(DesiredAccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).PreviouslyGrantedAccess as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(PreviouslyGrantedAccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).PrincipalSelfSid as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(PrincipalSelfSid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).GenericMapping as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(GenericMapping)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeListCount as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(ObjectTypeListCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeList as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(ObjectTypeList)
    )
  );
}
impl Default for _SE_ACCESS_REQUEST {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
pub type PSE_ACCESS_REQUEST = *mut _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SE_ACCESS_REPLY {
  pub Size: DWORD,
  pub ResultListCount: DWORD,
  pub GrantedAccess: PACCESS_MASK,
  pub AccessStatus: PDWORD,
  pub AccessReason: PACCESS_REASONS,
  pub Privileges: *mut PPRIVILEGE_SET,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REPLY() {
  assert_eq!(
    ::core::mem::size_of::<_SE_ACCESS_REPLY>(),
    40usize,
    concat!("Size of: ", stringify!(_SE_ACCESS_REPLY))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_ACCESS_REPLY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_ACCESS_REPLY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REPLY>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REPLY>())).ResultListCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(ResultListCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REPLY>())).GrantedAccess as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(GrantedAccess)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REPLY>())).AccessStatus as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(AccessStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REPLY>())).AccessReason as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(AccessReason)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_ACCESS_REPLY>())).Privileges as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(Privileges)
    )
  );
}
impl Default for _SE_ACCESS_REPLY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub type PSE_ACCESS_REPLY = *mut _SE_ACCESS_REPLY;
pub mod _SECURITY_IMPERSONATION_LEVEL {
  pub type Type = i32;
  pub const SecurityAnonymous: Type = 0;
  pub const SecurityIdentification: Type = 1;
  pub const SecurityImpersonation: Type = 2;
  pub const SecurityDelegation: Type = 3;
}
pub use self::_SECURITY_IMPERSONATION_LEVEL::Type as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL::Type;
pub mod _TOKEN_TYPE {
  pub type Type = i32;
  pub const TokenPrimary: Type = 1;
  pub const TokenImpersonation: Type = 2;
}
pub use self::_TOKEN_TYPE::Type as TOKEN_TYPE;
pub type PTOKEN_TYPE = *mut TOKEN_TYPE;
pub mod _TOKEN_ELEVATION_TYPE {
  pub type Type = i32;
  pub const TokenElevationTypeDefault: Type = 1;
  pub const TokenElevationTypeFull: Type = 2;
  pub const TokenElevationTypeLimited: Type = 3;
}
pub use self::_TOKEN_ELEVATION_TYPE::Type as TOKEN_ELEVATION_TYPE;
pub type PTOKEN_ELEVATION_TYPE = *mut _TOKEN_ELEVATION_TYPE::Type;
pub mod _TOKEN_INFORMATION_CLASS {
  pub type Type = i32;
  pub const TokenUser: Type = 1;
  pub const TokenGroups: Type = 2;
  pub const TokenPrivileges: Type = 3;
  pub const TokenOwner: Type = 4;
  pub const TokenPrimaryGroup: Type = 5;
  pub const TokenDefaultDacl: Type = 6;
  pub const TokenSource: Type = 7;
  pub const TokenType: Type = 8;
  pub const TokenImpersonationLevel: Type = 9;
  pub const TokenStatistics: Type = 10;
  pub const TokenRestrictedSids: Type = 11;
  pub const TokenSessionId: Type = 12;
  pub const TokenGroupsAndPrivileges: Type = 13;
  pub const TokenSessionReference: Type = 14;
  pub const TokenSandBoxInert: Type = 15;
  pub const TokenAuditPolicy: Type = 16;
  pub const TokenOrigin: Type = 17;
  pub const TokenElevationType: Type = 18;
  pub const TokenLinkedToken: Type = 19;
  pub const TokenElevation: Type = 20;
  pub const TokenHasRestrictions: Type = 21;
  pub const TokenAccessInformation: Type = 22;
  pub const TokenVirtualizationAllowed: Type = 23;
  pub const TokenVirtualizationEnabled: Type = 24;
  pub const TokenIntegrityLevel: Type = 25;
  pub const TokenUIAccess: Type = 26;
  pub const TokenMandatoryPolicy: Type = 27;
  pub const TokenLogonSid: Type = 28;
  pub const TokenIsAppContainer: Type = 29;
  pub const TokenCapabilities: Type = 30;
  pub const TokenAppContainerSid: Type = 31;
  pub const TokenAppContainerNumber: Type = 32;
  pub const TokenUserClaimAttributes: Type = 33;
  pub const TokenDeviceClaimAttributes: Type = 34;
  pub const TokenRestrictedUserClaimAttributes: Type = 35;
  pub const TokenRestrictedDeviceClaimAttributes: Type = 36;
  pub const TokenDeviceGroups: Type = 37;
  pub const TokenRestrictedDeviceGroups: Type = 38;
  pub const TokenSecurityAttributes: Type = 39;
  pub const TokenIsRestricted: Type = 40;
  pub const TokenProcessTrustLevel: Type = 41;
  pub const TokenPrivateNameSpace: Type = 42;
  pub const TokenSingletonAttributes: Type = 43;
  pub const TokenBnoIsolation: Type = 44;
  pub const TokenChildProcessFlags: Type = 45;
  pub const MaxTokenInfoClass: Type = 46;
}
pub use self::_TOKEN_INFORMATION_CLASS::Type as TOKEN_INFORMATION_CLASS;
pub type PTOKEN_INFORMATION_CLASS = *mut _TOKEN_INFORMATION_CLASS::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_USER {
  pub User: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_USER() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_USER>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_USER))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_USER>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_USER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_USER>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_USER),
      "::",
      stringify!(User)
    )
  );
}
impl Default for _TOKEN_USER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_USER = _TOKEN_USER;
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
  pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
  pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
  pub TokenUser: TOKEN_USER,
  pub User: SID_AND_ATTRIBUTES,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).TokenUser as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_1),
      "::",
      stringify!(TokenUser)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_1),
      "::",
      stringify!(User)
    )
  );
}
impl Default for _SE_TOKEN_USER__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SE_TOKEN_USER__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_SE_TOKEN_USER__bindgen_ty_1 {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
  pub Sid: SID,
  pub Buffer: [BYTE; 68usize],
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
    68usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_2),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Buffer as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_2),
      "::",
      stringify!(Buffer)
    )
  );
}
impl Default for _SE_TOKEN_USER__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SE_TOKEN_USER__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_SE_TOKEN_USER__bindgen_ty_2 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER() {
  assert_eq!(
    ::core::mem::size_of::<_SE_TOKEN_USER>(),
    88usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_TOKEN_USER>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER))
  );
}
impl Default for _SE_TOKEN_USER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SE_TOKEN_USER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SE_TOKEN_USER {{ __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?} }}",
      self.__bindgen_anon_1, self.__bindgen_anon_2
    )
  }
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type PSE_TOKEN_USER = _SE_TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_GROUPS {
  pub GroupCount: DWORD,
  pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__TOKEN_GROUPS() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_GROUPS>(),
    24usize,
    concat!("Size of: ", stringify!(_TOKEN_GROUPS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_GROUPS>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_GROUPS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_GROUPS>())).GroupCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS),
      "::",
      stringify!(GroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_GROUPS>())).Groups as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS),
      "::",
      stringify!(Groups)
    )
  );
}
impl Default for _TOKEN_GROUPS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_GROUPS = _TOKEN_GROUPS;
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_PRIVILEGES {
  pub PrivilegeCount: DWORD,
  pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__TOKEN_PRIVILEGES() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_PRIVILEGES>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_PRIVILEGES))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_PRIVILEGES>(),
    4usize,
    concat!("Alignment of ", stringify!(_TOKEN_PRIVILEGES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_PRIVILEGES>())).PrivilegeCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_PRIVILEGES),
      "::",
      stringify!(PrivilegeCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_PRIVILEGES>())).Privileges as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_PRIVILEGES),
      "::",
      stringify!(Privileges)
    )
  );
}
pub type TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES;
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_OWNER {
  pub Owner: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_OWNER() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_OWNER>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_OWNER))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_OWNER>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_OWNER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_OWNER>())).Owner as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_OWNER),
      "::",
      stringify!(Owner)
    )
  );
}
impl Default for _TOKEN_OWNER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_OWNER = _TOKEN_OWNER;
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_PRIMARY_GROUP {
  pub PrimaryGroup: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_PRIMARY_GROUP() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_PRIMARY_GROUP>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_PRIMARY_GROUP))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_PRIMARY_GROUP>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_PRIMARY_GROUP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_PRIMARY_GROUP>())).PrimaryGroup as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_PRIMARY_GROUP),
      "::",
      stringify!(PrimaryGroup)
    )
  );
}
impl Default for _TOKEN_PRIMARY_GROUP {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP;
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_DEFAULT_DACL {
  pub DefaultDacl: PACL,
}
#[test]
fn bindgen_test_layout__TOKEN_DEFAULT_DACL() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_DEFAULT_DACL>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_DEFAULT_DACL))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_DEFAULT_DACL>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_DEFAULT_DACL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_DEFAULT_DACL>())).DefaultDacl as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_DEFAULT_DACL),
      "::",
      stringify!(DefaultDacl)
    )
  );
}
impl Default for _TOKEN_DEFAULT_DACL {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL;
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_USER_CLAIMS {
  pub UserClaims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__TOKEN_USER_CLAIMS() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_USER_CLAIMS>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_USER_CLAIMS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_USER_CLAIMS>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_USER_CLAIMS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_USER_CLAIMS>())).UserClaims as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_USER_CLAIMS),
      "::",
      stringify!(UserClaims)
    )
  );
}
impl Default for _TOKEN_USER_CLAIMS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS;
pub type PTOKEN_USER_CLAIMS = *mut _TOKEN_USER_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_DEVICE_CLAIMS {
  pub DeviceClaims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__TOKEN_DEVICE_CLAIMS() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_DEVICE_CLAIMS>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_DEVICE_CLAIMS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_DEVICE_CLAIMS>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_DEVICE_CLAIMS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_DEVICE_CLAIMS>())).DeviceClaims as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_DEVICE_CLAIMS),
      "::",
      stringify!(DeviceClaims)
    )
  );
}
impl Default for _TOKEN_DEVICE_CLAIMS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS;
pub type PTOKEN_DEVICE_CLAIMS = *mut _TOKEN_DEVICE_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_GROUPS_AND_PRIVILEGES {
  pub SidCount: DWORD,
  pub SidLength: DWORD,
  pub Sids: PSID_AND_ATTRIBUTES,
  pub RestrictedSidCount: DWORD,
  pub RestrictedSidLength: DWORD,
  pub RestrictedSids: PSID_AND_ATTRIBUTES,
  pub PrivilegeCount: DWORD,
  pub PrivilegeLength: DWORD,
  pub Privileges: PLUID_AND_ATTRIBUTES,
  pub AuthenticationId: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_GROUPS_AND_PRIVILEGES() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_GROUPS_AND_PRIVILEGES>(),
    56usize,
    concat!("Size of: ", stringify!(_TOKEN_GROUPS_AND_PRIVILEGES))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_GROUPS_AND_PRIVILEGES>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_GROUPS_AND_PRIVILEGES))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).SidCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(SidCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).SidLength as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(SidLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).Sids as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(Sids)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).RestrictedSidCount as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(RestrictedSidCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).RestrictedSidLength as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(RestrictedSidLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).RestrictedSids as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(RestrictedSids)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).PrivilegeCount as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(PrivilegeCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).PrivilegeLength as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(PrivilegeLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).Privileges as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(Privileges)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).AuthenticationId as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
      "::",
      stringify!(AuthenticationId)
    )
  );
}
impl Default for _TOKEN_GROUPS_AND_PRIVILEGES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES;
pub type PTOKEN_GROUPS_AND_PRIVILEGES = *mut _TOKEN_GROUPS_AND_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_LINKED_TOKEN {
  pub LinkedToken: HANDLE,
}
#[test]
fn bindgen_test_layout__TOKEN_LINKED_TOKEN() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_LINKED_TOKEN>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_LINKED_TOKEN))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_LINKED_TOKEN>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_LINKED_TOKEN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_LINKED_TOKEN>())).LinkedToken as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_LINKED_TOKEN),
      "::",
      stringify!(LinkedToken)
    )
  );
}
impl Default for _TOKEN_LINKED_TOKEN {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN;
pub type PTOKEN_LINKED_TOKEN = *mut _TOKEN_LINKED_TOKEN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_ELEVATION {
  pub TokenIsElevated: DWORD,
}
#[test]
fn bindgen_test_layout__TOKEN_ELEVATION() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_ELEVATION>(),
    4usize,
    concat!("Size of: ", stringify!(_TOKEN_ELEVATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_ELEVATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_TOKEN_ELEVATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_ELEVATION>())).TokenIsElevated as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ELEVATION),
      "::",
      stringify!(TokenIsElevated)
    )
  );
}
pub type TOKEN_ELEVATION = _TOKEN_ELEVATION;
pub type PTOKEN_ELEVATION = *mut _TOKEN_ELEVATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_MANDATORY_LABEL {
  pub Label: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_MANDATORY_LABEL() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_MANDATORY_LABEL>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_MANDATORY_LABEL))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_MANDATORY_LABEL>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_MANDATORY_LABEL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_MANDATORY_LABEL>())).Label as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_MANDATORY_LABEL),
      "::",
      stringify!(Label)
    )
  );
}
impl Default for _TOKEN_MANDATORY_LABEL {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL;
pub type PTOKEN_MANDATORY_LABEL = *mut _TOKEN_MANDATORY_LABEL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_MANDATORY_POLICY {
  pub Policy: DWORD,
}
#[test]
fn bindgen_test_layout__TOKEN_MANDATORY_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_MANDATORY_POLICY>(),
    4usize,
    concat!("Size of: ", stringify!(_TOKEN_MANDATORY_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_MANDATORY_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_TOKEN_MANDATORY_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_MANDATORY_POLICY>())).Policy as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_MANDATORY_POLICY),
      "::",
      stringify!(Policy)
    )
  );
}
pub type TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY;
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
pub type PSECURITY_ATTRIBUTES_OPAQUE = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_ACCESS_INFORMATION {
  pub SidHash: PSID_AND_ATTRIBUTES_HASH,
  pub RestrictedSidHash: PSID_AND_ATTRIBUTES_HASH,
  pub Privileges: PTOKEN_PRIVILEGES,
  pub AuthenticationId: LUID,
  pub TokenType: TOKEN_TYPE,
  pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
  pub MandatoryPolicy: TOKEN_MANDATORY_POLICY,
  pub Flags: DWORD,
  pub AppContainerNumber: DWORD,
  pub PackageSid: PSID,
  pub CapabilitiesHash: PSID_AND_ATTRIBUTES_HASH,
  pub TrustLevelSid: PSID,
  pub SecurityAttributes: PSECURITY_ATTRIBUTES_OPAQUE,
}
#[test]
fn bindgen_test_layout__TOKEN_ACCESS_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_ACCESS_INFORMATION>(),
    88usize,
    concat!("Size of: ", stringify!(_TOKEN_ACCESS_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_ACCESS_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_ACCESS_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).SidHash as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(SidHash)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).RestrictedSidHash as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(RestrictedSidHash)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).Privileges as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(Privileges)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).AuthenticationId as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(AuthenticationId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).TokenType as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(TokenType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).ImpersonationLevel as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(ImpersonationLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).MandatoryPolicy as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(MandatoryPolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).Flags as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).AppContainerNumber as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(AppContainerNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).PackageSid as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(PackageSid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).CapabilitiesHash as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(CapabilitiesHash)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).TrustLevelSid as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(TrustLevelSid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).SecurityAttributes as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ACCESS_INFORMATION),
      "::",
      stringify!(SecurityAttributes)
    )
  );
}
impl Default for _TOKEN_ACCESS_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION;
pub type PTOKEN_ACCESS_INFORMATION = *mut _TOKEN_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_AUDIT_POLICY {
  pub PerUserPolicy: [BYTE; 30usize],
}
#[test]
fn bindgen_test_layout__TOKEN_AUDIT_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_AUDIT_POLICY>(),
    30usize,
    concat!("Size of: ", stringify!(_TOKEN_AUDIT_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_AUDIT_POLICY>(),
    1usize,
    concat!("Alignment of ", stringify!(_TOKEN_AUDIT_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_AUDIT_POLICY>())).PerUserPolicy as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_AUDIT_POLICY),
      "::",
      stringify!(PerUserPolicy)
    )
  );
}
pub type TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY;
pub type PTOKEN_AUDIT_POLICY = *mut _TOKEN_AUDIT_POLICY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_SOURCE {
  pub SourceName: [CHAR; 8usize],
  pub SourceIdentifier: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_SOURCE() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_SOURCE>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_SOURCE))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_SOURCE>(),
    4usize,
    concat!("Alignment of ", stringify!(_TOKEN_SOURCE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_SOURCE>())).SourceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_SOURCE),
      "::",
      stringify!(SourceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_SOURCE>())).SourceIdentifier as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_SOURCE),
      "::",
      stringify!(SourceIdentifier)
    )
  );
}
pub type TOKEN_SOURCE = _TOKEN_SOURCE;
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_STATISTICS {
  pub TokenId: LUID,
  pub AuthenticationId: LUID,
  pub ExpirationTime: LARGE_INTEGER,
  pub TokenType: TOKEN_TYPE,
  pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
  pub DynamicCharged: DWORD,
  pub DynamicAvailable: DWORD,
  pub GroupCount: DWORD,
  pub PrivilegeCount: DWORD,
  pub ModifiedId: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_STATISTICS() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_STATISTICS>(),
    56usize,
    concat!("Size of: ", stringify!(_TOKEN_STATISTICS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_STATISTICS>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_STATISTICS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).TokenId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(TokenId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).AuthenticationId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(AuthenticationId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).ExpirationTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(ExpirationTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).TokenType as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(TokenType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).ImpersonationLevel as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(ImpersonationLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).DynamicCharged as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(DynamicCharged)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).DynamicAvailable as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(DynamicAvailable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).GroupCount as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(GroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).PrivilegeCount as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(PrivilegeCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_STATISTICS>())).ModifiedId as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_STATISTICS),
      "::",
      stringify!(ModifiedId)
    )
  );
}
impl Default for _TOKEN_STATISTICS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TOKEN_STATISTICS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_TOKEN_STATISTICS {{ TokenId: {:?}, AuthenticationId: {:?}, ExpirationTime: {:?}, TokenType: {:?}, ImpersonationLevel: {:?}, DynamicCharged: {:?}, DynamicAvailable: {:?}, GroupCount: {:?}, PrivilegeCount: {:?}, ModifiedId: {:?} }}" , self . TokenId , self . AuthenticationId , self . ExpirationTime , self . TokenType , self . ImpersonationLevel , self . DynamicCharged , self . DynamicAvailable , self . GroupCount , self . PrivilegeCount , self . ModifiedId )
  }
}
pub type TOKEN_STATISTICS = _TOKEN_STATISTICS;
pub type PTOKEN_STATISTICS = *mut _TOKEN_STATISTICS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_CONTROL {
  pub TokenId: LUID,
  pub AuthenticationId: LUID,
  pub ModifiedId: LUID,
  pub TokenSource: TOKEN_SOURCE,
}
#[test]
fn bindgen_test_layout__TOKEN_CONTROL() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_CONTROL>(),
    40usize,
    concat!("Size of: ", stringify!(_TOKEN_CONTROL))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_CONTROL>(),
    4usize,
    concat!("Alignment of ", stringify!(_TOKEN_CONTROL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_CONTROL>())).TokenId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_CONTROL),
      "::",
      stringify!(TokenId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_CONTROL>())).AuthenticationId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_CONTROL),
      "::",
      stringify!(AuthenticationId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_CONTROL>())).ModifiedId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_CONTROL),
      "::",
      stringify!(ModifiedId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_CONTROL>())).TokenSource as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_CONTROL),
      "::",
      stringify!(TokenSource)
    )
  );
}
pub type TOKEN_CONTROL = _TOKEN_CONTROL;
pub type PTOKEN_CONTROL = *mut _TOKEN_CONTROL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TOKEN_ORIGIN {
  pub OriginatingLogonSession: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_ORIGIN() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_ORIGIN>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_ORIGIN))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_ORIGIN>(),
    4usize,
    concat!("Alignment of ", stringify!(_TOKEN_ORIGIN))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_ORIGIN>())).OriginatingLogonSession as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_ORIGIN),
      "::",
      stringify!(OriginatingLogonSession)
    )
  );
}
pub type TOKEN_ORIGIN = _TOKEN_ORIGIN;
pub type PTOKEN_ORIGIN = *mut _TOKEN_ORIGIN;
pub mod _MANDATORY_LEVEL {
  pub type Type = i32;
  pub const MandatoryLevelUntrusted: Type = 0;
  pub const MandatoryLevelLow: Type = 1;
  pub const MandatoryLevelMedium: Type = 2;
  pub const MandatoryLevelHigh: Type = 3;
  pub const MandatoryLevelSystem: Type = 4;
  pub const MandatoryLevelSecureProcess: Type = 5;
  pub const MandatoryLevelCount: Type = 6;
}
pub use self::_MANDATORY_LEVEL::Type as MANDATORY_LEVEL;
pub type PMANDATORY_LEVEL = *mut _MANDATORY_LEVEL::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_APPCONTAINER_INFORMATION {
  pub TokenAppContainer: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_APPCONTAINER_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_APPCONTAINER_INFORMATION>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_APPCONTAINER_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_APPCONTAINER_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_APPCONTAINER_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_APPCONTAINER_INFORMATION>())).TokenAppContainer as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_APPCONTAINER_INFORMATION),
      "::",
      stringify!(TokenAppContainer)
    )
  );
}
impl Default for _TOKEN_APPCONTAINER_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION;
pub type PTOKEN_APPCONTAINER_INFORMATION = *mut _TOKEN_APPCONTAINER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_SID_INFORMATION {
  pub Sid: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_SID_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_SID_INFORMATION>(),
    8usize,
    concat!("Size of: ", stringify!(_TOKEN_SID_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_SID_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_SID_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TOKEN_SID_INFORMATION>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_SID_INFORMATION),
      "::",
      stringify!(Sid)
    )
  );
}
impl Default for _TOKEN_SID_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_SID_INFORMATION = _TOKEN_SID_INFORMATION;
pub type PTOKEN_SID_INFORMATION = *mut _TOKEN_SID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TOKEN_BNO_ISOLATION_INFORMATION {
  pub IsolationPrefix: PWSTR,
  pub IsolationEnabled: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TOKEN_BNO_ISOLATION_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TOKEN_BNO_ISOLATION_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_BNO_ISOLATION_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TOKEN_BNO_ISOLATION_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_TOKEN_BNO_ISOLATION_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_BNO_ISOLATION_INFORMATION>())).IsolationPrefix as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_BNO_ISOLATION_INFORMATION),
      "::",
      stringify!(IsolationPrefix)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TOKEN_BNO_ISOLATION_INFORMATION>())).IsolationEnabled as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_BNO_ISOLATION_INFORMATION),
      "::",
      stringify!(IsolationEnabled)
    )
  );
}
impl Default for _TOKEN_BNO_ISOLATION_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOKEN_BNO_ISOLATION_INFORMATION = _TOKEN_BNO_ISOLATION_INFORMATION;
pub type PTOKEN_BNO_ISOLATION_INFORMATION = *mut _TOKEN_BNO_ISOLATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
  pub Version: DWORD64,
  pub Name: PWSTR,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>())).Name as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
      "::",
      stringify!(Name)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
  pub pValue: PVOID,
  pub ValueLength: DWORD,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>())).pValue as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
      "::",
      stringify!(pValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>())).ValueLength
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
      "::",
      stringify!(ValueLength)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
  *mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
  pub Name: PWSTR,
  pub ValueType: WORD,
  pub Reserved: WORD,
  pub Flags: DWORD,
  pub ValueCount: DWORD,
  pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
  pub pInt64: PLONG64,
  pub pUint64: PDWORD64,
  pub ppString: *mut PWSTR,
  pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
  pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pInt64 as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
      "::",
      stringify!(pInt64)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pUint64 as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
      "::",
      stringify!(pUint64)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).ppString as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
      "::",
      stringify!(ppString)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pFqbn as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
      "::",
      stringify!(pFqbn)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pOctetString
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
      "::",
      stringify!(pOctetString)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_V1() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_V1>(),
    32usize,
    concat!("Size of: ", stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1))
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_V1>(),
    8usize,
    concat!("Alignment of ", stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
      "::",
      stringify!(Name)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).ValueType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
      "::",
      stringify!(ValueType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Reserved as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).ValueCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
      "::",
      stringify!(ValueCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Values as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
      "::",
      stringify!(Values)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_V1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CLAIM_SECURITY_ATTRIBUTE_V1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_CLAIM_SECURITY_ATTRIBUTE_V1 {{ Name: {:?}, ValueType: {:?}, Reserved: {:?}, Flags: {:?}, ValueCount: {:?}, Values: {:?} }}" , self . Name , self . ValueType , self . Reserved , self . Flags , self . ValueCount , self . Values )
  }
}
pub type CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
  pub Name: DWORD,
  pub ValueType: WORD,
  pub Reserved: WORD,
  pub Flags: DWORD,
  pub ValueCount: DWORD,
  pub Values: _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
  pub pInt64: [DWORD; 1usize],
  pub pUint64: [DWORD; 1usize],
  pub ppString: [DWORD; 1usize],
  pub pFqbn: [DWORD; 1usize],
  pub pOctetString: [DWORD; 1usize],
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pInt64
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
      "::",
      stringify!(pInt64)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pUint64
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
      "::",
      stringify!(pUint64)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).ppString
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
      "::",
      stringify!(ppString)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pFqbn
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
      "::",
      stringify!(pFqbn)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pOctetString
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
      "::",
      stringify!(pOctetString)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>(),
    20usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Name as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
      "::",
      stringify!(Name)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).ValueType as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
      "::",
      stringify!(ValueType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Reserved as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).ValueCount as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
      "::",
      stringify!(ValueCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Values as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
      "::",
      stringify!(Values)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {{ Name: {:?}, ValueType: {:?}, Reserved: {:?}, Flags: {:?}, ValueCount: {:?}, Values: {:?} }}" , self . Name , self . ValueType , self . Reserved , self . Flags , self . ValueCount , self . Values )
  }
}
pub type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
  pub Version: WORD,
  pub Reserved: WORD,
  pub AttributeCount: DWORD,
  pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
  pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>())).pAttributeV1
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(pAttributeV1)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTES_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).Reserved as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).AttributeCount as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
      "::",
      stringify!(AttributeCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).Attribute as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
      "::",
      stringify!(Attribute)
    )
  );
}
impl Default for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_CLAIM_SECURITY_ATTRIBUTES_INFORMATION {{ Version: {:?}, Reserved: {:?}, AttributeCount: {:?}, Attribute: {:?} }}" , self . Version , self . Reserved , self . AttributeCount , self . Attribute )
  }
}
pub type CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
  pub Length: DWORD,
  pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
  pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
  pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
  assert_eq!(
    ::core::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
    12usize,
    concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).Length as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ImpersonationLevel as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(ImpersonationLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ContextTrackingMode as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(ContextTrackingMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).EffectiveOnly as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(EffectiveOnly)
    )
  );
}
impl Default for _SECURITY_QUALITY_OF_SERVICE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SE_IMPERSONATION_STATE {
  pub Token: PACCESS_TOKEN,
  pub CopyOnOpen: BOOLEAN,
  pub EffectiveOnly: BOOLEAN,
  pub Level: SECURITY_IMPERSONATION_LEVEL,
}
#[test]
fn bindgen_test_layout__SE_IMPERSONATION_STATE() {
  assert_eq!(
    ::core::mem::size_of::<_SE_IMPERSONATION_STATE>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_IMPERSONATION_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<_SE_IMPERSONATION_STATE>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_IMPERSONATION_STATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_IMPERSONATION_STATE>())).Token as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(Token)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_IMPERSONATION_STATE>())).CopyOnOpen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(CopyOnOpen)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SE_IMPERSONATION_STATE>())).EffectiveOnly as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(EffectiveOnly)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SE_IMPERSONATION_STATE>())).Level as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(Level)
    )
  );
}
impl Default for _SE_IMPERSONATION_STATE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = DWORD;
pub type PSECURITY_INFORMATION = *mut DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub type PSE_SIGNING_LEVEL = *mut BYTE;
pub mod _SE_IMAGE_SIGNATURE_TYPE {
  pub type Type = i32;
  pub const SeImageSignatureNone: Type = 0;
  pub const SeImageSignatureEmbedded: Type = 1;
  pub const SeImageSignatureCache: Type = 2;
  pub const SeImageSignatureCatalogCached: Type = 3;
  pub const SeImageSignatureCatalogNotCached: Type = 4;
  pub const SeImageSignatureCatalogHint: Type = 5;
  pub const SeImageSignaturePackageCatalog: Type = 6;
}
pub use self::_SE_IMAGE_SIGNATURE_TYPE::Type as SE_IMAGE_SIGNATURE_TYPE;
pub type PSE_IMAGE_SIGNATURE_TYPE = *mut _SE_IMAGE_SIGNATURE_TYPE::Type;
pub mod _SE_LEARNING_MODE_DATA_TYPE {
  pub type Type = i32;
  pub const SeLearningModeInvalidType: Type = 0;
  pub const SeLearningModeSettings: Type = 1;
  pub const SeLearningModeMax: Type = 2;
}
pub use self::_SE_LEARNING_MODE_DATA_TYPE::Type as SE_LEARNING_MODE_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SECURITY_CAPABILITIES {
  pub AppContainerSid: PSID,
  pub Capabilities: PSID_AND_ATTRIBUTES,
  pub CapabilityCount: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_CAPABILITIES() {
  assert_eq!(
    ::core::mem::size_of::<_SECURITY_CAPABILITIES>(),
    24usize,
    concat!("Size of: ", stringify!(_SECURITY_CAPABILITIES))
  );
  assert_eq!(
    ::core::mem::align_of::<_SECURITY_CAPABILITIES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_CAPABILITIES))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_CAPABILITIES>())).AppContainerSid as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(AppContainerSid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_CAPABILITIES>())).Capabilities as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(Capabilities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_CAPABILITIES>())).CapabilityCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(CapabilityCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_CAPABILITIES>())).Reserved as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(Reserved)
    )
  );
}
impl Default for _SECURITY_CAPABILITIES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES;
pub type PSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
pub type LPSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _JOB_SET_ARRAY {
  pub JobHandle: HANDLE,
  pub MemberLevel: DWORD,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__JOB_SET_ARRAY() {
  assert_eq!(
    ::core::mem::size_of::<_JOB_SET_ARRAY>(),
    16usize,
    concat!("Size of: ", stringify!(_JOB_SET_ARRAY))
  );
  assert_eq!(
    ::core::mem::align_of::<_JOB_SET_ARRAY>(),
    8usize,
    concat!("Alignment of ", stringify!(_JOB_SET_ARRAY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JOB_SET_ARRAY>())).JobHandle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOB_SET_ARRAY),
      "::",
      stringify!(JobHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JOB_SET_ARRAY>())).MemberLevel as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOB_SET_ARRAY),
      "::",
      stringify!(MemberLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JOB_SET_ARRAY>())).Flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOB_SET_ARRAY),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _JOB_SET_ARRAY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type JOB_SET_ARRAY = _JOB_SET_ARRAY;
pub type PJOB_SET_ARRAY = *mut _JOB_SET_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
  pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
  pub Handler: PEXCEPTION_ROUTINE,
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_EXCEPTION_REGISTRATION_RECORD>(),
    16usize,
    concat!("Size of: ", stringify!(_EXCEPTION_REGISTRATION_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXCEPTION_REGISTRATION_RECORD>(),
    8usize,
    concat!("Alignment of ", stringify!(_EXCEPTION_REGISTRATION_RECORD))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_REGISTRATION_RECORD>())).Next as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_REGISTRATION_RECORD),
      "::",
      stringify!(Next)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_REGISTRATION_RECORD>())).Handler as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_REGISTRATION_RECORD),
      "::",
      stringify!(Handler)
    )
  );
}
impl Default for _EXCEPTION_REGISTRATION_RECORD {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION_RECORD = *mut EXCEPTION_REGISTRATION_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
  pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
  pub StackBase: PVOID,
  pub StackLimit: PVOID,
  pub SubSystemTib: PVOID,
  pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
  pub ArbitraryUserPointer: PVOID,
  pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
  pub FiberData: PVOID,
  pub Version: DWORD,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__NT_TIB__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_NT_TIB__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_NT_TIB__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_NT_TIB__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_NT_TIB__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB__bindgen_ty_1>())).FiberData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB__bindgen_ty_1),
      "::",
      stringify!(FiberData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB__bindgen_ty_1>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB__bindgen_ty_1),
      "::",
      stringify!(Version)
    )
  );
}
impl Default for _NT_TIB__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _NT_TIB__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_NT_TIB__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__NT_TIB() {
  assert_eq!(
    ::core::mem::size_of::<_NT_TIB>(),
    56usize,
    concat!("Size of: ", stringify!(_NT_TIB))
  );
  assert_eq!(
    ::core::mem::align_of::<_NT_TIB>(),
    8usize,
    concat!("Alignment of ", stringify!(_NT_TIB))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB>())).ExceptionList as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB),
      "::",
      stringify!(ExceptionList)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB>())).StackBase as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB),
      "::",
      stringify!(StackBase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB>())).StackLimit as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB),
      "::",
      stringify!(StackLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB>())).SubSystemTib as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB),
      "::",
      stringify!(SubSystemTib)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB>())).ArbitraryUserPointer as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB),
      "::",
      stringify!(ArbitraryUserPointer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB>())).Self_ as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB),
      "::",
      stringify!(Self_)
    )
  );
}
impl Default for _NT_TIB {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _NT_TIB {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_NT_TIB {{ ExceptionList: {:?}, StackBase: {:?}, StackLimit: {:?}, SubSystemTib: {:?}, __bindgen_anon_1: {:?}, ArbitraryUserPointer: {:?}, Self: {:?} }}" , self . ExceptionList , self . StackBase , self . StackLimit , self . SubSystemTib , self . __bindgen_anon_1 , self . ArbitraryUserPointer , self . Self_ )
  }
}
pub type NT_TIB = _NT_TIB;
pub type PNT_TIB = *mut NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
  pub ExceptionList: DWORD,
  pub StackBase: DWORD,
  pub StackLimit: DWORD,
  pub SubSystemTib: DWORD,
  pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
  pub ArbitraryUserPointer: DWORD,
  pub Self_: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
  pub FiberData: DWORD,
  pub Version: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__NT_TIB32__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_NT_TIB32__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_NT_TIB32__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_NT_TIB32__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_NT_TIB32__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32__bindgen_ty_1>())).FiberData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32__bindgen_ty_1),
      "::",
      stringify!(FiberData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32__bindgen_ty_1>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32__bindgen_ty_1),
      "::",
      stringify!(Version)
    )
  );
}
impl Default for _NT_TIB32__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _NT_TIB32__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_NT_TIB32__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__NT_TIB32() {
  assert_eq!(
    ::core::mem::size_of::<_NT_TIB32>(),
    28usize,
    concat!("Size of: ", stringify!(_NT_TIB32))
  );
  assert_eq!(
    ::core::mem::align_of::<_NT_TIB32>(),
    4usize,
    concat!("Alignment of ", stringify!(_NT_TIB32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32>())).ExceptionList as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32),
      "::",
      stringify!(ExceptionList)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32>())).StackBase as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32),
      "::",
      stringify!(StackBase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32>())).StackLimit as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32),
      "::",
      stringify!(StackLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32>())).SubSystemTib as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32),
      "::",
      stringify!(SubSystemTib)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32>())).ArbitraryUserPointer as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32),
      "::",
      stringify!(ArbitraryUserPointer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB32>())).Self_ as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB32),
      "::",
      stringify!(Self_)
    )
  );
}
impl Default for _NT_TIB32 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _NT_TIB32 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_NT_TIB32 {{ ExceptionList: {:?}, StackBase: {:?}, StackLimit: {:?}, SubSystemTib: {:?}, __bindgen_anon_1: {:?}, ArbitraryUserPointer: {:?}, Self: {:?} }}" , self . ExceptionList , self . StackBase , self . StackLimit , self . SubSystemTib , self . __bindgen_anon_1 , self . ArbitraryUserPointer , self . Self_ )
  }
}
pub type NT_TIB32 = _NT_TIB32;
pub type PNT_TIB32 = *mut _NT_TIB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
  pub ExceptionList: DWORD64,
  pub StackBase: DWORD64,
  pub StackLimit: DWORD64,
  pub SubSystemTib: DWORD64,
  pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
  pub ArbitraryUserPointer: DWORD64,
  pub Self_: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
  pub FiberData: DWORD64,
  pub Version: DWORD,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__NT_TIB64__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_NT_TIB64__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_NT_TIB64__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_NT_TIB64__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_NT_TIB64__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64__bindgen_ty_1>())).FiberData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64__bindgen_ty_1),
      "::",
      stringify!(FiberData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64__bindgen_ty_1>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64__bindgen_ty_1),
      "::",
      stringify!(Version)
    )
  );
}
impl Default for _NT_TIB64__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _NT_TIB64__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_NT_TIB64__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__NT_TIB64() {
  assert_eq!(
    ::core::mem::size_of::<_NT_TIB64>(),
    56usize,
    concat!("Size of: ", stringify!(_NT_TIB64))
  );
  assert_eq!(
    ::core::mem::align_of::<_NT_TIB64>(),
    8usize,
    concat!("Alignment of ", stringify!(_NT_TIB64))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64>())).ExceptionList as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64),
      "::",
      stringify!(ExceptionList)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64>())).StackBase as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64),
      "::",
      stringify!(StackBase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64>())).StackLimit as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64),
      "::",
      stringify!(StackLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64>())).SubSystemTib as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64),
      "::",
      stringify!(SubSystemTib)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64>())).ArbitraryUserPointer as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64),
      "::",
      stringify!(ArbitraryUserPointer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NT_TIB64>())).Self_ as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_NT_TIB64),
      "::",
      stringify!(Self_)
    )
  );
}
impl Default for _NT_TIB64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _NT_TIB64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_NT_TIB64 {{ ExceptionList: {:?}, StackBase: {:?}, StackLimit: {:?}, SubSystemTib: {:?}, __bindgen_anon_1: {:?}, ArbitraryUserPointer: {:?}, Self: {:?} }}" , self . ExceptionList , self . StackBase , self . StackLimit , self . SubSystemTib , self . __bindgen_anon_1 , self . ArbitraryUserPointer , self . Self_ )
  }
}
pub type NT_TIB64 = _NT_TIB64;
pub type PNT_TIB64 = *mut _NT_TIB64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UMS_CREATE_THREAD_ATTRIBUTES {
  pub UmsVersion: DWORD,
  pub UmsContext: PVOID,
  pub UmsCompletionList: PVOID,
}
#[test]
fn bindgen_test_layout__UMS_CREATE_THREAD_ATTRIBUTES() {
  assert_eq!(
    ::core::mem::size_of::<_UMS_CREATE_THREAD_ATTRIBUTES>(),
    24usize,
    concat!("Size of: ", stringify!(_UMS_CREATE_THREAD_ATTRIBUTES))
  );
  assert_eq!(
    ::core::mem::align_of::<_UMS_CREATE_THREAD_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_UMS_CREATE_THREAD_ATTRIBUTES))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_CREATE_THREAD_ATTRIBUTES>())).UmsVersion as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
      "::",
      stringify!(UmsVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_CREATE_THREAD_ATTRIBUTES>())).UmsContext as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
      "::",
      stringify!(UmsContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_CREATE_THREAD_ATTRIBUTES>())).UmsCompletionList as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
      "::",
      stringify!(UmsCompletionList)
    )
  );
}
impl Default for _UMS_CREATE_THREAD_ATTRIBUTES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UMS_CREATE_THREAD_ATTRIBUTES = _UMS_CREATE_THREAD_ATTRIBUTES;
pub type PUMS_CREATE_THREAD_ATTRIBUTES = *mut _UMS_CREATE_THREAD_ATTRIBUTES;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _WOW64_ARCHITECTURE_INFORMATION {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout__WOW64_ARCHITECTURE_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_WOW64_ARCHITECTURE_INFORMATION>(),
    4usize,
    concat!("Size of: ", stringify!(_WOW64_ARCHITECTURE_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_WOW64_ARCHITECTURE_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_WOW64_ARCHITECTURE_INFORMATION))
  );
}
impl _WOW64_ARCHITECTURE_INFORMATION {
  #[inline]
  pub fn Machine(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_Machine(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn KernelMode(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_KernelMode(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn UserMode(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_UserMode(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(17usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Native(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Native(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(18usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Process(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Process(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(19usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedZero0(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedZero0(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(20usize, 12u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Machine: DWORD, KernelMode: DWORD, UserMode: DWORD, Native: DWORD, Process: DWORD,
    ReservedZero0: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let Machine: u32 = unsafe { ::core::mem::transmute(Machine) };
      Machine as u64
    });
    __bindgen_bitfield_unit.set(16usize, 1u8, {
      let KernelMode: u32 = unsafe { ::core::mem::transmute(KernelMode) };
      KernelMode as u64
    });
    __bindgen_bitfield_unit.set(17usize, 1u8, {
      let UserMode: u32 = unsafe { ::core::mem::transmute(UserMode) };
      UserMode as u64
    });
    __bindgen_bitfield_unit.set(18usize, 1u8, {
      let Native: u32 = unsafe { ::core::mem::transmute(Native) };
      Native as u64
    });
    __bindgen_bitfield_unit.set(19usize, 1u8, {
      let Process: u32 = unsafe { ::core::mem::transmute(Process) };
      Process as u64
    });
    __bindgen_bitfield_unit.set(20usize, 12u8, {
      let ReservedZero0: u32 = unsafe { ::core::mem::transmute(ReservedZero0) };
      ReservedZero0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type WOW64_ARCHITECTURE_INFORMATION = _WOW64_ARCHITECTURE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS {
  pub PagedPoolLimit: SIZE_T,
  pub NonPagedPoolLimit: SIZE_T,
  pub MinimumWorkingSetSize: SIZE_T,
  pub MaximumWorkingSetSize: SIZE_T,
  pub PagefileLimit: SIZE_T,
  pub TimeLimit: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS() {
  assert_eq!(
    ::core::mem::size_of::<_QUOTA_LIMITS>(),
    48usize,
    concat!("Size of: ", stringify!(_QUOTA_LIMITS))
  );
  assert_eq!(
    ::core::mem::align_of::<_QUOTA_LIMITS>(),
    8usize,
    concat!("Alignment of ", stringify!(_QUOTA_LIMITS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS>())).PagedPoolLimit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS),
      "::",
      stringify!(PagedPoolLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS>())).NonPagedPoolLimit as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS),
      "::",
      stringify!(NonPagedPoolLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUOTA_LIMITS>())).MinimumWorkingSetSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS),
      "::",
      stringify!(MinimumWorkingSetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUOTA_LIMITS>())).MaximumWorkingSetSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS),
      "::",
      stringify!(MaximumWorkingSetSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS>())).PagefileLimit as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS),
      "::",
      stringify!(PagefileLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS>())).TimeLimit as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS),
      "::",
      stringify!(TimeLimit)
    )
  );
}
impl Default for _QUOTA_LIMITS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _QUOTA_LIMITS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_QUOTA_LIMITS {{ PagedPoolLimit: {:?}, NonPagedPoolLimit: {:?}, MinimumWorkingSetSize: {:?}, MaximumWorkingSetSize: {:?}, PagefileLimit: {:?}, TimeLimit: {:?} }}" , self . PagedPoolLimit , self . NonPagedPoolLimit , self . MinimumWorkingSetSize , self . MaximumWorkingSetSize , self . PagefileLimit , self . TimeLimit )
  }
}
pub type QUOTA_LIMITS = _QUOTA_LIMITS;
pub type PQUOTA_LIMITS = *mut _QUOTA_LIMITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RATE_QUOTA_LIMIT {
  pub RateData: DWORD,
  pub __bindgen_anon_1: _RATE_QUOTA_LIMIT__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_RATE_QUOTA_LIMIT__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_RATE_QUOTA_LIMIT__bindgen_ty_1))
  );
}
impl _RATE_QUOTA_LIMIT__bindgen_ty_1 {
  #[inline]
  pub fn RatePercent(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
  }
  #[inline]
  pub fn set_RatePercent(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(7usize, 25u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    RatePercent: DWORD, Reserved0: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 7u8, {
      let RatePercent: u32 = unsafe { ::core::mem::transmute(RatePercent) };
      RatePercent as u64
    });
    __bindgen_bitfield_unit.set(7usize, 25u8, {
      let Reserved0: u32 = unsafe { ::core::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT() {
  assert_eq!(
    ::core::mem::size_of::<_RATE_QUOTA_LIMIT>(),
    4usize,
    concat!("Size of: ", stringify!(_RATE_QUOTA_LIMIT))
  );
  assert_eq!(
    ::core::mem::align_of::<_RATE_QUOTA_LIMIT>(),
    4usize,
    concat!("Alignment of ", stringify!(_RATE_QUOTA_LIMIT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RATE_QUOTA_LIMIT>())).RateData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RATE_QUOTA_LIMIT),
      "::",
      stringify!(RateData)
    )
  );
}
impl Default for _RATE_QUOTA_LIMIT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _RATE_QUOTA_LIMIT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_RATE_QUOTA_LIMIT {{ union }}")
  }
}
pub type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT;
pub type PRATE_QUOTA_LIMIT = *mut _RATE_QUOTA_LIMIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS_EX {
  pub PagedPoolLimit: SIZE_T,
  pub NonPagedPoolLimit: SIZE_T,
  pub MinimumWorkingSetSize: SIZE_T,
  pub MaximumWorkingSetSize: SIZE_T,
  pub PagefileLimit: SIZE_T,
  pub TimeLimit: LARGE_INTEGER,
  pub WorkingSetLimit: SIZE_T,
  pub Reserved2: SIZE_T,
  pub Reserved3: SIZE_T,
  pub Reserved4: SIZE_T,
  pub Flags: DWORD,
  pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS_EX() {
  assert_eq!(
    ::core::mem::size_of::<_QUOTA_LIMITS_EX>(),
    88usize,
    concat!("Size of: ", stringify!(_QUOTA_LIMITS_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<_QUOTA_LIMITS_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(_QUOTA_LIMITS_EX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).PagedPoolLimit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(PagedPoolLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).NonPagedPoolLimit as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(NonPagedPoolLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).MinimumWorkingSetSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(MinimumWorkingSetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).MaximumWorkingSetSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(MaximumWorkingSetSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).PagefileLimit as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(PagefileLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).TimeLimit as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(TimeLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).WorkingSetLimit as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(WorkingSetLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).Reserved2 as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).Reserved3 as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).Reserved4 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(Reserved4)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).Flags as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUOTA_LIMITS_EX>())).CpuRateLimit as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUOTA_LIMITS_EX),
      "::",
      stringify!(CpuRateLimit)
    )
  );
}
impl Default for _QUOTA_LIMITS_EX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _QUOTA_LIMITS_EX {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_QUOTA_LIMITS_EX {{ PagedPoolLimit: {:?}, NonPagedPoolLimit: {:?}, MinimumWorkingSetSize: {:?}, MaximumWorkingSetSize: {:?}, PagefileLimit: {:?}, TimeLimit: {:?}, WorkingSetLimit: {:?}, Reserved2: {:?}, Reserved3: {:?}, Reserved4: {:?}, Flags: {:?}, CpuRateLimit: {:?} }}" , self . PagedPoolLimit , self . NonPagedPoolLimit , self . MinimumWorkingSetSize , self . MaximumWorkingSetSize , self . PagefileLimit , self . TimeLimit , self . WorkingSetLimit , self . Reserved2 , self . Reserved3 , self . Reserved4 , self . Flags , self . CpuRateLimit )
  }
}
pub type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX;
pub type PQUOTA_LIMITS_EX = *mut _QUOTA_LIMITS_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IO_COUNTERS {
  pub ReadOperationCount: ULONGLONG,
  pub WriteOperationCount: ULONGLONG,
  pub OtherOperationCount: ULONGLONG,
  pub ReadTransferCount: ULONGLONG,
  pub WriteTransferCount: ULONGLONG,
  pub OtherTransferCount: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IO_COUNTERS() {
  assert_eq!(
    ::core::mem::size_of::<_IO_COUNTERS>(),
    48usize,
    concat!("Size of: ", stringify!(_IO_COUNTERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_IO_COUNTERS>(),
    8usize,
    concat!("Alignment of ", stringify!(_IO_COUNTERS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_IO_COUNTERS>())).ReadOperationCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_COUNTERS),
      "::",
      stringify!(ReadOperationCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_IO_COUNTERS>())).WriteOperationCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_COUNTERS),
      "::",
      stringify!(WriteOperationCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_IO_COUNTERS>())).OtherOperationCount as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_COUNTERS),
      "::",
      stringify!(OtherOperationCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_IO_COUNTERS>())).ReadTransferCount as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_COUNTERS),
      "::",
      stringify!(ReadTransferCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_IO_COUNTERS>())).WriteTransferCount as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_COUNTERS),
      "::",
      stringify!(WriteTransferCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_IO_COUNTERS>())).OtherTransferCount as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_COUNTERS),
      "::",
      stringify!(OtherTransferCount)
    )
  );
}
pub type IO_COUNTERS = _IO_COUNTERS;
pub type PIO_COUNTERS = *mut IO_COUNTERS;
pub mod _HARDWARE_COUNTER_TYPE {
  pub type Type = i32;
  pub const PMCCounter: Type = 0;
  pub const MaxHardwareCounterType: Type = 1;
}
pub use self::_HARDWARE_COUNTER_TYPE::Type as HARDWARE_COUNTER_TYPE;
pub type PHARDWARE_COUNTER_TYPE = *mut _HARDWARE_COUNTER_TYPE::Type;
pub mod _PROCESS_MITIGATION_POLICY {
  pub type Type = i32;
  pub const ProcessDEPPolicy: Type = 0;
  pub const ProcessASLRPolicy: Type = 1;
  pub const ProcessDynamicCodePolicy: Type = 2;
  pub const ProcessStrictHandleCheckPolicy: Type = 3;
  pub const ProcessSystemCallDisablePolicy: Type = 4;
  pub const ProcessMitigationOptionsMask: Type = 5;
  pub const ProcessExtensionPointDisablePolicy: Type = 6;
  pub const ProcessControlFlowGuardPolicy: Type = 7;
  pub const ProcessSignaturePolicy: Type = 8;
  pub const ProcessFontDisablePolicy: Type = 9;
  pub const ProcessImageLoadPolicy: Type = 10;
  pub const ProcessSystemCallFilterPolicy: Type = 11;
  pub const ProcessPayloadRestrictionPolicy: Type = 12;
  pub const ProcessChildProcessPolicy: Type = 13;
  pub const MaxProcessMitigationPolicy: Type = 14;
}
pub use self::_PROCESS_MITIGATION_POLICY::Type as PROCESS_MITIGATION_POLICY;
pub type PPROCESS_MITIGATION_POLICY = *mut _PROCESS_MITIGATION_POLICY::Type;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn EnableBottomUpRandomization(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableBottomUpRandomization(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableForceRelocateImages(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableForceRelocateImages(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableHighEntropy(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableHighEntropy(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn DisallowStrippedImages(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DisallowStrippedImages(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 28u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    EnableBottomUpRandomization: DWORD, EnableForceRelocateImages: DWORD, EnableHighEntropy: DWORD,
    DisallowStrippedImages: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let EnableBottomUpRandomization: u32 =
        unsafe { ::core::mem::transmute(EnableBottomUpRandomization) };
      EnableBottomUpRandomization as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let EnableForceRelocateImages: u32 =
        unsafe { ::core::mem::transmute(EnableForceRelocateImages) };
      EnableForceRelocateImages as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let EnableHighEntropy: u32 = unsafe { ::core::mem::transmute(EnableHighEntropy) };
      EnableHighEntropy as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let DisallowStrippedImages: u32 = unsafe { ::core::mem::transmute(DisallowStrippedImages) };
      DisallowStrippedImages as u64
    });
    __bindgen_bitfield_unit.set(4usize, 28u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>())).Flags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY>(),
    4usize,
    concat!("Size of: ", stringify!(_PROCESS_MITIGATION_ASLR_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_PROCESS_MITIGATION_ASLR_POLICY))
  );
}
impl Default for _PROCESS_MITIGATION_ASLR_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_ASLR_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_ASLR_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
pub type PPROCESS_MITIGATION_ASLR_POLICY = *mut _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1,
  pub Permanent: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn Enable(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Enable(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn DisableAtlThunkEmulation(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DisableAtlThunkEmulation(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Enable: DWORD, DisableAtlThunkEmulation: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Enable: u32 = unsafe { ::core::mem::transmute(Enable) };
      Enable as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let DisableAtlThunkEmulation: u32 =
        unsafe { ::core::mem::transmute(DisableAtlThunkEmulation) };
      DisableAtlThunkEmulation as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>())).Flags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY>(),
    8usize,
    concat!("Size of: ", stringify!(_PROCESS_MITIGATION_DEP_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_PROCESS_MITIGATION_DEP_POLICY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_DEP_POLICY>())).Permanent as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_DEP_POLICY),
      "::",
      stringify!(Permanent)
    )
  );
}
impl Default for _PROCESS_MITIGATION_DEP_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_DEP_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_DEP_POLICY {{ __bindgen_anon_1: {:?}, Permanent: {:?} }}",
      self.__bindgen_anon_1, self.Permanent
    )
  }
}
pub type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY;
pub type PPROCESS_MITIGATION_DEP_POLICY = *mut _PROCESS_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1()
{
  assert_eq!(
    ::core::mem::size_of::<
      _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn RaiseExceptionOnInvalidHandleReference(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn HandleExceptionsPermanentlyEnabled(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    RaiseExceptionOnInvalidHandleReference: DWORD, HandleExceptionsPermanentlyEnabled: DWORD,
    ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let RaiseExceptionOnInvalidHandleReference: u32 =
        unsafe { ::core::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
      RaiseExceptionOnInvalidHandleReference as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let HandleExceptionsPermanentlyEnabled: u32 =
        unsafe { ::core::mem::transmute(HandleExceptionsPermanentlyEnabled) };
      HandleExceptionsPermanentlyEnabled as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
  _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
  *mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1()
{
  assert_eq!(
    ::core::mem::size_of::<
      _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn DisallowWin32kSystemCalls(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DisallowWin32kSystemCalls(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditDisallowWin32kSystemCalls(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    DisallowWin32kSystemCalls: DWORD, AuditDisallowWin32kSystemCalls: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let DisallowWin32kSystemCalls: u32 =
        unsafe { ::core::mem::transmute(DisallowWin32kSystemCalls) };
      DisallowWin32kSystemCalls as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let AuditDisallowWin32kSystemCalls: u32 =
        unsafe { ::core::mem::transmute(AuditDisallowWin32kSystemCalls) };
      AuditDisallowWin32kSystemCalls as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
  _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
  *mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1:
    _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1(
) {
  assert_eq!(
    ::core::mem::size_of::<
      _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn DisableExtensionPoints(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DisableExtensionPoints(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    DisableExtensionPoints: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let DisableExtensionPoints: u32 = unsafe { ::core::mem::transmute(DisableExtensionPoints) };
      DisableExtensionPoints as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
  _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
  *mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn ProhibitDynamicCode(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_ProhibitDynamicCode(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllowThreadOptOut(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AllowThreadOptOut(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllowRemoteDowngrade(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AllowRemoteDowngrade(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditProhibitDynamicCode(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditProhibitDynamicCode(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 28u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    ProhibitDynamicCode: DWORD, AllowThreadOptOut: DWORD, AllowRemoteDowngrade: DWORD,
    AuditProhibitDynamicCode: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let ProhibitDynamicCode: u32 = unsafe { ::core::mem::transmute(ProhibitDynamicCode) };
      ProhibitDynamicCode as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let AllowThreadOptOut: u32 = unsafe { ::core::mem::transmute(AllowThreadOptOut) };
      AllowThreadOptOut as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let AllowRemoteDowngrade: u32 = unsafe { ::core::mem::transmute(AllowRemoteDowngrade) };
      AllowRemoteDowngrade as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let AuditProhibitDynamicCode: u32 =
        unsafe { ::core::mem::transmute(AuditProhibitDynamicCode) };
      AuditProhibitDynamicCode as u64
    });
    __bindgen_bitfield_unit.set(4usize, 28u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = *mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1>(
    ),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn EnableControlFlowGuard(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableControlFlowGuard(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableExportSuppression(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableExportSuppression(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn StrictMode(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_StrictMode(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 29u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    EnableControlFlowGuard: DWORD, EnableExportSuppression: DWORD, StrictMode: DWORD,
    ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let EnableControlFlowGuard: u32 = unsafe { ::core::mem::transmute(EnableControlFlowGuard) };
      EnableControlFlowGuard as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let EnableExportSuppression: u32 = unsafe { ::core::mem::transmute(EnableExportSuppression) };
      EnableExportSuppression as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let StrictMode: u32 = unsafe { ::core::mem::transmute(StrictMode) };
      StrictMode as u64
    });
    __bindgen_bitfield_unit.set(3usize, 29u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
  _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
  *mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1>(
    ),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1>(
    ),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn MicrosoftSignedOnly(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_MicrosoftSignedOnly(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn StoreSignedOnly(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_StoreSignedOnly(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn MitigationOptIn(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_MitigationOptIn(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditMicrosoftSignedOnly(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditMicrosoftSignedOnly(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditStoreSignedOnly(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditStoreSignedOnly(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 27u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    MicrosoftSignedOnly: DWORD, StoreSignedOnly: DWORD, MitigationOptIn: DWORD,
    AuditMicrosoftSignedOnly: DWORD, AuditStoreSignedOnly: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let MicrosoftSignedOnly: u32 = unsafe { ::core::mem::transmute(MicrosoftSignedOnly) };
      MicrosoftSignedOnly as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let StoreSignedOnly: u32 = unsafe { ::core::mem::transmute(StoreSignedOnly) };
      StoreSignedOnly as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let MitigationOptIn: u32 = unsafe { ::core::mem::transmute(MitigationOptIn) };
      MitigationOptIn as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let AuditMicrosoftSignedOnly: u32 =
        unsafe { ::core::mem::transmute(AuditMicrosoftSignedOnly) };
      AuditMicrosoftSignedOnly as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let AuditStoreSignedOnly: u32 = unsafe { ::core::mem::transmute(AuditStoreSignedOnly) };
      AuditStoreSignedOnly as u64
    });
    __bindgen_bitfield_unit.set(5usize, 27u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY =
  *mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn DisableNonSystemFonts(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DisableNonSystemFonts(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditNonSystemFontLoading(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditNonSystemFontLoading(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    DisableNonSystemFonts: DWORD, AuditNonSystemFontLoading: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let DisableNonSystemFonts: u32 = unsafe { ::core::mem::transmute(DisableNonSystemFonts) };
      DisableNonSystemFonts as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let AuditNonSystemFontLoading: u32 =
        unsafe { ::core::mem::transmute(AuditNonSystemFontLoading) };
      AuditNonSystemFontLoading as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_FONT_DISABLE_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = *mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn NoRemoteImages(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_NoRemoteImages(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn NoLowMandatoryLabelImages(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_NoLowMandatoryLabelImages(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn PreferSystem32Images(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_PreferSystem32Images(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditNoRemoteImages(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditNoRemoteImages(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditNoLowMandatoryLabelImages(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditNoLowMandatoryLabelImages(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 27u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    NoRemoteImages: DWORD, NoLowMandatoryLabelImages: DWORD, PreferSystem32Images: DWORD,
    AuditNoRemoteImages: DWORD, AuditNoLowMandatoryLabelImages: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let NoRemoteImages: u32 = unsafe { ::core::mem::transmute(NoRemoteImages) };
      NoRemoteImages as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let NoLowMandatoryLabelImages: u32 =
        unsafe { ::core::mem::transmute(NoLowMandatoryLabelImages) };
      NoLowMandatoryLabelImages as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let PreferSystem32Images: u32 = unsafe { ::core::mem::transmute(PreferSystem32Images) };
      PreferSystem32Images as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let AuditNoRemoteImages: u32 = unsafe { ::core::mem::transmute(AuditNoRemoteImages) };
      AuditNoRemoteImages as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let AuditNoLowMandatoryLabelImages: u32 =
        unsafe { ::core::mem::transmute(AuditNoLowMandatoryLabelImages) };
      AuditNoLowMandatoryLabelImages as u64
    });
    __bindgen_bitfield_unit.set(5usize, 27u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_IMAGE_LOAD_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = *mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1>(
    ),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn FilterId(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
  }
  #[inline]
  pub fn set_FilterId(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 28u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    FilterId: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 4u8, {
      let FilterId: u32 = unsafe { ::core::mem::transmute(FilterId) };
      FilterId as u64
    });
    __bindgen_bitfield_unit.set(4usize, 28u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
  _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
  *mut _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1()
{
  assert_eq!(
    ::core::mem::size_of::<
      _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn EnableExportAddressFilter(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableExportAddressFilter(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditExportAddressFilter(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditExportAddressFilter(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableExportAddressFilterPlus(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableExportAddressFilterPlus(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditExportAddressFilterPlus(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditExportAddressFilterPlus(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableImportAddressFilter(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableImportAddressFilter(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditImportAddressFilter(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditImportAddressFilter(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableRopStackPivot(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableRopStackPivot(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(6usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditRopStackPivot(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditRopStackPivot(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(7usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableRopCallerCheck(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableRopCallerCheck(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditRopCallerCheck(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditRopCallerCheck(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(9usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn EnableRopSimExec(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_EnableRopSimExec(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(10usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditRopSimExec(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditRopSimExec(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(11usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(12usize, 20u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    EnableExportAddressFilter: DWORD, AuditExportAddressFilter: DWORD,
    EnableExportAddressFilterPlus: DWORD, AuditExportAddressFilterPlus: DWORD,
    EnableImportAddressFilter: DWORD, AuditImportAddressFilter: DWORD, EnableRopStackPivot: DWORD,
    AuditRopStackPivot: DWORD, EnableRopCallerCheck: DWORD, AuditRopCallerCheck: DWORD,
    EnableRopSimExec: DWORD, AuditRopSimExec: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let EnableExportAddressFilter: u32 =
        unsafe { ::core::mem::transmute(EnableExportAddressFilter) };
      EnableExportAddressFilter as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let AuditExportAddressFilter: u32 =
        unsafe { ::core::mem::transmute(AuditExportAddressFilter) };
      AuditExportAddressFilter as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let EnableExportAddressFilterPlus: u32 =
        unsafe { ::core::mem::transmute(EnableExportAddressFilterPlus) };
      EnableExportAddressFilterPlus as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let AuditExportAddressFilterPlus: u32 =
        unsafe { ::core::mem::transmute(AuditExportAddressFilterPlus) };
      AuditExportAddressFilterPlus as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let EnableImportAddressFilter: u32 =
        unsafe { ::core::mem::transmute(EnableImportAddressFilter) };
      EnableImportAddressFilter as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let AuditImportAddressFilter: u32 =
        unsafe { ::core::mem::transmute(AuditImportAddressFilter) };
      AuditImportAddressFilter as u64
    });
    __bindgen_bitfield_unit.set(6usize, 1u8, {
      let EnableRopStackPivot: u32 = unsafe { ::core::mem::transmute(EnableRopStackPivot) };
      EnableRopStackPivot as u64
    });
    __bindgen_bitfield_unit.set(7usize, 1u8, {
      let AuditRopStackPivot: u32 = unsafe { ::core::mem::transmute(AuditRopStackPivot) };
      AuditRopStackPivot as u64
    });
    __bindgen_bitfield_unit.set(8usize, 1u8, {
      let EnableRopCallerCheck: u32 = unsafe { ::core::mem::transmute(EnableRopCallerCheck) };
      EnableRopCallerCheck as u64
    });
    __bindgen_bitfield_unit.set(9usize, 1u8, {
      let AuditRopCallerCheck: u32 = unsafe { ::core::mem::transmute(AuditRopCallerCheck) };
      AuditRopCallerCheck as u64
    });
    __bindgen_bitfield_unit.set(10usize, 1u8, {
      let EnableRopSimExec: u32 = unsafe { ::core::mem::transmute(EnableRopSimExec) };
      EnableRopSimExec as u64
    });
    __bindgen_bitfield_unit.set(11usize, 1u8, {
      let AuditRopSimExec: u32 = unsafe { ::core::mem::transmute(AuditRopSimExec) };
      AuditRopSimExec as u64
    });
    __bindgen_bitfield_unit.set(12usize, 20u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
  _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
  *mut _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
  pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
  pub Flags: DWORD,
  pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn NoChildProcessCreation(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_NoChildProcessCreation(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AuditNoChildProcessCreation(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AuditNoChildProcessCreation(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllowSecureProcessCreation(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AllowSecureProcessCreation(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 29u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    NoChildProcessCreation: DWORD, AuditNoChildProcessCreation: DWORD,
    AllowSecureProcessCreation: DWORD, ReservedFlags: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let NoChildProcessCreation: u32 = unsafe { ::core::mem::transmute(NoChildProcessCreation) };
      NoChildProcessCreation as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let AuditNoChildProcessCreation: u32 =
        unsafe { ::core::mem::transmute(AuditNoChildProcessCreation) };
      AuditNoChildProcessCreation as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let AllowSecureProcessCreation: u32 =
        unsafe { ::core::mem::transmute(AllowSecureProcessCreation) };
      AllowSecureProcessCreation as u64
    });
    __bindgen_bitfield_unit.set(3usize, 29u8, {
      let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>())).Flags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)
    )
  );
}
impl Default for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_PROCESS_MITIGATION_CHILD_PROCESS_POLICY {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub type PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = *mut _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
  pub TotalUserTime: LARGE_INTEGER,
  pub TotalKernelTime: LARGE_INTEGER,
  pub ThisPeriodTotalUserTime: LARGE_INTEGER,
  pub ThisPeriodTotalKernelTime: LARGE_INTEGER,
  pub TotalPageFaultCount: DWORD,
  pub TotalProcesses: DWORD,
  pub ActiveProcesses: DWORD,
  pub TotalTerminatedProcesses: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>(),
    48usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalUserTime as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(TotalUserTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalKernelTime
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(TotalKernelTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).ThisPeriodTotalUserTime
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(ThisPeriodTotalUserTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).ThisPeriodTotalKernelTime
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(ThisPeriodTotalKernelTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalPageFaultCount
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(TotalPageFaultCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalProcesses
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(TotalProcesses)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).ActiveProcesses
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(ActiveProcesses)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalTerminatedProcesses
        as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
      "::",
      stringify!(TotalTerminatedProcesses)
    )
  );
}
impl Default for _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {{ TotalUserTime: {:?}, TotalKernelTime: {:?}, ThisPeriodTotalUserTime: {:?}, ThisPeriodTotalKernelTime: {:?}, TotalPageFaultCount: {:?}, TotalProcesses: {:?}, ActiveProcesses: {:?}, TotalTerminatedProcesses: {:?} }}" , self . TotalUserTime , self . TotalKernelTime , self . ThisPeriodTotalUserTime , self . ThisPeriodTotalKernelTime , self . TotalPageFaultCount , self . TotalProcesses , self . ActiveProcesses , self . TotalTerminatedProcesses )
  }
}
pub type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = *mut _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
  pub PerProcessUserTimeLimit: LARGE_INTEGER,
  pub PerJobUserTimeLimit: LARGE_INTEGER,
  pub LimitFlags: DWORD,
  pub MinimumWorkingSetSize: SIZE_T,
  pub MaximumWorkingSetSize: SIZE_T,
  pub ActiveProcessLimit: DWORD,
  pub Affinity: ULONG_PTR,
  pub PriorityClass: DWORD,
  pub SchedulingClass: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_LIMIT_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>(),
    64usize,
    concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).PerProcessUserTimeLimit
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(PerProcessUserTimeLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).PerJobUserTimeLimit
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(PerJobUserTimeLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).LimitFlags as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(LimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).MinimumWorkingSetSize
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(MinimumWorkingSetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).MaximumWorkingSetSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(MaximumWorkingSetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).ActiveProcessLimit as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(ActiveProcessLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).Affinity as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(Affinity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).PriorityClass as *const _
        as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(PriorityClass)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).SchedulingClass as *const _
        as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
      "::",
      stringify!(SchedulingClass)
    )
  );
}
impl Default for _JOBOBJECT_BASIC_LIMIT_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_BASIC_LIMIT_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_JOBOBJECT_BASIC_LIMIT_INFORMATION {{ PerProcessUserTimeLimit: {:?}, PerJobUserTimeLimit: {:?}, LimitFlags: {:?}, MinimumWorkingSetSize: {:?}, MaximumWorkingSetSize: {:?}, ActiveProcessLimit: {:?}, Affinity: {:?}, PriorityClass: {:?}, SchedulingClass: {:?} }}" , self . PerProcessUserTimeLimit , self . PerJobUserTimeLimit , self . LimitFlags , self . MinimumWorkingSetSize , self . MaximumWorkingSetSize , self . ActiveProcessLimit , self . Affinity , self . PriorityClass , self . SchedulingClass )
  }
}
pub type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub type PJOBOBJECT_BASIC_LIMIT_INFORMATION = *mut _JOBOBJECT_BASIC_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
  pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
  pub IoInfo: IO_COUNTERS,
  pub ProcessMemoryLimit: SIZE_T,
  pub JobMemoryLimit: SIZE_T,
  pub PeakProcessMemoryUsed: SIZE_T,
  pub PeakJobMemoryUsed: SIZE_T,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_EXTENDED_LIMIT_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>(),
    144usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).BasicLimitInformation
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
      "::",
      stringify!(BasicLimitInformation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).IoInfo as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
      "::",
      stringify!(IoInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).ProcessMemoryLimit
        as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
      "::",
      stringify!(ProcessMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).JobMemoryLimit as *const _
        as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
      "::",
      stringify!(JobMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).PeakProcessMemoryUsed
        as *const _ as usize
    },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
      "::",
      stringify!(PeakProcessMemoryUsed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).PeakJobMemoryUsed
        as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
      "::",
      stringify!(PeakJobMemoryUsed)
    )
  );
}
impl Default for _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_JOBOBJECT_EXTENDED_LIMIT_INFORMATION {{ BasicLimitInformation: {:?}, IoInfo: {:?}, ProcessMemoryLimit: {:?}, JobMemoryLimit: {:?}, PeakProcessMemoryUsed: {:?}, PeakJobMemoryUsed: {:?} }}" , self . BasicLimitInformation , self . IoInfo , self . ProcessMemoryLimit , self . JobMemoryLimit , self . PeakProcessMemoryUsed , self . PeakJobMemoryUsed )
  }
}
pub type JOBOBJECT_EXTENDED_LIMIT_INFORMATION = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = *mut _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
  pub NumberOfAssignedProcesses: DWORD,
  pub NumberOfProcessIdsInList: DWORD,
  pub ProcessIdList: [ULONG_PTR; 1usize],
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_PROCESS_ID_LIST() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>(),
    16usize,
    concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST))
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>())).NumberOfAssignedProcesses
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
      "::",
      stringify!(NumberOfAssignedProcesses)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>())).NumberOfProcessIdsInList
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
      "::",
      stringify!(NumberOfProcessIdsInList)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>())).ProcessIdList as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
      "::",
      stringify!(ProcessIdList)
    )
  );
}
pub type JOBOBJECT_BASIC_PROCESS_ID_LIST = _JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub type PJOBOBJECT_BASIC_PROCESS_ID_LIST = *mut _JOBOBJECT_BASIC_PROCESS_ID_LIST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
  pub UIRestrictionsClass: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_UI_RESTRICTIONS() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>(),
    4usize,
    concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS))
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>())).UIRestrictionsClass as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS),
      "::",
      stringify!(UIRestrictionsClass)
    )
  );
}
pub type JOBOBJECT_BASIC_UI_RESTRICTIONS = _JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub type PJOBOBJECT_BASIC_UI_RESTRICTIONS = *mut _JOBOBJECT_BASIC_UI_RESTRICTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
  pub SecurityLimitFlags: DWORD,
  pub JobToken: HANDLE,
  pub SidsToDisable: PTOKEN_GROUPS,
  pub PrivilegesToDelete: PTOKEN_PRIVILEGES,
  pub RestrictedSids: PTOKEN_GROUPS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_SECURITY_LIMIT_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).SecurityLimitFlags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
      "::",
      stringify!(SecurityLimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).JobToken as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
      "::",
      stringify!(JobToken)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).SidsToDisable as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
      "::",
      stringify!(SidsToDisable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).PrivilegesToDelete
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
      "::",
      stringify!(PrivilegesToDelete)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).RestrictedSids as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
      "::",
      stringify!(RestrictedSids)
    )
  );
}
impl Default for _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type JOBOBJECT_SECURITY_LIMIT_INFORMATION = _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub type PJOBOBJECT_SECURITY_LIMIT_INFORMATION = *mut _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
  pub EndOfJobTimeAction: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_END_OF_JOB_TIME_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>())).EndOfJobTimeAction
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION),
      "::",
      stringify!(EndOfJobTimeAction)
    )
  );
}
pub type JOBOBJECT_END_OF_JOB_TIME_INFORMATION = _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub type PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = *mut _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
  pub CompletionKey: PVOID,
  pub CompletionPort: HANDLE,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_ASSOCIATE_COMPLETION_PORT() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>())).CompletionKey as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT),
      "::",
      stringify!(CompletionKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>())).CompletionPort as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT),
      "::",
      stringify!(CompletionPort)
    )
  );
}
impl Default for _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type JOBOBJECT_ASSOCIATE_COMPLETION_PORT = _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub type PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = *mut _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
  pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
  pub IoInfo: IO_COUNTERS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>(),
    96usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>())).BasicInfo
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
      "::",
      stringify!(BasicInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>())).IoInfo as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
      "::",
      stringify!(IoInfo)
    )
  );
}
impl Default for _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {{ BasicInfo: {:?}, IoInfo: {:?} }}",
      self.BasicInfo, self.IoInfo
    )
  }
}
pub type JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
  _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
  *mut _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_JOBSET_INFORMATION {
  pub MemberLevel: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_JOBSET_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_JOBSET_INFORMATION>(),
    4usize,
    concat!("Size of: ", stringify!(_JOBOBJECT_JOBSET_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_JOBSET_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_JOBOBJECT_JOBSET_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_JOBSET_INFORMATION>())).MemberLevel as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_JOBSET_INFORMATION),
      "::",
      stringify!(MemberLevel)
    )
  );
}
pub type JOBOBJECT_JOBSET_INFORMATION = _JOBOBJECT_JOBSET_INFORMATION;
pub type PJOBOBJECT_JOBSET_INFORMATION = *mut _JOBOBJECT_JOBSET_INFORMATION;
pub mod _JOBOBJECT_RATE_CONTROL_TOLERANCE {
  pub type Type = i32;
  pub const ToleranceLow: Type = 1;
  pub const ToleranceMedium: Type = 2;
  pub const ToleranceHigh: Type = 3;
}
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE::Type as JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub type PJOBOBJECT_RATE_CONTROL_TOLERANCE = *mut _JOBOBJECT_RATE_CONTROL_TOLERANCE::Type;
pub mod _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
  pub type Type = i32;
  pub const ToleranceIntervalShort: Type = 1;
  pub const ToleranceIntervalMedium: Type = 2;
  pub const ToleranceIntervalLong: Type = 3;
}
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL::Type as JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
pub type PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL =
  *mut _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL::Type;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
  pub IoReadBytesLimit: DWORD64,
  pub IoWriteBytesLimit: DWORD64,
  pub PerJobUserTimeLimit: LARGE_INTEGER,
  pub JobMemoryLimit: DWORD64,
  pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  pub LimitFlags: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>(),
    48usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).IoReadBytesLimit
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(IoReadBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).IoWriteBytesLimit
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(IoWriteBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).PerJobUserTimeLimit
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(PerJobUserTimeLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).JobMemoryLimit
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(JobMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).RateControlTolerance
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(RateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>()))
        .RateControlToleranceInterval as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(RateControlToleranceInterval)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).LimitFlags as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
      "::",
      stringify!(LimitFlags)
    )
  );
}
impl Default for _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {{ IoReadBytesLimit: {:?}, IoWriteBytesLimit: {:?}, PerJobUserTimeLimit: {:?}, JobMemoryLimit: {:?}, RateControlTolerance: {:?}, RateControlToleranceInterval: {:?}, LimitFlags: {:?} }}" , self . IoReadBytesLimit , self . IoWriteBytesLimit , self . PerJobUserTimeLimit , self . JobMemoryLimit , self . RateControlTolerance , self . RateControlToleranceInterval , self . LimitFlags )
  }
}
pub type JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub type PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = *mut _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
  pub IoReadBytesLimit: DWORD64,
  pub IoWriteBytesLimit: DWORD64,
  pub PerJobUserTimeLimit: LARGE_INTEGER,
  pub __bindgen_anon_1: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1,
  pub __bindgen_anon_2: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2,
  pub __bindgen_anon_3: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3,
  pub LimitFlags: DWORD,
  pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub JobLowMemoryLimit: DWORD64,
  pub IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {
  pub JobHighMemoryLimit: DWORD64,
  pub JobMemoryLimit: DWORD64,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>()))
        .JobHighMemoryLimit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1),
      "::",
      stringify!(JobHighMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>()))
        .JobMemoryLimit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1),
      "::",
      stringify!(JobMemoryLimit)
    )
  );
}
impl Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {{ union }}"
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {
  pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>()))
        .RateControlTolerance as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2),
      "::",
      stringify!(RateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>()))
        .CpuRateControlTolerance as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2),
      "::",
      stringify!(CpuRateControlTolerance)
    )
  );
}
impl Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {{ union }}"
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {
  pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  pub CpuRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>()))
        .RateControlToleranceInterval as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3),
      "::",
      stringify!(RateControlToleranceInterval)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>()))
        .CpuRateControlToleranceInterval as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3),
      "::",
      stringify!(CpuRateControlToleranceInterval)
    )
  );
}
impl Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).IoReadBytesLimit
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(IoReadBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).IoWriteBytesLimit
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(IoWriteBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).PerJobUserTimeLimit
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(PerJobUserTimeLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).LimitFlags as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(LimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).IoRateControlTolerance
        as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(IoRateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).JobLowMemoryLimit
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(JobLowMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
        .IoRateControlToleranceInterval as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(IoRateControlToleranceInterval)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
        .NetRateControlTolerance as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(NetRateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
        .NetRateControlToleranceInterval as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
      "::",
      stringify!(NetRateControlToleranceInterval)
    )
  );
}
impl Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {{ IoReadBytesLimit: {:?}, IoWriteBytesLimit: {:?}, PerJobUserTimeLimit: {:?}, __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?}, __bindgen_anon_3: {:?}, LimitFlags: {:?}, IoRateControlTolerance: {:?}, JobLowMemoryLimit: {:?}, IoRateControlToleranceInterval: {:?}, NetRateControlTolerance: {:?}, NetRateControlToleranceInterval: {:?} }}" , self . IoReadBytesLimit , self . IoWriteBytesLimit , self . PerJobUserTimeLimit , self . __bindgen_anon_1 , self . __bindgen_anon_2 , self . __bindgen_anon_3 , self . LimitFlags , self . IoRateControlTolerance , self . JobLowMemoryLimit , self . IoRateControlToleranceInterval , self . NetRateControlTolerance , self . NetRateControlToleranceInterval )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
  pub LimitFlags: DWORD,
  pub ViolationLimitFlags: DWORD,
  pub IoReadBytes: DWORD64,
  pub IoReadBytesLimit: DWORD64,
  pub IoWriteBytes: DWORD64,
  pub IoWriteBytesLimit: DWORD64,
  pub PerJobUserTime: LARGE_INTEGER,
  pub PerJobUserTimeLimit: LARGE_INTEGER,
  pub JobMemory: DWORD64,
  pub JobMemoryLimit: DWORD64,
  pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_LIMIT_VIOLATION_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>(),
    80usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).LimitFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(LimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).ViolationLimitFlags
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(ViolationLimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoReadBytes as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(IoReadBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoReadBytesLimit
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(IoReadBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoWriteBytes as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(IoWriteBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoWriteBytesLimit
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(IoWriteBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).PerJobUserTime as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(PerJobUserTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).PerJobUserTimeLimit
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(PerJobUserTimeLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).JobMemory as *const _
        as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(JobMemory)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).JobMemoryLimit as *const _
        as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(JobMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).RateControlTolerance
        as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(RateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).RateControlToleranceLimit
        as *const _ as usize
    },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
      "::",
      stringify!(RateControlToleranceLimit)
    )
  );
}
impl Default for _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_JOBOBJECT_LIMIT_VIOLATION_INFORMATION {{ LimitFlags: {:?}, ViolationLimitFlags: {:?}, IoReadBytes: {:?}, IoReadBytesLimit: {:?}, IoWriteBytes: {:?}, IoWriteBytesLimit: {:?}, PerJobUserTime: {:?}, PerJobUserTimeLimit: {:?}, JobMemory: {:?}, JobMemoryLimit: {:?}, RateControlTolerance: {:?}, RateControlToleranceLimit: {:?} }}" , self . LimitFlags , self . ViolationLimitFlags , self . IoReadBytes , self . IoReadBytesLimit , self . IoWriteBytes , self . IoWriteBytesLimit , self . PerJobUserTime , self . PerJobUserTimeLimit , self . JobMemory , self . JobMemoryLimit , self . RateControlTolerance , self . RateControlToleranceLimit )
  }
}
pub type JOBOBJECT_LIMIT_VIOLATION_INFORMATION = _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub type PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = *mut _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
  pub LimitFlags: DWORD,
  pub ViolationLimitFlags: DWORD,
  pub IoReadBytes: DWORD64,
  pub IoReadBytesLimit: DWORD64,
  pub IoWriteBytes: DWORD64,
  pub IoWriteBytesLimit: DWORD64,
  pub PerJobUserTime: LARGE_INTEGER,
  pub PerJobUserTimeLimit: LARGE_INTEGER,
  pub JobMemory: DWORD64,
  pub __bindgen_anon_1: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1,
  pub __bindgen_anon_2: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2,
  pub __bindgen_anon_3: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3,
  pub JobLowMemoryLimit: DWORD64,
  pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {
  pub JobHighMemoryLimit: DWORD64,
  pub JobMemoryLimit: DWORD64,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>()))
        .JobHighMemoryLimit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1),
      "::",
      stringify!(JobHighMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>()))
        .JobMemoryLimit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1),
      "::",
      stringify!(JobMemoryLimit)
    )
  );
}
impl Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {{ union }}"
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {
  pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>()))
        .RateControlTolerance as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2),
      "::",
      stringify!(RateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>()))
        .CpuRateControlTolerance as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2),
      "::",
      stringify!(CpuRateControlTolerance)
    )
  );
}
impl Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {{ union }}"
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {
  pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  pub CpuRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>()))
        .RateControlToleranceLimit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3),
      "::",
      stringify!(RateControlToleranceLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>()))
        .CpuRateControlToleranceLimit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3),
      "::",
      stringify!(CpuRateControlToleranceLimit)
    )
  );
}
impl Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>(),
    104usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).LimitFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(LimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).ViolationLimitFlags
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(ViolationLimitFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoReadBytes as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(IoReadBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoReadBytesLimit
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(IoReadBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoWriteBytes as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(IoWriteBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoWriteBytesLimit
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(IoWriteBytesLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).PerJobUserTime
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(PerJobUserTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).PerJobUserTimeLimit
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(PerJobUserTimeLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).JobMemory as *const _
        as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(JobMemory)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).JobLowMemoryLimit
        as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(JobLowMemoryLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoRateControlTolerance
        as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(IoRateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>()))
        .IoRateControlToleranceLimit as *const _ as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(IoRateControlToleranceLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).NetRateControlTolerance
        as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(NetRateControlTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>()))
        .NetRateControlToleranceLimit as *const _ as usize
    },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
      "::",
      stringify!(NetRateControlToleranceLimit)
    )
  );
}
impl Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {{ LimitFlags: {:?}, ViolationLimitFlags: {:?}, IoReadBytes: {:?}, IoReadBytesLimit: {:?}, IoWriteBytes: {:?}, IoWriteBytesLimit: {:?}, PerJobUserTime: {:?}, PerJobUserTimeLimit: {:?}, JobMemory: {:?}, __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?}, __bindgen_anon_3: {:?}, JobLowMemoryLimit: {:?}, IoRateControlTolerance: {:?}, IoRateControlToleranceLimit: {:?}, NetRateControlTolerance: {:?}, NetRateControlToleranceLimit: {:?} }}" , self . LimitFlags , self . ViolationLimitFlags , self . IoReadBytes , self . IoReadBytesLimit , self . IoWriteBytes , self . IoWriteBytesLimit , self . PerJobUserTime , self . PerJobUserTimeLimit , self . JobMemory , self . __bindgen_anon_1 , self . __bindgen_anon_2 , self . __bindgen_anon_3 , self . JobLowMemoryLimit , self . IoRateControlTolerance , self . IoRateControlToleranceLimit , self . NetRateControlTolerance , self . NetRateControlToleranceLimit )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
  pub ControlFlags: DWORD,
  pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {
  pub CpuRate: DWORD,
  pub Weight: DWORD,
  pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub MinRate: WORD,
  pub MaxRate: WORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1>(
      )))
      .MinRate as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(MinRate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1>(
      )))
      .MaxRate as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(MaxRate)
    )
  );
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>())).CpuRate
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(CpuRate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>())).Weight
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Weight)
    )
  );
}
impl Default for _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>())).ControlFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(ControlFlags)
    )
  );
}
impl Default for _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {{ ControlFlags: {:?}, __bindgen_anon_1: {:?} }}",
      self.ControlFlags, self.__bindgen_anon_1
    )
  }
}
pub type JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub type PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = *mut _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub mod JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
  pub type Type = i32;
  pub const JOB_OBJECT_NET_RATE_CONTROL_ENABLE: Type = 1;
  pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH: Type = 2;
  pub const JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG: Type = 4;
  pub const JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS: Type = 7;
}
pub type __C_ASSERT__ = [libc::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
  pub MaxBandwidth: DWORD64,
  pub ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS::Type,
  pub DscpTag: BYTE,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NET_RATE_CONTROL_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>())).MaxBandwidth as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(MaxBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>())).ControlFlags as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(ControlFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>())).DscpTag as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(DscpTag)
    )
  );
}
impl Default for JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub mod JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
  pub type Type = i32;
  pub const JOB_OBJECT_IO_RATE_CONTROL_ENABLE: Type = 1;
  pub const JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME: Type = 2;
  pub const JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
  pub MaxIops: LONG64,
  pub MaxBandwidth: LONG64,
  pub ReservationIops: LONG64,
  pub VolumeName: PWSTR,
  pub BaseIoSize: DWORD,
  pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS::Type,
  pub VolumeNameLength: WORD,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>(),
    48usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).MaxIops as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(MaxIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).MaxBandwidth
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(MaxBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).ReservationIops
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(ReservationIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).VolumeName
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(VolumeName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).BaseIoSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(BaseIoSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).ControlFlags
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(ControlFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).VolumeNameLength
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
      "::",
      stringify!(VolumeNameLength)
    )
  );
}
impl Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1 =
  JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
  pub MaxIops: LONG64,
  pub MaxBandwidth: LONG64,
  pub ReservationIops: LONG64,
  pub VolumeName: PWSTR,
  pub BaseIoSize: DWORD,
  pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS::Type,
  pub VolumeNameLength: WORD,
  pub CriticalReservationIops: LONG64,
  pub ReservationBandwidth: LONG64,
  pub CriticalReservationBandwidth: LONG64,
  pub MaxTimePercent: LONG64,
  pub ReservationTimePercent: LONG64,
  pub CriticalReservationTimePercent: LONG64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>(),
    96usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).MaxIops
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(MaxIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).MaxBandwidth
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(MaxBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).ReservationIops
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(ReservationIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).VolumeName
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(VolumeName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).BaseIoSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(BaseIoSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).ControlFlags
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(ControlFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).VolumeNameLength
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(VolumeNameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
        .CriticalReservationIops as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(CriticalReservationIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
        .ReservationBandwidth as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(ReservationBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
        .CriticalReservationBandwidth as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(CriticalReservationBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).MaxTimePercent
        as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(MaxTimePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
        .ReservationTimePercent as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(ReservationTimePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
        .CriticalReservationTimePercent as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
      "::",
      stringify!(CriticalReservationTimePercent)
    )
  );
}
impl Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
  pub MaxIops: LONG64,
  pub MaxBandwidth: LONG64,
  pub ReservationIops: LONG64,
  pub VolumeName: PWSTR,
  pub BaseIoSize: DWORD,
  pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS::Type,
  pub VolumeNameLength: WORD,
  pub CriticalReservationIops: LONG64,
  pub ReservationBandwidth: LONG64,
  pub CriticalReservationBandwidth: LONG64,
  pub MaxTimePercent: LONG64,
  pub ReservationTimePercent: LONG64,
  pub CriticalReservationTimePercent: LONG64,
  pub SoftMaxIops: LONG64,
  pub SoftMaxBandwidth: LONG64,
  pub SoftMaxTimePercent: LONG64,
  pub LimitExcessNotifyIops: LONG64,
  pub LimitExcessNotifyBandwidth: LONG64,
  pub LimitExcessNotifyTimePercent: LONG64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>(),
    144usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).MaxIops
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(MaxIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).MaxBandwidth
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(MaxBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).ReservationIops
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(ReservationIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).VolumeName
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(VolumeName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).BaseIoSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(BaseIoSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).ControlFlags
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(ControlFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).VolumeNameLength
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(VolumeNameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .CriticalReservationIops as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(CriticalReservationIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .ReservationBandwidth as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(ReservationBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .CriticalReservationBandwidth as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(CriticalReservationBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).MaxTimePercent
        as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(MaxTimePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .ReservationTimePercent as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(ReservationTimePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .CriticalReservationTimePercent as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(CriticalReservationTimePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).SoftMaxIops
        as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(SoftMaxIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).SoftMaxBandwidth
        as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(SoftMaxBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .SoftMaxTimePercent as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(SoftMaxTimePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .LimitExcessNotifyIops as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(LimitExcessNotifyIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .LimitExcessNotifyBandwidth as *const _ as usize
    },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(LimitExcessNotifyBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
        .LimitExcessNotifyTimePercent as *const _ as usize
    },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
      "::",
      stringify!(LimitExcessNotifyTimePercent)
    )
  );
}
impl Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub mod JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
  pub type Type = i32;
  pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE: Type = 1;
  pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE: Type = 2;
  pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_STATS {
  pub IoCount: ULONG_PTR,
  pub TotalNonOverlappedQueueTime: ULONGLONG,
  pub TotalNonOverlappedServiceTime: ULONGLONG,
  pub TotalSize: ULONGLONG,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_IO_ATTRIBUTION_STATS() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_IO_ATTRIBUTION_STATS>(),
    32usize,
    concat!("Size of: ", stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS))
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_IO_ATTRIBUTION_STATS>(),
    8usize,
    concat!("Alignment of ", stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).IoCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
      "::",
      stringify!(IoCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).TotalNonOverlappedQueueTime
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
      "::",
      stringify!(TotalNonOverlappedQueueTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).TotalNonOverlappedServiceTime
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
      "::",
      stringify!(TotalNonOverlappedServiceTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).TotalSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
      "::",
      stringify!(TotalSize)
    )
  );
}
pub type JOBOBJECT_IO_ATTRIBUTION_STATS = _JOBOBJECT_IO_ATTRIBUTION_STATS;
pub type PJOBOBJECT_IO_ATTRIBUTION_STATS = *mut _JOBOBJECT_IO_ATTRIBUTION_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
  pub ControlFlags: DWORD,
  pub ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
  pub WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_IO_ATTRIBUTION_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>())).ControlFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
      "::",
      stringify!(ControlFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>())).ReadStats as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
      "::",
      stringify!(ReadStats)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>())).WriteStats as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
      "::",
      stringify!(WriteStats)
    )
  );
}
pub type JOBOBJECT_IO_ATTRIBUTION_INFORMATION = _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub type PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = *mut _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub mod _JOBOBJECTINFOCLASS {
  pub type Type = i32;
  pub const JobObjectBasicAccountingInformation: Type = 1;
  pub const JobObjectBasicLimitInformation: Type = 2;
  pub const JobObjectBasicProcessIdList: Type = 3;
  pub const JobObjectBasicUIRestrictions: Type = 4;
  pub const JobObjectSecurityLimitInformation: Type = 5;
  pub const JobObjectEndOfJobTimeInformation: Type = 6;
  pub const JobObjectAssociateCompletionPortInformation: Type = 7;
  pub const JobObjectBasicAndIoAccountingInformation: Type = 8;
  pub const JobObjectExtendedLimitInformation: Type = 9;
  pub const JobObjectJobSetInformation: Type = 10;
  pub const JobObjectGroupInformation: Type = 11;
  pub const JobObjectNotificationLimitInformation: Type = 12;
  pub const JobObjectLimitViolationInformation: Type = 13;
  pub const JobObjectGroupInformationEx: Type = 14;
  pub const JobObjectCpuRateControlInformation: Type = 15;
  pub const JobObjectCompletionFilter: Type = 16;
  pub const JobObjectCompletionCounter: Type = 17;
  pub const JobObjectReserved1Information: Type = 18;
  pub const JobObjectReserved2Information: Type = 19;
  pub const JobObjectReserved3Information: Type = 20;
  pub const JobObjectReserved4Information: Type = 21;
  pub const JobObjectReserved5Information: Type = 22;
  pub const JobObjectReserved6Information: Type = 23;
  pub const JobObjectReserved7Information: Type = 24;
  pub const JobObjectReserved8Information: Type = 25;
  pub const JobObjectReserved9Information: Type = 26;
  pub const JobObjectReserved10Information: Type = 27;
  pub const JobObjectReserved11Information: Type = 28;
  pub const JobObjectReserved12Information: Type = 29;
  pub const JobObjectReserved13Information: Type = 30;
  pub const JobObjectReserved14Information: Type = 31;
  pub const JobObjectNetRateControlInformation: Type = 32;
  pub const JobObjectNotificationLimitInformation2: Type = 33;
  pub const JobObjectLimitViolationInformation2: Type = 34;
  pub const JobObjectCreateSilo: Type = 35;
  pub const JobObjectSiloBasicInformation: Type = 36;
  pub const JobObjectReserved15Information: Type = 37;
  pub const JobObjectReserved16Information: Type = 38;
  pub const JobObjectReserved17Information: Type = 39;
  pub const JobObjectReserved18Information: Type = 40;
  pub const JobObjectReserved19Information: Type = 41;
  pub const JobObjectReserved20Information: Type = 42;
  pub const JobObjectReserved21Information: Type = 43;
  pub const JobObjectReserved22Information: Type = 44;
  pub const JobObjectReserved23Information: Type = 45;
  pub const JobObjectReserved24Information: Type = 46;
  pub const JobObjectReserved25Information: Type = 47;
  pub const MaxJobObjectInfoClass: Type = 48;
}
pub use self::_JOBOBJECTINFOCLASS::Type as JOBOBJECTINFOCLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SILOOBJECT_BASIC_INFORMATION {
  pub SiloId: DWORD,
  pub SiloParentId: DWORD,
  pub NumberOfProcesses: DWORD,
  pub IsInServerSilo: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__SILOOBJECT_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_SILOOBJECT_BASIC_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_SILOOBJECT_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(SiloId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloParentId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(SiloParentId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).NumberOfProcesses as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(NumberOfProcesses)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).IsInServerSilo as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(IsInServerSilo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION;
pub type PSILOOBJECT_BASIC_INFORMATION = *mut _SILOOBJECT_BASIC_INFORMATION;
pub mod _SERVERSILO_STATE {
  pub type Type = i32;
  pub const SERVERSILO_INITING: Type = 0;
  pub const SERVERSILO_STARTED: Type = 1;
  pub const SERVERSILO_SHUTTING_DOWN: Type = 2;
  pub const SERVERSILO_TERMINATING: Type = 3;
  pub const SERVERSILO_TERMINATED: Type = 4;
}
pub use self::_SERVERSILO_STATE::Type as SERVERSILO_STATE;
pub type PSERVERSILO_STATE = *mut _SERVERSILO_STATE::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVERSILO_BASIC_INFORMATION {
  pub ServiceSessionId: DWORD,
  pub State: SERVERSILO_STATE,
  pub ExitStatus: DWORD,
}
#[test]
fn bindgen_test_layout__SERVERSILO_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_SERVERSILO_BASIC_INFORMATION>(),
    12usize,
    concat!("Size of: ", stringify!(_SERVERSILO_BASIC_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVERSILO_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVERSILO_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ServiceSessionId as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(ServiceSessionId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).State as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ExitStatus as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(ExitStatus)
    )
  );
}
impl Default for _SERVERSILO_BASIC_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION;
pub type PSERVERSILO_BASIC_INFORMATION = *mut _SERVERSILO_BASIC_INFORMATION;
pub mod _FIRMWARE_TYPE {
  pub type Type = i32;
  pub const FirmwareTypeUnknown: Type = 0;
  pub const FirmwareTypeBios: Type = 1;
  pub const FirmwareTypeUefi: Type = 2;
  pub const FirmwareTypeMax: Type = 3;
}
pub use self::_FIRMWARE_TYPE::Type as FIRMWARE_TYPE;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE::Type;
pub mod _LOGICAL_PROCESSOR_RELATIONSHIP {
  pub type Type = i32;
  pub const RelationProcessorCore: Type = 0;
  pub const RelationNumaNode: Type = 1;
  pub const RelationCache: Type = 2;
  pub const RelationProcessorPackage: Type = 3;
  pub const RelationGroup: Type = 4;
  pub const RelationAll: Type = 65535;
}
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP::Type as LOGICAL_PROCESSOR_RELATIONSHIP;
pub mod _PROCESSOR_CACHE_TYPE {
  pub type Type = i32;
  pub const CacheUnified: Type = 0;
  pub const CacheInstruction: Type = 1;
  pub const CacheData: Type = 2;
  pub const CacheTrace: Type = 3;
}
pub use self::_PROCESSOR_CACHE_TYPE::Type as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CACHE_DESCRIPTOR {
  pub Level: BYTE,
  pub Associativity: BYTE,
  pub LineSize: WORD,
  pub Size: DWORD,
  pub Type: PROCESSOR_CACHE_TYPE,
}
#[test]
fn bindgen_test_layout__CACHE_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<_CACHE_DESCRIPTOR>(),
    12usize,
    concat!("Size of: ", stringify!(_CACHE_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_CACHE_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_CACHE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_DESCRIPTOR>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_DESCRIPTOR>())).Associativity as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Associativity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_DESCRIPTOR>())).LineSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(LineSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_DESCRIPTOR>())).Type as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Type)
    )
  );
}
impl Default for _CACHE_DESCRIPTOR {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
  pub ProcessorMask: ULONG_PTR,
  pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
  pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
  pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
  pub Cache: CACHE_DESCRIPTOR,
  pub Reserved: [ULONGLONG; 2usize],
  _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub Flags: BYTE,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
  pub NodeNumber: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>()))
        .NodeNumber as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(NodeNumber)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).ProcessorCore
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(ProcessorCore)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).NumaNode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(NumaNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Cache
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Cache)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Reserved
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
impl Default for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).ProcessorMask as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
      "::",
      stringify!(ProcessorMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).Relationship as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
      "::",
      stringify!(Relationship)
    )
  );
}
impl Default for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_SYSTEM_LOGICAL_PROCESSOR_INFORMATION {{ ProcessorMask: {:?}, Relationship: {:?}, __bindgen_anon_1: {:?} }}" , self . ProcessorMask , self . Relationship , self . __bindgen_anon_1 )
  }
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESSOR_RELATIONSHIP {
  pub Flags: BYTE,
  pub EfficiencyClass: BYTE,
  pub Reserved: [BYTE; 20usize],
  pub GroupCount: WORD,
  pub GroupMask: [GROUP_AFFINITY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_RELATIONSHIP() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESSOR_RELATIONSHIP>(),
    40usize,
    concat!("Size of: ", stringify!(_PROCESSOR_RELATIONSHIP))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESSOR_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_RELATIONSHIP>())).EfficiencyClass as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(EfficiencyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupCount as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(GroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _NUMA_NODE_RELATIONSHIP {
  pub NodeNumber: DWORD,
  pub Reserved: [BYTE; 20usize],
  pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__NUMA_NODE_RELATIONSHIP() {
  assert_eq!(
    ::core::mem::size_of::<_NUMA_NODE_RELATIONSHIP>(),
    40usize,
    concat!("Size of: ", stringify!(_NUMA_NODE_RELATIONSHIP))
  );
  assert_eq!(
    ::core::mem::align_of::<_NUMA_NODE_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_NUMA_NODE_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).NodeNumber as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(NodeNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).GroupMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CACHE_RELATIONSHIP {
  pub Level: BYTE,
  pub Associativity: BYTE,
  pub LineSize: WORD,
  pub CacheSize: DWORD,
  pub Type: PROCESSOR_CACHE_TYPE,
  pub Reserved: [BYTE; 20usize],
  pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__CACHE_RELATIONSHIP() {
  assert_eq!(
    ::core::mem::size_of::<_CACHE_RELATIONSHIP>(),
    48usize,
    concat!("Size of: ", stringify!(_CACHE_RELATIONSHIP))
  );
  assert_eq!(
    ::core::mem::align_of::<_CACHE_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_CACHE_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).Associativity as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Associativity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).LineSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(LineSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).CacheSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(CacheSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).Type as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).Reserved as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CACHE_RELATIONSHIP>())).GroupMask as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
impl Default for _CACHE_RELATIONSHIP {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
  pub MaximumProcessorCount: BYTE,
  pub ActiveProcessorCount: BYTE,
  pub Reserved: [BYTE; 38usize],
  pub ActiveProcessorMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__PROCESSOR_GROUP_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESSOR_GROUP_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_PROCESSOR_GROUP_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESSOR_GROUP_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_GROUP_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_GROUP_INFO>())).MaximumProcessorCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(MaximumProcessorCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorCount as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(ActiveProcessorCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_GROUP_INFO>())).Reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorMask as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(ActiveProcessorMask)
    )
  );
}
impl Default for _PROCESSOR_GROUP_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESSOR_GROUP_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_PROCESSOR_GROUP_INFO {{ MaximumProcessorCount: {:?}, ActiveProcessorCount: {:?}, Reserved: [...], ActiveProcessorMask: {:?} }}" , self . MaximumProcessorCount , self . ActiveProcessorCount , self . ActiveProcessorMask )
  }
}
impl ::core::cmp::PartialEq for _PROCESSOR_GROUP_INFO {
  fn eq(&self, other: &_PROCESSOR_GROUP_INFO) -> bool {
    self.MaximumProcessorCount == other.MaximumProcessorCount
      && self.ActiveProcessorCount == other.ActiveProcessorCount
      && &self.Reserved[..] == &other.Reserved[..]
      && self.ActiveProcessorMask == other.ActiveProcessorMask
  }
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
  pub MaximumGroupCount: WORD,
  pub ActiveGroupCount: WORD,
  pub Reserved: [BYTE; 20usize],
  pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__GROUP_RELATIONSHIP() {
  assert_eq!(
    ::core::mem::size_of::<_GROUP_RELATIONSHIP>(),
    72usize,
    concat!("Size of: ", stringify!(_GROUP_RELATIONSHIP))
  );
  assert_eq!(
    ::core::mem::align_of::<_GROUP_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_GROUP_RELATIONSHIP))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_GROUP_RELATIONSHIP>())).MaximumGroupCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(MaximumGroupCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_GROUP_RELATIONSHIP>())).ActiveGroupCount as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(ActiveGroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GROUP_RELATIONSHIP>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GROUP_RELATIONSHIP>())).GroupInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(GroupInfo)
    )
  );
}
impl Default for _GROUP_RELATIONSHIP {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _GROUP_RELATIONSHIP {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_GROUP_RELATIONSHIP {{ MaximumGroupCount: {:?}, ActiveGroupCount: {:?}, Reserved: {:?}, GroupInfo: {:?} }}" , self . MaximumGroupCount , self . ActiveGroupCount , self . Reserved , self . GroupInfo )
  }
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
  pub Size: DWORD,
  pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
  pub Processor: PROCESSOR_RELATIONSHIP,
  pub NumaNode: NUMA_NODE_RELATIONSHIP,
  pub Cache: CACHE_RELATIONSHIP,
  pub Group: GROUP_RELATIONSHIP,
  _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Processor
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Processor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).NumaNode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(NumaNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Cache
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Cache)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Group
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Group)
    )
  );
}
impl Default for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
    80usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Relationship as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
      "::",
      stringify!(Relationship)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Size as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
      "::",
      stringify!(Size)
    )
  );
}
impl Default for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {{ Relationship: {:?}, Size: {:?}, __bindgen_anon_1: {:?} }}" , self . Relationship , self . Size , self . __bindgen_anon_1 )
  }
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub mod _CPU_SET_INFORMATION_TYPE {
  pub type Type = i32;
  pub const CpuSetInformation: Type = 0;
}
pub use self::_CPU_SET_INFORMATION_TYPE::Type as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE::Type;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
  pub Size: DWORD,
  pub Type: CPU_SET_INFORMATION_TYPE,
  pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
  pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub Id: DWORD,
  pub Group: WORD,
  pub LogicalProcessorIndex: BYTE,
  pub CoreIndex: BYTE,
  pub LastLevelCacheIndex: BYTE,
  pub NumaNodeIndex: BYTE,
  pub EfficiencyClass: BYTE,
  pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  pub Reserved: DWORD,
  pub AllocationTag: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub AllFlags: BYTE,
  pub __bindgen_anon_1:
    _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
  assert_eq!(
    ::core::mem::size_of::<
      _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
      )
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
      )
    )
  );
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn Parked(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_Parked(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Allocated(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_Allocated(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllocatedToTargetProcess(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_AllocatedToTargetProcess(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn RealTime(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_RealTime(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Parked: BYTE, Allocated: BYTE, AllocatedToTargetProcess: BYTE, RealTime: BYTE,
    ReservedFlags: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Parked: u8 = unsafe { ::core::mem::transmute(Parked) };
      Parked as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let Allocated: u8 = unsafe { ::core::mem::transmute(Allocated) };
      Allocated as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let AllocatedToTargetProcess: u8 =
        unsafe { ::core::mem::transmute(AllocatedToTargetProcess) };
      AllocatedToTargetProcess as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let RealTime: u8 = unsafe { ::core::mem::transmute(RealTime) };
      RealTime as u64
    });
    __bindgen_bitfield_unit.set(4usize, 4u8, {
      let ReservedFlags: u8 = unsafe { ::core::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
    ),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      & ( * ( :: core :: ptr :: null :: < _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . AllFlags as * const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AllFlags)
    )
  );
}
impl Default for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Id
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Id)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Group
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .LogicalProcessorIndex as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LogicalProcessorIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).CoreIndex
        as *const _ as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(CoreIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .LastLevelCacheIndex as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LastLevelCacheIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .NumaNodeIndex as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(NumaNodeIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .EfficiencyClass as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(EfficiencyClass)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Reserved
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .AllocationTag as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AllocationTag)
    )
  );
}
impl Default for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {{ Id: {:?}, Group: {:?}, LogicalProcessorIndex: {:?}, CoreIndex: {:?}, LastLevelCacheIndex: {:?}, NumaNodeIndex: {:?}, EfficiencyClass: {:?}, __bindgen_anon_1: {:?}, Reserved: {:?}, AllocationTag: {:?} }}" , self . Id , self . Group , self . LogicalProcessorIndex , self . CoreIndex , self . LastLevelCacheIndex , self . NumaNodeIndex , self . EfficiencyClass , self . __bindgen_anon_1 , self . Reserved , self . AllocationTag )
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>())).CpuSet as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(CpuSet)
    )
  );
}
impl Default for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION),
      "::",
      stringify!(Type)
    )
  );
}
impl Default for _SYSTEM_CPU_SET_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_CPU_SET_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SYSTEM_CPU_SET_INFORMATION {{ Size: {:?}, Type: {:?}, __bindgen_anon_1: {:?} }}",
      self.Size, self.Type, self.__bindgen_anon_1
    )
  }
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
  pub CycleTime: DWORD64,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>())).CycleTime as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION),
      "::",
      stringify!(CycleTime)
    )
  );
}
pub type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub type PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = *mut _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _XSTATE_FEATURE {
  pub Offset: DWORD,
  pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__XSTATE_FEATURE() {
  assert_eq!(
    ::core::mem::size_of::<_XSTATE_FEATURE>(),
    8usize,
    concat!("Size of: ", stringify!(_XSTATE_FEATURE))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSTATE_FEATURE>(),
    4usize,
    concat!("Alignment of ", stringify!(_XSTATE_FEATURE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_FEATURE>())).Offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_FEATURE),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_FEATURE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_FEATURE),
      "::",
      stringify!(Size)
    )
  );
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
pub type PXSTATE_FEATURE = *mut _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
  pub EnabledFeatures: DWORD64,
  pub EnabledVolatileFeatures: DWORD64,
  pub Size: DWORD,
  pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
  pub Features: [XSTATE_FEATURE; 64usize],
  pub EnabledSupervisorFeatures: DWORD64,
  pub AlignedFeatures: DWORD64,
  pub AllFeatureSize: DWORD,
  pub AllFeatures: [DWORD; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
  pub ControlFlags: DWORD,
  pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn OptimizedSave(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_OptimizedSave(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn CompactionEnabled(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_CompactionEnabled(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    OptimizedSave: DWORD, CompactionEnabled: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let OptimizedSave: u32 = unsafe { ::core::mem::transmute(OptimizedSave) };
      OptimizedSave as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let CompactionEnabled: u32 = unsafe { ::core::mem::transmute(CompactionEnabled) };
      CompactionEnabled as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_XSTATE_CONFIGURATION__bindgen_ty_1>())).ControlFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1),
      "::",
      stringify!(ControlFlags)
    )
  );
}
impl Default for _XSTATE_CONFIGURATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _XSTATE_CONFIGURATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_XSTATE_CONFIGURATION__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION() {
  assert_eq!(
    ::core::mem::size_of::<_XSTATE_CONFIGURATION>(),
    816usize,
    concat!("Size of: ", stringify!(_XSTATE_CONFIGURATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_XSTATE_CONFIGURATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_XSTATE_CONFIGURATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledFeatures as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(EnabledFeatures)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledVolatileFeatures as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(EnabledVolatileFeatures)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).Size as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).Features as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(Features)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledSupervisorFeatures as *const _
        as usize
    },
    536usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(EnabledSupervisorFeatures)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).AlignedFeatures as *const _ as usize
    },
    544usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(AlignedFeatures)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).AllFeatureSize as *const _ as usize
    },
    552usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(AllFeatureSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_XSTATE_CONFIGURATION>())).AllFeatures as *const _ as usize },
    556usize,
    concat!(
      "Offset of field: ",
      stringify!(_XSTATE_CONFIGURATION),
      "::",
      stringify!(AllFeatures)
    )
  );
}
impl Default for _XSTATE_CONFIGURATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _XSTATE_CONFIGURATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_XSTATE_CONFIGURATION {{ EnabledFeatures: {:?}, EnabledVolatileFeatures: {:?}, Size: {:?}, __bindgen_anon_1: {:?}, Features: [...], EnabledSupervisorFeatures: {:?}, AlignedFeatures: {:?}, AllFeatureSize: {:?}, AllFeatures: [...] }}" , self . EnabledFeatures , self . EnabledVolatileFeatures , self . Size , self . __bindgen_anon_1 , self . EnabledSupervisorFeatures , self . AlignedFeatures , self . AllFeatureSize )
  }
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
pub type PXSTATE_CONFIGURATION = *mut _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _MEMORY_BASIC_INFORMATION {
  pub BaseAddress: PVOID,
  pub AllocationBase: PVOID,
  pub AllocationProtect: DWORD,
  pub RegionSize: SIZE_T,
  pub State: DWORD,
  pub Protect: DWORD,
  pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_MEMORY_BASIC_INFORMATION>(),
    48usize,
    concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_MEMORY_BASIC_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).BaseAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(BaseAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).AllocationBase as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(AllocationBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).AllocationProtect as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(AllocationProtect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).RegionSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(RegionSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).State as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).Protect as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(Protect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION>())).Type as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION),
      "::",
      stringify!(Type)
    )
  );
}
impl Default for _MEMORY_BASIC_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MEMORY_BASIC_INFORMATION32 {
  pub BaseAddress: DWORD,
  pub AllocationBase: DWORD,
  pub AllocationProtect: DWORD,
  pub RegionSize: DWORD,
  pub State: DWORD,
  pub Protect: DWORD,
  pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION32() {
  assert_eq!(
    ::core::mem::size_of::<_MEMORY_BASIC_INFORMATION32>(),
    28usize,
    concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION32))
  );
  assert_eq!(
    ::core::mem::align_of::<_MEMORY_BASIC_INFORMATION32>(),
    4usize,
    concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION32))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).BaseAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(BaseAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).AllocationBase as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(AllocationBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).AllocationProtect as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(AllocationProtect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).RegionSize as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(RegionSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).State as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).Protect as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(Protect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).Type as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION32),
      "::",
      stringify!(Type)
    )
  );
}
pub type MEMORY_BASIC_INFORMATION32 = _MEMORY_BASIC_INFORMATION32;
pub type PMEMORY_BASIC_INFORMATION32 = *mut _MEMORY_BASIC_INFORMATION32;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MEMORY_BASIC_INFORMATION64 {
  pub BaseAddress: ULONGLONG,
  pub AllocationBase: ULONGLONG,
  pub AllocationProtect: DWORD,
  pub __alignment1: DWORD,
  pub RegionSize: ULONGLONG,
  pub State: DWORD,
  pub Protect: DWORD,
  pub Type: DWORD,
  pub __alignment2: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION64() {
  assert_eq!(
    ::core::mem::size_of::<_MEMORY_BASIC_INFORMATION64>(),
    48usize,
    concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION64))
  );
  assert_eq!(
    ::core::mem::align_of::<_MEMORY_BASIC_INFORMATION64>(),
    16usize,
    concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION64))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).BaseAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(BaseAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).AllocationBase as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(AllocationBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).AllocationProtect as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(AllocationProtect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).__alignment1 as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(__alignment1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).RegionSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(RegionSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).State as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).Protect as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(Protect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).Type as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).__alignment2 as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_BASIC_INFORMATION64),
      "::",
      stringify!(__alignment2)
    )
  );
}
pub type MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64;
pub type PMEMORY_BASIC_INFORMATION64 = *mut _MEMORY_BASIC_INFORMATION64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CFG_CALL_TARGET_INFO {
  pub Offset: ULONG_PTR,
  pub Flags: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__CFG_CALL_TARGET_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CFG_CALL_TARGET_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_CFG_CALL_TARGET_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CFG_CALL_TARGET_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_CFG_CALL_TARGET_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CFG_CALL_TARGET_INFO>())).Offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CFG_CALL_TARGET_INFO),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CFG_CALL_TARGET_INFO>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CFG_CALL_TARGET_INFO),
      "::",
      stringify!(Flags)
    )
  );
}
pub type CFG_CALL_TARGET_INFO = _CFG_CALL_TARGET_INFO;
pub type PCFG_CALL_TARGET_INFO = *mut _CFG_CALL_TARGET_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_SGX {
  pub Secs: [BYTE; 4096usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_SGX() {
  assert_eq!(
    ::core::mem::size_of::<_ENCLAVE_CREATE_INFO_SGX>(),
    4096usize,
    concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_SGX))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENCLAVE_CREATE_INFO_SGX>(),
    1usize,
    concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_SGX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_CREATE_INFO_SGX>())).Secs as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_CREATE_INFO_SGX),
      "::",
      stringify!(Secs)
    )
  );
}
impl Default for _ENCLAVE_CREATE_INFO_SGX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ENCLAVE_CREATE_INFO_SGX {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_ENCLAVE_CREATE_INFO_SGX {{ Secs: [...] }}")
  }
}
impl ::core::cmp::PartialEq for _ENCLAVE_CREATE_INFO_SGX {
  fn eq(&self, other: &_ENCLAVE_CREATE_INFO_SGX) -> bool {
    &self.Secs[..] == &other.Secs[..]
  }
}
pub type ENCLAVE_CREATE_INFO_SGX = _ENCLAVE_CREATE_INFO_SGX;
pub type PENCLAVE_CREATE_INFO_SGX = *mut _ENCLAVE_CREATE_INFO_SGX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_SGX {
  pub SigStruct: [BYTE; 1808usize],
  pub Reserved1: [BYTE; 240usize],
  pub EInitToken: [BYTE; 304usize],
  pub Reserved2: [BYTE; 1744usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_SGX() {
  assert_eq!(
    ::core::mem::size_of::<_ENCLAVE_INIT_INFO_SGX>(),
    4096usize,
    concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_SGX))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENCLAVE_INIT_INFO_SGX>(),
    1usize,
    concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_SGX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).SigStruct as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_INIT_INFO_SGX),
      "::",
      stringify!(SigStruct)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).Reserved1 as *const _ as usize },
    1808usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_INIT_INFO_SGX),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).EInitToken as *const _ as usize },
    2048usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_INIT_INFO_SGX),
      "::",
      stringify!(EInitToken)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).Reserved2 as *const _ as usize },
    2352usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_INIT_INFO_SGX),
      "::",
      stringify!(Reserved2)
    )
  );
}
impl Default for _ENCLAVE_INIT_INFO_SGX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ENCLAVE_INIT_INFO_SGX {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_ENCLAVE_INIT_INFO_SGX {{ SigStruct: [...], Reserved1: [...], EInitToken: [...], Reserved2: [...] }}" )
  }
}
impl ::core::cmp::PartialEq for _ENCLAVE_INIT_INFO_SGX {
  fn eq(&self, other: &_ENCLAVE_INIT_INFO_SGX) -> bool {
    &self.SigStruct[..] == &other.SigStruct[..]
      && &self.Reserved1[..] == &other.Reserved1[..]
      && &self.EInitToken[..] == &other.EInitToken[..]
      && &self.Reserved2[..] == &other.Reserved2[..]
  }
}
pub type ENCLAVE_INIT_INFO_SGX = _ENCLAVE_INIT_INFO_SGX;
pub type PENCLAVE_INIT_INFO_SGX = *mut _ENCLAVE_INIT_INFO_SGX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ENCLAVE_CREATE_INFO_VBS {
  pub Flags: DWORD,
  pub OwnerID: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_VBS() {
  assert_eq!(
    ::core::mem::size_of::<_ENCLAVE_CREATE_INFO_VBS>(),
    36usize,
    concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_VBS))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENCLAVE_CREATE_INFO_VBS>(),
    4usize,
    concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_VBS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_CREATE_INFO_VBS>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_CREATE_INFO_VBS),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_CREATE_INFO_VBS>())).OwnerID as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_CREATE_INFO_VBS),
      "::",
      stringify!(OwnerID)
    )
  );
}
pub type ENCLAVE_CREATE_INFO_VBS = _ENCLAVE_CREATE_INFO_VBS;
pub type PENCLAVE_CREATE_INFO_VBS = *mut _ENCLAVE_CREATE_INFO_VBS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ENCLAVE_INIT_INFO_VBS {
  pub Length: DWORD,
  pub ThreadCount: DWORD,
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_VBS() {
  assert_eq!(
    ::core::mem::size_of::<_ENCLAVE_INIT_INFO_VBS>(),
    8usize,
    concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_VBS))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENCLAVE_INIT_INFO_VBS>(),
    4usize,
    concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_VBS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_INIT_INFO_VBS>())).Length as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_INIT_INFO_VBS),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ENCLAVE_INIT_INFO_VBS>())).ThreadCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENCLAVE_INIT_INFO_VBS),
      "::",
      stringify!(ThreadCount)
    )
  );
}
pub type ENCLAVE_INIT_INFO_VBS = _ENCLAVE_INIT_INFO_VBS;
pub type PENCLAVE_INIT_INFO_VBS = *mut _ENCLAVE_INIT_INFO_VBS;
pub type ENCLAVE_TARGET_FUNCTION =
  ::core::option::Option<unsafe extern "C" fn(arg1: PVOID) -> PVOID>;
pub type PENCLAVE_TARGET_FUNCTION = ENCLAVE_TARGET_FUNCTION;
pub type LPENCLAVE_TARGET_FUNCTION = PENCLAVE_TARGET_FUNCTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_ID_128 {
  pub Identifier: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_128() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ID_128>(),
    16usize,
    concat!("Size of: ", stringify!(_FILE_ID_128))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ID_128>(),
    1usize,
    concat!("Alignment of ", stringify!(_FILE_ID_128))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_128>())).Identifier as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_128),
      "::",
      stringify!(Identifier)
    )
  );
}
pub type FILE_ID_128 = _FILE_ID_128;
pub type PFILE_ID_128 = *mut _FILE_ID_128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_NOTIFY_INFORMATION {
  pub NextEntryOffset: DWORD,
  pub Action: DWORD,
  pub FileNameLength: DWORD,
  pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_NOTIFY_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_FILE_NOTIFY_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_NOTIFY_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_NOTIFY_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_INFORMATION>())).NextEntryOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_INFORMATION),
      "::",
      stringify!(NextEntryOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_NOTIFY_INFORMATION>())).Action as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_INFORMATION),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_INFORMATION>())).FileNameLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_INFORMATION),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_NOTIFY_INFORMATION>())).FileName as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_INFORMATION),
      "::",
      stringify!(FileName)
    )
  );
}
pub type FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION;
pub type PFILE_NOTIFY_INFORMATION = *mut _FILE_NOTIFY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_EXTENDED_INFORMATION {
  pub NextEntryOffset: DWORD,
  pub Action: DWORD,
  pub CreationTime: LARGE_INTEGER,
  pub LastModificationTime: LARGE_INTEGER,
  pub LastChangeTime: LARGE_INTEGER,
  pub LastAccessTime: LARGE_INTEGER,
  pub AllocatedLength: LARGE_INTEGER,
  pub FileSize: LARGE_INTEGER,
  pub FileAttributes: DWORD,
  pub ReparsePointTag: DWORD,
  pub FileId: LARGE_INTEGER,
  pub ParentFileId: LARGE_INTEGER,
  pub FileNameLength: DWORD,
  pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_EXTENDED_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_NOTIFY_EXTENDED_INFORMATION>(),
    88usize,
    concat!("Size of: ", stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_NOTIFY_EXTENDED_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).NextEntryOffset as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(NextEntryOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).Action as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).CreationTime as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(CreationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).LastModificationTime
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(LastModificationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).LastChangeTime as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(LastChangeTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).LastAccessTime as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(LastAccessTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).AllocatedLength as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(AllocatedLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileSize as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(FileSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileAttributes as *const _
        as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(FileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).ReparsePointTag as *const _
        as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(ReparsePointTag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileId as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(FileId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).ParentFileId as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(ParentFileId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileNameLength as *const _
        as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileName as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
      "::",
      stringify!(FileName)
    )
  );
}
impl Default for _FILE_NOTIFY_EXTENDED_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_NOTIFY_EXTENDED_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_NOTIFY_EXTENDED_INFORMATION {{ NextEntryOffset: {:?}, Action: {:?}, CreationTime: {:?}, LastModificationTime: {:?}, LastChangeTime: {:?}, LastAccessTime: {:?}, AllocatedLength: {:?}, FileSize: {:?}, FileAttributes: {:?}, ReparsePointTag: {:?}, FileId: {:?}, ParentFileId: {:?}, FileNameLength: {:?}, FileName: {:?} }}" , self . NextEntryOffset , self . Action , self . CreationTime , self . LastModificationTime , self . LastChangeTime , self . LastAccessTime , self . AllocatedLength , self . FileSize , self . FileAttributes , self . ReparsePointTag , self . FileId , self . ParentFileId , self . FileNameLength , self . FileName )
  }
}
pub type FILE_NOTIFY_EXTENDED_INFORMATION = _FILE_NOTIFY_EXTENDED_INFORMATION;
pub type PFILE_NOTIFY_EXTENDED_INFORMATION = *mut _FILE_NOTIFY_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
  pub Buffer: *mut libc::c_void,
  pub Alignment: ULONGLONG,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_SEGMENT_ELEMENT>(),
    8usize,
    concat!("Size of: ", stringify!(_FILE_SEGMENT_ELEMENT))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_SEGMENT_ELEMENT>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_SEGMENT_ELEMENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_SEGMENT_ELEMENT>())).Buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_SEGMENT_ELEMENT),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_SEGMENT_ELEMENT>())).Alignment as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_SEGMENT_ELEMENT),
      "::",
      stringify!(Alignment)
    )
  );
}
impl Default for _FILE_SEGMENT_ELEMENT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_SEGMENT_ELEMENT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_FILE_SEGMENT_ELEMENT {{ union }}")
  }
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _REPARSE_GUID_DATA_BUFFER {
  pub ReparseTag: DWORD,
  pub ReparseDataLength: WORD,
  pub Reserved: WORD,
  pub ReparseGuid: GUID,
  pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
  pub DataBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__REPARSE_GUID_DATA_BUFFER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>())).DataBuffer as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1),
      "::",
      stringify!(DataBuffer)
    )
  );
}
#[test]
fn bindgen_test_layout__REPARSE_GUID_DATA_BUFFER() {
  assert_eq!(
    ::core::mem::size_of::<_REPARSE_GUID_DATA_BUFFER>(),
    28usize,
    concat!("Size of: ", stringify!(_REPARSE_GUID_DATA_BUFFER))
  );
  assert_eq!(
    ::core::mem::align_of::<_REPARSE_GUID_DATA_BUFFER>(),
    4usize,
    concat!("Alignment of ", stringify!(_REPARSE_GUID_DATA_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).ReparseTag as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER),
      "::",
      stringify!(ReparseTag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).ReparseDataLength as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER),
      "::",
      stringify!(ReparseDataLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).Reserved as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).ReparseGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER),
      "::",
      stringify!(ReparseGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).GenericReparseBuffer as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_REPARSE_GUID_DATA_BUFFER),
      "::",
      stringify!(GenericReparseBuffer)
    )
  );
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
pub type PREPARSE_GUID_DATA_BUFFER = *mut _REPARSE_GUID_DATA_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub MaximumIos: DWORD,
  pub ObjectId: [DWORD; 4usize],
  pub Reserved: [DWORD; 13usize],
  pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_INPUT() {
  assert_eq!(
    ::core::mem::size_of::<_SCRUB_DATA_INPUT>(),
    896usize,
    concat!("Size of: ", stringify!(_SCRUB_DATA_INPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCRUB_DATA_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCRUB_DATA_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_INPUT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_INPUT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_INPUT>())).MaximumIos as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(MaximumIos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_INPUT>())).ObjectId as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(ObjectId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_INPUT>())).Reserved as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_INPUT>())).ResumeContext as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(ResumeContext)
    )
  );
}
impl Default for _SCRUB_DATA_INPUT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SCRUB_DATA_INPUT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_SCRUB_DATA_INPUT {{ Size: {:?}, Flags: {:?}, MaximumIos: {:?}, ObjectId: {:?}, Reserved: {:?}, ResumeContext: [...] }}" , self . Size , self . Flags , self . MaximumIos , self . ObjectId , self . Reserved )
  }
}
impl ::core::cmp::PartialEq for _SCRUB_DATA_INPUT {
  fn eq(&self, other: &_SCRUB_DATA_INPUT) -> bool {
    self.Size == other.Size
      && self.Flags == other.Flags
      && self.MaximumIos == other.MaximumIos
      && self.ObjectId == other.ObjectId
      && self.Reserved == other.Reserved
      && &self.ResumeContext[..] == &other.ResumeContext[..]
  }
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
pub type PSCRUB_DATA_INPUT = *mut _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCRUB_PARITY_EXTENT {
  pub Offset: LONGLONG,
  pub Length: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT() {
  assert_eq!(
    ::core::mem::size_of::<_SCRUB_PARITY_EXTENT>(),
    16usize,
    concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCRUB_PARITY_EXTENT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT>())).Offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT),
      "::",
      stringify!(Length)
    )
  );
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
pub type PSCRUB_PARITY_EXTENT = *mut _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
  pub Size: WORD,
  pub Flags: WORD,
  pub NumberOfParityExtents: WORD,
  pub MaximumNumberOfParityExtents: WORD,
  pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_SCRUB_PARITY_EXTENT_DATA>(),
    24usize,
    concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCRUB_PARITY_EXTENT_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).NumberOfParityExtents as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(NumberOfParityExtents)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).MaximumNumberOfParityExtents
        as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(MaximumNumberOfParityExtents)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).ParityExtents as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(ParityExtents)
    )
  );
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
pub type PSCRUB_PARITY_EXTENT_DATA = *mut _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Status: DWORD,
  pub ErrorFileOffset: ULONGLONG,
  pub ErrorLength: ULONGLONG,
  pub NumberOfBytesRepaired: ULONGLONG,
  pub NumberOfBytesFailed: ULONGLONG,
  pub InternalFileReference: ULONGLONG,
  pub ResumeContextLength: WORD,
  pub ParityExtentDataOffset: WORD,
  pub Reserved: [DWORD; 5usize],
  pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_OUTPUT() {
  assert_eq!(
    ::core::mem::size_of::<_SCRUB_DATA_OUTPUT>(),
    896usize,
    concat!("Size of: ", stringify!(_SCRUB_DATA_OUTPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<_SCRUB_DATA_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_DATA_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).Status as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Status)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorFileOffset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ErrorFileOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ErrorLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesRepaired as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfBytesRepaired)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesFailed as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfBytesFailed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).InternalFileReference as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(InternalFileReference)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContextLength as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ResumeContextLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).ParityExtentDataOffset as *const _ as usize
    },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ParityExtentDataOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).Reserved as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContext as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ResumeContext)
    )
  );
}
impl Default for _SCRUB_DATA_OUTPUT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SCRUB_DATA_OUTPUT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_SCRUB_DATA_OUTPUT {{ Size: {:?}, Flags: {:?}, Status: {:?}, ErrorFileOffset: {:?}, ErrorLength: {:?}, NumberOfBytesRepaired: {:?}, NumberOfBytesFailed: {:?}, InternalFileReference: {:?}, ResumeContextLength: {:?}, ParityExtentDataOffset: {:?}, Reserved: {:?}, ResumeContext: [...] }}" , self . Size , self . Flags , self . Status , self . ErrorFileOffset , self . ErrorLength , self . NumberOfBytesRepaired , self . NumberOfBytesFailed , self . InternalFileReference , self . ResumeContextLength , self . ParityExtentDataOffset , self . Reserved )
  }
}
impl ::core::cmp::PartialEq for _SCRUB_DATA_OUTPUT {
  fn eq(&self, other: &_SCRUB_DATA_OUTPUT) -> bool {
    self.Size == other.Size
      && self.Flags == other.Flags
      && self.Status == other.Status
      && self.ErrorFileOffset == other.ErrorFileOffset
      && self.ErrorLength == other.ErrorLength
      && self.NumberOfBytesRepaired == other.NumberOfBytesRepaired
      && self.NumberOfBytesFailed == other.NumberOfBytesFailed
      && self.InternalFileReference == other.InternalFileReference
      && self.ResumeContextLength == other.ResumeContextLength
      && self.ParityExtentDataOffset == other.ParityExtentDataOffset
      && self.Reserved == other.Reserved
      && &self.ResumeContext[..] == &other.ResumeContext[..]
  }
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub type PSCRUB_DATA_OUTPUT = *mut _SCRUB_DATA_OUTPUT;
pub mod _SharedVirtualDiskSupportType {
  pub type Type = i32;
  pub const SharedVirtualDisksUnsupported: Type = 0;
  pub const SharedVirtualDisksSupported: Type = 1;
  pub const SharedVirtualDiskSnapshotsSupported: Type = 3;
  pub const SharedVirtualDiskCDPSnapshotsSupported: Type = 7;
}
pub use self::_SharedVirtualDiskSupportType::Type as SharedVirtualDiskSupportType;
pub mod _SharedVirtualDiskHandleState {
  pub type Type = i32;
  pub const SharedVirtualDiskHandleStateNone: Type = 0;
  pub const SharedVirtualDiskHandleStateFileShared: Type = 1;
  pub const SharedVirtualDiskHandleStateHandleShared: Type = 3;
}
pub use self::_SharedVirtualDiskHandleState::Type as SharedVirtualDiskHandleState;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SHARED_VIRTUAL_DISK_SUPPORT {
  pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
  pub HandleState: SharedVirtualDiskHandleState,
}
#[test]
fn bindgen_test_layout__SHARED_VIRTUAL_DISK_SUPPORT() {
  assert_eq!(
    ::core::mem::size_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
    8usize,
    concat!("Size of: ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
  );
  assert_eq!(
    ::core::mem::align_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).SharedVirtualDiskSupport as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
      "::",
      stringify!(SharedVirtualDiskSupport)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).HandleState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
      "::",
      stringify!(HandleState)
    )
  );
}
impl Default for _SHARED_VIRTUAL_DISK_SUPPORT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT;
pub type PSHARED_VIRTUAL_DISK_SUPPORT = *mut _SHARED_VIRTUAL_DISK_SUPPORT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _NETWORK_APP_INSTANCE_EA {
  pub AppInstanceID: GUID,
  pub CsvFlags: DWORD,
}
#[test]
fn bindgen_test_layout__NETWORK_APP_INSTANCE_EA() {
  assert_eq!(
    ::core::mem::size_of::<_NETWORK_APP_INSTANCE_EA>(),
    20usize,
    concat!("Size of: ", stringify!(_NETWORK_APP_INSTANCE_EA))
  );
  assert_eq!(
    ::core::mem::align_of::<_NETWORK_APP_INSTANCE_EA>(),
    4usize,
    concat!("Alignment of ", stringify!(_NETWORK_APP_INSTANCE_EA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_NETWORK_APP_INSTANCE_EA>())).AppInstanceID as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETWORK_APP_INSTANCE_EA),
      "::",
      stringify!(AppInstanceID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETWORK_APP_INSTANCE_EA>())).CsvFlags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETWORK_APP_INSTANCE_EA),
      "::",
      stringify!(CsvFlags)
    )
  );
}
pub type NETWORK_APP_INSTANCE_EA = _NETWORK_APP_INSTANCE_EA;
pub type PNETWORK_APP_INSTANCE_EA = *mut _NETWORK_APP_INSTANCE_EA;
extern "C" {
  #[link_name = "\u{1}GUID_MAX_POWER_SAVINGS"]
  pub static GUID_MAX_POWER_SAVINGS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_MIN_POWER_SAVINGS"]
  pub static GUID_MIN_POWER_SAVINGS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_TYPICAL_POWER_SAVINGS"]
  pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
extern "C" {
  #[link_name = "\u{1}NO_SUBGROUP_GUID"]
  pub static NO_SUBGROUP_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}ALL_POWERSCHEMES_GUID"]
  pub static ALL_POWERSCHEMES_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_POWERSCHEME_PERSONALITY"]
  pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ACTIVE_POWERSCHEME"]
  pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_IDLE_RESILIENCY_SUBGROUP"]
  pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_IDLE_RESILIENCY_PERIOD"]
  pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DEEP_SLEEP_ENABLED"]
  pub static GUID_DEEP_SLEEP_ENABLED: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DEEP_SLEEP_PLATFORM_STATE"]
  pub static GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_COALESCING_POWERDOWN_TIMEOUT"]
  pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT"]
  pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_SUBGROUP"]
  pub static GUID_VIDEO_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_POWERDOWN_TIMEOUT"]
  pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_ANNOYANCE_TIMEOUT"]
  pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE"]
  pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_DIM_TIMEOUT"]
  pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_ADAPTIVE_POWERDOWN"]
  pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_MONITOR_POWER_ON"]
  pub static GUID_MONITOR_POWER_ON: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS"]
  pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS"]
  pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS"]
  pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS"]
  pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_CONSOLE_DISPLAY_STATE"]
  pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ALLOW_DISPLAY_REQUIRED"]
  pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_VIDEO_CONSOLE_LOCK_TIMEOUT"]
  pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP"]
  pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_NON_ADAPTIVE_INPUT_TIMEOUT"]
  pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ADAPTIVE_INPUT_CONTROLLER_STATE"]
  pub static GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_SUBGROUP"]
  pub static GUID_DISK_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_MAX_POWER"]
  pub static GUID_DISK_MAX_POWER: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_POWERDOWN_TIMEOUT"]
  pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_IDLE_TIMEOUT"]
  pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_BURST_IGNORE_THRESHOLD"]
  pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISK_ADAPTIVE_POWERDOWN"]
  pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SLEEP_SUBGROUP"]
  pub static GUID_SLEEP_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SLEEP_IDLE_THRESHOLD"]
  pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_STANDBY_TIMEOUT"]
  pub static GUID_STANDBY_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_UNATTEND_SLEEP_TIMEOUT"]
  pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_HIBERNATE_TIMEOUT"]
  pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_HIBERNATE_FASTS4_POLICY"]
  pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_CRITICAL_POWER_TRANSITION"]
  pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SYSTEM_AWAYMODE"]
  pub static GUID_SYSTEM_AWAYMODE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ALLOW_AWAYMODE"]
  pub static GUID_ALLOW_AWAYMODE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_USER_PRESENCE_PREDICTION"]
  pub static GUID_USER_PRESENCE_PREDICTION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_STANDBY_BUDGET_GRACE_PERIOD"]
  pub static GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_STANDBY_BUDGET_PERCENT"]
  pub static GUID_STANDBY_BUDGET_PERCENT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_STANDBY_RESERVE_GRACE_PERIOD"]
  pub static GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_STANDBY_RESERVE_TIME"]
  pub static GUID_STANDBY_RESERVE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_STANDBY_RESET_PERCENT"]
  pub static GUID_STANDBY_RESET_PERCENT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ALLOW_STANDBY_STATES"]
  pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ALLOW_RTC_WAKE"]
  pub static GUID_ALLOW_RTC_WAKE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_LEGACY_RTC_MITIGATION"]
  pub static GUID_LEGACY_RTC_MITIGATION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ALLOW_SYSTEM_REQUIRED"]
  pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_POWER_SAVING_STATUS"]
  pub static GUID_POWER_SAVING_STATUS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ENERGY_SAVER_SUBGROUP"]
  pub static GUID_ENERGY_SAVER_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ENERGY_SAVER_BATTERY_THRESHOLD"]
  pub static GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ENERGY_SAVER_BRIGHTNESS"]
  pub static GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ENERGY_SAVER_POLICY"]
  pub static GUID_ENERGY_SAVER_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SYSTEM_BUTTON_SUBGROUP"]
  pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_POWERBUTTON_ACTION"]
  pub static GUID_POWERBUTTON_ACTION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SLEEPBUTTON_ACTION"]
  pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_USERINTERFACEBUTTON_ACTION"]
  pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_LIDCLOSE_ACTION"]
  pub static GUID_LIDCLOSE_ACTION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_LIDOPEN_POWERSTATE"]
  pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_SUBGROUP"]
  pub static GUID_BATTERY_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_0"]
  pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_0"]
  pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_0"]
  pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_1"]
  pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_1"]
  pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_1"]
  pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_2"]
  pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_2"]
  pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_2"]
  pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_3"]
  pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_3"]
  pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_3"]
  pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_SETTINGS_SUBGROUP"]
  pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_POLICY"]
  pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MAXIMUM"]
  pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MAXIMUM_1"]
  pub static GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MINIMUM"]
  pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MINIMUM_1"]
  pub static GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_FREQUENCY_LIMIT"]
  pub static GUID_PROCESSOR_FREQUENCY_LIMIT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_FREQUENCY_LIMIT_1"]
  pub static GUID_PROCESSOR_FREQUENCY_LIMIT_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_ALLOW_THROTTLING"]
  pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLESTATE_POLICY"]
  pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERFSTATE_POLICY"]
  pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_THRESHOLD"]
  pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1"]
  pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_THRESHOLD"]
  pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1"]
  pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_POLICY"]
  pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_POLICY_1"]
  pub static GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_POLICY"]
  pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_POLICY_1"]
  pub static GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_TIME"]
  pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_TIME_1"]
  pub static GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_TIME"]
  pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_TIME_1"]
  pub static GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_TIME_CHECK"]
  pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_BOOST_POLICY"]
  pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_BOOST_MODE"]
  pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_AUTONOMOUS_MODE"]
  pub static GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE"]
  pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW"]
  pub static GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_DUTY_CYCLING"]
  pub static GUID_PROCESSOR_DUTY_CYCLING: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLE_ALLOW_SCALING"]
  pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLE_DISABLE"]
  pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLE_STATE_MAXIMUM"]
  pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLE_TIME_CHECK"]
  pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD"]
  pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD"]
  pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD"]
  pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD"]
  pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY"]
  pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY"]
  pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MAX_CORES"]
  pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1"]
  pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MIN_CORES"]
  pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1"]
  pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME"]
  pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME"]
  pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR"]
  pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD"]
  pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING"]
  pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR"]
  pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD"]
  pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING"]
  pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD"]
  pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PARKING_CORE_OVERRIDE"]
  pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PARKING_PERF_STATE"]
  pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PARKING_PERF_STATE_1"]
  pub static GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD"]
  pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD"]
  pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD"]
  pub static GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_HISTORY"]
  pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_HISTORY_1"]
  pub static GUID_PROCESSOR_PERF_HISTORY_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_HISTORY"]
  pub static GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_HISTORY"]
  pub static GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY"]
  pub static GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT"]
  pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT_PERF"]
  pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1"]
  pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK"]
  pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1"]
  pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_DISTRIBUTE_UTILITY"]
  pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_HETEROGENEOUS_POLICY"]
  pub static GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_HETERO_DECREASE_TIME"]
  pub static GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_HETERO_INCREASE_TIME"]
  pub static GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD"]
  pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD"]
  pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CLASS0_FLOOR_PERF"]
  pub static GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_CLASS1_INITIAL_PERF"]
  pub static GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_THREAD_SCHEDULING_POLICY"]
  pub static GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY"]
  pub static GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SYSTEM_COOLING_POLICY"]
  pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_LOCK_CONSOLE_ON_WAKE"]
  pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DEVICE_IDLE_POLICY"]
  pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_CONNECTIVITY_IN_STANDBY"]
  pub static GUID_CONNECTIVITY_IN_STANDBY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_DISCONNECTED_STANDBY_MODE"]
  pub static GUID_DISCONNECTED_STANDBY_MODE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ACDC_POWER_SOURCE"]
  pub static GUID_ACDC_POWER_SOURCE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_LIDSWITCH_STATE_CHANGE"]
  pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_PERCENTAGE_REMAINING"]
  pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BATTERY_COUNT"]
  pub static GUID_BATTERY_COUNT: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_GLOBAL_USER_PRESENCE"]
  pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SESSION_DISPLAY_STATUS"]
  pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_SESSION_USER_PRESENCE"]
  pub static GUID_SESSION_USER_PRESENCE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_IDLE_BACKGROUND_TASK"]
  pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_BACKGROUND_TASK_NOTIFICATION"]
  pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_APPLAUNCH_BUTTON"]
  pub static GUID_APPLAUNCH_BUTTON: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PCIEXPRESS_SETTINGS_SUBGROUP"]
  pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_PCIEXPRESS_ASPM_POLICY"]
  pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_ENABLE_SWITCH_FORCED_SHUTDOWN"]
  pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_INTSTEER_SUBGROUP"]
  pub static GUID_INTSTEER_SUBGROUP: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_INTSTEER_MODE"]
  pub static GUID_INTSTEER_MODE: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_INTSTEER_LOAD_PER_PROC_TRIGGER"]
  pub static GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_INTSTEER_TIME_UNPARK_TRIGGER"]
  pub static GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
}
extern "C" {
  #[link_name = "\u{1}GUID_MIXED_REALITY_MODE"]
  pub static GUID_MIXED_REALITY_MODE: GUID;
}
pub mod _SYSTEM_POWER_STATE {
  pub type Type = i32;
  pub const PowerSystemUnspecified: Type = 0;
  pub const PowerSystemWorking: Type = 1;
  pub const PowerSystemSleeping1: Type = 2;
  pub const PowerSystemSleeping2: Type = 3;
  pub const PowerSystemSleeping3: Type = 4;
  pub const PowerSystemHibernate: Type = 5;
  pub const PowerSystemShutdown: Type = 6;
  pub const PowerSystemMaximum: Type = 7;
}
pub use self::_SYSTEM_POWER_STATE::Type as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE::Type;
pub mod POWER_ACTION {
  pub type Type = i32;
  pub const PowerActionNone: Type = 0;
  pub const PowerActionReserved: Type = 1;
  pub const PowerActionSleep: Type = 2;
  pub const PowerActionHibernate: Type = 3;
  pub const PowerActionShutdown: Type = 4;
  pub const PowerActionShutdownReset: Type = 5;
  pub const PowerActionShutdownOff: Type = 6;
  pub const PowerActionWarmEject: Type = 7;
  pub const PowerActionDisplayOff: Type = 8;
}
pub type PPOWER_ACTION = *mut POWER_ACTION::Type;
pub mod _DEVICE_POWER_STATE {
  pub type Type = i32;
  pub const PowerDeviceUnspecified: Type = 0;
  pub const PowerDeviceD0: Type = 1;
  pub const PowerDeviceD1: Type = 2;
  pub const PowerDeviceD2: Type = 3;
  pub const PowerDeviceD3: Type = 4;
  pub const PowerDeviceMaximum: Type = 5;
}
pub use self::_DEVICE_POWER_STATE::Type as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE::Type;
pub mod _MONITOR_DISPLAY_STATE {
  pub type Type = i32;
  pub const PowerMonitorOff: Type = 0;
  pub const PowerMonitorOn: Type = 1;
  pub const PowerMonitorDim: Type = 2;
}
pub use self::_MONITOR_DISPLAY_STATE::Type as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE::Type;
pub mod _USER_ACTIVITY_PRESENCE {
  pub type Type = i32;
  pub const PowerUserPresent: Type = 0;
  pub const PowerUserNotPresent: Type = 1;
  pub const PowerUserInactive: Type = 2;
  pub const PowerUserMaximum: Type = 3;
  pub const PowerUserInvalid: Type = 3;
}
pub use self::_USER_ACTIVITY_PRESENCE::Type as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE::Type;
pub type EXECUTION_STATE = DWORD;
pub type PEXECUTION_STATE = *mut DWORD;
pub mod LATENCY_TIME {
  pub type Type = i32;
  pub const LT_DONT_CARE: Type = 0;
  pub const LT_LOWEST_LATENCY: Type = 1;
}
pub mod _POWER_REQUEST_TYPE {
  pub type Type = i32;
  pub const PowerRequestDisplayRequired: Type = 0;
  pub const PowerRequestSystemRequired: Type = 1;
  pub const PowerRequestAwayModeRequired: Type = 2;
  pub const PowerRequestExecutionRequired: Type = 3;
}
pub use self::_POWER_REQUEST_TYPE::Type as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct CM_Power_Data_s {
  pub PD_Size: DWORD,
  pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
  pub PD_Capabilities: DWORD,
  pub PD_D1Latency: DWORD,
  pub PD_D2Latency: DWORD,
  pub PD_D3Latency: DWORD,
  pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
  pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_CM_Power_Data_s() {
  assert_eq!(
    ::core::mem::size_of::<CM_Power_Data_s>(),
    56usize,
    concat!("Size of: ", stringify!(CM_Power_Data_s))
  );
  assert_eq!(
    ::core::mem::align_of::<CM_Power_Data_s>(),
    4usize,
    concat!("Alignment of ", stringify!(CM_Power_Data_s))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_MostRecentPowerState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_MostRecentPowerState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_Capabilities as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_Capabilities)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_D1Latency as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_D1Latency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_D2Latency as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_D2Latency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_D3Latency as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_D3Latency)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_PowerStateMapping as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_PowerStateMapping)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<CM_Power_Data_s>())).PD_DeepestSystemWake as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(CM_Power_Data_s),
      "::",
      stringify!(PD_DeepestSystemWake)
    )
  );
}
impl Default for CM_Power_Data_s {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CM_POWER_DATA = CM_Power_Data_s;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
pub mod POWER_INFORMATION_LEVEL {
  pub type Type = i32;
  pub const SystemPowerPolicyAc: Type = 0;
  pub const SystemPowerPolicyDc: Type = 1;
  pub const VerifySystemPolicyAc: Type = 2;
  pub const VerifySystemPolicyDc: Type = 3;
  pub const SystemPowerCapabilities: Type = 4;
  pub const SystemBatteryState: Type = 5;
  pub const SystemPowerStateHandler: Type = 6;
  pub const ProcessorStateHandler: Type = 7;
  pub const SystemPowerPolicyCurrent: Type = 8;
  pub const AdministratorPowerPolicy: Type = 9;
  pub const SystemReserveHiberFile: Type = 10;
  pub const ProcessorInformation: Type = 11;
  pub const SystemPowerInformation: Type = 12;
  pub const ProcessorStateHandler2: Type = 13;
  pub const LastWakeTime: Type = 14;
  pub const LastSleepTime: Type = 15;
  pub const SystemExecutionState: Type = 16;
  pub const SystemPowerStateNotifyHandler: Type = 17;
  pub const ProcessorPowerPolicyAc: Type = 18;
  pub const ProcessorPowerPolicyDc: Type = 19;
  pub const VerifyProcessorPowerPolicyAc: Type = 20;
  pub const VerifyProcessorPowerPolicyDc: Type = 21;
  pub const ProcessorPowerPolicyCurrent: Type = 22;
  pub const SystemPowerStateLogging: Type = 23;
  pub const SystemPowerLoggingEntry: Type = 24;
  pub const SetPowerSettingValue: Type = 25;
  pub const NotifyUserPowerSetting: Type = 26;
  pub const PowerInformationLevelUnused0: Type = 27;
  pub const SystemMonitorHiberBootPowerOff: Type = 28;
  pub const SystemVideoState: Type = 29;
  pub const TraceApplicationPowerMessage: Type = 30;
  pub const TraceApplicationPowerMessageEnd: Type = 31;
  pub const ProcessorPerfStates: Type = 32;
  pub const ProcessorIdleStates: Type = 33;
  pub const ProcessorCap: Type = 34;
  pub const SystemWakeSource: Type = 35;
  pub const SystemHiberFileInformation: Type = 36;
  pub const TraceServicePowerMessage: Type = 37;
  pub const ProcessorLoad: Type = 38;
  pub const PowerShutdownNotification: Type = 39;
  pub const MonitorCapabilities: Type = 40;
  pub const SessionPowerInit: Type = 41;
  pub const SessionDisplayState: Type = 42;
  pub const PowerRequestCreate: Type = 43;
  pub const PowerRequestAction: Type = 44;
  pub const GetPowerRequestList: Type = 45;
  pub const ProcessorInformationEx: Type = 46;
  pub const NotifyUserModeLegacyPowerEvent: Type = 47;
  pub const GroupPark: Type = 48;
  pub const ProcessorIdleDomains: Type = 49;
  pub const WakeTimerList: Type = 50;
  pub const SystemHiberFileSize: Type = 51;
  pub const ProcessorIdleStatesHv: Type = 52;
  pub const ProcessorPerfStatesHv: Type = 53;
  pub const ProcessorPerfCapHv: Type = 54;
  pub const ProcessorSetIdle: Type = 55;
  pub const LogicalProcessorIdling: Type = 56;
  pub const UserPresence: Type = 57;
  pub const PowerSettingNotificationName: Type = 58;
  pub const GetPowerSettingValue: Type = 59;
  pub const IdleResiliency: Type = 60;
  pub const SessionRITState: Type = 61;
  pub const SessionConnectNotification: Type = 62;
  pub const SessionPowerCleanup: Type = 63;
  pub const SessionLockState: Type = 64;
  pub const SystemHiberbootState: Type = 65;
  pub const PlatformInformation: Type = 66;
  pub const PdcInvocation: Type = 67;
  pub const MonitorInvocation: Type = 68;
  pub const FirmwareTableInformationRegistered: Type = 69;
  pub const SetShutdownSelectedTime: Type = 70;
  pub const SuspendResumeInvocation: Type = 71;
  pub const PlmPowerRequestCreate: Type = 72;
  pub const ScreenOff: Type = 73;
  pub const CsDeviceNotification: Type = 74;
  pub const PlatformRole: Type = 75;
  pub const LastResumePerformance: Type = 76;
  pub const DisplayBurst: Type = 77;
  pub const ExitLatencySamplingPercentage: Type = 78;
  pub const RegisterSpmPowerSettings: Type = 79;
  pub const PlatformIdleStates: Type = 80;
  pub const ProcessorIdleVeto: Type = 81;
  pub const PlatformIdleVeto: Type = 82;
  pub const SystemBatteryStatePrecise: Type = 83;
  pub const ThermalEvent: Type = 84;
  pub const PowerRequestActionInternal: Type = 85;
  pub const BatteryDeviceState: Type = 86;
  pub const PowerInformationInternal: Type = 87;
  pub const ThermalStandby: Type = 88;
  pub const SystemHiberFileType: Type = 89;
  pub const PhysicalPowerButtonPress: Type = 90;
  pub const QueryPotentialDripsConstraint: Type = 91;
  pub const EnergyTrackerCreate: Type = 92;
  pub const EnergyTrackerQuery: Type = 93;
  pub const UpdateBlackBoxRecorder: Type = 94;
  pub const PowerInformationLevelMaximum: Type = 95;
}
pub mod POWER_USER_PRESENCE_TYPE {
  pub type Type = i32;
  pub const UserNotPresent: Type = 0;
  pub const UserPresent: Type = 1;
  pub const UserUnknown: Type = 255;
}
pub type PPOWER_USER_PRESENCE_TYPE = *mut POWER_USER_PRESENCE_TYPE::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _POWER_USER_PRESENCE {
  pub UserPresence: POWER_USER_PRESENCE_TYPE::Type,
}
#[test]
fn bindgen_test_layout__POWER_USER_PRESENCE() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_USER_PRESENCE>(),
    4usize,
    concat!("Size of: ", stringify!(_POWER_USER_PRESENCE))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_USER_PRESENCE>(),
    4usize,
    concat!("Alignment of ", stringify!(_POWER_USER_PRESENCE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_USER_PRESENCE>())).UserPresence as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_USER_PRESENCE),
      "::",
      stringify!(UserPresence)
    )
  );
}
impl Default for _POWER_USER_PRESENCE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POWER_SESSION_CONNECT {
  pub Connected: BOOLEAN,
  pub Console: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_CONNECT() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_SESSION_CONNECT>(),
    2usize,
    concat!("Size of: ", stringify!(_POWER_SESSION_CONNECT))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_SESSION_CONNECT>(),
    1usize,
    concat!("Alignment of ", stringify!(_POWER_SESSION_CONNECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_SESSION_CONNECT>())).Connected as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_CONNECT),
      "::",
      stringify!(Connected)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_SESSION_CONNECT>())).Console as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_CONNECT),
      "::",
      stringify!(Console)
    )
  );
}
pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POWER_SESSION_TIMEOUTS {
  pub InputTimeout: DWORD,
  pub DisplayTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_TIMEOUTS() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_SESSION_TIMEOUTS>(),
    8usize,
    concat!("Size of: ", stringify!(_POWER_SESSION_TIMEOUTS))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_SESSION_TIMEOUTS>(),
    4usize,
    concat!("Alignment of ", stringify!(_POWER_SESSION_TIMEOUTS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_POWER_SESSION_TIMEOUTS>())).InputTimeout as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_TIMEOUTS),
      "::",
      stringify!(InputTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_POWER_SESSION_TIMEOUTS>())).DisplayTimeout as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_TIMEOUTS),
      "::",
      stringify!(DisplayTimeout)
    )
  );
}
pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POWER_SESSION_RIT_STATE {
  pub Active: BOOLEAN,
  pub LastInputTime: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_RIT_STATE() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_SESSION_RIT_STATE>(),
    8usize,
    concat!("Size of: ", stringify!(_POWER_SESSION_RIT_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_SESSION_RIT_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_POWER_SESSION_RIT_STATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_SESSION_RIT_STATE>())).Active as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_RIT_STATE),
      "::",
      stringify!(Active)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_POWER_SESSION_RIT_STATE>())).LastInputTime as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_RIT_STATE),
      "::",
      stringify!(LastInputTime)
    )
  );
}
pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POWER_SESSION_WINLOGON {
  pub SessionId: DWORD,
  pub Console: BOOLEAN,
  pub Locked: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_WINLOGON() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_SESSION_WINLOGON>(),
    8usize,
    concat!("Size of: ", stringify!(_POWER_SESSION_WINLOGON))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_SESSION_WINLOGON>(),
    4usize,
    concat!("Alignment of ", stringify!(_POWER_SESSION_WINLOGON))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_SESSION_WINLOGON>())).SessionId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_WINLOGON),
      "::",
      stringify!(SessionId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_SESSION_WINLOGON>())).Console as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_WINLOGON),
      "::",
      stringify!(Console)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_SESSION_WINLOGON>())).Locked as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_SESSION_WINLOGON),
      "::",
      stringify!(Locked)
    )
  );
}
pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POWER_IDLE_RESILIENCY {
  pub CoalescingTimeout: DWORD,
  pub IdleResiliencyPeriod: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_IDLE_RESILIENCY() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_IDLE_RESILIENCY>(),
    8usize,
    concat!("Size of: ", stringify!(_POWER_IDLE_RESILIENCY))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_IDLE_RESILIENCY>(),
    4usize,
    concat!("Alignment of ", stringify!(_POWER_IDLE_RESILIENCY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_POWER_IDLE_RESILIENCY>())).CoalescingTimeout as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_IDLE_RESILIENCY),
      "::",
      stringify!(CoalescingTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_POWER_IDLE_RESILIENCY>())).IdleResiliencyPeriod as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_IDLE_RESILIENCY),
      "::",
      stringify!(IdleResiliencyPeriod)
    )
  );
}
pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
pub mod POWER_MONITOR_REQUEST_REASON {
  pub type Type = i32;
  pub const MonitorRequestReasonUnknown: Type = 0;
  pub const MonitorRequestReasonPowerButton: Type = 1;
  pub const MonitorRequestReasonRemoteConnection: Type = 2;
  pub const MonitorRequestReasonScMonitorpower: Type = 3;
  pub const MonitorRequestReasonUserInput: Type = 4;
  pub const MonitorRequestReasonAcDcDisplayBurst: Type = 5;
  pub const MonitorRequestReasonUserDisplayBurst: Type = 6;
  pub const MonitorRequestReasonPoSetSystemState: Type = 7;
  pub const MonitorRequestReasonSetThreadExecutionState: Type = 8;
  pub const MonitorRequestReasonFullWake: Type = 9;
  pub const MonitorRequestReasonSessionUnlock: Type = 10;
  pub const MonitorRequestReasonScreenOffRequest: Type = 11;
  pub const MonitorRequestReasonIdleTimeout: Type = 12;
  pub const MonitorRequestReasonPolicyChange: Type = 13;
  pub const MonitorRequestReasonSleepButton: Type = 14;
  pub const MonitorRequestReasonLid: Type = 15;
  pub const MonitorRequestReasonBatteryCountChange: Type = 16;
  pub const MonitorRequestReasonGracePeriod: Type = 17;
  pub const MonitorRequestReasonPnP: Type = 18;
  pub const MonitorRequestReasonDP: Type = 19;
  pub const MonitorRequestReasonSxTransition: Type = 20;
  pub const MonitorRequestReasonSystemIdle: Type = 21;
  pub const MonitorRequestReasonNearProximity: Type = 22;
  pub const MonitorRequestReasonThermalStandby: Type = 23;
  pub const MonitorRequestReasonResumePdc: Type = 24;
  pub const MonitorRequestReasonResumeS4: Type = 25;
  pub const MonitorRequestReasonTerminal: Type = 26;
  pub const MonitorRequestReasonPdcSignal: Type = 27;
  pub const MonitorRequestReasonAcDcDisplayBurstSuppressed: Type = 28;
  pub const MonitorRequestReasonSystemStateEntered: Type = 29;
  pub const MonitorRequestReasonWinrt: Type = 30;
  pub const MonitorRequestReasonUserInputKeyboard: Type = 31;
  pub const MonitorRequestReasonUserInputMouse: Type = 32;
  pub const MonitorRequestReasonUserInputTouch: Type = 33;
  pub const MonitorRequestReasonUserInputPen: Type = 34;
  pub const MonitorRequestReasonUserInputAccelerometer: Type = 35;
  pub const MonitorRequestReasonUserInputHid: Type = 36;
  pub const MonitorRequestReasonUserInputPoUserPresent: Type = 37;
  pub const MonitorRequestReasonUserInputSessionSwitch: Type = 38;
  pub const MonitorRequestReasonUserInputInitialization: Type = 39;
  pub const MonitorRequestReasonPdcSignalWindowsMobilePwrNotif: Type = 40;
  pub const MonitorRequestReasonPdcSignalWindowsMobileShell: Type = 41;
  pub const MonitorRequestReasonPdcSignalHeyCortana: Type = 42;
  pub const MonitorRequestReasonPdcSignalHolographicShell: Type = 43;
  pub const MonitorRequestReasonMax: Type = 44;
}
pub mod _POWER_MONITOR_REQUEST_TYPE {
  pub type Type = i32;
  pub const MonitorRequestTypeOff: Type = 0;
  pub const MonitorRequestTypeOnAndPresent: Type = 1;
  pub const MonitorRequestTypeToggleOn: Type = 2;
}
pub use self::_POWER_MONITOR_REQUEST_TYPE::Type as POWER_MONITOR_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _POWER_MONITOR_INVOCATION {
  pub Console: BOOLEAN,
  pub RequestReason: POWER_MONITOR_REQUEST_REASON::Type,
}
#[test]
fn bindgen_test_layout__POWER_MONITOR_INVOCATION() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_MONITOR_INVOCATION>(),
    8usize,
    concat!("Size of: ", stringify!(_POWER_MONITOR_INVOCATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_MONITOR_INVOCATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_POWER_MONITOR_INVOCATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_MONITOR_INVOCATION>())).Console as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_MONITOR_INVOCATION),
      "::",
      stringify!(Console)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_POWER_MONITOR_INVOCATION>())).RequestReason as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_MONITOR_INVOCATION),
      "::",
      stringify!(RequestReason)
    )
  );
}
impl Default for _POWER_MONITOR_INVOCATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RESUME_PERFORMANCE {
  pub PostTimeMs: DWORD,
  pub TotalResumeTimeMs: ULONGLONG,
  pub ResumeCompleteTimestamp: ULONGLONG,
}
#[test]
fn bindgen_test_layout__RESUME_PERFORMANCE() {
  assert_eq!(
    ::core::mem::size_of::<_RESUME_PERFORMANCE>(),
    24usize,
    concat!("Size of: ", stringify!(_RESUME_PERFORMANCE))
  );
  assert_eq!(
    ::core::mem::align_of::<_RESUME_PERFORMANCE>(),
    8usize,
    concat!("Alignment of ", stringify!(_RESUME_PERFORMANCE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RESUME_PERFORMANCE>())).PostTimeMs as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESUME_PERFORMANCE),
      "::",
      stringify!(PostTimeMs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESUME_PERFORMANCE>())).TotalResumeTimeMs as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESUME_PERFORMANCE),
      "::",
      stringify!(TotalResumeTimeMs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESUME_PERFORMANCE>())).ResumeCompleteTimestamp as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESUME_PERFORMANCE),
      "::",
      stringify!(ResumeCompleteTimestamp)
    )
  );
}
pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
pub mod SYSTEM_POWER_CONDITION {
  pub type Type = i32;
  pub const PoAc: Type = 0;
  pub const PoDc: Type = 1;
  pub const PoHot: Type = 2;
  pub const PoConditionMaximum: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SET_POWER_SETTING_VALUE {
  pub Version: DWORD,
  pub Guid: GUID,
  pub PowerCondition: SYSTEM_POWER_CONDITION::Type,
  pub DataLength: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_SET_POWER_SETTING_VALUE() {
  assert_eq!(
    ::core::mem::size_of::<SET_POWER_SETTING_VALUE>(),
    32usize,
    concat!("Size of: ", stringify!(SET_POWER_SETTING_VALUE))
  );
  assert_eq!(
    ::core::mem::align_of::<SET_POWER_SETTING_VALUE>(),
    4usize,
    concat!("Alignment of ", stringify!(SET_POWER_SETTING_VALUE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SET_POWER_SETTING_VALUE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SET_POWER_SETTING_VALUE>())).Guid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Guid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SET_POWER_SETTING_VALUE>())).PowerCondition as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(PowerCondition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SET_POWER_SETTING_VALUE>())).DataLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(DataLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SET_POWER_SETTING_VALUE>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Data)
    )
  );
}
impl Default for SET_POWER_SETTING_VALUE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PSET_POWER_SETTING_VALUE = *mut SET_POWER_SETTING_VALUE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct NOTIFY_USER_POWER_SETTING {
  pub Guid: GUID,
}
#[test]
fn bindgen_test_layout_NOTIFY_USER_POWER_SETTING() {
  assert_eq!(
    ::core::mem::size_of::<NOTIFY_USER_POWER_SETTING>(),
    16usize,
    concat!("Size of: ", stringify!(NOTIFY_USER_POWER_SETTING))
  );
  assert_eq!(
    ::core::mem::align_of::<NOTIFY_USER_POWER_SETTING>(),
    4usize,
    concat!("Alignment of ", stringify!(NOTIFY_USER_POWER_SETTING))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<NOTIFY_USER_POWER_SETTING>())).Guid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(NOTIFY_USER_POWER_SETTING),
      "::",
      stringify!(Guid)
    )
  );
}
pub type PNOTIFY_USER_POWER_SETTING = *mut NOTIFY_USER_POWER_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
  pub ActivationTime: LARGE_INTEGER,
  pub Flags: DWORD,
  pub ButtonInstanceID: DWORD,
}
#[test]
fn bindgen_test_layout__APPLICATIONLAUNCH_SETTING_VALUE() {
  assert_eq!(
    ::core::mem::size_of::<_APPLICATIONLAUNCH_SETTING_VALUE>(),
    16usize,
    concat!("Size of: ", stringify!(_APPLICATIONLAUNCH_SETTING_VALUE))
  );
  assert_eq!(
    ::core::mem::align_of::<_APPLICATIONLAUNCH_SETTING_VALUE>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_APPLICATIONLAUNCH_SETTING_VALUE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APPLICATIONLAUNCH_SETTING_VALUE>())).ActivationTime as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
      "::",
      stringify!(ActivationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APPLICATIONLAUNCH_SETTING_VALUE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APPLICATIONLAUNCH_SETTING_VALUE>())).ButtonInstanceID as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
      "::",
      stringify!(ButtonInstanceID)
    )
  );
}
impl Default for _APPLICATIONLAUNCH_SETTING_VALUE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _APPLICATIONLAUNCH_SETTING_VALUE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_APPLICATIONLAUNCH_SETTING_VALUE {{ ActivationTime: {:?}, Flags: {:?}, ButtonInstanceID: {:?} }}" , self . ActivationTime , self . Flags , self . ButtonInstanceID )
  }
}
pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE = *mut _APPLICATIONLAUNCH_SETTING_VALUE;
pub mod _POWER_PLATFORM_ROLE {
  pub type Type = i32;
  pub const PlatformRoleUnspecified: Type = 0;
  pub const PlatformRoleDesktop: Type = 1;
  pub const PlatformRoleMobile: Type = 2;
  pub const PlatformRoleWorkstation: Type = 3;
  pub const PlatformRoleEnterpriseServer: Type = 4;
  pub const PlatformRoleSOHOServer: Type = 5;
  pub const PlatformRoleAppliancePC: Type = 6;
  pub const PlatformRolePerformanceServer: Type = 7;
  pub const PlatformRoleSlate: Type = 8;
  pub const PlatformRoleMaximum: Type = 9;
}
pub use self::_POWER_PLATFORM_ROLE::Type as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE::Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POWER_PLATFORM_INFORMATION {
  pub AoAc: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_PLATFORM_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_POWER_PLATFORM_INFORMATION>(),
    1usize,
    concat!("Size of: ", stringify!(_POWER_PLATFORM_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_POWER_PLATFORM_INFORMATION>(),
    1usize,
    concat!("Alignment of ", stringify!(_POWER_PLATFORM_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POWER_PLATFORM_INFORMATION>())).AoAc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POWER_PLATFORM_INFORMATION),
      "::",
      stringify!(AoAc)
    )
  );
}
pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BATTERY_REPORTING_SCALE {
  pub Granularity: DWORD,
  pub Capacity: DWORD,
}
#[test]
fn bindgen_test_layout_BATTERY_REPORTING_SCALE() {
  assert_eq!(
    ::core::mem::size_of::<BATTERY_REPORTING_SCALE>(),
    8usize,
    concat!("Size of: ", stringify!(BATTERY_REPORTING_SCALE))
  );
  assert_eq!(
    ::core::mem::align_of::<BATTERY_REPORTING_SCALE>(),
    4usize,
    concat!("Alignment of ", stringify!(BATTERY_REPORTING_SCALE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<BATTERY_REPORTING_SCALE>())).Granularity as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(BATTERY_REPORTING_SCALE),
      "::",
      stringify!(Granularity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BATTERY_REPORTING_SCALE>())).Capacity as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(BATTERY_REPORTING_SCALE),
      "::",
      stringify!(Capacity)
    )
  );
}
pub type PBATTERY_REPORTING_SCALE = *mut BATTERY_REPORTING_SCALE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_WMI_LEGACY_PERFSTATE {
  pub Frequency: DWORD,
  pub Flags: DWORD,
  pub PercentFrequency: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_WMI_LEGACY_PERFSTATE() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_LEGACY_PERFSTATE>(),
    12usize,
    concat!("Size of: ", stringify!(PPM_WMI_LEGACY_PERFSTATE))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_LEGACY_PERFSTATE>(),
    4usize,
    concat!("Alignment of ", stringify!(PPM_WMI_LEGACY_PERFSTATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_LEGACY_PERFSTATE>())).Frequency as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_LEGACY_PERFSTATE),
      "::",
      stringify!(Frequency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_LEGACY_PERFSTATE>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_LEGACY_PERFSTATE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_LEGACY_PERFSTATE>())).PercentFrequency as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_LEGACY_PERFSTATE),
      "::",
      stringify!(PercentFrequency)
    )
  );
}
pub type PPPM_WMI_LEGACY_PERFSTATE = *mut PPM_WMI_LEGACY_PERFSTATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_WMI_IDLE_STATE {
  pub Latency: DWORD,
  pub Power: DWORD,
  pub TimeCheck: DWORD,
  pub PromotePercent: BYTE,
  pub DemotePercent: BYTE,
  pub StateType: BYTE,
  pub Reserved: BYTE,
  pub StateFlags: DWORD,
  pub Context: DWORD,
  pub IdleHandler: DWORD,
  pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATE() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_IDLE_STATE>(),
    32usize,
    concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_IDLE_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).Latency as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(Latency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).Power as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(Power)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).TimeCheck as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(TimeCheck)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).PromotePercent as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(PromotePercent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).DemotePercent as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(DemotePercent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).StateType as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(StateType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).Reserved as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).StateFlags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(StateFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).Context as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(Context)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).IdleHandler as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(IdleHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATE>())).Reserved1 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATE),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type PPPM_WMI_IDLE_STATE = *mut PPM_WMI_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_WMI_IDLE_STATES {
  pub Type: DWORD,
  pub Count: DWORD,
  pub TargetState: DWORD,
  pub OldState: DWORD,
  pub TargetProcessors: DWORD64,
  pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATES() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_IDLE_STATES>(),
    56usize,
    concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATES))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_IDLE_STATES>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES>())).Count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES>())).TargetState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES),
      "::",
      stringify!(TargetState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES>())).OldState as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES),
      "::",
      stringify!(OldState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES>())).TargetProcessors as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES),
      "::",
      stringify!(TargetProcessors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES>())).State as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES),
      "::",
      stringify!(State)
    )
  );
}
pub type PPPM_WMI_IDLE_STATES = *mut PPM_WMI_IDLE_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct PPM_WMI_IDLE_STATES_EX {
  pub Type: DWORD,
  pub Count: DWORD,
  pub TargetState: DWORD,
  pub OldState: DWORD,
  pub TargetProcessors: PVOID,
  pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATES_EX() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_IDLE_STATES_EX>(),
    56usize,
    concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATES_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_IDLE_STATES_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATES_EX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES_EX),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).Count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES_EX),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).TargetState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES_EX),
      "::",
      stringify!(TargetState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).OldState as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES_EX),
      "::",
      stringify!(OldState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).TargetProcessors as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES_EX),
      "::",
      stringify!(TargetProcessors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).State as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_IDLE_STATES_EX),
      "::",
      stringify!(State)
    )
  );
}
impl Default for PPM_WMI_IDLE_STATES_EX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PPPM_WMI_IDLE_STATES_EX = *mut PPM_WMI_IDLE_STATES_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_WMI_PERF_STATE {
  pub Frequency: DWORD,
  pub Power: DWORD,
  pub PercentFrequency: BYTE,
  pub IncreaseLevel: BYTE,
  pub DecreaseLevel: BYTE,
  pub Type: BYTE,
  pub IncreaseTime: DWORD,
  pub DecreaseTime: DWORD,
  pub Control: DWORD64,
  pub Status: DWORD64,
  pub HitCount: DWORD,
  pub Reserved1: DWORD,
  pub Reserved2: DWORD64,
  pub Reserved3: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATE() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_PERF_STATE>(),
    64usize,
    concat!("Size of: ", stringify!(PPM_WMI_PERF_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_PERF_STATE>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Frequency as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Frequency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Power as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Power)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).PercentFrequency as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(PercentFrequency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).IncreaseLevel as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(IncreaseLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).DecreaseLevel as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(DecreaseLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Type as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).IncreaseTime as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(IncreaseTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).DecreaseTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(DecreaseTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Control as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Status as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Status)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).HitCount as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(HitCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Reserved1 as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Reserved2 as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATE>())).Reserved3 as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATE),
      "::",
      stringify!(Reserved3)
    )
  );
}
pub type PPPM_WMI_PERF_STATE = *mut PPM_WMI_PERF_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_WMI_PERF_STATES {
  pub Count: DWORD,
  pub MaxFrequency: DWORD,
  pub CurrentState: DWORD,
  pub MaxPerfState: DWORD,
  pub MinPerfState: DWORD,
  pub LowestPerfState: DWORD,
  pub ThermalConstraint: DWORD,
  pub BusyAdjThreshold: BYTE,
  pub PolicyType: BYTE,
  pub Type: BYTE,
  pub Reserved: BYTE,
  pub TimerInterval: DWORD,
  pub TargetProcessors: DWORD64,
  pub PStateHandler: DWORD,
  pub PStateContext: DWORD,
  pub TStateHandler: DWORD,
  pub TStateContext: DWORD,
  pub FeedbackHandler: DWORD,
  pub Reserved1: DWORD,
  pub Reserved2: DWORD64,
  pub State: [PPM_WMI_PERF_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATES() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_PERF_STATES>(),
    144usize,
    concat!("Size of: ", stringify!(PPM_WMI_PERF_STATES))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_PERF_STATES>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).MaxFrequency as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(MaxFrequency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).CurrentState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(CurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).MaxPerfState as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(MaxPerfState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).MinPerfState as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(MinPerfState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).LowestPerfState as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(LowestPerfState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).ThermalConstraint as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(ThermalConstraint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).BusyAdjThreshold as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(BusyAdjThreshold)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).PolicyType as *const _ as usize },
    29usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(PolicyType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).Type as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).Reserved as *const _ as usize },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).TimerInterval as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(TimerInterval)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).TargetProcessors as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(TargetProcessors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).PStateHandler as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(PStateHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).PStateContext as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(PStateContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).TStateHandler as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(TStateHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).TStateContext as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(TStateContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).FeedbackHandler as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(FeedbackHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).Reserved1 as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).Reserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES>())).State as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES),
      "::",
      stringify!(State)
    )
  );
}
pub type PPPM_WMI_PERF_STATES = *mut PPM_WMI_PERF_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct PPM_WMI_PERF_STATES_EX {
  pub Count: DWORD,
  pub MaxFrequency: DWORD,
  pub CurrentState: DWORD,
  pub MaxPerfState: DWORD,
  pub MinPerfState: DWORD,
  pub LowestPerfState: DWORD,
  pub ThermalConstraint: DWORD,
  pub BusyAdjThreshold: BYTE,
  pub PolicyType: BYTE,
  pub Type: BYTE,
  pub Reserved: BYTE,
  pub TimerInterval: DWORD,
  pub TargetProcessors: PVOID,
  pub PStateHandler: DWORD,
  pub PStateContext: DWORD,
  pub TStateHandler: DWORD,
  pub TStateContext: DWORD,
  pub FeedbackHandler: DWORD,
  pub Reserved1: DWORD,
  pub Reserved2: DWORD64,
  pub State: [PPM_WMI_PERF_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATES_EX() {
  assert_eq!(
    ::core::mem::size_of::<PPM_WMI_PERF_STATES_EX>(),
    144usize,
    concat!("Size of: ", stringify!(PPM_WMI_PERF_STATES_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_WMI_PERF_STATES_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATES_EX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).MaxFrequency as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(MaxFrequency)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).CurrentState as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(CurrentState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).MaxPerfState as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(MaxPerfState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).MinPerfState as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(MinPerfState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).LowestPerfState as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(LowestPerfState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).ThermalConstraint as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(ThermalConstraint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).BusyAdjThreshold as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(BusyAdjThreshold)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).PolicyType as *const _ as usize },
    29usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(PolicyType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Type as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Reserved as *const _ as usize },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TimerInterval as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(TimerInterval)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TargetProcessors as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(TargetProcessors)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).PStateHandler as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(PStateHandler)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).PStateContext as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(PStateContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TStateHandler as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(TStateHandler)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TStateContext as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(TStateContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).FeedbackHandler as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(FeedbackHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Reserved1 as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Reserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_WMI_PERF_STATES_EX>())).State as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_WMI_PERF_STATES_EX),
      "::",
      stringify!(State)
    )
  );
}
impl Default for PPM_WMI_PERF_STATES_EX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PPPM_WMI_PERF_STATES_EX = *mut PPM_WMI_PERF_STATES_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_IDLE_STATE_ACCOUNTING {
  pub IdleTransitions: DWORD,
  pub FailedTransitions: DWORD,
  pub InvalidBucketIndex: DWORD,
  pub TotalTime: DWORD64,
  pub IdleTimeBuckets: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_ACCOUNTING() {
  assert_eq!(
    ::core::mem::size_of::<PPM_IDLE_STATE_ACCOUNTING>(),
    48usize,
    concat!("Size of: ", stringify!(PPM_IDLE_STATE_ACCOUNTING))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_IDLE_STATE_ACCOUNTING>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_IDLE_STATE_ACCOUNTING))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).IdleTransitions as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING),
      "::",
      stringify!(IdleTransitions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).FailedTransitions as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING),
      "::",
      stringify!(FailedTransitions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).InvalidBucketIndex as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING),
      "::",
      stringify!(InvalidBucketIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).TotalTime as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING),
      "::",
      stringify!(TotalTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).IdleTimeBuckets as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING),
      "::",
      stringify!(IdleTimeBuckets)
    )
  );
}
pub type PPPM_IDLE_STATE_ACCOUNTING = *mut PPM_IDLE_STATE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_IDLE_ACCOUNTING {
  pub StateCount: DWORD,
  pub TotalTransitions: DWORD,
  pub ResetCount: DWORD,
  pub StartTime: DWORD64,
  pub State: [PPM_IDLE_STATE_ACCOUNTING; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_ACCOUNTING() {
  assert_eq!(
    ::core::mem::size_of::<PPM_IDLE_ACCOUNTING>(),
    72usize,
    concat!("Size of: ", stringify!(PPM_IDLE_ACCOUNTING))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_IDLE_ACCOUNTING>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_IDLE_ACCOUNTING))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING>())).StateCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING),
      "::",
      stringify!(StateCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING>())).TotalTransitions as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING),
      "::",
      stringify!(TotalTransitions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING>())).ResetCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING),
      "::",
      stringify!(ResetCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING>())).StartTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING),
      "::",
      stringify!(StartTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING>())).State as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING),
      "::",
      stringify!(State)
    )
  );
}
pub type PPPM_IDLE_ACCOUNTING = *mut PPM_IDLE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_IDLE_STATE_BUCKET_EX {
  pub TotalTimeUs: DWORD64,
  pub MinTimeUs: DWORD,
  pub MaxTimeUs: DWORD,
  pub Count: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_BUCKET_EX() {
  assert_eq!(
    ::core::mem::size_of::<PPM_IDLE_STATE_BUCKET_EX>(),
    24usize,
    concat!("Size of: ", stringify!(PPM_IDLE_STATE_BUCKET_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_IDLE_STATE_BUCKET_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_IDLE_STATE_BUCKET_EX))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).TotalTimeUs as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_BUCKET_EX),
      "::",
      stringify!(TotalTimeUs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).MinTimeUs as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_BUCKET_EX),
      "::",
      stringify!(MinTimeUs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).MaxTimeUs as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_BUCKET_EX),
      "::",
      stringify!(MaxTimeUs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).Count as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_BUCKET_EX),
      "::",
      stringify!(Count)
    )
  );
}
pub type PPPM_IDLE_STATE_BUCKET_EX = *mut PPM_IDLE_STATE_BUCKET_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_IDLE_STATE_ACCOUNTING_EX {
  pub TotalTime: DWORD64,
  pub IdleTransitions: DWORD,
  pub FailedTransitions: DWORD,
  pub InvalidBucketIndex: DWORD,
  pub MinTimeUs: DWORD,
  pub MaxTimeUs: DWORD,
  pub CancelledTransitions: DWORD,
  pub IdleTimeBuckets: [PPM_IDLE_STATE_BUCKET_EX; 16usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_ACCOUNTING_EX() {
  assert_eq!(
    ::core::mem::size_of::<PPM_IDLE_STATE_ACCOUNTING_EX>(),
    416usize,
    concat!("Size of: ", stringify!(PPM_IDLE_STATE_ACCOUNTING_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_IDLE_STATE_ACCOUNTING_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_IDLE_STATE_ACCOUNTING_EX))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).TotalTime as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(TotalTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).IdleTransitions as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(IdleTransitions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).FailedTransitions as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(FailedTransitions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).InvalidBucketIndex as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(InvalidBucketIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).MinTimeUs as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(MinTimeUs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).MaxTimeUs as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(MaxTimeUs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).CancelledTransitions as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(CancelledTransitions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).IdleTimeBuckets as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
      "::",
      stringify!(IdleTimeBuckets)
    )
  );
}
pub type PPPM_IDLE_STATE_ACCOUNTING_EX = *mut PPM_IDLE_STATE_ACCOUNTING_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_IDLE_ACCOUNTING_EX {
  pub StateCount: DWORD,
  pub TotalTransitions: DWORD,
  pub ResetCount: DWORD,
  pub AbortCount: DWORD,
  pub StartTime: DWORD64,
  pub State: [PPM_IDLE_STATE_ACCOUNTING_EX; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_ACCOUNTING_EX() {
  assert_eq!(
    ::core::mem::size_of::<PPM_IDLE_ACCOUNTING_EX>(),
    440usize,
    concat!("Size of: ", stringify!(PPM_IDLE_ACCOUNTING_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_IDLE_ACCOUNTING_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_IDLE_ACCOUNTING_EX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).StateCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING_EX),
      "::",
      stringify!(StateCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).TotalTransitions as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING_EX),
      "::",
      stringify!(TotalTransitions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).ResetCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING_EX),
      "::",
      stringify!(ResetCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).AbortCount as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING_EX),
      "::",
      stringify!(AbortCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).StartTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING_EX),
      "::",
      stringify!(StartTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).State as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLE_ACCOUNTING_EX),
      "::",
      stringify!(State)
    )
  );
}
pub type PPPM_IDLE_ACCOUNTING_EX = *mut PPM_IDLE_ACCOUNTING_EX;
extern "C" {
  #[link_name = "\u{1}PPM_PERFSTATE_CHANGE_GUID"]
  pub static PPM_PERFSTATE_CHANGE_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_PERFSTATE_DOMAIN_CHANGE_GUID"]
  pub static PPM_PERFSTATE_DOMAIN_CHANGE_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_IDLESTATE_CHANGE_GUID"]
  pub static PPM_IDLESTATE_CHANGE_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_PERFSTATES_DATA_GUID"]
  pub static PPM_PERFSTATES_DATA_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_IDLESTATES_DATA_GUID"]
  pub static PPM_IDLESTATES_DATA_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_IDLE_ACCOUNTING_GUID"]
  pub static PPM_IDLE_ACCOUNTING_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_IDLE_ACCOUNTING_EX_GUID"]
  pub static PPM_IDLE_ACCOUNTING_EX_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_THERMALCONSTRAINT_GUID"]
  pub static PPM_THERMALCONSTRAINT_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_PERFMON_PERFSTATE_GUID"]
  pub static PPM_PERFMON_PERFSTATE_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}PPM_THERMAL_POLICY_CHANGE_GUID"]
  pub static PPM_THERMAL_POLICY_CHANGE_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_PERFSTATE_EVENT {
  pub State: DWORD,
  pub Status: DWORD,
  pub Latency: DWORD,
  pub Speed: DWORD,
  pub Processor: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_PERFSTATE_EVENT() {
  assert_eq!(
    ::core::mem::size_of::<PPM_PERFSTATE_EVENT>(),
    20usize,
    concat!("Size of: ", stringify!(PPM_PERFSTATE_EVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_PERFSTATE_EVENT>(),
    4usize,
    concat!("Alignment of ", stringify!(PPM_PERFSTATE_EVENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_EVENT>())).State as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_EVENT),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_EVENT>())).Status as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_EVENT),
      "::",
      stringify!(Status)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_EVENT>())).Latency as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_EVENT),
      "::",
      stringify!(Latency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_EVENT>())).Speed as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_EVENT),
      "::",
      stringify!(Speed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_EVENT>())).Processor as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_EVENT),
      "::",
      stringify!(Processor)
    )
  );
}
pub type PPPM_PERFSTATE_EVENT = *mut PPM_PERFSTATE_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_PERFSTATE_DOMAIN_EVENT {
  pub State: DWORD,
  pub Latency: DWORD,
  pub Speed: DWORD,
  pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_PERFSTATE_DOMAIN_EVENT() {
  assert_eq!(
    ::core::mem::size_of::<PPM_PERFSTATE_DOMAIN_EVENT>(),
    24usize,
    concat!("Size of: ", stringify!(PPM_PERFSTATE_DOMAIN_EVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_PERFSTATE_DOMAIN_EVENT>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_PERFSTATE_DOMAIN_EVENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).State as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).Latency as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
      "::",
      stringify!(Latency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).Speed as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
      "::",
      stringify!(Speed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).Processors as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
      "::",
      stringify!(Processors)
    )
  );
}
pub type PPPM_PERFSTATE_DOMAIN_EVENT = *mut PPM_PERFSTATE_DOMAIN_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_IDLESTATE_EVENT {
  pub NewState: DWORD,
  pub OldState: DWORD,
  pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_IDLESTATE_EVENT() {
  assert_eq!(
    ::core::mem::size_of::<PPM_IDLESTATE_EVENT>(),
    16usize,
    concat!("Size of: ", stringify!(PPM_IDLESTATE_EVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_IDLESTATE_EVENT>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_IDLESTATE_EVENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLESTATE_EVENT>())).NewState as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLESTATE_EVENT),
      "::",
      stringify!(NewState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLESTATE_EVENT>())).OldState as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLESTATE_EVENT),
      "::",
      stringify!(OldState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_IDLESTATE_EVENT>())).Processors as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_IDLESTATE_EVENT),
      "::",
      stringify!(Processors)
    )
  );
}
pub type PPPM_IDLESTATE_EVENT = *mut PPM_IDLESTATE_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_THERMALCHANGE_EVENT {
  pub ThermalConstraint: DWORD,
  pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_THERMALCHANGE_EVENT() {
  assert_eq!(
    ::core::mem::size_of::<PPM_THERMALCHANGE_EVENT>(),
    16usize,
    concat!("Size of: ", stringify!(PPM_THERMALCHANGE_EVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_THERMALCHANGE_EVENT>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_THERMALCHANGE_EVENT))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_THERMALCHANGE_EVENT>())).ThermalConstraint as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_THERMALCHANGE_EVENT),
      "::",
      stringify!(ThermalConstraint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_THERMALCHANGE_EVENT>())).Processors as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_THERMALCHANGE_EVENT),
      "::",
      stringify!(Processors)
    )
  );
}
pub type PPPM_THERMALCHANGE_EVENT = *mut PPM_THERMALCHANGE_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PPM_THERMAL_POLICY_EVENT {
  pub Mode: BYTE,
  pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_THERMAL_POLICY_EVENT() {
  assert_eq!(
    ::core::mem::size_of::<PPM_THERMAL_POLICY_EVENT>(),
    16usize,
    concat!("Size of: ", stringify!(PPM_THERMAL_POLICY_EVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<PPM_THERMAL_POLICY_EVENT>(),
    8usize,
    concat!("Alignment of ", stringify!(PPM_THERMAL_POLICY_EVENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PPM_THERMAL_POLICY_EVENT>())).Mode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_THERMAL_POLICY_EVENT),
      "::",
      stringify!(Mode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PPM_THERMAL_POLICY_EVENT>())).Processors as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PPM_THERMAL_POLICY_EVENT),
      "::",
      stringify!(Processors)
    )
  );
}
pub type PPPM_THERMAL_POLICY_EVENT = *mut PPM_THERMAL_POLICY_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct POWER_ACTION_POLICY {
  pub Action: POWER_ACTION::Type,
  pub Flags: DWORD,
  pub EventCode: DWORD,
}
#[test]
fn bindgen_test_layout_POWER_ACTION_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<POWER_ACTION_POLICY>(),
    12usize,
    concat!("Size of: ", stringify!(POWER_ACTION_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<POWER_ACTION_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(POWER_ACTION_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<POWER_ACTION_POLICY>())).Action as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<POWER_ACTION_POLICY>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<POWER_ACTION_POLICY>())).EventCode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(EventCode)
    )
  );
}
impl Default for POWER_ACTION_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PPOWER_ACTION_POLICY = *mut POWER_ACTION_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SYSTEM_POWER_LEVEL {
  pub Enable: BOOLEAN,
  pub Spare: [BYTE; 3usize],
  pub BatteryLevel: DWORD,
  pub PowerPolicy: POWER_ACTION_POLICY,
  pub MinSystemState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_LEVEL() {
  assert_eq!(
    ::core::mem::size_of::<SYSTEM_POWER_LEVEL>(),
    24usize,
    concat!("Size of: ", stringify!(SYSTEM_POWER_LEVEL))
  );
  assert_eq!(
    ::core::mem::align_of::<SYSTEM_POWER_LEVEL>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_POWER_LEVEL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_LEVEL>())).Enable as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(Enable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_LEVEL>())).Spare as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(Spare)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_LEVEL>())).BatteryLevel as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(BatteryLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_LEVEL>())).PowerPolicy as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(PowerPolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_LEVEL>())).MinSystemState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(MinSystemState)
    )
  );
}
impl Default for SYSTEM_POWER_LEVEL {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PSYSTEM_POWER_LEVEL = *mut SYSTEM_POWER_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SYSTEM_POWER_POLICY {
  pub Revision: DWORD,
  pub PowerButton: POWER_ACTION_POLICY,
  pub SleepButton: POWER_ACTION_POLICY,
  pub LidClose: POWER_ACTION_POLICY,
  pub LidOpenWake: SYSTEM_POWER_STATE,
  pub Reserved: DWORD,
  pub Idle: POWER_ACTION_POLICY,
  pub IdleTimeout: DWORD,
  pub IdleSensitivity: BYTE,
  pub DynamicThrottle: BYTE,
  pub Spare2: [BYTE; 2usize],
  pub MinSleep: SYSTEM_POWER_STATE,
  pub MaxSleep: SYSTEM_POWER_STATE,
  pub ReducedLatencySleep: SYSTEM_POWER_STATE,
  pub WinLogonFlags: DWORD,
  pub Spare3: DWORD,
  pub DozeS4Timeout: DWORD,
  pub BroadcastCapacityResolution: DWORD,
  pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
  pub VideoTimeout: DWORD,
  pub VideoDimDisplay: BOOLEAN,
  pub VideoReserved: [DWORD; 3usize],
  pub SpindownTimeout: DWORD,
  pub OptimizeForPower: BOOLEAN,
  pub FanThrottleTolerance: BYTE,
  pub ForcedThrottle: BYTE,
  pub MinThrottle: BYTE,
  pub OverThrottled: POWER_ACTION_POLICY,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_POWER_POLICY>(),
    232usize,
    concat!("Size of: ", stringify!(_SYSTEM_POWER_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_POWER_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_POWER_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).PowerButton as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(PowerButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).SleepButton as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(SleepButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).LidClose as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(LidClose)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).LidOpenWake as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(LidOpenWake)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).Reserved as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).Idle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Idle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleTimeout as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(IdleTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleSensitivity as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(IdleSensitivity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).DynamicThrottle as *const _ as usize
    },
    65usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DynamicThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Spare2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).MinSleep as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MinSleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).MaxSleep as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MaxSleep)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).ReducedLatencySleep as *const _ as usize
    },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(ReducedLatencySleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).WinLogonFlags as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(WinLogonFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare3 as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Spare3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).DozeS4Timeout as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DozeS4Timeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).BroadcastCapacityResolution as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(BroadcastCapacityResolution)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).DischargePolicy as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DischargePolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoTimeout as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoDimDisplay as *const _ as usize
    },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoDimDisplay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoReserved as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).SpindownTimeout as *const _ as usize
    },
    212usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(SpindownTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).OptimizeForPower as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(OptimizeForPower)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).FanThrottleTolerance as *const _ as usize
    },
    217usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(FanThrottleTolerance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).ForcedThrottle as *const _ as usize
    },
    218usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(ForcedThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).MinThrottle as *const _ as usize },
    219usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MinThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_POLICY>())).OverThrottled as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(OverThrottled)
    )
  );
}
impl Default for _SYSTEM_POWER_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY;
pub type PSYSTEM_POWER_POLICY = *mut _SYSTEM_POWER_POLICY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PROCESSOR_IDLESTATE_INFO {
  pub TimeCheck: DWORD,
  pub DemotePercent: BYTE,
  pub PromotePercent: BYTE,
  pub Spare: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_IDLESTATE_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(PROCESSOR_IDLESTATE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_IDLESTATE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(PROCESSOR_IDLESTATE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).TimeCheck as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_INFO),
      "::",
      stringify!(TimeCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).DemotePercent as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_INFO),
      "::",
      stringify!(DemotePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).PromotePercent as *const _ as usize
    },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_INFO),
      "::",
      stringify!(PromotePercent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).Spare as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_INFO),
      "::",
      stringify!(Spare)
    )
  );
}
pub type PPROCESSOR_IDLESTATE_INFO = *mut PROCESSOR_IDLESTATE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY {
  pub Revision: WORD,
  pub Flags: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1,
  pub PolicyCount: DWORD,
  pub Policy: [PROCESSOR_IDLESTATE_INFO; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
  pub AsWORD: WORD,
  pub __bindgen_anon_1: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Size of: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn AllowScaling(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set_AllowScaling(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Disabled(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set_Disabled(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 14u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    AllowScaling: WORD, Disabled: WORD, Reserved: WORD,
  ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let AllowScaling: u16 = unsafe { ::core::mem::transmute(AllowScaling) };
      AllowScaling as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let Disabled: u16 = unsafe { ::core::mem::transmute(Disabled) };
      Disabled as u64
    });
    __bindgen_bitfield_unit.set(2usize, 14u8, {
      let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>(),
    2usize,
    concat!(
      "Size of: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>())).AsWORD as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1),
      "::",
      stringify!(AsWORD)
    )
  );
}
impl Default for PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_IDLESTATE_POLICY>(),
    32usize,
    concat!("Size of: ", stringify!(PROCESSOR_IDLESTATE_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_IDLESTATE_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(PROCESSOR_IDLESTATE_POLICY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).Revision as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).PolicyCount as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY),
      "::",
      stringify!(PolicyCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).Policy as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_IDLESTATE_POLICY),
      "::",
      stringify!(Policy)
    )
  );
}
impl Default for PROCESSOR_IDLESTATE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for PROCESSOR_IDLESTATE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "PROCESSOR_IDLESTATE_POLICY {{ Revision: {:?}, Flags: {:?}, PolicyCount: {:?}, Policy: {:?} }}" , self . Revision , self . Flags , self . PolicyCount , self . Policy )
  }
}
pub type PPROCESSOR_IDLESTATE_POLICY = *mut PROCESSOR_IDLESTATE_POLICY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESSOR_POWER_POLICY_INFO {
  pub TimeCheck: DWORD,
  pub DemoteLimit: DWORD,
  pub PromoteLimit: DWORD,
  pub DemotePercent: BYTE,
  pub PromotePercent: BYTE,
  pub Spare: [BYTE; 2usize],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESSOR_POWER_POLICY_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESSOR_POWER_POLICY_INFO>(),
    20usize,
    concat!("Size of: ", stringify!(_PROCESSOR_POWER_POLICY_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESSOR_POWER_POLICY_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_POWER_POLICY_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).TimeCheck as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY_INFO),
      "::",
      stringify!(TimeCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).DemoteLimit as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY_INFO),
      "::",
      stringify!(DemoteLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).PromoteLimit as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY_INFO),
      "::",
      stringify!(PromoteLimit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).DemotePercent as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY_INFO),
      "::",
      stringify!(DemotePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).PromotePercent as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY_INFO),
      "::",
      stringify!(PromotePercent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).Spare as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY_INFO),
      "::",
      stringify!(Spare)
    )
  );
}
impl _PROCESSOR_POWER_POLICY_INFO {
  #[inline]
  pub fn AllowDemotion(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AllowDemotion(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllowPromotion(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AllowPromotion(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    AllowDemotion: DWORD, AllowPromotion: DWORD, Reserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let AllowDemotion: u32 = unsafe { ::core::mem::transmute(AllowDemotion) };
      AllowDemotion as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let AllowPromotion: u32 = unsafe { ::core::mem::transmute(AllowPromotion) };
      AllowPromotion as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type PROCESSOR_POWER_POLICY_INFO = _PROCESSOR_POWER_POLICY_INFO;
pub type PPROCESSOR_POWER_POLICY_INFO = *mut _PROCESSOR_POWER_POLICY_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESSOR_POWER_POLICY {
  pub Revision: DWORD,
  pub DynamicThrottle: BYTE,
  pub Spare: [BYTE; 3usize],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
  pub PolicyCount: DWORD,
  pub Policy: [PROCESSOR_POWER_POLICY_INFO; 3usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_POWER_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESSOR_POWER_POLICY>(),
    76usize,
    concat!("Size of: ", stringify!(_PROCESSOR_POWER_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESSOR_POWER_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_POWER_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY>())).DynamicThrottle as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY),
      "::",
      stringify!(DynamicThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY>())).Spare as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY),
      "::",
      stringify!(Spare)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY>())).PolicyCount as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY),
      "::",
      stringify!(PolicyCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESSOR_POWER_POLICY>())).Policy as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_POWER_POLICY),
      "::",
      stringify!(Policy)
    )
  );
}
impl _PROCESSOR_POWER_POLICY {
  #[inline]
  pub fn DisableCStates(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DisableCStates(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    DisableCStates: DWORD, Reserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let DisableCStates: u32 = unsafe { ::core::mem::transmute(DisableCStates) };
      DisableCStates as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type PROCESSOR_POWER_POLICY = _PROCESSOR_POWER_POLICY;
pub type PPROCESSOR_POWER_POLICY = *mut _PROCESSOR_POWER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY {
  pub Revision: DWORD,
  pub MaxThrottle: BYTE,
  pub MinThrottle: BYTE,
  pub BusyAdjThreshold: BYTE,
  pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1,
  pub TimeCheck: DWORD,
  pub IncreaseTime: DWORD,
  pub DecreaseTime: DWORD,
  pub IncreasePercent: DWORD,
  pub DecreasePercent: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
  pub Spare: BYTE,
  pub Flags: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  pub AsBYTE: BYTE,
  pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn NoDomainAccounting(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_NoDomainAccounting(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn IncreasePolicy(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
  }
  #[inline]
  pub fn set_IncreasePolicy(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn DecreasePolicy(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
  }
  #[inline]
  pub fn set_DecreasePolicy(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> BYTE {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 3u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    NoDomainAccounting: BYTE, IncreasePolicy: BYTE, DecreasePolicy: BYTE, Reserved: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let NoDomainAccounting: u8 = unsafe { ::core::mem::transmute(NoDomainAccounting) };
      NoDomainAccounting as u64
    });
    __bindgen_bitfield_unit.set(1usize, 2u8, {
      let IncreasePolicy: u8 = unsafe { ::core::mem::transmute(IncreasePolicy) };
      IncreasePolicy as u64
    });
    __bindgen_bitfield_unit.set(3usize, 2u8, {
      let DecreasePolicy: u8 = unsafe { ::core::mem::transmute(DecreasePolicy) };
      DecreasePolicy as u64
    });
    __bindgen_bitfield_unit.set(5usize, 3u8, {
      let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>())).AsBYTE
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AsBYTE)
    )
  );
}
impl Default for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>())).Spare as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Spare)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>())).Flags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<PROCESSOR_PERFSTATE_POLICY>(),
    28usize,
    concat!("Size of: ", stringify!(PROCESSOR_PERFSTATE_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESSOR_PERFSTATE_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(PROCESSOR_PERFSTATE_POLICY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).Revision as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).MaxThrottle as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(MaxThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).MinThrottle as *const _ as usize
    },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(MinThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).BusyAdjThreshold as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(BusyAdjThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).TimeCheck as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(TimeCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).IncreaseTime as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(IncreaseTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).DecreaseTime as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(DecreaseTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).IncreasePercent as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(IncreasePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).DecreasePercent as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESSOR_PERFSTATE_POLICY),
      "::",
      stringify!(DecreasePercent)
    )
  );
}
impl Default for PROCESSOR_PERFSTATE_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for PROCESSOR_PERFSTATE_POLICY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "PROCESSOR_PERFSTATE_POLICY {{ Revision: {:?}, MaxThrottle: {:?}, MinThrottle: {:?}, BusyAdjThreshold: {:?}, __bindgen_anon_1: {:?}, TimeCheck: {:?}, IncreaseTime: {:?}, DecreaseTime: {:?}, IncreasePercent: {:?}, DecreasePercent: {:?} }}" , self . Revision , self . MaxThrottle , self . MinThrottle , self . BusyAdjThreshold , self . __bindgen_anon_1 , self . TimeCheck , self . IncreaseTime , self . DecreaseTime , self . IncreasePercent , self . DecreasePercent )
  }
}
pub type PPROCESSOR_PERFSTATE_POLICY = *mut PROCESSOR_PERFSTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ADMINISTRATOR_POWER_POLICY {
  pub MinSleep: SYSTEM_POWER_STATE,
  pub MaxSleep: SYSTEM_POWER_STATE,
  pub MinVideoTimeout: DWORD,
  pub MaxVideoTimeout: DWORD,
  pub MinSpindownTimeout: DWORD,
  pub MaxSpindownTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__ADMINISTRATOR_POWER_POLICY() {
  assert_eq!(
    ::core::mem::size_of::<_ADMINISTRATOR_POWER_POLICY>(),
    24usize,
    concat!("Size of: ", stringify!(_ADMINISTRATOR_POWER_POLICY))
  );
  assert_eq!(
    ::core::mem::align_of::<_ADMINISTRATOR_POWER_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_ADMINISTRATOR_POWER_POLICY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MinSleep as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ADMINISTRATOR_POWER_POLICY),
      "::",
      stringify!(MinSleep)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MaxSleep as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ADMINISTRATOR_POWER_POLICY),
      "::",
      stringify!(MaxSleep)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MinVideoTimeout as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ADMINISTRATOR_POWER_POLICY),
      "::",
      stringify!(MinVideoTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MaxVideoTimeout as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ADMINISTRATOR_POWER_POLICY),
      "::",
      stringify!(MaxVideoTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MinSpindownTimeout as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ADMINISTRATOR_POWER_POLICY),
      "::",
      stringify!(MinSpindownTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MaxSpindownTimeout as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_ADMINISTRATOR_POWER_POLICY),
      "::",
      stringify!(MaxSpindownTimeout)
    )
  );
}
impl Default for _ADMINISTRATOR_POWER_POLICY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ADMINISTRATOR_POWER_POLICY = _ADMINISTRATOR_POWER_POLICY;
pub type PADMINISTRATOR_POWER_POLICY = *mut _ADMINISTRATOR_POWER_POLICY;
pub mod _HIBERFILE_BUCKET_SIZE {
  pub type Type = i32;
  pub const HiberFileBucket1GB: Type = 0;
  pub const HiberFileBucket2GB: Type = 1;
  pub const HiberFileBucket4GB: Type = 2;
  pub const HiberFileBucket8GB: Type = 3;
  pub const HiberFileBucket16GB: Type = 4;
  pub const HiberFileBucket32GB: Type = 5;
  pub const HiberFileBucketUnlimited: Type = 6;
  pub const HiberFileBucketMax: Type = 7;
}
pub use self::_HIBERFILE_BUCKET_SIZE::Type as HIBERFILE_BUCKET_SIZE;
pub type PHIBERFILE_BUCKET_SIZE = *mut _HIBERFILE_BUCKET_SIZE::Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _HIBERFILE_BUCKET {
  pub MaxPhysicalMemory: DWORD64,
  pub PhysicalMemoryPercent: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__HIBERFILE_BUCKET() {
  assert_eq!(
    ::core::mem::size_of::<_HIBERFILE_BUCKET>(),
    24usize,
    concat!("Size of: ", stringify!(_HIBERFILE_BUCKET))
  );
  assert_eq!(
    ::core::mem::align_of::<_HIBERFILE_BUCKET>(),
    8usize,
    concat!("Alignment of ", stringify!(_HIBERFILE_BUCKET))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_HIBERFILE_BUCKET>())).MaxPhysicalMemory as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HIBERFILE_BUCKET),
      "::",
      stringify!(MaxPhysicalMemory)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_HIBERFILE_BUCKET>())).PhysicalMemoryPercent as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HIBERFILE_BUCKET),
      "::",
      stringify!(PhysicalMemoryPercent)
    )
  );
}
pub type HIBERFILE_BUCKET = _HIBERFILE_BUCKET;
pub type PHIBERFILE_BUCKET = *mut _HIBERFILE_BUCKET;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SYSTEM_POWER_CAPABILITIES {
  pub PowerButtonPresent: BOOLEAN,
  pub SleepButtonPresent: BOOLEAN,
  pub LidPresent: BOOLEAN,
  pub SystemS1: BOOLEAN,
  pub SystemS2: BOOLEAN,
  pub SystemS3: BOOLEAN,
  pub SystemS4: BOOLEAN,
  pub SystemS5: BOOLEAN,
  pub HiberFilePresent: BOOLEAN,
  pub FullWake: BOOLEAN,
  pub VideoDimPresent: BOOLEAN,
  pub ApmPresent: BOOLEAN,
  pub UpsPresent: BOOLEAN,
  pub ThermalControl: BOOLEAN,
  pub ProcessorThrottle: BOOLEAN,
  pub ProcessorMinThrottle: BYTE,
  pub ProcessorMaxThrottle: BYTE,
  pub FastSystemS4: BOOLEAN,
  pub Hiberboot: BOOLEAN,
  pub WakeAlarmPresent: BOOLEAN,
  pub AoAc: BOOLEAN,
  pub DiskSpinDown: BOOLEAN,
  pub HiberFileType: BYTE,
  pub AoAcConnectivitySupported: BOOLEAN,
  pub spare3: [BYTE; 6usize],
  pub SystemBatteriesPresent: BOOLEAN,
  pub BatteriesAreShortTerm: BOOLEAN,
  pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
  pub AcOnLineWake: SYSTEM_POWER_STATE,
  pub SoftLidWake: SYSTEM_POWER_STATE,
  pub RtcWake: SYSTEM_POWER_STATE,
  pub MinDeviceWakeState: SYSTEM_POWER_STATE,
  pub DefaultLowLatencyWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_CAPABILITIES() {
  assert_eq!(
    ::core::mem::size_of::<SYSTEM_POWER_CAPABILITIES>(),
    76usize,
    concat!("Size of: ", stringify!(SYSTEM_POWER_CAPABILITIES))
  );
  assert_eq!(
    ::core::mem::align_of::<SYSTEM_POWER_CAPABILITIES>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_POWER_CAPABILITIES))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).PowerButtonPresent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(PowerButtonPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SleepButtonPresent as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SleepButtonPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).LidPresent as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(LidPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS1 as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS3 as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS4 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS4)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS5 as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFilePresent as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(HiberFilePresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FullWake as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(FullWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).VideoDimPresent as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(VideoDimPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ApmPresent as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ApmPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).UpsPresent as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(UpsPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ThermalControl as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ThermalControl)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorThrottle as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMinThrottle as *const _
        as usize
    },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorMinThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMaxThrottle as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorMaxThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FastSystemS4 as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(FastSystemS4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).Hiberboot as *const _ as usize
    },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(Hiberboot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).WakeAlarmPresent as *const _ as usize
    },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(WakeAlarmPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAc as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AoAc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DiskSpinDown as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(DiskSpinDown)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFileType as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(HiberFileType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAcConnectivitySupported as *const _
        as usize
    },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AoAcConnectivitySupported)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).spare3 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(spare3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemBatteriesPresent as *const _
        as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemBatteriesPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteriesAreShortTerm as *const _
        as usize
    },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(BatteriesAreShortTerm)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteryScale as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(BatteryScale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AcOnLineWake as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AcOnLineWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SoftLidWake as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SoftLidWake)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).RtcWake as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(RtcWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).MinDeviceWakeState as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(MinDeviceWakeState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DefaultLowLatencyWake as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(DefaultLowLatencyWake)
    )
  );
}
impl Default for SYSTEM_POWER_CAPABILITIES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PSYSTEM_POWER_CAPABILITIES = *mut SYSTEM_POWER_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SYSTEM_BATTERY_STATE {
  pub AcOnLine: BOOLEAN,
  pub BatteryPresent: BOOLEAN,
  pub Charging: BOOLEAN,
  pub Discharging: BOOLEAN,
  pub Spare1: [BOOLEAN; 3usize],
  pub Tag: BYTE,
  pub MaxCapacity: DWORD,
  pub RemainingCapacity: DWORD,
  pub Rate: DWORD,
  pub EstimatedTime: DWORD,
  pub DefaultAlert1: DWORD,
  pub DefaultAlert2: DWORD,
}
#[test]
fn bindgen_test_layout_SYSTEM_BATTERY_STATE() {
  assert_eq!(
    ::core::mem::size_of::<SYSTEM_BATTERY_STATE>(),
    32usize,
    concat!("Size of: ", stringify!(SYSTEM_BATTERY_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<SYSTEM_BATTERY_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_BATTERY_STATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).AcOnLine as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(AcOnLine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).BatteryPresent as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(BatteryPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).Charging as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Charging)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).Discharging as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Discharging)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).Spare1 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Spare1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).Tag as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Tag)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).MaxCapacity as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(MaxCapacity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).RemainingCapacity as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(RemainingCapacity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).Rate as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).EstimatedTime as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(EstimatedTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(DefaultAlert1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert2 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(DefaultAlert2)
    )
  );
}
pub type PSYSTEM_BATTERY_STATE = *mut SYSTEM_BATTERY_STATE;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DOS_HEADER {
  pub _bindgen_opaque_blob: [u16; 32usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DOS_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DOS_HEADER>(),
    64usize,
    concat!("Size of: ", stringify!(_IMAGE_DOS_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DOS_HEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_DOS_HEADER))
  );
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
pub type PIMAGE_DOS_HEADER = *mut _IMAGE_DOS_HEADER;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_OS2_HEADER {
  pub _bindgen_opaque_blob: [u16; 32usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OS2_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_OS2_HEADER>(),
    64usize,
    concat!("Size of: ", stringify!(_IMAGE_OS2_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_OS2_HEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_OS2_HEADER))
  );
}
pub type IMAGE_OS2_HEADER = _IMAGE_OS2_HEADER;
pub type PIMAGE_OS2_HEADER = *mut _IMAGE_OS2_HEADER;
#[repr(C)]
#[repr(align(2))]
pub struct _IMAGE_VXD_HEADER {
  pub _bindgen_opaque_blob: [u16; 98usize],
}
#[test]
fn bindgen_test_layout__IMAGE_VXD_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_VXD_HEADER>(),
    196usize,
    concat!("Size of: ", stringify!(_IMAGE_VXD_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_VXD_HEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_VXD_HEADER))
  );
}
impl Default for _IMAGE_VXD_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_VXD_HEADER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_VXD_HEADER {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_VXD_HEADER {
  fn eq(&self, other: &_IMAGE_VXD_HEADER) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_VXD_HEADER = _IMAGE_VXD_HEADER;
pub type PIMAGE_VXD_HEADER = *mut _IMAGE_VXD_HEADER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_FILE_HEADER {
  pub _bindgen_opaque_blob: [u32; 5usize],
}
#[test]
fn bindgen_test_layout__IMAGE_FILE_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_FILE_HEADER>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_FILE_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_FILE_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_FILE_HEADER))
  );
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
pub type PIMAGE_FILE_HEADER = *mut _IMAGE_FILE_HEADER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DATA_DIRECTORY {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DATA_DIRECTORY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DATA_DIRECTORY>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_DATA_DIRECTORY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DATA_DIRECTORY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_DATA_DIRECTORY))
  );
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
pub type PIMAGE_DATA_DIRECTORY = *mut _IMAGE_DATA_DIRECTORY;
#[repr(C)]
#[repr(align(4))]
pub struct _IMAGE_OPTIONAL_HEADER {
  pub _bindgen_opaque_blob: [u32; 56usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_OPTIONAL_HEADER>(),
    224usize,
    concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_OPTIONAL_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER))
  );
}
impl Default for _IMAGE_OPTIONAL_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_OPTIONAL_HEADER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_OPTIONAL_HEADER {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_OPTIONAL_HEADER {
  fn eq(&self, other: &_IMAGE_OPTIONAL_HEADER) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER;
pub type PIMAGE_OPTIONAL_HEADER32 = *mut _IMAGE_OPTIONAL_HEADER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ROM_OPTIONAL_HEADER {
  pub _bindgen_opaque_blob: [u32; 14usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ROM_OPTIONAL_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ROM_OPTIONAL_HEADER>(),
    56usize,
    concat!("Size of: ", stringify!(_IMAGE_ROM_OPTIONAL_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ROM_OPTIONAL_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_ROM_OPTIONAL_HEADER))
  );
}
pub type IMAGE_ROM_OPTIONAL_HEADER = _IMAGE_ROM_OPTIONAL_HEADER;
pub type PIMAGE_ROM_OPTIONAL_HEADER = *mut _IMAGE_ROM_OPTIONAL_HEADER;
#[repr(C)]
#[repr(align(4))]
pub struct _IMAGE_OPTIONAL_HEADER64 {
  pub _bindgen_opaque_blob: [u32; 60usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_OPTIONAL_HEADER64>(),
    240usize,
    concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_OPTIONAL_HEADER64>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER64))
  );
}
impl Default for _IMAGE_OPTIONAL_HEADER64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_OPTIONAL_HEADER64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_OPTIONAL_HEADER64 {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_OPTIONAL_HEADER64 {
  fn eq(&self, other: &_IMAGE_OPTIONAL_HEADER64) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER64 = *mut _IMAGE_OPTIONAL_HEADER64;
pub type IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER = PIMAGE_OPTIONAL_HEADER64;
#[repr(C)]
#[repr(align(4))]
pub struct _IMAGE_NT_HEADERS64 {
  pub _bindgen_opaque_blob: [u32; 66usize],
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_NT_HEADERS64>(),
    264usize,
    concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_NT_HEADERS64>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS64))
  );
}
impl Default for _IMAGE_NT_HEADERS64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_NT_HEADERS64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_NT_HEADERS64 {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_NT_HEADERS64 {
  fn eq(&self, other: &_IMAGE_NT_HEADERS64) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_NT_HEADERS64 = _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
#[repr(C)]
#[repr(align(4))]
pub struct _IMAGE_NT_HEADERS {
  pub _bindgen_opaque_blob: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_NT_HEADERS>(),
    248usize,
    concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_NT_HEADERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS))
  );
}
impl Default for _IMAGE_NT_HEADERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_NT_HEADERS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_NT_HEADERS {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_NT_HEADERS {
  fn eq(&self, other: &_IMAGE_NT_HEADERS) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS;
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ROM_HEADERS {
  pub _bindgen_opaque_blob: [u32; 19usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ROM_HEADERS() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ROM_HEADERS>(),
    76usize,
    concat!("Size of: ", stringify!(_IMAGE_ROM_HEADERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ROM_HEADERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_ROM_HEADERS))
  );
}
pub type IMAGE_ROM_HEADERS = _IMAGE_ROM_HEADERS;
pub type PIMAGE_ROM_HEADERS = *mut _IMAGE_ROM_HEADERS;
pub type IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ANON_OBJECT_HEADER {
  pub Sig1: WORD,
  pub Sig2: WORD,
  pub Version: WORD,
  pub Machine: WORD,
  pub TimeDateStamp: DWORD,
  pub ClassID: CLSID,
  pub SizeOfData: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<ANON_OBJECT_HEADER>(),
    32usize,
    concat!("Size of: ", stringify!(ANON_OBJECT_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<ANON_OBJECT_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).Sig1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(Sig1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).Sig2 as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(Sig2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).Version as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).Machine as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(Machine)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).TimeDateStamp as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(TimeDateStamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).ClassID as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(ClassID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER>())).SizeOfData as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER),
      "::",
      stringify!(SizeOfData)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ANON_OBJECT_HEADER_V2 {
  pub Sig1: WORD,
  pub Sig2: WORD,
  pub Version: WORD,
  pub Machine: WORD,
  pub TimeDateStamp: DWORD,
  pub ClassID: CLSID,
  pub SizeOfData: DWORD,
  pub Flags: DWORD,
  pub MetaDataSize: DWORD,
  pub MetaDataOffset: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER_V2() {
  assert_eq!(
    ::core::mem::size_of::<ANON_OBJECT_HEADER_V2>(),
    44usize,
    concat!("Size of: ", stringify!(ANON_OBJECT_HEADER_V2))
  );
  assert_eq!(
    ::core::mem::align_of::<ANON_OBJECT_HEADER_V2>(),
    4usize,
    concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER_V2))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).Sig1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(Sig1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).Sig2 as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(Sig2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).Version as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).Machine as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(Machine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).TimeDateStamp as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(TimeDateStamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).ClassID as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(ClassID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).SizeOfData as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(SizeOfData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).Flags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).MetaDataSize as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(MetaDataSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_V2>())).MetaDataOffset as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_V2),
      "::",
      stringify!(MetaDataOffset)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ANON_OBJECT_HEADER_BIGOBJ {
  pub Sig1: WORD,
  pub Sig2: WORD,
  pub Version: WORD,
  pub Machine: WORD,
  pub TimeDateStamp: DWORD,
  pub ClassID: CLSID,
  pub SizeOfData: DWORD,
  pub Flags: DWORD,
  pub MetaDataSize: DWORD,
  pub MetaDataOffset: DWORD,
  pub NumberOfSections: DWORD,
  pub PointerToSymbolTable: DWORD,
  pub NumberOfSymbols: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER_BIGOBJ() {
  assert_eq!(
    ::core::mem::size_of::<ANON_OBJECT_HEADER_BIGOBJ>(),
    56usize,
    concat!("Size of: ", stringify!(ANON_OBJECT_HEADER_BIGOBJ))
  );
  assert_eq!(
    ::core::mem::align_of::<ANON_OBJECT_HEADER_BIGOBJ>(),
    4usize,
    concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER_BIGOBJ))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Sig1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(Sig1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Sig2 as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(Sig2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Version as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Machine as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(Machine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).TimeDateStamp as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(TimeDateStamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).ClassID as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(ClassID)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).SizeOfData as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(SizeOfData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Flags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).MetaDataSize as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(MetaDataSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).MetaDataOffset as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(MetaDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).NumberOfSections as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(NumberOfSections)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).PointerToSymbolTable as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(PointerToSymbolTable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).NumberOfSymbols as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(ANON_OBJECT_HEADER_BIGOBJ),
      "::",
      stringify!(NumberOfSymbols)
    )
  );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_SECTION_HEADER {
  pub _bindgen_opaque_blob: [u32; 10usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_SECTION_HEADER__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_SECTION_HEADER__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_SECTION_HEADER__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SECTION_HEADER>(),
    40usize,
    concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SECTION_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_SECTION_HEADER))
  );
}
pub type IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER;
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_SYMBOL {
  pub _bindgen_opaque_blob: [u16; 9usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SYMBOL__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_SYMBOL__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SYMBOL__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_SYMBOL__bindgen_ty_1))
  );
}
impl Default for _IMAGE_SYMBOL__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_SYMBOL__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_SYMBOL__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SYMBOL>(),
    18usize,
    concat!("Size of: ", stringify!(_IMAGE_SYMBOL))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SYMBOL>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_SYMBOL))
  );
}
pub type IMAGE_SYMBOL = _IMAGE_SYMBOL;
pub type PIMAGE_SYMBOL = *mut IMAGE_SYMBOL;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_SYMBOL_EX {
  pub _bindgen_opaque_blob: [u16; 10usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL_EX__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1))
  );
}
impl Default for _IMAGE_SYMBOL_EX__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_SYMBOL_EX__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_SYMBOL_EX__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SYMBOL_EX>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_SYMBOL_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SYMBOL_EX>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_SYMBOL_EX))
  );
}
pub type IMAGE_SYMBOL_EX = _IMAGE_SYMBOL_EX;
pub type PIMAGE_SYMBOL_EX = *mut IMAGE_SYMBOL_EX;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
  pub bAuxType: BYTE,
  pub bReserved: BYTE,
  pub SymbolTableIndex: DWORD,
  pub rgbReserved: [BYTE; 12usize],
}
#[test]
fn bindgen_test_layout_IMAGE_AUX_SYMBOL_TOKEN_DEF() {
  assert_eq!(
    ::core::mem::size_of::<IMAGE_AUX_SYMBOL_TOKEN_DEF>(),
    18usize,
    concat!("Size of: ", stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF))
  );
  assert_eq!(
    ::core::mem::align_of::<IMAGE_AUX_SYMBOL_TOKEN_DEF>(),
    2usize,
    concat!("Alignment of ", stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_AUX_SYMBOL_TOKEN_DEF>())).bAuxType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
      "::",
      stringify!(bAuxType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_AUX_SYMBOL_TOKEN_DEF>())).bReserved as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_AUX_SYMBOL_TOKEN_DEF>())).SymbolTableIndex as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
      "::",
      stringify!(SymbolTableIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_AUX_SYMBOL_TOKEN_DEF>())).rgbReserved as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
      "::",
      stringify!(rgbReserved)
    )
  );
}
pub type PIMAGE_AUX_SYMBOL_TOKEN_DEF = *mut IMAGE_AUX_SYMBOL_TOKEN_DEF;
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL {
  pub _bindgen_opaque_blob: [u16; 9usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 9usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {{ opaque }}"
    )
  }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
    )
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
  pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2)
    )
  );
}
impl Default for _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {{ opaque }}"
    )
  }
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1>(),
    18usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1))
  );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_2 {
  pub _bindgen_opaque_blob: [u8; 18usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>(),
    18usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2))
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_3 {
  pub _bindgen_opaque_blob: [u16; 9usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_3>(),
    18usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_3>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3))
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_4 {
  pub _bindgen_opaque_blob: [u16; 9usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_4() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_4>(),
    18usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_4>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4))
  );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL>(),
    18usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL))
  );
}
impl Default for _IMAGE_AUX_SYMBOL {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_AUX_SYMBOL {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_AUX_SYMBOL {{ opaque }}")
  }
}
pub type IMAGE_AUX_SYMBOL = _IMAGE_AUX_SYMBOL;
pub type PIMAGE_AUX_SYMBOL = *mut IMAGE_AUX_SYMBOL;
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL_EX {
  pub _bindgen_opaque_blob: [u16; 10usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1)
    )
  );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2 {
  pub _bindgen_opaque_blob: [u8; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2)
    )
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3 {
  pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3)
    )
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4 {
  pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_4() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4)
    )
  );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5 {
  pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_5() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_AUX_SYMBOL_EX>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_AUX_SYMBOL_EX>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL_EX))
  );
}
impl Default for _IMAGE_AUX_SYMBOL_EX {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_AUX_SYMBOL_EX {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_AUX_SYMBOL_EX {{ opaque }}")
  }
}
pub type IMAGE_AUX_SYMBOL_EX = _IMAGE_AUX_SYMBOL_EX;
pub type PIMAGE_AUX_SYMBOL_EX = *mut IMAGE_AUX_SYMBOL_EX;
pub mod IMAGE_AUX_SYMBOL_TYPE {
  pub type Type = i32;
  pub const IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF: Type = 1;
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RELOCATION {
  pub _bindgen_opaque_blob: [u16; 5usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_RELOCATION__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RELOCATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RELOCATION__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_RELOCATION__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RELOCATION__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_RELOCATION__bindgen_ty_1))
  );
}
impl Default for _IMAGE_RELOCATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_RELOCATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_RELOCATION__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_RELOCATION() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RELOCATION>(),
    10usize,
    concat!("Size of: ", stringify!(_IMAGE_RELOCATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RELOCATION>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_RELOCATION))
  );
}
pub type IMAGE_RELOCATION = _IMAGE_RELOCATION;
pub type PIMAGE_RELOCATION = *mut IMAGE_RELOCATION;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_LINENUMBER {
  pub _bindgen_opaque_blob: [u16; 3usize],
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_LINENUMBER__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_LINENUMBER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_LINENUMBER__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_LINENUMBER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_LINENUMBER__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_LINENUMBER__bindgen_ty_1))
  );
}
impl Default for _IMAGE_LINENUMBER__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_LINENUMBER__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_LINENUMBER__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_LINENUMBER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_LINENUMBER>(),
    6usize,
    concat!("Size of: ", stringify!(_IMAGE_LINENUMBER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_LINENUMBER>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_LINENUMBER))
  );
}
pub type IMAGE_LINENUMBER = _IMAGE_LINENUMBER;
pub type PIMAGE_LINENUMBER = *mut IMAGE_LINENUMBER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_BASE_RELOCATION {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_BASE_RELOCATION() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_BASE_RELOCATION>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_BASE_RELOCATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_BASE_RELOCATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_BASE_RELOCATION))
  );
}
pub type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
pub type PIMAGE_BASE_RELOCATION = *mut IMAGE_BASE_RELOCATION;
#[repr(C)]
#[repr(align(1))]
pub struct _IMAGE_ARCHIVE_MEMBER_HEADER {
  pub _bindgen_opaque_blob: [u8; 60usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ARCHIVE_MEMBER_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARCHIVE_MEMBER_HEADER>(),
    60usize,
    concat!("Size of: ", stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARCHIVE_MEMBER_HEADER>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER))
  );
}
impl Default for _IMAGE_ARCHIVE_MEMBER_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_ARCHIVE_MEMBER_HEADER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_ARCHIVE_MEMBER_HEADER {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_ARCHIVE_MEMBER_HEADER {
  fn eq(&self, other: &_IMAGE_ARCHIVE_MEMBER_HEADER) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_ARCHIVE_MEMBER_HEADER = _IMAGE_ARCHIVE_MEMBER_HEADER;
pub type PIMAGE_ARCHIVE_MEMBER_HEADER = *mut _IMAGE_ARCHIVE_MEMBER_HEADER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_EXPORT_DIRECTORY {
  pub _bindgen_opaque_blob: [u32; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_EXPORT_DIRECTORY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_EXPORT_DIRECTORY>(),
    40usize,
    concat!("Size of: ", stringify!(_IMAGE_EXPORT_DIRECTORY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_EXPORT_DIRECTORY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_EXPORT_DIRECTORY))
  );
}
pub type IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY;
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_IMPORT_BY_NAME {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_BY_NAME() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_IMPORT_BY_NAME>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_IMPORT_BY_NAME))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_IMPORT_BY_NAME>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_IMPORT_BY_NAME))
  );
}
pub type IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME;
pub type PIMAGE_IMPORT_BY_NAME = *mut _IMAGE_IMPORT_BY_NAME;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_THUNK_DATA64 {
  pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA64__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA64__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_THUNK_DATA64__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_THUNK_DATA64__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_THUNK_DATA64__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_THUNK_DATA64__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_THUNK_DATA64__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_THUNK_DATA64>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_THUNK_DATA64>(),
    8usize,
    concat!("Alignment of ", stringify!(_IMAGE_THUNK_DATA64))
  );
}
pub type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_THUNK_DATA32 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA32__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA32__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_THUNK_DATA32__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_THUNK_DATA32__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_THUNK_DATA32__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_THUNK_DATA32__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_THUNK_DATA32__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA32() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_THUNK_DATA32>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA32))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_THUNK_DATA32>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_THUNK_DATA32))
  );
}
pub type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
pub type PIMAGE_THUNK_DATA32 = *mut IMAGE_THUNK_DATA32;
pub type PIMAGE_TLS_CALLBACK =
  ::core::option::Option<unsafe extern "C" fn(DllHandle: PVOID, Reason: DWORD, Reserved: PVOID)>;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_TLS_DIRECTORY64 {
  pub _bindgen_opaque_blob: [u32; 10usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY64__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_TLS_DIRECTORY64__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_TLS_DIRECTORY64__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_TLS_DIRECTORY64__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY64>(),
    40usize,
    concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY64>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY64))
  );
}
pub type IMAGE_TLS_DIRECTORY64 = _IMAGE_TLS_DIRECTORY64;
pub type PIMAGE_TLS_DIRECTORY64 = *mut IMAGE_TLS_DIRECTORY64;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_TLS_DIRECTORY32 {
  pub _bindgen_opaque_blob: [u32; 6usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY32>(),
    24usize,
    concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY32))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY32>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY32))
  );
}
pub type IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32;
pub type PIMAGE_TLS_DIRECTORY32 = *mut IMAGE_TLS_DIRECTORY32;
pub type IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
pub type IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY64;
pub type PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_IMPORT_DESCRIPTOR {
  pub _bindgen_opaque_blob: [u32; 5usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
  );
}
pub type IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR;
pub type PIMAGE_IMPORT_DESCRIPTOR = *mut IMAGE_IMPORT_DESCRIPTOR;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_BOUND_IMPORT_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR))
  );
}
pub type IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub type PIMAGE_BOUND_IMPORT_DESCRIPTOR = *mut _IMAGE_BOUND_IMPORT_DESCRIPTOR;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_BOUND_FORWARDER_REF {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_BOUND_FORWARDER_REF() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_BOUND_FORWARDER_REF>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_BOUND_FORWARDER_REF))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_BOUND_FORWARDER_REF>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_BOUND_FORWARDER_REF))
  );
}
pub type IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF;
pub type PIMAGE_BOUND_FORWARDER_REF = *mut _IMAGE_BOUND_FORWARDER_REF;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR {
  pub _bindgen_opaque_blob: [u32; 8usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR>(),
    32usize,
    concat!("Size of: ", stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR))
  );
}
pub type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PIMAGE_DELAYLOAD_DESCRIPTOR = *mut _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PCIMAGE_DELAYLOAD_DESCRIPTOR = *const IMAGE_DELAYLOAD_DESCRIPTOR;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DIRECTORY {
  pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY>(),
    16usize,
    concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIRECTORY))
  );
}
pub type IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY;
pub type PIMAGE_RESOURCE_DIRECTORY = *mut _IMAGE_RESOURCE_DIRECTORY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {{ opaque }}"
    )
  }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2)
    )
  );
}
impl Default for _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {{ opaque }}"
    )
  }
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY))
  );
}
pub type IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub type PIMAGE_RESOURCE_DIRECTORY_ENTRY = *mut _IMAGE_RESOURCE_DIRECTORY_ENTRY;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DIRECTORY_STRING {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_STRING() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_STRING>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_STRING>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING)
    )
  );
}
pub type IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING;
pub type PIMAGE_RESOURCE_DIRECTORY_STRING = *mut _IMAGE_RESOURCE_DIRECTORY_STRING;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DIR_STRING_U {
  pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIR_STRING_U() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DIR_STRING_U>(),
    4usize,
    concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIR_STRING_U))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DIR_STRING_U>(),
    2usize,
    concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIR_STRING_U))
  );
}
pub type IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U;
pub type PIMAGE_RESOURCE_DIR_STRING_U = *mut _IMAGE_RESOURCE_DIR_STRING_U;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RESOURCE_DATA_ENTRY {
  pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DATA_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RESOURCE_DATA_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DATA_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RESOURCE_DATA_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DATA_ENTRY))
  );
}
pub type IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY;
pub type PIMAGE_RESOURCE_DATA_ENTRY = *mut _IMAGE_RESOURCE_DATA_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
  pub _bindgen_opaque_blob: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__IMAGE_LOAD_CONFIG_CODE_INTEGRITY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>(),
    12usize,
    concat!("Size of: ", stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY)
    )
  );
}
pub type IMAGE_LOAD_CONFIG_CODE_INTEGRITY = _IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
pub type PIMAGE_LOAD_CONFIG_CODE_INTEGRITY = *mut _IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION_TABLE() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION_TABLE>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION_TABLE))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION_TABLE>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION_TABLE))
  );
}
pub type IMAGE_DYNAMIC_RELOCATION_TABLE = _IMAGE_DYNAMIC_RELOCATION_TABLE;
pub type PIMAGE_DYNAMIC_RELOCATION_TABLE = *mut _IMAGE_DYNAMIC_RELOCATION_TABLE;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DYNAMIC_RELOCATION32 {
  pub _bindgen_opaque_blob: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION32() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION32>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION32))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION32>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION32))
  );
}
pub type IMAGE_DYNAMIC_RELOCATION32 = _IMAGE_DYNAMIC_RELOCATION32;
pub type PIMAGE_DYNAMIC_RELOCATION32 = *mut _IMAGE_DYNAMIC_RELOCATION32;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DYNAMIC_RELOCATION64 {
  pub _bindgen_opaque_blob: [u8; 12usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION64>(),
    12usize,
    concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION64>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION64))
  );
}
pub type IMAGE_DYNAMIC_RELOCATION64 = _IMAGE_DYNAMIC_RELOCATION64;
pub type PIMAGE_DYNAMIC_RELOCATION64 = *mut _IMAGE_DYNAMIC_RELOCATION64;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
  pub _bindgen_opaque_blob: [u8; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION32_V2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION32_V2>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION32_V2>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2))
  );
}
pub type IMAGE_DYNAMIC_RELOCATION32_V2 = _IMAGE_DYNAMIC_RELOCATION32_V2;
pub type PIMAGE_DYNAMIC_RELOCATION32_V2 = *mut _IMAGE_DYNAMIC_RELOCATION32_V2;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
  pub _bindgen_opaque_blob: [u8; 24usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION64_V2() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION64_V2>(),
    24usize,
    concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION64_V2>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2))
  );
}
pub type IMAGE_DYNAMIC_RELOCATION64_V2 = _IMAGE_DYNAMIC_RELOCATION64_V2;
pub type PIMAGE_DYNAMIC_RELOCATION64_V2 = *mut _IMAGE_DYNAMIC_RELOCATION64_V2;
pub type IMAGE_DYNAMIC_RELOCATION = IMAGE_DYNAMIC_RELOCATION64;
pub type PIMAGE_DYNAMIC_RELOCATION = PIMAGE_DYNAMIC_RELOCATION64;
pub type IMAGE_DYNAMIC_RELOCATION_V2 = IMAGE_DYNAMIC_RELOCATION64_V2;
pub type PIMAGE_DYNAMIC_RELOCATION_V2 = PIMAGE_DYNAMIC_RELOCATION64_V2;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
  pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout__IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER)
    )
  );
}
pub type IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
pub type PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = *mut IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
  pub _bindgen_opaque_blob: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER)
    )
  );
}
pub type IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
pub type PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = *mut IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
#[repr(C)]
#[repr(align(4))]
pub struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
  pub _bindgen_opaque_blob: [u32; 40usize],
}
#[test]
fn bindgen_test_layout__IMAGE_LOAD_CONFIG_DIRECTORY32() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_LOAD_CONFIG_DIRECTORY32>(),
    160usize,
    concat!("Size of: ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_LOAD_CONFIG_DIRECTORY32>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32))
  );
}
impl Default for _IMAGE_LOAD_CONFIG_DIRECTORY32 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_LOAD_CONFIG_DIRECTORY32 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_LOAD_CONFIG_DIRECTORY32 {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_LOAD_CONFIG_DIRECTORY32 {
  fn eq(&self, other: &_IMAGE_LOAD_CONFIG_DIRECTORY32) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_LOAD_CONFIG_DIRECTORY32 = _IMAGE_LOAD_CONFIG_DIRECTORY32;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY32 = *mut _IMAGE_LOAD_CONFIG_DIRECTORY32;
#[repr(C)]
#[repr(align(4))]
pub struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
  pub _bindgen_opaque_blob: [u32; 64usize],
}
#[test]
fn bindgen_test_layout__IMAGE_LOAD_CONFIG_DIRECTORY64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_LOAD_CONFIG_DIRECTORY64>(),
    256usize,
    concat!("Size of: ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_LOAD_CONFIG_DIRECTORY64>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY64))
  );
}
impl Default for _IMAGE_LOAD_CONFIG_DIRECTORY64 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_LOAD_CONFIG_DIRECTORY64 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_LOAD_CONFIG_DIRECTORY64 {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_LOAD_CONFIG_DIRECTORY64 {
  fn eq(&self, other: &_IMAGE_LOAD_CONFIG_DIRECTORY64) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_LOAD_CONFIG_DIRECTORY64 = _IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY64 = *mut _IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_HOT_PATCH_INFO {
  pub _bindgen_opaque_blob: [u32; 6usize],
}
#[test]
fn bindgen_test_layout__IMAGE_HOT_PATCH_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_HOT_PATCH_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_IMAGE_HOT_PATCH_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_HOT_PATCH_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_HOT_PATCH_INFO))
  );
}
pub type IMAGE_HOT_PATCH_INFO = _IMAGE_HOT_PATCH_INFO;
pub type PIMAGE_HOT_PATCH_INFO = *mut _IMAGE_HOT_PATCH_INFO;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_HOT_PATCH_BASE {
  pub _bindgen_opaque_blob: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__IMAGE_HOT_PATCH_BASE() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_HOT_PATCH_BASE>(),
    32usize,
    concat!("Size of: ", stringify!(_IMAGE_HOT_PATCH_BASE))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_HOT_PATCH_BASE>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_HOT_PATCH_BASE))
  );
}
pub type IMAGE_HOT_PATCH_BASE = _IMAGE_HOT_PATCH_BASE;
pub type PIMAGE_HOT_PATCH_BASE = *mut _IMAGE_HOT_PATCH_BASE;
#[repr(C)]
#[repr(align(1))]
pub struct _IMAGE_HOT_PATCH_HASHES {
  pub _bindgen_opaque_blob: [u8; 52usize],
}
#[test]
fn bindgen_test_layout__IMAGE_HOT_PATCH_HASHES() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_HOT_PATCH_HASHES>(),
    52usize,
    concat!("Size of: ", stringify!(_IMAGE_HOT_PATCH_HASHES))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_HOT_PATCH_HASHES>(),
    1usize,
    concat!("Alignment of ", stringify!(_IMAGE_HOT_PATCH_HASHES))
  );
}
impl Default for _IMAGE_HOT_PATCH_HASHES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_HOT_PATCH_HASHES {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_HOT_PATCH_HASHES {{ opaque }}")
  }
}
impl ::core::cmp::PartialEq for _IMAGE_HOT_PATCH_HASHES {
  fn eq(&self, other: &_IMAGE_HOT_PATCH_HASHES) -> bool {
    &self._bindgen_opaque_blob[..] == &other._bindgen_opaque_blob[..]
  }
}
pub type IMAGE_HOT_PATCH_HASHES = _IMAGE_HOT_PATCH_HASHES;
pub type PIMAGE_HOT_PATCH_HASHES = *mut _IMAGE_HOT_PATCH_HASHES;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_CE_RUNTIME_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY)
    )
  );
}
pub type IMAGE_CE_RUNTIME_FUNCTION_ENTRY = _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {{ opaque }}"
    )
  }
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY)
    )
  );
}
pub type IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {{ opaque }}"
    )
  }
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY)
    )
  );
}
pub type IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)
    )
  );
}
pub type IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 5usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>(),
    20usize,
    concat!("Size of: ", stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
    )
  );
}
pub type IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 3usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {{ opaque }}"
    )
  }
}
#[test]
fn bindgen_test_layout__IMAGE_RUNTIME_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY>(),
    12usize,
    concat!("Size of: ", stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY))
  );
}
pub type _PIMAGE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ENCLAVE_CONFIG32 {
  pub _bindgen_opaque_blob: [u32; 19usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ENCLAVE_CONFIG32() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ENCLAVE_CONFIG32>(),
    76usize,
    concat!("Size of: ", stringify!(_IMAGE_ENCLAVE_CONFIG32))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ENCLAVE_CONFIG32>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_ENCLAVE_CONFIG32))
  );
}
pub type IMAGE_ENCLAVE_CONFIG32 = _IMAGE_ENCLAVE_CONFIG32;
pub type PIMAGE_ENCLAVE_CONFIG32 = *mut _IMAGE_ENCLAVE_CONFIG32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ENCLAVE_CONFIG64 {
  pub _bindgen_opaque_blob: [u32; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ENCLAVE_CONFIG64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ENCLAVE_CONFIG64>(),
    80usize,
    concat!("Size of: ", stringify!(_IMAGE_ENCLAVE_CONFIG64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ENCLAVE_CONFIG64>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_ENCLAVE_CONFIG64))
  );
}
pub type IMAGE_ENCLAVE_CONFIG64 = _IMAGE_ENCLAVE_CONFIG64;
pub type PIMAGE_ENCLAVE_CONFIG64 = *mut _IMAGE_ENCLAVE_CONFIG64;
pub type IMAGE_ENCLAVE_CONFIG = IMAGE_ENCLAVE_CONFIG64;
pub type PIMAGE_ENCLAVE_CONFIG = PIMAGE_ENCLAVE_CONFIG64;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_ENCLAVE_IMPORT {
  pub _bindgen_opaque_blob: [u32; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ENCLAVE_IMPORT() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_ENCLAVE_IMPORT>(),
    80usize,
    concat!("Size of: ", stringify!(_IMAGE_ENCLAVE_IMPORT))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_ENCLAVE_IMPORT>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_ENCLAVE_IMPORT))
  );
}
pub type IMAGE_ENCLAVE_IMPORT = _IMAGE_ENCLAVE_IMPORT;
pub type PIMAGE_ENCLAVE_IMPORT = *mut _IMAGE_ENCLAVE_IMPORT;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DEBUG_DIRECTORY {
  pub _bindgen_opaque_blob: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DEBUG_DIRECTORY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DEBUG_DIRECTORY>(),
    28usize,
    concat!("Size of: ", stringify!(_IMAGE_DEBUG_DIRECTORY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DEBUG_DIRECTORY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_DEBUG_DIRECTORY))
  );
}
pub type IMAGE_DEBUG_DIRECTORY = _IMAGE_DEBUG_DIRECTORY;
pub type PIMAGE_DEBUG_DIRECTORY = *mut _IMAGE_DEBUG_DIRECTORY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_COFF_SYMBOLS_HEADER {
  pub _bindgen_opaque_blob: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__IMAGE_COFF_SYMBOLS_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_COFF_SYMBOLS_HEADER>(),
    32usize,
    concat!("Size of: ", stringify!(_IMAGE_COFF_SYMBOLS_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_COFF_SYMBOLS_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_COFF_SYMBOLS_HEADER))
  );
}
pub type IMAGE_COFF_SYMBOLS_HEADER = _IMAGE_COFF_SYMBOLS_HEADER;
pub type PIMAGE_COFF_SYMBOLS_HEADER = *mut _IMAGE_COFF_SYMBOLS_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FPO_DATA {
  pub ulOffStart: DWORD,
  pub cbProcSize: DWORD,
  pub cdwLocals: DWORD,
  pub cdwParams: WORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout__FPO_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_FPO_DATA>(),
    16usize,
    concat!("Size of: ", stringify!(_FPO_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_FPO_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_FPO_DATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FPO_DATA>())).ulOffStart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FPO_DATA),
      "::",
      stringify!(ulOffStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FPO_DATA>())).cbProcSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FPO_DATA),
      "::",
      stringify!(cbProcSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FPO_DATA>())).cdwLocals as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FPO_DATA),
      "::",
      stringify!(cdwLocals)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FPO_DATA>())).cdwParams as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_FPO_DATA),
      "::",
      stringify!(cdwParams)
    )
  );
}
impl _FPO_DATA {
  #[inline]
  pub fn cbProlog(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_cbProlog(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn cbRegs(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
  }
  #[inline]
  pub fn set_cbRegs(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 3u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasSEH(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set_fHasSEH(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(11usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fUseBP(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set_fUseBP(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(12usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(13usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn cbFrame(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
  }
  #[inline]
  pub fn set_cbFrame(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(14usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    cbProlog: WORD, cbRegs: WORD, fHasSEH: WORD, fUseBP: WORD, reserved: WORD, cbFrame: WORD,
  ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let cbProlog: u16 = unsafe { ::core::mem::transmute(cbProlog) };
      cbProlog as u64
    });
    __bindgen_bitfield_unit.set(8usize, 3u8, {
      let cbRegs: u16 = unsafe { ::core::mem::transmute(cbRegs) };
      cbRegs as u64
    });
    __bindgen_bitfield_unit.set(11usize, 1u8, {
      let fHasSEH: u16 = unsafe { ::core::mem::transmute(fHasSEH) };
      fHasSEH as u64
    });
    __bindgen_bitfield_unit.set(12usize, 1u8, {
      let fUseBP: u16 = unsafe { ::core::mem::transmute(fUseBP) };
      fUseBP as u64
    });
    __bindgen_bitfield_unit.set(13usize, 1u8, {
      let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit.set(14usize, 2u8, {
      let cbFrame: u16 = unsafe { ::core::mem::transmute(cbFrame) };
      cbFrame as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type FPO_DATA = _FPO_DATA;
pub type PFPO_DATA = *mut _FPO_DATA;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_DEBUG_MISC {
  pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DEBUG_MISC() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_DEBUG_MISC>(),
    16usize,
    concat!("Size of: ", stringify!(_IMAGE_DEBUG_MISC))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_DEBUG_MISC>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_DEBUG_MISC))
  );
}
pub type IMAGE_DEBUG_MISC = _IMAGE_DEBUG_MISC;
pub type PIMAGE_DEBUG_MISC = *mut _IMAGE_DEBUG_MISC;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_FUNCTION_ENTRY {
  pub _bindgen_opaque_blob: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_FUNCTION_ENTRY>(),
    12usize,
    concat!("Size of: ", stringify!(_IMAGE_FUNCTION_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_FUNCTION_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_FUNCTION_ENTRY))
  );
}
pub type IMAGE_FUNCTION_ENTRY = _IMAGE_FUNCTION_ENTRY;
pub type PIMAGE_FUNCTION_ENTRY = *mut _IMAGE_FUNCTION_ENTRY;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_FUNCTION_ENTRY64 {
  pub _bindgen_opaque_blob: [u32; 6usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {
  pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY64__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY64() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_FUNCTION_ENTRY64>(),
    24usize,
    concat!("Size of: ", stringify!(_IMAGE_FUNCTION_ENTRY64))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_FUNCTION_ENTRY64>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_FUNCTION_ENTRY64))
  );
}
pub type IMAGE_FUNCTION_ENTRY64 = _IMAGE_FUNCTION_ENTRY64;
pub type PIMAGE_FUNCTION_ENTRY64 = *mut _IMAGE_FUNCTION_ENTRY64;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_SEPARATE_DEBUG_HEADER {
  pub _bindgen_opaque_blob: [u32; 12usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SEPARATE_DEBUG_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_SEPARATE_DEBUG_HEADER>(),
    48usize,
    concat!("Size of: ", stringify!(_IMAGE_SEPARATE_DEBUG_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_SEPARATE_DEBUG_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_IMAGE_SEPARATE_DEBUG_HEADER))
  );
}
pub type IMAGE_SEPARATE_DEBUG_HEADER = _IMAGE_SEPARATE_DEBUG_HEADER;
pub type PIMAGE_SEPARATE_DEBUG_HEADER = *mut _IMAGE_SEPARATE_DEBUG_HEADER;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _NON_PAGED_DEBUG_INFO {
  pub Signature: WORD,
  pub Flags: WORD,
  pub Size: DWORD,
  pub Machine: WORD,
  pub Characteristics: WORD,
  pub TimeDateStamp: DWORD,
  pub CheckSum: DWORD,
  pub SizeOfImage: DWORD,
  pub ImageBase: ULONGLONG,
}
#[test]
fn bindgen_test_layout__NON_PAGED_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_NON_PAGED_DEBUG_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_NON_PAGED_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_NON_PAGED_DEBUG_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_NON_PAGED_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).Signature as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(Signature)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).Machine as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(Machine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).Characteristics as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(Characteristics)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).TimeDateStamp as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(TimeDateStamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).CheckSum as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(CheckSum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).SizeOfImage as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(SizeOfImage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NON_PAGED_DEBUG_INFO>())).ImageBase as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NON_PAGED_DEBUG_INFO),
      "::",
      stringify!(ImageBase)
    )
  );
}
pub type NON_PAGED_DEBUG_INFO = _NON_PAGED_DEBUG_INFO;
pub type PNON_PAGED_DEBUG_INFO = *mut _NON_PAGED_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ImageArchitectureHeader {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
  pub FirstEntryRVA: DWORD,
}
#[test]
fn bindgen_test_layout__ImageArchitectureHeader() {
  assert_eq!(
    ::core::mem::size_of::<_ImageArchitectureHeader>(),
    8usize,
    concat!("Size of: ", stringify!(_ImageArchitectureHeader))
  );
  assert_eq!(
    ::core::mem::align_of::<_ImageArchitectureHeader>(),
    4usize,
    concat!("Alignment of ", stringify!(_ImageArchitectureHeader))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ImageArchitectureHeader>())).FirstEntryRVA as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ImageArchitectureHeader),
      "::",
      stringify!(FirstEntryRVA)
    )
  );
}
impl _ImageArchitectureHeader {
  #[inline]
  pub fn AmaskValue(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_AmaskValue(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AmaskShift(&self) -> libc::c_uint {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
  }
  #[inline]
  pub fn set_AmaskShift(&mut self, val: libc::c_uint) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    AmaskValue: libc::c_uint, AmaskShift: libc::c_uint,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let AmaskValue: u32 = unsafe { ::core::mem::transmute(AmaskValue) };
      AmaskValue as u64
    });
    __bindgen_bitfield_unit.set(8usize, 8u8, {
      let AmaskShift: u32 = unsafe { ::core::mem::transmute(AmaskShift) };
      AmaskShift as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type IMAGE_ARCHITECTURE_HEADER = _ImageArchitectureHeader;
pub type PIMAGE_ARCHITECTURE_HEADER = *mut _ImageArchitectureHeader;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ImageArchitectureEntry {
  pub FixupInstRVA: DWORD,
  pub NewInst: DWORD,
}
#[test]
fn bindgen_test_layout__ImageArchitectureEntry() {
  assert_eq!(
    ::core::mem::size_of::<_ImageArchitectureEntry>(),
    8usize,
    concat!("Size of: ", stringify!(_ImageArchitectureEntry))
  );
  assert_eq!(
    ::core::mem::align_of::<_ImageArchitectureEntry>(),
    4usize,
    concat!("Alignment of ", stringify!(_ImageArchitectureEntry))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ImageArchitectureEntry>())).FixupInstRVA as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ImageArchitectureEntry),
      "::",
      stringify!(FixupInstRVA)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ImageArchitectureEntry>())).NewInst as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ImageArchitectureEntry),
      "::",
      stringify!(NewInst)
    )
  );
}
pub type IMAGE_ARCHITECTURE_ENTRY = _ImageArchitectureEntry;
pub type PIMAGE_ARCHITECTURE_ENTRY = *mut _ImageArchitectureEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPORT_OBJECT_HEADER {
  pub Sig1: WORD,
  pub Sig2: WORD,
  pub Version: WORD,
  pub Machine: WORD,
  pub TimeDateStamp: DWORD,
  pub SizeOfData: DWORD,
  pub __bindgen_anon_1: IMPORT_OBJECT_HEADER__bindgen_ty_1,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPORT_OBJECT_HEADER__bindgen_ty_1 {
  pub Ordinal: WORD,
  pub Hint: WORD,
  _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_IMPORT_OBJECT_HEADER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<IMPORT_OBJECT_HEADER__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<IMPORT_OBJECT_HEADER__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER__bindgen_ty_1>())).Ordinal as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1),
      "::",
      stringify!(Ordinal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER__bindgen_ty_1>())).Hint as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1),
      "::",
      stringify!(Hint)
    )
  );
}
impl Default for IMPORT_OBJECT_HEADER__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for IMPORT_OBJECT_HEADER__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "IMPORT_OBJECT_HEADER__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_IMPORT_OBJECT_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<IMPORT_OBJECT_HEADER>(),
    20usize,
    concat!("Size of: ", stringify!(IMPORT_OBJECT_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<IMPORT_OBJECT_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(IMPORT_OBJECT_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER>())).Sig1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER),
      "::",
      stringify!(Sig1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER>())).Sig2 as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER),
      "::",
      stringify!(Sig2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER>())).Version as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER>())).Machine as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER),
      "::",
      stringify!(Machine)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER>())).TimeDateStamp as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER),
      "::",
      stringify!(TimeDateStamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMPORT_OBJECT_HEADER>())).SizeOfData as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(IMPORT_OBJECT_HEADER),
      "::",
      stringify!(SizeOfData)
    )
  );
}
impl Default for IMPORT_OBJECT_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for IMPORT_OBJECT_HEADER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "IMPORT_OBJECT_HEADER {{ Sig1: {:?}, Sig2: {:?}, Version: {:?}, Machine: {:?}, TimeDateStamp: {:?}, SizeOfData: {:?}, __bindgen_anon_1: {:?}, Type : {:?}, NameType : {:?}, Reserved : {:?} }}" , self . Sig1 , self . Sig2 , self . Version , self . Machine , self . TimeDateStamp , self . SizeOfData , self . __bindgen_anon_1 , self . Type ( ) , self . NameType ( ) , self . Reserved ( ) )
  }
}
impl IMPORT_OBJECT_HEADER {
  #[inline]
  pub fn Type(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
  }
  #[inline]
  pub fn set_Type(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn NameType(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u16) }
  }
  #[inline]
  pub fn set_NameType(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 3u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> WORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: WORD) {
    unsafe {
      let val: u16 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 11u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Type: WORD, NameType: WORD, Reserved: WORD,
  ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 2u8, {
      let Type: u16 = unsafe { ::core::mem::transmute(Type) };
      Type as u64
    });
    __bindgen_bitfield_unit.set(2usize, 3u8, {
      let NameType: u16 = unsafe { ::core::mem::transmute(NameType) };
      NameType as u64
    });
    __bindgen_bitfield_unit.set(5usize, 11u8, {
      let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
pub mod IMPORT_OBJECT_TYPE {
  pub type Type = i32;
  pub const IMPORT_OBJECT_CODE: Type = 0;
  pub const IMPORT_OBJECT_DATA: Type = 1;
  pub const IMPORT_OBJECT_CONST: Type = 2;
}
pub mod IMPORT_OBJECT_NAME_TYPE {
  pub type Type = i32;
  pub const IMPORT_OBJECT_ORDINAL: Type = 0;
  pub const IMPORT_OBJECT_NAME: Type = 1;
  pub const IMPORT_OBJECT_NAME_NO_PREFIX: Type = 2;
  pub const IMPORT_OBJECT_NAME_UNDECORATE: Type = 3;
  pub const IMPORT_OBJECT_NAME_EXPORTAS: Type = 4;
}
pub mod ReplacesCorHdrNumericDefines {
  pub type Type = i32;
  pub const COMIMAGE_FLAGS_ILONLY: Type = 1;
  pub const COMIMAGE_FLAGS_32BITREQUIRED: Type = 2;
  pub const COMIMAGE_FLAGS_IL_LIBRARY: Type = 4;
  pub const COMIMAGE_FLAGS_STRONGNAMESIGNED: Type = 8;
  pub const COMIMAGE_FLAGS_NATIVE_ENTRYPOINT: Type = 16;
  pub const COMIMAGE_FLAGS_TRACKDEBUGDATA: Type = 65536;
  pub const COMIMAGE_FLAGS_32BITPREFERRED: Type = 131072;
  pub const COR_VERSION_MAJOR_V2: Type = 2;
  pub const COR_VERSION_MAJOR: Type = 2;
  pub const COR_VERSION_MINOR: Type = 5;
  pub const COR_DELETED_NAME_LENGTH: Type = 8;
  pub const COR_VTABLEGAP_NAME_LENGTH: Type = 8;
  pub const NATIVE_TYPE_MAX_CB: Type = 1;
  pub const COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE: Type = 255;
  pub const IMAGE_COR_MIH_METHODRVA: Type = 1;
  pub const IMAGE_COR_MIH_EHRVA: Type = 2;
  pub const IMAGE_COR_MIH_BASICBLOCK: Type = 8;
  pub const COR_VTABLE_32BIT: Type = 1;
  pub const COR_VTABLE_64BIT: Type = 2;
  pub const COR_VTABLE_FROM_UNMANAGED: Type = 4;
  pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN: Type = 8;
  pub const COR_VTABLE_CALL_MOST_DERIVED: Type = 16;
  pub const IMAGE_COR_EATJ_THUNK_SIZE: Type = 32;
  pub const MAX_CLASS_NAME: Type = 1024;
  pub const MAX_PACKAGE_NAME: Type = 1024;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMAGE_COR20_HEADER {
  pub cb: DWORD,
  pub MajorRuntimeVersion: WORD,
  pub MinorRuntimeVersion: WORD,
  pub MetaData: IMAGE_DATA_DIRECTORY,
  pub Flags: DWORD,
  pub __bindgen_anon_1: IMAGE_COR20_HEADER__bindgen_ty_1,
  pub Resources: IMAGE_DATA_DIRECTORY,
  pub StrongNameSignature: IMAGE_DATA_DIRECTORY,
  pub CodeManagerTable: IMAGE_DATA_DIRECTORY,
  pub VTableFixups: IMAGE_DATA_DIRECTORY,
  pub ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
  pub ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMAGE_COR20_HEADER__bindgen_ty_1 {
  pub EntryPointToken: DWORD,
  pub EntryPointRVA: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_IMAGE_COR20_HEADER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<IMAGE_COR20_HEADER__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(IMAGE_COR20_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<IMAGE_COR20_HEADER__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(IMAGE_COR20_HEADER__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER__bindgen_ty_1>())).EntryPointToken as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER__bindgen_ty_1),
      "::",
      stringify!(EntryPointToken)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER__bindgen_ty_1>())).EntryPointRVA as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER__bindgen_ty_1),
      "::",
      stringify!(EntryPointRVA)
    )
  );
}
impl Default for IMAGE_COR20_HEADER__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for IMAGE_COR20_HEADER__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "IMAGE_COR20_HEADER__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_IMAGE_COR20_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<IMAGE_COR20_HEADER>(),
    72usize,
    concat!("Size of: ", stringify!(IMAGE_COR20_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<IMAGE_COR20_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(IMAGE_COR20_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).MajorRuntimeVersion as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(MajorRuntimeVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).MinorRuntimeVersion as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(MinorRuntimeVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).MetaData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(MetaData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).Flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).Resources as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(Resources)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).StrongNameSignature as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(StrongNameSignature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).CodeManagerTable as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(CodeManagerTable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).VTableFixups as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(VTableFixups)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).ExportAddressTableJumps as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(ExportAddressTableJumps)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<IMAGE_COR20_HEADER>())).ManagedNativeHeader as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(IMAGE_COR20_HEADER),
      "::",
      stringify!(ManagedNativeHeader)
    )
  );
}
impl Default for IMAGE_COR20_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for IMAGE_COR20_HEADER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "IMAGE_COR20_HEADER {{ cb: {:?}, MajorRuntimeVersion: {:?}, MinorRuntimeVersion: {:?}, MetaData: {:?}, Flags: {:?}, __bindgen_anon_1: {:?}, Resources: {:?}, StrongNameSignature: {:?}, CodeManagerTable: {:?}, VTableFixups: {:?}, ExportAddressTableJumps: {:?}, ManagedNativeHeader: {:?} }}" , self . cb , self . MajorRuntimeVersion , self . MinorRuntimeVersion , self . MetaData , self . Flags , self . __bindgen_anon_1 , self . Resources , self . StrongNameSignature , self . CodeManagerTable , self . VTableFixups , self . ExportAddressTableJumps , self . ManagedNativeHeader )
  }
}
pub type PIMAGE_COR20_HEADER = *mut IMAGE_COR20_HEADER;
extern "C" {
  pub fn RtlCaptureStackBackTrace(
    FramesToSkip: DWORD, FramesToCapture: DWORD, BackTrace: *mut PVOID, BackTraceHash: PDWORD,
  ) -> WORD;
}
extern "C" {
  pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "C" {
  pub fn RtlUnwind(
    TargetFrame: PVOID, TargetIp: PVOID, ExceptionRecord: PEXCEPTION_RECORD, ReturnValue: PVOID,
  );
}
extern "C" {
  pub fn RtlAddFunctionTable(
    FunctionTable: PRUNTIME_FUNCTION, EntryCount: DWORD, BaseAddress: DWORD64,
  ) -> BOOLEAN;
}
extern "C" {
  pub fn RtlDeleteFunctionTable(FunctionTable: PRUNTIME_FUNCTION) -> BOOLEAN;
}
extern "C" {
  pub fn RtlInstallFunctionTableCallback(
    TableIdentifier: DWORD64, BaseAddress: DWORD64, Length: DWORD,
    Callback: PGET_RUNTIME_FUNCTION_CALLBACK, Context: PVOID, OutOfProcessCallbackDll: PCWSTR,
  ) -> BOOLEAN;
}
extern "C" {
  pub fn RtlAddGrowableFunctionTable(
    DynamicTable: *mut PVOID, FunctionTable: PRUNTIME_FUNCTION, EntryCount: DWORD,
    MaximumEntryCount: DWORD, RangeBase: ULONG_PTR, RangeEnd: ULONG_PTR,
  ) -> DWORD;
}
extern "C" {
  pub fn RtlGrowFunctionTable(DynamicTable: PVOID, NewEntryCount: DWORD);
}
extern "C" {
  pub fn RtlDeleteGrowableFunctionTable(DynamicTable: PVOID);
}
extern "C" {
  pub fn RtlLookupFunctionEntry(
    ControlPc: DWORD64, ImageBase: PDWORD64, HistoryTable: PUNWIND_HISTORY_TABLE,
  ) -> PRUNTIME_FUNCTION;
}
extern "C" {
  pub fn RtlRestoreContext(ContextRecord: PCONTEXT, ExceptionRecord: *mut _EXCEPTION_RECORD);
}
extern "C" {
  pub fn RtlUnwindEx(
    TargetFrame: PVOID, TargetIp: PVOID, ExceptionRecord: PEXCEPTION_RECORD, ReturnValue: PVOID,
    ContextRecord: PCONTEXT, HistoryTable: PUNWIND_HISTORY_TABLE,
  );
}
extern "C" {
  pub fn RtlVirtualUnwind(
    HandlerType: DWORD, ImageBase: DWORD64, ControlPc: DWORD64, FunctionEntry: PRUNTIME_FUNCTION,
    ContextRecord: PCONTEXT, HandlerData: *mut PVOID, EstablisherFrame: PDWORD64,
    ContextPointers: PKNONVOLATILE_CONTEXT_POINTERS,
  ) -> PEXCEPTION_ROUTINE;
}
extern "C" {
  pub fn RtlPcToFileHeader(PcValue: PVOID, BaseOfImage: *mut PVOID) -> PVOID;
}
extern "C" {
  pub fn RtlCompareMemory(
    Source1: *const libc::c_void, Source2: *const libc::c_void, Length: SIZE_T,
  ) -> SIZE_T;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SLIST_ENTRY {
  pub Next: *mut _SLIST_ENTRY,
  pub __bindgen_padding_0: u64,
}
#[test]
fn bindgen_test_layout__SLIST_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_SLIST_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_SLIST_ENTRY>(),
    16usize,
    concat!("Alignment of ", stringify!(_SLIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SLIST_ENTRY>())).Next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_ENTRY),
      "::",
      stringify!(Next)
    )
  );
}
impl Default for _SLIST_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
  pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
  pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
  _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
  pub Alignment: ULONGLONG,
  pub Region: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Alignment as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER__bindgen_ty_1),
      "::",
      stringify!(Alignment)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Region as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER__bindgen_ty_1),
      "::",
      stringify!(Region)
    )
  );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u64>,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_SLIST_HEADER__bindgen_ty_2>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_SLIST_HEADER__bindgen_ty_2>(),
    8usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_2))
  );
}
impl _SLIST_HEADER__bindgen_ty_2 {
  #[inline]
  pub fn Depth(&self) -> ULONGLONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
  }
  #[inline]
  pub fn set_Depth(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn Sequence(&self) -> ULONGLONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
  }
  #[inline]
  pub fn set_Sequence(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 48u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> ULONGLONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::core::mem::transmute(val);
      self._bitfield_1.set(64usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn NextEntry(&self) -> ULONGLONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
  }
  #[inline]
  pub fn set_NextEntry(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::core::mem::transmute(val);
      self._bitfield_1.set(68usize, 60u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Depth: ULONGLONG, Sequence: ULONGLONG, Reserved: ULONGLONG, NextEntry: ULONGLONG,
  ) -> __BindgenBitfieldUnit<[u8; 16usize], u64> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u64> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let Depth: u64 = unsafe { ::core::mem::transmute(Depth) };
      Depth as u64
    });
    __bindgen_bitfield_unit.set(16usize, 48u8, {
      let Sequence: u64 = unsafe { ::core::mem::transmute(Sequence) };
      Sequence as u64
    });
    __bindgen_bitfield_unit.set(64usize, 4u8, {
      let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit.set(68usize, 60u8, {
      let NextEntry: u64 = unsafe { ::core::mem::transmute(NextEntry) };
      NextEntry as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_SLIST_HEADER>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_SLIST_HEADER>(),
    16usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SLIST_HEADER>())).HeaderX64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER),
      "::",
      stringify!(HeaderX64)
    )
  );
}
impl Default for _SLIST_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SLIST_HEADER {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_SLIST_HEADER {{ union }}")
  }
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
extern "C" {
  pub fn RtlInitializeSListHead(ListHead: PSLIST_HEADER);
}
extern "C" {
  pub fn RtlFirstEntrySList(ListHead: *const SLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn RtlInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn RtlInterlockedPushEntrySList(
    ListHead: PSLIST_HEADER, ListEntry: PSLIST_ENTRY,
  ) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn RtlInterlockedPushListSListEx(
    ListHead: PSLIST_HEADER, List: PSLIST_ENTRY, ListEnd: PSLIST_ENTRY, Count: DWORD,
  ) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn RtlInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn RtlQueryDepthSList(ListHead: PSLIST_HEADER) -> WORD;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
  pub Ptr: PVOID,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__RTL_RUN_ONCE() {
  assert_eq!(
    ::core::mem::size_of::<_RTL_RUN_ONCE>(),
    8usize,
    concat!("Size of: ", stringify!(_RTL_RUN_ONCE))
  );
  assert_eq!(
    ::core::mem::align_of::<_RTL_RUN_ONCE>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_RUN_ONCE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_RUN_ONCE>())).Ptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_RUN_ONCE),
      "::",
      stringify!(Ptr)
    )
  );
}
impl Default for _RTL_RUN_ONCE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _RTL_RUN_ONCE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_RTL_RUN_ONCE {{ union }}")
  }
}
pub type RTL_RUN_ONCE = _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RTL_BARRIER {
  pub Reserved1: DWORD,
  pub Reserved2: DWORD,
  pub Reserved3: [ULONG_PTR; 2usize],
  pub Reserved4: DWORD,
  pub Reserved5: DWORD,
}
#[test]
fn bindgen_test_layout__RTL_BARRIER() {
  assert_eq!(
    ::core::mem::size_of::<_RTL_BARRIER>(),
    32usize,
    concat!("Size of: ", stringify!(_RTL_BARRIER))
  );
  assert_eq!(
    ::core::mem::align_of::<_RTL_BARRIER>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_BARRIER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_BARRIER>())).Reserved1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_BARRIER>())).Reserved2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_BARRIER>())).Reserved3 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_BARRIER>())).Reserved4 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved4)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_BARRIER>())).Reserved5 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved5)
    )
  );
}
pub type RTL_BARRIER = _RTL_BARRIER;
pub type PRTL_BARRIER = *mut _RTL_BARRIER;
extern "C" {
  pub fn __fastfail(Code: libc::c_uint);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MESSAGE_RESOURCE_ENTRY {
  pub Length: WORD,
  pub Flags: WORD,
  pub Text: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_MESSAGE_RESOURCE_ENTRY>(),
    6usize,
    concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_MESSAGE_RESOURCE_ENTRY>(),
    2usize,
    concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MESSAGE_RESOURCE_ENTRY>())).Length as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_ENTRY),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MESSAGE_RESOURCE_ENTRY>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MESSAGE_RESOURCE_ENTRY>())).Text as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_ENTRY),
      "::",
      stringify!(Text)
    )
  );
}
pub type MESSAGE_RESOURCE_ENTRY = _MESSAGE_RESOURCE_ENTRY;
pub type PMESSAGE_RESOURCE_ENTRY = *mut _MESSAGE_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MESSAGE_RESOURCE_BLOCK {
  pub LowId: DWORD,
  pub HighId: DWORD,
  pub OffsetToEntries: DWORD,
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_BLOCK() {
  assert_eq!(
    ::core::mem::size_of::<_MESSAGE_RESOURCE_BLOCK>(),
    12usize,
    concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_BLOCK))
  );
  assert_eq!(
    ::core::mem::align_of::<_MESSAGE_RESOURCE_BLOCK>(),
    4usize,
    concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_BLOCK))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MESSAGE_RESOURCE_BLOCK>())).LowId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_BLOCK),
      "::",
      stringify!(LowId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MESSAGE_RESOURCE_BLOCK>())).HighId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_BLOCK),
      "::",
      stringify!(HighId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MESSAGE_RESOURCE_BLOCK>())).OffsetToEntries as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_BLOCK),
      "::",
      stringify!(OffsetToEntries)
    )
  );
}
pub type MESSAGE_RESOURCE_BLOCK = _MESSAGE_RESOURCE_BLOCK;
pub type PMESSAGE_RESOURCE_BLOCK = *mut _MESSAGE_RESOURCE_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MESSAGE_RESOURCE_DATA {
  pub NumberOfBlocks: DWORD,
  pub Blocks: [MESSAGE_RESOURCE_BLOCK; 1usize],
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_MESSAGE_RESOURCE_DATA>(),
    16usize,
    concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_MESSAGE_RESOURCE_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MESSAGE_RESOURCE_DATA>())).NumberOfBlocks as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_DATA),
      "::",
      stringify!(NumberOfBlocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MESSAGE_RESOURCE_DATA>())).Blocks as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MESSAGE_RESOURCE_DATA),
      "::",
      stringify!(Blocks)
    )
  );
}
pub type MESSAGE_RESOURCE_DATA = _MESSAGE_RESOURCE_DATA;
pub type PMESSAGE_RESOURCE_DATA = *mut _MESSAGE_RESOURCE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOA {
  pub dwOSVersionInfoSize: DWORD,
  pub dwMajorVersion: DWORD,
  pub dwMinorVersion: DWORD,
  pub dwBuildNumber: DWORD,
  pub dwPlatformId: DWORD,
  pub szCSDVersion: [CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOA() {
  assert_eq!(
    ::core::mem::size_of::<_OSVERSIONINFOA>(),
    148usize,
    concat!("Size of: ", stringify!(_OSVERSIONINFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<_OSVERSIONINFOA>(),
    4usize,
    concat!("Alignment of ", stringify!(_OSVERSIONINFOA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOA>())).dwOSVersionInfoSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOA),
      "::",
      stringify!(dwOSVersionInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOA>())).dwMajorVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOA),
      "::",
      stringify!(dwMajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOA>())).dwMinorVersion as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOA),
      "::",
      stringify!(dwMinorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOA>())).dwBuildNumber as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOA),
      "::",
      stringify!(dwBuildNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOA>())).dwPlatformId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOA),
      "::",
      stringify!(dwPlatformId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOA>())).szCSDVersion as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOA),
      "::",
      stringify!(szCSDVersion)
    )
  );
}
impl Default for _OSVERSIONINFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OSVERSIONINFOA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_OSVERSIONINFOA {{ dwOSVersionInfoSize: {:?}, dwMajorVersion: {:?}, dwMinorVersion: {:?}, dwBuildNumber: {:?}, dwPlatformId: {:?}, szCSDVersion: [...] }}" , self . dwOSVersionInfoSize , self . dwMajorVersion , self . dwMinorVersion , self . dwBuildNumber , self . dwPlatformId )
  }
}
impl ::core::cmp::PartialEq for _OSVERSIONINFOA {
  fn eq(&self, other: &_OSVERSIONINFOA) -> bool {
    self.dwOSVersionInfoSize == other.dwOSVersionInfoSize
      && self.dwMajorVersion == other.dwMajorVersion
      && self.dwMinorVersion == other.dwMinorVersion
      && self.dwBuildNumber == other.dwBuildNumber
      && self.dwPlatformId == other.dwPlatformId
      && &self.szCSDVersion[..] == &other.szCSDVersion[..]
  }
}
pub type OSVERSIONINFOA = _OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOW {
  pub dwOSVersionInfoSize: DWORD,
  pub dwMajorVersion: DWORD,
  pub dwMinorVersion: DWORD,
  pub dwBuildNumber: DWORD,
  pub dwPlatformId: DWORD,
  pub szCSDVersion: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOW() {
  assert_eq!(
    ::core::mem::size_of::<_OSVERSIONINFOW>(),
    276usize,
    concat!("Size of: ", stringify!(_OSVERSIONINFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<_OSVERSIONINFOW>(),
    4usize,
    concat!("Alignment of ", stringify!(_OSVERSIONINFOW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOW>())).dwOSVersionInfoSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOW),
      "::",
      stringify!(dwOSVersionInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOW>())).dwMajorVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOW),
      "::",
      stringify!(dwMajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOW>())).dwMinorVersion as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOW),
      "::",
      stringify!(dwMinorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOW>())).dwBuildNumber as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOW),
      "::",
      stringify!(dwBuildNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOW>())).dwPlatformId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOW),
      "::",
      stringify!(dwPlatformId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOW>())).szCSDVersion as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOW),
      "::",
      stringify!(szCSDVersion)
    )
  );
}
impl Default for _OSVERSIONINFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OSVERSIONINFOW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_OSVERSIONINFOW {{ dwOSVersionInfoSize: {:?}, dwMajorVersion: {:?}, dwMinorVersion: {:?}, dwBuildNumber: {:?}, dwPlatformId: {:?}, szCSDVersion: [...] }}" , self . dwOSVersionInfoSize , self . dwMajorVersion , self . dwMinorVersion , self . dwBuildNumber , self . dwPlatformId )
  }
}
impl ::core::cmp::PartialEq for _OSVERSIONINFOW {
  fn eq(&self, other: &_OSVERSIONINFOW) -> bool {
    self.dwOSVersionInfoSize == other.dwOSVersionInfoSize
      && self.dwMajorVersion == other.dwMajorVersion
      && self.dwMinorVersion == other.dwMinorVersion
      && self.dwBuildNumber == other.dwBuildNumber
      && self.dwPlatformId == other.dwPlatformId
      && &self.szCSDVersion[..] == &other.szCSDVersion[..]
  }
}
pub type OSVERSIONINFOW = _OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type OSVERSIONINFO = OSVERSIONINFOA;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOEXA {
  pub dwOSVersionInfoSize: DWORD,
  pub dwMajorVersion: DWORD,
  pub dwMinorVersion: DWORD,
  pub dwBuildNumber: DWORD,
  pub dwPlatformId: DWORD,
  pub szCSDVersion: [CHAR; 128usize],
  pub wServicePackMajor: WORD,
  pub wServicePackMinor: WORD,
  pub wSuiteMask: WORD,
  pub wProductType: BYTE,
  pub wReserved: BYTE,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXA() {
  assert_eq!(
    ::core::mem::size_of::<_OSVERSIONINFOEXA>(),
    156usize,
    concat!("Size of: ", stringify!(_OSVERSIONINFOEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<_OSVERSIONINFOEXA>(),
    4usize,
    concat!("Alignment of ", stringify!(_OSVERSIONINFOEXA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).dwOSVersionInfoSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(dwOSVersionInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).dwMajorVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(dwMajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).dwMinorVersion as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(dwMinorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).dwBuildNumber as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(dwBuildNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).dwPlatformId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(dwPlatformId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).szCSDVersion as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(szCSDVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).wServicePackMajor as *const _ as usize
    },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(wServicePackMajor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).wServicePackMinor as *const _ as usize
    },
    150usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(wServicePackMinor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).wSuiteMask as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(wSuiteMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).wProductType as *const _ as usize },
    154usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(wProductType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXA>())).wReserved as *const _ as usize },
    155usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXA),
      "::",
      stringify!(wReserved)
    )
  );
}
impl Default for _OSVERSIONINFOEXA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OSVERSIONINFOEXA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_OSVERSIONINFOEXA {{ dwOSVersionInfoSize: {:?}, dwMajorVersion: {:?}, dwMinorVersion: {:?}, dwBuildNumber: {:?}, dwPlatformId: {:?}, szCSDVersion: [...], wServicePackMajor: {:?}, wServicePackMinor: {:?}, wSuiteMask: {:?}, wProductType: {:?}, wReserved: {:?} }}" , self . dwOSVersionInfoSize , self . dwMajorVersion , self . dwMinorVersion , self . dwBuildNumber , self . dwPlatformId , self . wServicePackMajor , self . wServicePackMinor , self . wSuiteMask , self . wProductType , self . wReserved )
  }
}
impl ::core::cmp::PartialEq for _OSVERSIONINFOEXA {
  fn eq(&self, other: &_OSVERSIONINFOEXA) -> bool {
    self.dwOSVersionInfoSize == other.dwOSVersionInfoSize
      && self.dwMajorVersion == other.dwMajorVersion
      && self.dwMinorVersion == other.dwMinorVersion
      && self.dwBuildNumber == other.dwBuildNumber
      && self.dwPlatformId == other.dwPlatformId
      && &self.szCSDVersion[..] == &other.szCSDVersion[..]
      && self.wServicePackMajor == other.wServicePackMajor
      && self.wServicePackMinor == other.wServicePackMinor
      && self.wSuiteMask == other.wSuiteMask
      && self.wProductType == other.wProductType
      && self.wReserved == other.wReserved
  }
}
pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
  pub dwOSVersionInfoSize: DWORD,
  pub dwMajorVersion: DWORD,
  pub dwMinorVersion: DWORD,
  pub dwBuildNumber: DWORD,
  pub dwPlatformId: DWORD,
  pub szCSDVersion: [WCHAR; 128usize],
  pub wServicePackMajor: WORD,
  pub wServicePackMinor: WORD,
  pub wSuiteMask: WORD,
  pub wProductType: BYTE,
  pub wReserved: BYTE,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXW() {
  assert_eq!(
    ::core::mem::size_of::<_OSVERSIONINFOEXW>(),
    284usize,
    concat!("Size of: ", stringify!(_OSVERSIONINFOEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<_OSVERSIONINFOEXW>(),
    4usize,
    concat!("Alignment of ", stringify!(_OSVERSIONINFOEXW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).dwOSVersionInfoSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(dwOSVersionInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).dwMajorVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(dwMajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).dwMinorVersion as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(dwMinorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).dwBuildNumber as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(dwBuildNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).dwPlatformId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(dwPlatformId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).szCSDVersion as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(szCSDVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).wServicePackMajor as *const _ as usize
    },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(wServicePackMajor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).wServicePackMinor as *const _ as usize
    },
    278usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(wServicePackMinor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).wSuiteMask as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(wSuiteMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).wProductType as *const _ as usize },
    282usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(wProductType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OSVERSIONINFOEXW>())).wReserved as *const _ as usize },
    283usize,
    concat!(
      "Offset of field: ",
      stringify!(_OSVERSIONINFOEXW),
      "::",
      stringify!(wReserved)
    )
  );
}
impl Default for _OSVERSIONINFOEXW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OSVERSIONINFOEXW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_OSVERSIONINFOEXW {{ dwOSVersionInfoSize: {:?}, dwMajorVersion: {:?}, dwMinorVersion: {:?}, dwBuildNumber: {:?}, dwPlatformId: {:?}, szCSDVersion: [...], wServicePackMajor: {:?}, wServicePackMinor: {:?}, wSuiteMask: {:?}, wProductType: {:?}, wReserved: {:?} }}" , self . dwOSVersionInfoSize , self . dwMajorVersion , self . dwMinorVersion , self . dwBuildNumber , self . dwPlatformId , self . wServicePackMajor , self . wServicePackMinor , self . wSuiteMask , self . wProductType , self . wReserved )
  }
}
impl ::core::cmp::PartialEq for _OSVERSIONINFOEXW {
  fn eq(&self, other: &_OSVERSIONINFOEXW) -> bool {
    self.dwOSVersionInfoSize == other.dwOSVersionInfoSize
      && self.dwMajorVersion == other.dwMajorVersion
      && self.dwMinorVersion == other.dwMinorVersion
      && self.dwBuildNumber == other.dwBuildNumber
      && self.dwPlatformId == other.dwPlatformId
      && &self.szCSDVersion[..] == &other.szCSDVersion[..]
      && self.wServicePackMajor == other.wServicePackMajor
      && self.wServicePackMinor == other.wServicePackMinor
      && self.wSuiteMask == other.wSuiteMask
      && self.wProductType == other.wProductType
      && self.wReserved == other.wReserved
  }
}
pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
extern "C" {
  pub fn VerSetConditionMask(
    ConditionMask: ULONGLONG, TypeMask: DWORD, Condition: BYTE,
  ) -> ULONGLONG;
}
extern "C" {
  pub fn RtlGetProductInfo(
    OSMajorVersion: DWORD, OSMinorVersion: DWORD, SpMajorVersion: DWORD, SpMinorVersion: DWORD,
    ReturnedProductType: PDWORD,
  ) -> BOOLEAN;
}
pub mod _RTL_UMS_THREAD_INFO_CLASS {
  pub type Type = i32;
  pub const UmsThreadInvalidInfoClass: Type = 0;
  pub const UmsThreadUserContext: Type = 1;
  pub const UmsThreadPriority: Type = 2;
  pub const UmsThreadAffinity: Type = 3;
  pub const UmsThreadTeb: Type = 4;
  pub const UmsThreadIsSuspended: Type = 5;
  pub const UmsThreadIsTerminated: Type = 6;
  pub const UmsThreadMaxInfoClass: Type = 7;
}
pub use self::_RTL_UMS_THREAD_INFO_CLASS::Type as RTL_UMS_THREAD_INFO_CLASS;
pub type PRTL_UMS_THREAD_INFO_CLASS = *mut _RTL_UMS_THREAD_INFO_CLASS::Type;
pub mod _RTL_UMS_SCHEDULER_REASON {
  pub type Type = i32;
  pub const UmsSchedulerStartup: Type = 0;
  pub const UmsSchedulerThreadBlocked: Type = 1;
  pub const UmsSchedulerThreadYield: Type = 2;
}
pub use self::_RTL_UMS_SCHEDULER_REASON::Type as RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_REASON = *mut _RTL_UMS_SCHEDULER_REASON::Type;
pub type PRTL_UMS_SCHEDULER_ENTRY_POINT = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
  pub fn RtlCrc32(Buffer: *const libc::c_void, Size: usize, InitialCrc: DWORD) -> DWORD;
}
extern "C" {
  pub fn RtlCrc64(Buffer: *const libc::c_void, Size: usize, InitialCrc: ULONGLONG) -> ULONGLONG;
}
pub mod _OS_DEPLOYEMENT_STATE_VALUES {
  pub type Type = i32;
  pub const OS_DEPLOYMENT_STANDARD: Type = 1;
  pub const OS_DEPLOYMENT_COMPACT: Type = 2;
}
pub use self::_OS_DEPLOYEMENT_STATE_VALUES::Type as OS_DEPLOYEMENT_STATE_VALUES;
extern "C" {
  pub fn RtlOsDeploymentState(Flags: DWORD) -> OS_DEPLOYEMENT_STATE_VALUES;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _NV_MEMORY_RANGE {
  pub BaseAddress: *mut libc::c_void,
  pub Length: SIZE_T,
}
#[test]
fn bindgen_test_layout__NV_MEMORY_RANGE() {
  assert_eq!(
    ::core::mem::size_of::<_NV_MEMORY_RANGE>(),
    16usize,
    concat!("Size of: ", stringify!(_NV_MEMORY_RANGE))
  );
  assert_eq!(
    ::core::mem::align_of::<_NV_MEMORY_RANGE>(),
    8usize,
    concat!("Alignment of ", stringify!(_NV_MEMORY_RANGE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NV_MEMORY_RANGE>())).BaseAddress as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NV_MEMORY_RANGE),
      "::",
      stringify!(BaseAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NV_MEMORY_RANGE>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NV_MEMORY_RANGE),
      "::",
      stringify!(Length)
    )
  );
}
impl Default for _NV_MEMORY_RANGE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NV_MEMORY_RANGE = _NV_MEMORY_RANGE;
pub type PNV_MEMORY_RANGE = *mut _NV_MEMORY_RANGE;
extern "C" {
  pub fn RtlGetNonVolatileToken(NvBuffer: PVOID, Size: SIZE_T, NvToken: *mut PVOID) -> DWORD;
}
extern "C" {
  pub fn RtlFreeNonVolatileToken(NvToken: PVOID) -> DWORD;
}
extern "C" {
  pub fn RtlFlushNonVolatileMemory(
    NvToken: PVOID, NvBuffer: PVOID, Size: SIZE_T, Flags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn RtlDrainNonVolatileFlush(NvToken: PVOID) -> DWORD;
}
extern "C" {
  pub fn RtlWriteNonVolatileMemory(
    NvToken: PVOID, NvDestination: *mut libc::c_void, Source: *mut libc::c_void, Size: SIZE_T,
    Flags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn RtlFlushNonVolatileMemoryRanges(
    NvToken: PVOID, NvRanges: PNV_MEMORY_RANGE, NumRanges: SIZE_T, Flags: DWORD,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CORRELATION_VECTOR {
  pub Version: CHAR,
  pub Vector: [CHAR; 129usize],
}
#[test]
fn bindgen_test_layout_CORRELATION_VECTOR() {
  assert_eq!(
    ::core::mem::size_of::<CORRELATION_VECTOR>(),
    130usize,
    concat!("Size of: ", stringify!(CORRELATION_VECTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<CORRELATION_VECTOR>(),
    1usize,
    concat!("Alignment of ", stringify!(CORRELATION_VECTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CORRELATION_VECTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(CORRELATION_VECTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<CORRELATION_VECTOR>())).Vector as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(CORRELATION_VECTOR),
      "::",
      stringify!(Vector)
    )
  );
}
impl Default for CORRELATION_VECTOR {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for CORRELATION_VECTOR {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "CORRELATION_VECTOR {{ Version: {:?}, Vector: [...] }}",
      self.Version
    )
  }
}
impl ::core::cmp::PartialEq for CORRELATION_VECTOR {
  fn eq(&self, other: &CORRELATION_VECTOR) -> bool {
    self.Version == other.Version && &self.Vector[..] == &other.Vector[..]
  }
}
pub type PCORRELATION_VECTOR = *mut CORRELATION_VECTOR;
extern "C" {
  pub fn RtlInitializeCorrelationVector(
    CorrelationVector: PCORRELATION_VECTOR, Version: libc::c_int, Guid: *const GUID,
  ) -> DWORD;
}
extern "C" {
  pub fn RtlIncrementCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> DWORD;
}
extern "C" {
  pub fn RtlExtendCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> DWORD;
}
extern "C" {
  pub fn RtlValidateCorrelationVector(Vector: PCORRELATION_VECTOR) -> DWORD;
}
pub mod _IMAGE_POLICY_ENTRY_TYPE {
  pub type Type = i32;
  pub const ImagePolicyEntryTypeNone: Type = 0;
  pub const ImagePolicyEntryTypeBool: Type = 1;
  pub const ImagePolicyEntryTypeInt8: Type = 2;
  pub const ImagePolicyEntryTypeUInt8: Type = 3;
  pub const ImagePolicyEntryTypeInt16: Type = 4;
  pub const ImagePolicyEntryTypeUInt16: Type = 5;
  pub const ImagePolicyEntryTypeInt32: Type = 6;
  pub const ImagePolicyEntryTypeUInt32: Type = 7;
  pub const ImagePolicyEntryTypeInt64: Type = 8;
  pub const ImagePolicyEntryTypeUInt64: Type = 9;
  pub const ImagePolicyEntryTypeAnsiString: Type = 10;
  pub const ImagePolicyEntryTypeUnicodeString: Type = 11;
  pub const ImagePolicyEntryTypeMaximum: Type = 12;
}
pub use self::_IMAGE_POLICY_ENTRY_TYPE::Type as IMAGE_POLICY_ENTRY_TYPE;
pub mod _IMAGE_POLICY_ID {
  pub type Type = i32;
  pub const ImagePolicyIdNone: Type = 0;
  pub const ImagePolicyIdEtw: Type = 1;
  pub const ImagePolicyIdDebug: Type = 2;
  pub const ImagePolicyIdCrashDump: Type = 3;
  pub const ImagePolicyIdCrashDumpKey: Type = 4;
  pub const ImagePolicyIdCrashDumpKeyGuid: Type = 5;
  pub const ImagePolicyIdParentSd: Type = 6;
  pub const ImagePolicyIdParentSdRev: Type = 7;
  pub const ImagePolicyIdSvn: Type = 8;
  pub const ImagePolicyIdDeviceId: Type = 9;
  pub const ImagePolicyIdCapability: Type = 10;
  pub const ImagePolicyIdScenarioId: Type = 11;
  pub const ImagePolicyIdMaximum: Type = 12;
}
pub use self::_IMAGE_POLICY_ID::Type as IMAGE_POLICY_ID;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_POLICY_ENTRY {
  pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
  pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout__IMAGE_POLICY_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1)
    )
  );
}
impl Default for _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_IMAGE_POLICY_ENTRY__bindgen_ty_1 {{ opaque }}")
  }
}
#[test]
fn bindgen_test_layout__IMAGE_POLICY_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_POLICY_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_IMAGE_POLICY_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_POLICY_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_IMAGE_POLICY_ENTRY))
  );
}
pub type IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY;
pub type PCIMAGE_POLICY_ENTRY = *const IMAGE_POLICY_ENTRY;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _IMAGE_POLICY_METADATA {
  pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_POLICY_METADATA() {
  assert_eq!(
    ::core::mem::size_of::<_IMAGE_POLICY_METADATA>(),
    16usize,
    concat!("Size of: ", stringify!(_IMAGE_POLICY_METADATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_IMAGE_POLICY_METADATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_IMAGE_POLICY_METADATA))
  );
}
pub type IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA;
pub type PCIMAGE_POLICY_METADATA = *const IMAGE_POLICY_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
  pub Type: WORD,
  pub CreatorBackTraceIndex: WORD,
  pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
  pub ProcessLocksList: LIST_ENTRY,
  pub EntryCount: DWORD,
  pub ContentionCount: DWORD,
  pub Flags: DWORD,
  pub CreatorBackTraceIndexHigh: WORD,
  pub SpareWORD: WORD,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION_DEBUG() {
  assert_eq!(
    ::core::mem::size_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
    48usize,
    concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
  );
  assert_eq!(
    ::core::mem::align_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).CreatorBackTraceIndex as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(CreatorBackTraceIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).CriticalSection as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(CriticalSection)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).ProcessLocksList as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(ProcessLocksList)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).EntryCount as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(EntryCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).ContentionCount as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(ContentionCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).Flags as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).CreatorBackTraceIndexHigh as *const _
        as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(CreatorBackTraceIndexHigh)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).SpareWORD as *const _ as usize
    },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION_DEBUG),
      "::",
      stringify!(SpareWORD)
    )
  );
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
pub type RTL_RESOURCE_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_RESOURCE_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RTL_CRITICAL_SECTION {
  pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
  pub LockCount: LONG,
  pub RecursionCount: LONG,
  pub OwningThread: HANDLE,
  pub LockSemaphore: HANDLE,
  pub SpinCount: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
  assert_eq!(
    ::core::mem::size_of::<_RTL_CRITICAL_SECTION>(),
    40usize,
    concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
  );
  assert_eq!(
    ::core::mem::align_of::<_RTL_CRITICAL_SECTION>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION>())).DebugInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION),
      "::",
      stringify!(DebugInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION>())).LockCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION),
      "::",
      stringify!(LockCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION>())).RecursionCount as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION),
      "::",
      stringify!(RecursionCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION>())).OwningThread as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION),
      "::",
      stringify!(OwningThread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION>())).LockSemaphore as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION),
      "::",
      stringify!(LockSemaphore)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CRITICAL_SECTION>())).SpinCount as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CRITICAL_SECTION),
      "::",
      stringify!(SpinCount)
    )
  );
}
impl Default for _RTL_CRITICAL_SECTION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RTL_SRWLOCK {
  pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
  assert_eq!(
    ::core::mem::size_of::<_RTL_SRWLOCK>(),
    8usize,
    concat!("Size of: ", stringify!(_RTL_SRWLOCK))
  );
  assert_eq!(
    ::core::mem::align_of::<_RTL_SRWLOCK>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_SRWLOCK>())).Ptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_SRWLOCK),
      "::",
      stringify!(Ptr)
    )
  );
}
impl Default for _RTL_SRWLOCK {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
pub type PRTL_SRWLOCK = *mut _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RTL_CONDITION_VARIABLE {
  pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_CONDITION_VARIABLE() {
  assert_eq!(
    ::core::mem::size_of::<_RTL_CONDITION_VARIABLE>(),
    8usize,
    concat!("Size of: ", stringify!(_RTL_CONDITION_VARIABLE))
  );
  assert_eq!(
    ::core::mem::align_of::<_RTL_CONDITION_VARIABLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_CONDITION_VARIABLE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RTL_CONDITION_VARIABLE>())).Ptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_CONDITION_VARIABLE),
      "::",
      stringify!(Ptr)
    )
  );
}
impl Default for _RTL_CONDITION_VARIABLE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RTL_CONDITION_VARIABLE = _RTL_CONDITION_VARIABLE;
pub type PRTL_CONDITION_VARIABLE = *mut _RTL_CONDITION_VARIABLE;
pub type PAPCFUNC = ::core::option::Option<unsafe extern "C" fn(Parameter: ULONG_PTR)>;
pub type PVECTORED_EXCEPTION_HANDLER =
  ::core::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
pub mod _HEAP_INFORMATION_CLASS {
  pub type Type = i32;
  pub const HeapCompatibilityInformation: Type = 0;
  pub const HeapEnableTerminationOnCorruption: Type = 1;
  pub const HeapOptimizeResources: Type = 3;
}
pub use self::_HEAP_INFORMATION_CLASS::Type as HEAP_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
  pub Version: DWORD,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__HEAP_OPTIMIZE_RESOURCES_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>())).Flags as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION),
      "::",
      stringify!(Flags)
    )
  );
}
pub type HEAP_OPTIMIZE_RESOURCES_INFORMATION = _HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub type PHEAP_OPTIMIZE_RESOURCES_INFORMATION = *mut _HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub type WAITORTIMERCALLBACKFUNC =
  ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: BOOLEAN)>;
pub type WORKERCALLBACKFUNC = ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type APC_CALLBACK_FUNCTION =
  ::core::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID, arg3: PVOID)>;
pub type WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
pub type PFLS_CALLBACK_FUNCTION = ::core::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
pub type PSECURE_MEMORY_CACHE_CALLBACK =
  ::core::option::Option<unsafe extern "C" fn(Addr: PVOID, Range: SIZE_T) -> BOOLEAN>;
pub mod _ACTIVATION_CONTEXT_INFO_CLASS {
  pub type Type = i32;
  pub const ActivationContextBasicInformation: Type = 1;
  pub const ActivationContextDetailedInformation: Type = 2;
  pub const AssemblyDetailedInformationInActivationContext: Type = 3;
  pub const FileInformationInAssemblyOfAssemblyInActivationContext: Type = 4;
  pub const RunlevelInformationInActivationContext: Type = 5;
  pub const CompatibilityInformationInActivationContext: Type = 6;
  pub const ActivationContextManifestResourceName: Type = 7;
  pub const MaxActivationContextInfoClass: Type = 8;
  pub const AssemblyDetailedInformationInActivationContxt: Type = 3;
  pub const FileInformationInAssemblyOfAssemblyInActivationContxt: Type = 4;
}
pub use self::_ACTIVATION_CONTEXT_INFO_CLASS::Type as ACTIVATION_CONTEXT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACTIVATION_CONTEXT_QUERY_INDEX {
  pub ulAssemblyIndex: DWORD,
  pub ulFileIndexInAssembly: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_QUERY_INDEX() {
  assert_eq!(
    ::core::mem::size_of::<_ACTIVATION_CONTEXT_QUERY_INDEX>(),
    8usize,
    concat!("Size of: ", stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX))
  );
  assert_eq!(
    ::core::mem::align_of::<_ACTIVATION_CONTEXT_QUERY_INDEX>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_QUERY_INDEX>())).ulAssemblyIndex as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX),
      "::",
      stringify!(ulAssemblyIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_QUERY_INDEX>())).ulFileIndexInAssembly as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX),
      "::",
      stringify!(ulFileIndexInAssembly)
    )
  );
}
pub type ACTIVATION_CONTEXT_QUERY_INDEX = _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PACTIVATION_CONTEXT_QUERY_INDEX = *mut _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PCACTIVATION_CONTEXT_QUERY_INDEX = *const _ACTIVATION_CONTEXT_QUERY_INDEX;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
  pub ulFlags: DWORD,
  pub ulFilenameLength: DWORD,
  pub ulPathLength: DWORD,
  pub lpFileName: PCWSTR,
  pub lpFilePath: PCWSTR,
}
#[test]
fn bindgen_test_layout__ASSEMBLY_FILE_DETAILED_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ASSEMBLY_FILE_DETAILED_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_ASSEMBLY_FILE_DETAILED_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).ulFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
      "::",
      stringify!(ulFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).ulFilenameLength as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
      "::",
      stringify!(ulFilenameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).ulPathLength as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
      "::",
      stringify!(ulPathLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).lpFileName as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
      "::",
      stringify!(lpFileName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).lpFilePath as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
      "::",
      stringify!(lpFilePath)
    )
  );
}
impl Default for _ASSEMBLY_FILE_DETAILED_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ASSEMBLY_FILE_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PASSEMBLY_FILE_DETAILED_INFORMATION = *mut _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PCASSEMBLY_FILE_DETAILED_INFORMATION = *const ASSEMBLY_FILE_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
  pub ulFlags: DWORD,
  pub ulEncodedAssemblyIdentityLength: DWORD,
  pub ulManifestPathType: DWORD,
  pub ulManifestPathLength: DWORD,
  pub liManifestLastWriteTime: LARGE_INTEGER,
  pub ulPolicyPathType: DWORD,
  pub ulPolicyPathLength: DWORD,
  pub liPolicyLastWriteTime: LARGE_INTEGER,
  pub ulMetadataSatelliteRosterIndex: DWORD,
  pub ulManifestVersionMajor: DWORD,
  pub ulManifestVersionMinor: DWORD,
  pub ulPolicyVersionMajor: DWORD,
  pub ulPolicyVersionMinor: DWORD,
  pub ulAssemblyDirectoryNameLength: DWORD,
  pub lpAssemblyEncodedAssemblyIdentity: PCWSTR,
  pub lpAssemblyManifestPath: PCWSTR,
  pub lpAssemblyPolicyPath: PCWSTR,
  pub lpAssemblyDirectoryName: PCWSTR,
  pub ulFileCount: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(),
    104usize,
    concat!(
      "Size of: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>())).ulFlags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulEncodedAssemblyIdentityLength as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulEncodedAssemblyIdentityLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulManifestPathType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulManifestPathType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulManifestPathLength as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulManifestPathLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .liManifestLastWriteTime as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(liManifestLastWriteTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulPolicyPathType as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulPolicyPathType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulPolicyPathLength as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulPolicyPathLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .liPolicyLastWriteTime as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(liPolicyLastWriteTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulMetadataSatelliteRosterIndex as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulMetadataSatelliteRosterIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulManifestVersionMajor as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulManifestVersionMajor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulManifestVersionMinor as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulManifestVersionMinor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulPolicyVersionMajor as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulPolicyVersionMajor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulPolicyVersionMinor as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulPolicyVersionMinor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .ulAssemblyDirectoryNameLength as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulAssemblyDirectoryNameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .lpAssemblyEncodedAssemblyIdentity as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(lpAssemblyEncodedAssemblyIdentity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .lpAssemblyManifestPath as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(lpAssemblyManifestPath)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .lpAssemblyPolicyPath as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(lpAssemblyPolicyPath)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
        .lpAssemblyDirectoryName as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(lpAssemblyDirectoryName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>())).ulFileCount
        as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
      "::",
      stringify!(ulFileCount)
    )
  );
}
impl Default for _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {{ ulFlags: {:?}, ulEncodedAssemblyIdentityLength: {:?}, ulManifestPathType: {:?}, ulManifestPathLength: {:?}, liManifestLastWriteTime: {:?}, ulPolicyPathType: {:?}, ulPolicyPathLength: {:?}, liPolicyLastWriteTime: {:?}, ulMetadataSatelliteRosterIndex: {:?}, ulManifestVersionMajor: {:?}, ulManifestVersionMinor: {:?}, ulPolicyVersionMajor: {:?}, ulPolicyVersionMinor: {:?}, ulAssemblyDirectoryNameLength: {:?}, lpAssemblyEncodedAssemblyIdentity: {:?}, lpAssemblyManifestPath: {:?}, lpAssemblyPolicyPath: {:?}, lpAssemblyDirectoryName: {:?}, ulFileCount: {:?} }}" , self . ulFlags , self . ulEncodedAssemblyIdentityLength , self . ulManifestPathType , self . ulManifestPathLength , self . liManifestLastWriteTime , self . ulPolicyPathType , self . ulPolicyPathLength , self . liPolicyLastWriteTime , self . ulMetadataSatelliteRosterIndex , self . ulManifestVersionMajor , self . ulManifestVersionMinor , self . ulPolicyVersionMajor , self . ulPolicyVersionMinor , self . ulAssemblyDirectoryNameLength , self . lpAssemblyEncodedAssemblyIdentity , self . lpAssemblyManifestPath , self . lpAssemblyPolicyPath , self . lpAssemblyDirectoryName , self . ulFileCount )
  }
}
pub type ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
  _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
  *mut _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
  *const _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub mod ACTCTX_REQUESTED_RUN_LEVEL {
  pub type Type = i32;
  pub const ACTCTX_RUN_LEVEL_UNSPECIFIED: Type = 0;
  pub const ACTCTX_RUN_LEVEL_AS_INVOKER: Type = 1;
  pub const ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE: Type = 2;
  pub const ACTCTX_RUN_LEVEL_REQUIRE_ADMIN: Type = 3;
  pub const ACTCTX_RUN_LEVEL_NUMBERS: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
  pub ulFlags: DWORD,
  pub RunLevel: ACTCTX_REQUESTED_RUN_LEVEL::Type,
  pub UiAccess: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>())).ulFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
      "::",
      stringify!(ulFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>())).RunLevel as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
      "::",
      stringify!(RunLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>())).UiAccess as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
      "::",
      stringify!(UiAccess)
    )
  );
}
impl Default for _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = *mut _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION =
  *const _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub mod ACTCTX_COMPATIBILITY_ELEMENT_TYPE {
  pub type Type = i32;
  pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN: Type = 0;
  pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS: Type = 1;
  pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _COMPATIBILITY_CONTEXT_ELEMENT {
  pub Id: GUID,
  pub Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE::Type,
}
#[test]
fn bindgen_test_layout__COMPATIBILITY_CONTEXT_ELEMENT() {
  assert_eq!(
    ::core::mem::size_of::<_COMPATIBILITY_CONTEXT_ELEMENT>(),
    20usize,
    concat!("Size of: ", stringify!(_COMPATIBILITY_CONTEXT_ELEMENT))
  );
  assert_eq!(
    ::core::mem::align_of::<_COMPATIBILITY_CONTEXT_ELEMENT>(),
    4usize,
    concat!("Alignment of ", stringify!(_COMPATIBILITY_CONTEXT_ELEMENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMPATIBILITY_CONTEXT_ELEMENT>())).Id as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMPATIBILITY_CONTEXT_ELEMENT),
      "::",
      stringify!(Id)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_COMPATIBILITY_CONTEXT_ELEMENT>())).Type as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMPATIBILITY_CONTEXT_ELEMENT),
      "::",
      stringify!(Type)
    )
  );
}
impl Default for _COMPATIBILITY_CONTEXT_ELEMENT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type COMPATIBILITY_CONTEXT_ELEMENT = _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCOMPATIBILITY_CONTEXT_ELEMENT = *mut _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCCOMPATIBILITY_CONTEXT_ELEMENT = *const _COMPATIBILITY_CONTEXT_ELEMENT;
#[repr(C)]
#[derive(Debug)]
pub struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
  pub ElementCount: DWORD,
  pub Elements: __IncompleteArrayField<COMPATIBILITY_CONTEXT_ELEMENT>,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)
    )
  );
}
impl Default for _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
  _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
  *mut _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
  *const _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SUPPORTED_OS_INFO {
  pub MajorVersion: WORD,
  pub MinorVersion: WORD,
}
#[test]
fn bindgen_test_layout__SUPPORTED_OS_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SUPPORTED_OS_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SUPPORTED_OS_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SUPPORTED_OS_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_SUPPORTED_OS_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SUPPORTED_OS_INFO>())).MajorVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SUPPORTED_OS_INFO),
      "::",
      stringify!(MajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SUPPORTED_OS_INFO>())).MinorVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SUPPORTED_OS_INFO),
      "::",
      stringify!(MinorVersion)
    )
  );
}
pub type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO;
pub type PSUPPORTED_OS_INFO = *mut _SUPPORTED_OS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
  pub dwFlags: DWORD,
  pub ulFormatVersion: DWORD,
  pub ulAssemblyCount: DWORD,
  pub ulRootManifestPathType: DWORD,
  pub ulRootManifestPathChars: DWORD,
  pub ulRootConfigurationPathType: DWORD,
  pub ulRootConfigurationPathChars: DWORD,
  pub ulAppDirPathType: DWORD,
  pub ulAppDirPathChars: DWORD,
  pub lpRootManifestPath: PCWSTR,
  pub lpRootConfigurationPath: PCWSTR,
  pub lpAppDirPath: PCWSTR,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_DETAILED_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>(),
    64usize,
    concat!(
      "Size of: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).dwFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulFormatVersion
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulFormatVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulAssemblyCount
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulAssemblyCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulRootManifestPathType
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulRootManifestPathType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulRootManifestPathChars
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulRootManifestPathChars)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
        .ulRootConfigurationPathType as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulRootConfigurationPathType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
        .ulRootConfigurationPathChars as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulRootConfigurationPathChars)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulAppDirPathType
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulAppDirPathType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulAppDirPathChars
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(ulAppDirPathChars)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).lpRootManifestPath
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(lpRootManifestPath)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).lpRootConfigurationPath
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(lpRootConfigurationPath)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).lpAppDirPath as *const _
        as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
      "::",
      stringify!(lpAppDirPath)
    )
  );
}
impl Default for _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTIVATION_CONTEXT_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_DETAILED_INFORMATION = *mut _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_DETAILED_INFORMATION =
  *const _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _HARDWARE_COUNTER_DATA {
  pub Type: HARDWARE_COUNTER_TYPE,
  pub Reserved: DWORD,
  pub Value: DWORD64,
}
#[test]
fn bindgen_test_layout__HARDWARE_COUNTER_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_HARDWARE_COUNTER_DATA>(),
    16usize,
    concat!("Size of: ", stringify!(_HARDWARE_COUNTER_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_HARDWARE_COUNTER_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_HARDWARE_COUNTER_DATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HARDWARE_COUNTER_DATA>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HARDWARE_COUNTER_DATA),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HARDWARE_COUNTER_DATA>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_HARDWARE_COUNTER_DATA),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HARDWARE_COUNTER_DATA>())).Value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HARDWARE_COUNTER_DATA),
      "::",
      stringify!(Value)
    )
  );
}
impl Default for _HARDWARE_COUNTER_DATA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA;
pub type PHARDWARE_COUNTER_DATA = *mut _HARDWARE_COUNTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _PERFORMANCE_DATA {
  pub Size: WORD,
  pub Version: BYTE,
  pub HwCountersCount: BYTE,
  pub ContextSwitchCount: DWORD,
  pub WaitReasonBitMap: DWORD64,
  pub CycleTime: DWORD64,
  pub RetryCount: DWORD,
  pub Reserved: DWORD,
  pub HwCounters: [HARDWARE_COUNTER_DATA; 16usize],
}
#[test]
fn bindgen_test_layout__PERFORMANCE_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_PERFORMANCE_DATA>(),
    288usize,
    concat!("Size of: ", stringify!(_PERFORMANCE_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_PERFORMANCE_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_PERFORMANCE_DATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).Version as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).HwCountersCount as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(HwCountersCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).ContextSwitchCount as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(ContextSwitchCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).WaitReasonBitMap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(WaitReasonBitMap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).CycleTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(CycleTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).RetryCount as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(RetryCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).Reserved as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PERFORMANCE_DATA>())).HwCounters as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_PERFORMANCE_DATA),
      "::",
      stringify!(HwCounters)
    )
  );
}
impl Default for _PERFORMANCE_DATA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PERFORMANCE_DATA = _PERFORMANCE_DATA;
pub type PPERFORMANCE_DATA = *mut _PERFORMANCE_DATA;
extern "C" {
  pub fn RtlGetDeviceFamilyInfoEnum(
    pullUAPInfo: *mut ULONGLONG, pulDeviceFamily: *mut DWORD, pulDeviceForm: *mut DWORD,
  );
}
extern "C" {
  pub fn RtlConvertDeviceFamilyInfoToString(
    pulDeviceFamilyBufferSize: PDWORD, pulDeviceFormBufferSize: PDWORD, DeviceFamily: PWSTR,
    DeviceForm: PWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn RtlSwitchedVVI(
    VersionInfo: PRTL_OSVERSIONINFOEXW, TypeMask: DWORD, ConditionMask: ULONGLONG,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _EVENTLOGRECORD {
  pub Length: DWORD,
  pub Reserved: DWORD,
  pub RecordNumber: DWORD,
  pub TimeGenerated: DWORD,
  pub TimeWritten: DWORD,
  pub EventID: DWORD,
  pub EventType: WORD,
  pub NumStrings: WORD,
  pub EventCategory: WORD,
  pub ReservedFlags: WORD,
  pub ClosingRecordNumber: DWORD,
  pub StringOffset: DWORD,
  pub UserSidLength: DWORD,
  pub UserSidOffset: DWORD,
  pub DataLength: DWORD,
  pub DataOffset: DWORD,
}
#[test]
fn bindgen_test_layout__EVENTLOGRECORD() {
  assert_eq!(
    ::core::mem::size_of::<_EVENTLOGRECORD>(),
    56usize,
    concat!("Size of: ", stringify!(_EVENTLOGRECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_EVENTLOGRECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(_EVENTLOGRECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).Length as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).RecordNumber as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(RecordNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).TimeGenerated as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(TimeGenerated)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).TimeWritten as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(TimeWritten)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).EventID as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(EventID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).EventType as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(EventType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).NumStrings as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(NumStrings)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).EventCategory as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(EventCategory)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).ReservedFlags as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(ReservedFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EVENTLOGRECORD>())).ClosingRecordNumber as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(ClosingRecordNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).StringOffset as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(StringOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).UserSidLength as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(UserSidLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).UserSidOffset as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(UserSidOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).DataLength as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(DataLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOGRECORD>())).DataOffset as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOGRECORD),
      "::",
      stringify!(DataOffset)
    )
  );
}
pub type EVENTLOGRECORD = _EVENTLOGRECORD;
pub type PEVENTLOGRECORD = *mut _EVENTLOGRECORD;
pub type EVENTSFORLOGFILE = _EVENTSFORLOGFILE;
pub type PEVENTSFORLOGFILE = *mut _EVENTSFORLOGFILE;
pub type PACKEDEVENTINFO = _PACKEDEVENTINFO;
pub type PPACKEDEVENTINFO = *mut _PACKEDEVENTINFO;
#[repr(C)]
pub struct _EVENTSFORLOGFILE {
  pub ulSize: DWORD,
  pub szLogicalLogFile: [WCHAR; 256usize],
  pub ulNumRecords: DWORD,
  pub pEventLogRecords: __IncompleteArrayField<EVENTLOGRECORD>,
}
#[test]
fn bindgen_test_layout__EVENTSFORLOGFILE() {
  assert_eq!(
    ::core::mem::size_of::<_EVENTSFORLOGFILE>(),
    520usize,
    concat!("Size of: ", stringify!(_EVENTSFORLOGFILE))
  );
  assert_eq!(
    ::core::mem::align_of::<_EVENTSFORLOGFILE>(),
    4usize,
    concat!("Alignment of ", stringify!(_EVENTSFORLOGFILE))
  );
}
impl Default for _EVENTSFORLOGFILE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _EVENTSFORLOGFILE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_EVENTSFORLOGFILE {{ ulSize: {:?}, szLogicalLogFile: [...], ulNumRecords: {:?}, pEventLogRecords: {:?} }}" , self . ulSize , self . ulNumRecords , self . pEventLogRecords )
  }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _PACKEDEVENTINFO {
  pub ulSize: DWORD,
  pub ulNumEventsForLogFile: DWORD,
  pub ulOffsets: __IncompleteArrayField<DWORD>,
}
#[test]
fn bindgen_test_layout__PACKEDEVENTINFO() {
  assert_eq!(
    ::core::mem::size_of::<_PACKEDEVENTINFO>(),
    8usize,
    concat!("Size of: ", stringify!(_PACKEDEVENTINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_PACKEDEVENTINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_PACKEDEVENTINFO))
  );
}
pub mod _CM_SERVICE_NODE_TYPE {
  pub type Type = i32;
  pub const DriverType: Type = 1;
  pub const FileSystemType: Type = 2;
  pub const Win32ServiceOwnProcess: Type = 16;
  pub const Win32ServiceShareProcess: Type = 32;
  pub const AdapterType: Type = 4;
  pub const RecognizerType: Type = 8;
}
pub use self::_CM_SERVICE_NODE_TYPE::Type as SERVICE_NODE_TYPE;
pub mod _CM_SERVICE_LOAD_TYPE {
  pub type Type = i32;
  pub const BootLoad: Type = 0;
  pub const SystemLoad: Type = 1;
  pub const AutoLoad: Type = 2;
  pub const DemandLoad: Type = 3;
  pub const DisableLoad: Type = 4;
}
pub use self::_CM_SERVICE_LOAD_TYPE::Type as SERVICE_LOAD_TYPE;
pub mod _CM_ERROR_CONTROL_TYPE {
  pub type Type = i32;
  pub const IgnoreError: Type = 0;
  pub const NormalError: Type = 1;
  pub const SevereError: Type = 2;
  pub const CriticalError: Type = 3;
}
pub use self::_CM_ERROR_CONTROL_TYPE::Type as SERVICE_ERROR_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_ERASE {
  pub Type: DWORD,
  pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_ERASE() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_ERASE>(),
    8usize,
    concat!("Size of: ", stringify!(_TAPE_ERASE))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_ERASE>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_ERASE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_ERASE>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_ERASE),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_ERASE>())).Immediate as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_ERASE),
      "::",
      stringify!(Immediate)
    )
  );
}
pub type TAPE_ERASE = _TAPE_ERASE;
pub type PTAPE_ERASE = *mut _TAPE_ERASE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_PREPARE {
  pub Operation: DWORD,
  pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_PREPARE() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_PREPARE>(),
    8usize,
    concat!("Size of: ", stringify!(_TAPE_PREPARE))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_PREPARE>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_PREPARE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_PREPARE>())).Operation as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_PREPARE),
      "::",
      stringify!(Operation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_PREPARE>())).Immediate as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_PREPARE),
      "::",
      stringify!(Immediate)
    )
  );
}
pub type TAPE_PREPARE = _TAPE_PREPARE;
pub type PTAPE_PREPARE = *mut _TAPE_PREPARE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_WRITE_MARKS {
  pub Type: DWORD,
  pub Count: DWORD,
  pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_WRITE_MARKS() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_WRITE_MARKS>(),
    12usize,
    concat!("Size of: ", stringify!(_TAPE_WRITE_MARKS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_WRITE_MARKS>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_WRITE_MARKS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_WRITE_MARKS>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_WRITE_MARKS),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_WRITE_MARKS>())).Count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_WRITE_MARKS),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_WRITE_MARKS>())).Immediate as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_WRITE_MARKS),
      "::",
      stringify!(Immediate)
    )
  );
}
pub type TAPE_WRITE_MARKS = _TAPE_WRITE_MARKS;
pub type PTAPE_WRITE_MARKS = *mut _TAPE_WRITE_MARKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_POSITION {
  pub Type: DWORD,
  pub Partition: DWORD,
  pub Offset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TAPE_GET_POSITION() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_GET_POSITION>(),
    16usize,
    concat!("Size of: ", stringify!(_TAPE_GET_POSITION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_GET_POSITION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TAPE_GET_POSITION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_GET_POSITION>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_POSITION),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_GET_POSITION>())).Partition as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_POSITION),
      "::",
      stringify!(Partition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_GET_POSITION>())).Offset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_POSITION),
      "::",
      stringify!(Offset)
    )
  );
}
impl Default for _TAPE_GET_POSITION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TAPE_GET_POSITION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_TAPE_GET_POSITION {{ Type: {:?}, Partition: {:?}, Offset: {:?} }}",
      self.Type, self.Partition, self.Offset
    )
  }
}
pub type TAPE_GET_POSITION = _TAPE_GET_POSITION;
pub type PTAPE_GET_POSITION = *mut _TAPE_GET_POSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_SET_POSITION {
  pub Method: DWORD,
  pub Partition: DWORD,
  pub Offset: LARGE_INTEGER,
  pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_SET_POSITION() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_SET_POSITION>(),
    24usize,
    concat!("Size of: ", stringify!(_TAPE_SET_POSITION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_SET_POSITION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TAPE_SET_POSITION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_SET_POSITION>())).Method as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_POSITION),
      "::",
      stringify!(Method)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_SET_POSITION>())).Partition as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_POSITION),
      "::",
      stringify!(Partition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_SET_POSITION>())).Offset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_POSITION),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_SET_POSITION>())).Immediate as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_POSITION),
      "::",
      stringify!(Immediate)
    )
  );
}
impl Default for _TAPE_SET_POSITION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TAPE_SET_POSITION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_TAPE_SET_POSITION {{ Method: {:?}, Partition: {:?}, Offset: {:?}, Immediate: {:?} }}",
      self.Method, self.Partition, self.Offset, self.Immediate
    )
  }
}
pub type TAPE_SET_POSITION = _TAPE_SET_POSITION;
pub type PTAPE_SET_POSITION = *mut _TAPE_SET_POSITION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_GET_DRIVE_PARAMETERS {
  pub ECC: BOOLEAN,
  pub Compression: BOOLEAN,
  pub DataPadding: BOOLEAN,
  pub ReportSetmarks: BOOLEAN,
  pub DefaultBlockSize: DWORD,
  pub MaximumBlockSize: DWORD,
  pub MinimumBlockSize: DWORD,
  pub MaximumPartitionCount: DWORD,
  pub FeaturesLow: DWORD,
  pub FeaturesHigh: DWORD,
  pub EOTWarningZoneSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_GET_DRIVE_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_GET_DRIVE_PARAMETERS>(),
    32usize,
    concat!("Size of: ", stringify!(_TAPE_GET_DRIVE_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_GET_DRIVE_PARAMETERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_GET_DRIVE_PARAMETERS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).ECC as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(ECC)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).Compression as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(Compression)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).DataPadding as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(DataPadding)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).ReportSetmarks as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(ReportSetmarks)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).DefaultBlockSize as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(DefaultBlockSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).MaximumBlockSize as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(MaximumBlockSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).MinimumBlockSize as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(MinimumBlockSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).MaximumPartitionCount as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(MaximumPartitionCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).FeaturesLow as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(FeaturesLow)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).FeaturesHigh as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(FeaturesHigh)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).EOTWarningZoneSize as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_DRIVE_PARAMETERS),
      "::",
      stringify!(EOTWarningZoneSize)
    )
  );
}
pub type TAPE_GET_DRIVE_PARAMETERS = _TAPE_GET_DRIVE_PARAMETERS;
pub type PTAPE_GET_DRIVE_PARAMETERS = *mut _TAPE_GET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_SET_DRIVE_PARAMETERS {
  pub ECC: BOOLEAN,
  pub Compression: BOOLEAN,
  pub DataPadding: BOOLEAN,
  pub ReportSetmarks: BOOLEAN,
  pub EOTWarningZoneSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_SET_DRIVE_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_SET_DRIVE_PARAMETERS>(),
    8usize,
    concat!("Size of: ", stringify!(_TAPE_SET_DRIVE_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_SET_DRIVE_PARAMETERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_SET_DRIVE_PARAMETERS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).ECC as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_DRIVE_PARAMETERS),
      "::",
      stringify!(ECC)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).Compression as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_DRIVE_PARAMETERS),
      "::",
      stringify!(Compression)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).DataPadding as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_DRIVE_PARAMETERS),
      "::",
      stringify!(DataPadding)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).ReportSetmarks as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_DRIVE_PARAMETERS),
      "::",
      stringify!(ReportSetmarks)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).EOTWarningZoneSize as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_DRIVE_PARAMETERS),
      "::",
      stringify!(EOTWarningZoneSize)
    )
  );
}
pub type TAPE_SET_DRIVE_PARAMETERS = _TAPE_SET_DRIVE_PARAMETERS;
pub type PTAPE_SET_DRIVE_PARAMETERS = *mut _TAPE_SET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_MEDIA_PARAMETERS {
  pub Capacity: LARGE_INTEGER,
  pub Remaining: LARGE_INTEGER,
  pub BlockSize: DWORD,
  pub PartitionCount: DWORD,
  pub WriteProtected: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_GET_MEDIA_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_GET_MEDIA_PARAMETERS>(),
    32usize,
    concat!("Size of: ", stringify!(_TAPE_GET_MEDIA_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_GET_MEDIA_PARAMETERS>(),
    8usize,
    concat!("Alignment of ", stringify!(_TAPE_GET_MEDIA_PARAMETERS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).Capacity as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_MEDIA_PARAMETERS),
      "::",
      stringify!(Capacity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).Remaining as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_MEDIA_PARAMETERS),
      "::",
      stringify!(Remaining)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).BlockSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_MEDIA_PARAMETERS),
      "::",
      stringify!(BlockSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).PartitionCount as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_MEDIA_PARAMETERS),
      "::",
      stringify!(PartitionCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).WriteProtected as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_GET_MEDIA_PARAMETERS),
      "::",
      stringify!(WriteProtected)
    )
  );
}
impl Default for _TAPE_GET_MEDIA_PARAMETERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TAPE_GET_MEDIA_PARAMETERS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_TAPE_GET_MEDIA_PARAMETERS {{ Capacity: {:?}, Remaining: {:?}, BlockSize: {:?}, PartitionCount: {:?}, WriteProtected: {:?} }}" , self . Capacity , self . Remaining , self . BlockSize , self . PartitionCount , self . WriteProtected )
  }
}
pub type TAPE_GET_MEDIA_PARAMETERS = _TAPE_GET_MEDIA_PARAMETERS;
pub type PTAPE_GET_MEDIA_PARAMETERS = *mut _TAPE_GET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_SET_MEDIA_PARAMETERS {
  pub BlockSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_SET_MEDIA_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_SET_MEDIA_PARAMETERS>(),
    4usize,
    concat!("Size of: ", stringify!(_TAPE_SET_MEDIA_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_SET_MEDIA_PARAMETERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_SET_MEDIA_PARAMETERS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_SET_MEDIA_PARAMETERS>())).BlockSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_SET_MEDIA_PARAMETERS),
      "::",
      stringify!(BlockSize)
    )
  );
}
pub type TAPE_SET_MEDIA_PARAMETERS = _TAPE_SET_MEDIA_PARAMETERS;
pub type PTAPE_SET_MEDIA_PARAMETERS = *mut _TAPE_SET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TAPE_CREATE_PARTITION {
  pub Method: DWORD,
  pub Count: DWORD,
  pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_CREATE_PARTITION() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_CREATE_PARTITION>(),
    12usize,
    concat!("Size of: ", stringify!(_TAPE_CREATE_PARTITION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_CREATE_PARTITION>(),
    4usize,
    concat!("Alignment of ", stringify!(_TAPE_CREATE_PARTITION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_CREATE_PARTITION>())).Method as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_CREATE_PARTITION),
      "::",
      stringify!(Method)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_CREATE_PARTITION>())).Count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_CREATE_PARTITION),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_CREATE_PARTITION>())).Size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_CREATE_PARTITION),
      "::",
      stringify!(Size)
    )
  );
}
pub type TAPE_CREATE_PARTITION = _TAPE_CREATE_PARTITION;
pub type PTAPE_CREATE_PARTITION = *mut _TAPE_CREATE_PARTITION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TAPE_WMI_OPERATIONS {
  pub Method: DWORD,
  pub DataBufferSize: DWORD,
  pub DataBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__TAPE_WMI_OPERATIONS() {
  assert_eq!(
    ::core::mem::size_of::<_TAPE_WMI_OPERATIONS>(),
    16usize,
    concat!("Size of: ", stringify!(_TAPE_WMI_OPERATIONS))
  );
  assert_eq!(
    ::core::mem::align_of::<_TAPE_WMI_OPERATIONS>(),
    8usize,
    concat!("Alignment of ", stringify!(_TAPE_WMI_OPERATIONS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_WMI_OPERATIONS>())).Method as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_WMI_OPERATIONS),
      "::",
      stringify!(Method)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TAPE_WMI_OPERATIONS>())).DataBufferSize as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_WMI_OPERATIONS),
      "::",
      stringify!(DataBufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TAPE_WMI_OPERATIONS>())).DataBuffer as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TAPE_WMI_OPERATIONS),
      "::",
      stringify!(DataBuffer)
    )
  );
}
impl Default for _TAPE_WMI_OPERATIONS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TAPE_WMI_OPERATIONS = _TAPE_WMI_OPERATIONS;
pub type PTAPE_WMI_OPERATIONS = *mut _TAPE_WMI_OPERATIONS;
pub mod _TAPE_DRIVE_PROBLEM_TYPE {
  pub type Type = i32;
  pub const TapeDriveProblemNone: Type = 0;
  pub const TapeDriveReadWriteWarning: Type = 1;
  pub const TapeDriveReadWriteError: Type = 2;
  pub const TapeDriveReadWarning: Type = 3;
  pub const TapeDriveWriteWarning: Type = 4;
  pub const TapeDriveReadError: Type = 5;
  pub const TapeDriveWriteError: Type = 6;
  pub const TapeDriveHardwareError: Type = 7;
  pub const TapeDriveUnsupportedMedia: Type = 8;
  pub const TapeDriveScsiConnectionError: Type = 9;
  pub const TapeDriveTimetoClean: Type = 10;
  pub const TapeDriveCleanDriveNow: Type = 11;
  pub const TapeDriveMediaLifeExpired: Type = 12;
  pub const TapeDriveSnappedTape: Type = 13;
}
pub use self::_TAPE_DRIVE_PROBLEM_TYPE::Type as TAPE_DRIVE_PROBLEM_TYPE;
pub type UOW = GUID;
pub type PUOW = *mut GUID;
pub type CRM_PROTOCOL_ID = GUID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
  pub TransactionKey: PVOID,
  pub TransactionNotification: ULONG,
  pub TmVirtualClock: LARGE_INTEGER,
  pub ArgumentLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_NOTIFICATION>(),
    32usize,
    concat!("Size of: ", stringify!(_TRANSACTION_NOTIFICATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_NOTIFICATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TRANSACTION_NOTIFICATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION>())).TransactionKey as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION),
      "::",
      stringify!(TransactionKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION>())).TransactionNotification as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION),
      "::",
      stringify!(TransactionNotification)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION>())).TmVirtualClock as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION),
      "::",
      stringify!(TmVirtualClock)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION>())).ArgumentLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION),
      "::",
      stringify!(ArgumentLength)
    )
  );
}
impl Default for _TRANSACTION_NOTIFICATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TRANSACTION_NOTIFICATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_TRANSACTION_NOTIFICATION {{ TransactionKey: {:?}, TransactionNotification: {:?}, TmVirtualClock: {:?}, ArgumentLength: {:?} }}" , self . TransactionKey , self . TransactionNotification , self . TmVirtualClock , self . ArgumentLength )
  }
}
pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
  pub EnlistmentId: GUID,
  pub UOW: UOW,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>())).EnlistmentId
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT),
      "::",
      stringify!(EnlistmentId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>())).UOW as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT),
      "::",
      stringify!(UOW)
    )
  );
}
pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
  *mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
  pub TmIdentity: GUID,
  pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>(),
    20usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>())).TmIdentity
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT),
      "::",
      stringify!(TmIdentity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>())).Flags as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT),
      "::",
      stringify!(Flags)
    )
  );
}
pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
  *mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
  pub SavepointId: SAVEPOINT_ID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>())).SavepointId
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT),
      "::",
      stringify!(SavepointId)
    )
  );
}
pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
  *mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
  pub PropagationCookie: ULONG,
  pub UOW: GUID,
  pub TmIdentity: GUID,
  pub BufferLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).PropagationCookie
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
      "::",
      stringify!(PropagationCookie)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).UOW as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
      "::",
      stringify!(UOW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).TmIdentity
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
      "::",
      stringify!(TmIdentity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).BufferLength
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
      "::",
      stringify!(BufferLength)
    )
  );
}
pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
  *mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
  pub MarshalCookie: ULONG,
  pub UOW: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>(),
    20usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>())).MarshalCookie
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT),
      "::",
      stringify!(MarshalCookie)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>())).UOW as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT),
      "::",
      stringify!(UOW)
    )
  );
}
pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
  *mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
  *mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _KCRM_MARSHAL_HEADER {
  pub VersionMajor: ULONG,
  pub VersionMinor: ULONG,
  pub NumProtocols: ULONG,
  pub Unused: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_MARSHAL_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<_KCRM_MARSHAL_HEADER>(),
    16usize,
    concat!("Size of: ", stringify!(_KCRM_MARSHAL_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_KCRM_MARSHAL_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_KCRM_MARSHAL_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_MARSHAL_HEADER>())).VersionMajor as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_MARSHAL_HEADER),
      "::",
      stringify!(VersionMajor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_MARSHAL_HEADER>())).VersionMinor as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_MARSHAL_HEADER),
      "::",
      stringify!(VersionMinor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_MARSHAL_HEADER>())).NumProtocols as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_MARSHAL_HEADER),
      "::",
      stringify!(NumProtocols)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_MARSHAL_HEADER>())).Unused as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_MARSHAL_HEADER),
      "::",
      stringify!(Unused)
    )
  );
}
pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KCRM_TRANSACTION_BLOB {
  pub UOW: UOW,
  pub TmIdentity: GUID,
  pub IsolationLevel: ULONG,
  pub IsolationFlags: ULONG,
  pub Timeout: ULONG,
  pub Description: [WCHAR; 64usize],
}
#[test]
fn bindgen_test_layout__KCRM_TRANSACTION_BLOB() {
  assert_eq!(
    ::core::mem::size_of::<_KCRM_TRANSACTION_BLOB>(),
    172usize,
    concat!("Size of: ", stringify!(_KCRM_TRANSACTION_BLOB))
  );
  assert_eq!(
    ::core::mem::align_of::<_KCRM_TRANSACTION_BLOB>(),
    4usize,
    concat!("Alignment of ", stringify!(_KCRM_TRANSACTION_BLOB))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_TRANSACTION_BLOB>())).UOW as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_TRANSACTION_BLOB),
      "::",
      stringify!(UOW)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_TRANSACTION_BLOB>())).TmIdentity as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_TRANSACTION_BLOB),
      "::",
      stringify!(TmIdentity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KCRM_TRANSACTION_BLOB>())).IsolationLevel as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_TRANSACTION_BLOB),
      "::",
      stringify!(IsolationLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KCRM_TRANSACTION_BLOB>())).IsolationFlags as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_TRANSACTION_BLOB),
      "::",
      stringify!(IsolationFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_TRANSACTION_BLOB>())).Timeout as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_TRANSACTION_BLOB),
      "::",
      stringify!(Timeout)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_TRANSACTION_BLOB>())).Description as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_TRANSACTION_BLOB),
      "::",
      stringify!(Description)
    )
  );
}
impl Default for _KCRM_TRANSACTION_BLOB {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _KCRM_TRANSACTION_BLOB {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_KCRM_TRANSACTION_BLOB {{ UOW: {:?}, TmIdentity: {:?}, IsolationLevel: {:?}, IsolationFlags: {:?}, Timeout: {:?}, Description: [...] }}" , self . UOW , self . TmIdentity , self . IsolationLevel , self . IsolationFlags , self . Timeout )
  }
}
impl ::core::cmp::PartialEq for _KCRM_TRANSACTION_BLOB {
  fn eq(&self, other: &_KCRM_TRANSACTION_BLOB) -> bool {
    self.UOW == other.UOW
      && self.TmIdentity == other.TmIdentity
      && self.IsolationLevel == other.IsolationLevel
      && self.IsolationFlags == other.IsolationFlags
      && self.Timeout == other.Timeout
      && &self.Description[..] == &other.Description[..]
  }
}
pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _KCRM_PROTOCOL_BLOB {
  pub ProtocolId: CRM_PROTOCOL_ID,
  pub StaticInfoLength: ULONG,
  pub TransactionIdInfoLength: ULONG,
  pub Unused1: ULONG,
  pub Unused2: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_PROTOCOL_BLOB() {
  assert_eq!(
    ::core::mem::size_of::<_KCRM_PROTOCOL_BLOB>(),
    32usize,
    concat!("Size of: ", stringify!(_KCRM_PROTOCOL_BLOB))
  );
  assert_eq!(
    ::core::mem::align_of::<_KCRM_PROTOCOL_BLOB>(),
    4usize,
    concat!("Alignment of ", stringify!(_KCRM_PROTOCOL_BLOB))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_PROTOCOL_BLOB>())).ProtocolId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_PROTOCOL_BLOB),
      "::",
      stringify!(ProtocolId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KCRM_PROTOCOL_BLOB>())).StaticInfoLength as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_PROTOCOL_BLOB),
      "::",
      stringify!(StaticInfoLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KCRM_PROTOCOL_BLOB>())).TransactionIdInfoLength as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_PROTOCOL_BLOB),
      "::",
      stringify!(TransactionIdInfoLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_PROTOCOL_BLOB>())).Unused1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_PROTOCOL_BLOB),
      "::",
      stringify!(Unused1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KCRM_PROTOCOL_BLOB>())).Unused2 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_KCRM_PROTOCOL_BLOB),
      "::",
      stringify!(Unused2)
    )
  );
}
pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub mod _TRANSACTION_OUTCOME {
  pub type Type = i32;
  pub const TransactionOutcomeUndetermined: Type = 1;
  pub const TransactionOutcomeCommitted: Type = 2;
  pub const TransactionOutcomeAborted: Type = 3;
}
pub use self::_TRANSACTION_OUTCOME::Type as TRANSACTION_OUTCOME;
pub mod _TRANSACTION_STATE {
  pub type Type = i32;
  pub const TransactionStateNormal: Type = 1;
  pub const TransactionStateIndoubt: Type = 2;
  pub const TransactionStateCommittedNotify: Type = 3;
}
pub use self::_TRANSACTION_STATE::Type as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_BASIC_INFORMATION {
  pub TransactionId: GUID,
  pub State: DWORD,
  pub Outcome: DWORD,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_BASIC_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_TRANSACTION_BASIC_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_TRANSACTION_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_BASIC_INFORMATION>())).TransactionId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_BASIC_INFORMATION),
      "::",
      stringify!(TransactionId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_BASIC_INFORMATION>())).State as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_BASIC_INFORMATION),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_BASIC_INFORMATION>())).Outcome as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_BASIC_INFORMATION),
      "::",
      stringify!(Outcome)
    )
  );
}
pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
  pub TmIdentity: GUID,
  pub VirtualClock: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_BASIC_INFORMATION>())).TmIdentity as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION),
      "::",
      stringify!(TmIdentity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_BASIC_INFORMATION>())).VirtualClock as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION),
      "::",
      stringify!(VirtualClock)
    )
  );
}
impl Default for _TRANSACTIONMANAGER_BASIC_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TRANSACTIONMANAGER_BASIC_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_TRANSACTIONMANAGER_BASIC_INFORMATION {{ TmIdentity: {:?}, VirtualClock: {:?} }}",
      self.TmIdentity, self.VirtualClock
    )
  }
}
pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
  pub LogIdentity: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOG_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_LOG_INFORMATION>())).LogIdentity as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION),
      "::",
      stringify!(LogIdentity)
    )
  );
}
pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION = *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
  pub LogPathLength: DWORD,
  pub LogPath: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOGPATH_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>())).LogPathLength as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION),
      "::",
      stringify!(LogPathLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>())).LogPath as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION),
      "::",
      stringify!(LogPath)
    )
  );
}
pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
  pub LastRecoveredLsn: ULONGLONG,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_RECOVERY_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>())).LastRecoveredLsn
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION),
      "::",
      stringify!(LastRecoveredLsn)
    )
  );
}
pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
  pub OldestTransactionGuid: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_OLDEST_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>())).OldestTransactionGuid
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION),
      "::",
      stringify!(OldestTransactionGuid)
    )
  );
}
pub type TRANSACTIONMANAGER_OLDEST_INFORMATION = _TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub type PTRANSACTIONMANAGER_OLDEST_INFORMATION = *mut _TRANSACTIONMANAGER_OLDEST_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
  pub IsolationLevel: DWORD,
  pub IsolationFlags: DWORD,
  pub Timeout: LARGE_INTEGER,
  pub Outcome: DWORD,
  pub DescriptionLength: DWORD,
  pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_PROPERTIES_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_PROPERTIES_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(_TRANSACTION_PROPERTIES_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_PROPERTIES_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).IsolationLevel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
      "::",
      stringify!(IsolationLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).IsolationFlags as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
      "::",
      stringify!(IsolationFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).Timeout as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
      "::",
      stringify!(Timeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).Outcome as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
      "::",
      stringify!(Outcome)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).DescriptionLength as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
      "::",
      stringify!(DescriptionLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).Description as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
      "::",
      stringify!(Description)
    )
  );
}
impl Default for _TRANSACTION_PROPERTIES_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TRANSACTION_PROPERTIES_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_TRANSACTION_PROPERTIES_INFORMATION {{ IsolationLevel: {:?}, IsolationFlags: {:?}, Timeout: {:?}, Outcome: {:?}, DescriptionLength: {:?}, Description: {:?} }}" , self . IsolationLevel , self . IsolationFlags , self . Timeout , self . Outcome , self . DescriptionLength , self . Description )
  }
}
pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION = *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_BIND_INFORMATION {
  pub TmHandle: HANDLE,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BIND_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_BIND_INFORMATION>(),
    8usize,
    concat!("Size of: ", stringify!(_TRANSACTION_BIND_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_BIND_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TRANSACTION_BIND_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_BIND_INFORMATION>())).TmHandle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_BIND_INFORMATION),
      "::",
      stringify!(TmHandle)
    )
  );
}
impl Default for _TRANSACTION_BIND_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
  pub EnlistmentId: GUID,
  pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENT_PAIR() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_ENLISTMENT_PAIR>(),
    32usize,
    concat!("Size of: ", stringify!(_TRANSACTION_ENLISTMENT_PAIR))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_ENLISTMENT_PAIR>(),
    4usize,
    concat!("Alignment of ", stringify!(_TRANSACTION_ENLISTMENT_PAIR))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_ENLISTMENT_PAIR>())).EnlistmentId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_ENLISTMENT_PAIR),
      "::",
      stringify!(EnlistmentId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_ENLISTMENT_PAIR>())).ResourceManagerId as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_ENLISTMENT_PAIR),
      "::",
      stringify!(ResourceManagerId)
    )
  );
}
pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
  pub NumberOfEnlistments: DWORD,
  pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENTS_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>(),
    36usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_ENLISTMENTS_INFORMATION>())).NumberOfEnlistments
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION),
      "::",
      stringify!(NumberOfEnlistments)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_ENLISTMENTS_INFORMATION>())).EnlistmentPair as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION),
      "::",
      stringify!(EnlistmentPair)
    )
  );
}
pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION = *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
  pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
#[test]
fn bindgen_test_layout__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>()))
        .SuperiorEnlistmentPair as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION),
      "::",
      stringify!(SuperiorEnlistmentPair)
    )
  );
}
pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
  *mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
  pub ResourceManagerId: GUID,
  pub DescriptionLength: DWORD,
  pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_RESOURCEMANAGER_BASIC_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_RESOURCEMANAGER_BASIC_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_RESOURCEMANAGER_BASIC_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_RESOURCEMANAGER_BASIC_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESOURCEMANAGER_BASIC_INFORMATION>())).ResourceManagerId as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
      "::",
      stringify!(ResourceManagerId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESOURCEMANAGER_BASIC_INFORMATION>())).DescriptionLength as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
      "::",
      stringify!(DescriptionLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESOURCEMANAGER_BASIC_INFORMATION>())).Description as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
      "::",
      stringify!(Description)
    )
  );
}
pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION = *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
  pub IoCompletionPortHandle: HANDLE,
  pub CompletionKey: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_COMPLETION_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESOURCEMANAGER_COMPLETION_INFORMATION>())).IoCompletionPortHandle
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION),
      "::",
      stringify!(IoCompletionPortHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_RESOURCEMANAGER_COMPLETION_INFORMATION>())).CompletionKey as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION),
      "::",
      stringify!(CompletionKey)
    )
  );
}
impl Default for _RESOURCEMANAGER_COMPLETION_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub mod _TRANSACTION_INFORMATION_CLASS {
  pub type Type = i32;
  pub const TransactionBasicInformation: Type = 0;
  pub const TransactionPropertiesInformation: Type = 1;
  pub const TransactionEnlistmentInformation: Type = 2;
  pub const TransactionSuperiorEnlistmentInformation: Type = 3;
  pub const TransactionBindInformation: Type = 4;
  pub const TransactionDTCPrivateInformation: Type = 5;
}
pub use self::_TRANSACTION_INFORMATION_CLASS::Type as TRANSACTION_INFORMATION_CLASS;
pub mod _TRANSACTIONMANAGER_INFORMATION_CLASS {
  pub type Type = i32;
  pub const TransactionManagerBasicInformation: Type = 0;
  pub const TransactionManagerLogInformation: Type = 1;
  pub const TransactionManagerLogPathInformation: Type = 2;
  pub const TransactionManagerRecoveryInformation: Type = 4;
  pub const TransactionManagerOnlineProbeInformation: Type = 3;
  pub const TransactionManagerOldestTransactionInformation: Type = 5;
}
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS::Type as TRANSACTIONMANAGER_INFORMATION_CLASS;
pub mod _RESOURCEMANAGER_INFORMATION_CLASS {
  pub type Type = i32;
  pub const ResourceManagerBasicInformation: Type = 0;
  pub const ResourceManagerCompletionInformation: Type = 1;
}
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS::Type as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
  pub EnlistmentId: GUID,
  pub TransactionId: GUID,
  pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ENLISTMENT_BASIC_INFORMATION>(),
    48usize,
    concat!("Size of: ", stringify!(_ENLISTMENT_BASIC_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENLISTMENT_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_ENLISTMENT_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENLISTMENT_BASIC_INFORMATION>())).EnlistmentId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENLISTMENT_BASIC_INFORMATION),
      "::",
      stringify!(EnlistmentId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENLISTMENT_BASIC_INFORMATION>())).TransactionId as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENLISTMENT_BASIC_INFORMATION),
      "::",
      stringify!(TransactionId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENLISTMENT_BASIC_INFORMATION>())).ResourceManagerId as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENLISTMENT_BASIC_INFORMATION),
      "::",
      stringify!(ResourceManagerId)
    )
  );
}
pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ENLISTMENT_CRM_INFORMATION {
  pub CrmTransactionManagerId: GUID,
  pub CrmResourceManagerId: GUID,
  pub CrmEnlistmentId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_CRM_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ENLISTMENT_CRM_INFORMATION>(),
    48usize,
    concat!("Size of: ", stringify!(_ENLISTMENT_CRM_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENLISTMENT_CRM_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_ENLISTMENT_CRM_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENLISTMENT_CRM_INFORMATION>())).CrmTransactionManagerId as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENLISTMENT_CRM_INFORMATION),
      "::",
      stringify!(CrmTransactionManagerId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENLISTMENT_CRM_INFORMATION>())).CrmResourceManagerId as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENLISTMENT_CRM_INFORMATION),
      "::",
      stringify!(CrmResourceManagerId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENLISTMENT_CRM_INFORMATION>())).CrmEnlistmentId as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENLISTMENT_CRM_INFORMATION),
      "::",
      stringify!(CrmEnlistmentId)
    )
  );
}
pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
pub mod _ENLISTMENT_INFORMATION_CLASS {
  pub type Type = i32;
  pub const EnlistmentBasicInformation: Type = 0;
  pub const EnlistmentRecoveryInformation: Type = 1;
  pub const EnlistmentCrmInformation: Type = 2;
}
pub use self::_ENLISTMENT_INFORMATION_CLASS::Type as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_LIST_ENTRY {
  pub UOW: UOW,
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_LIST_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_TRANSACTION_LIST_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_LIST_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_TRANSACTION_LIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRANSACTION_LIST_ENTRY>())).UOW as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_LIST_ENTRY),
      "::",
      stringify!(UOW)
    )
  );
}
pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRANSACTION_LIST_INFORMATION {
  pub NumberOfTransactions: DWORD,
  pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TRANSACTION_LIST_INFORMATION>(),
    20usize,
    concat!("Size of: ", stringify!(_TRANSACTION_LIST_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRANSACTION_LIST_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_TRANSACTION_LIST_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_LIST_INFORMATION>())).NumberOfTransactions as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_LIST_INFORMATION),
      "::",
      stringify!(NumberOfTransactions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TRANSACTION_LIST_INFORMATION>())).TransactionInformation as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRANSACTION_LIST_INFORMATION),
      "::",
      stringify!(TransactionInformation)
    )
  );
}
pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
pub mod _KTMOBJECT_TYPE {
  pub type Type = i32;
  pub const KTMOBJECT_TRANSACTION: Type = 0;
  pub const KTMOBJECT_TRANSACTION_MANAGER: Type = 1;
  pub const KTMOBJECT_RESOURCE_MANAGER: Type = 2;
  pub const KTMOBJECT_ENLISTMENT: Type = 3;
  pub const KTMOBJECT_INVALID: Type = 4;
}
pub use self::_KTMOBJECT_TYPE::Type as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE::Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _KTMOBJECT_CURSOR {
  pub LastQuery: GUID,
  pub ObjectIdCount: DWORD,
  pub ObjectIds: [GUID; 1usize],
}
#[test]
fn bindgen_test_layout__KTMOBJECT_CURSOR() {
  assert_eq!(
    ::core::mem::size_of::<_KTMOBJECT_CURSOR>(),
    36usize,
    concat!("Size of: ", stringify!(_KTMOBJECT_CURSOR))
  );
  assert_eq!(
    ::core::mem::align_of::<_KTMOBJECT_CURSOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_KTMOBJECT_CURSOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KTMOBJECT_CURSOR>())).LastQuery as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KTMOBJECT_CURSOR),
      "::",
      stringify!(LastQuery)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KTMOBJECT_CURSOR>())).ObjectIdCount as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_KTMOBJECT_CURSOR),
      "::",
      stringify!(ObjectIdCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KTMOBJECT_CURSOR>())).ObjectIds as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_KTMOBJECT_CURSOR),
      "::",
      stringify!(ObjectIds)
    )
  );
}
pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
pub type TP_VERSION = DWORD;
pub type PTP_VERSION = *mut DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {
  _unused: [u8; 0],
}
pub type TP_CALLBACK_INSTANCE = _TP_CALLBACK_INSTANCE;
pub type PTP_CALLBACK_INSTANCE = *mut _TP_CALLBACK_INSTANCE;
pub type PTP_SIMPLE_CALLBACK =
  ::core::option::Option<unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL {
  _unused: [u8; 0],
}
pub type TP_POOL = _TP_POOL;
pub type PTP_POOL = *mut _TP_POOL;
pub mod _TP_CALLBACK_PRIORITY {
  pub type Type = i32;
  pub const TP_CALLBACK_PRIORITY_HIGH: Type = 0;
  pub const TP_CALLBACK_PRIORITY_NORMAL: Type = 1;
  pub const TP_CALLBACK_PRIORITY_LOW: Type = 2;
  pub const TP_CALLBACK_PRIORITY_INVALID: Type = 3;
  pub const TP_CALLBACK_PRIORITY_COUNT: Type = 3;
}
pub use self::_TP_CALLBACK_PRIORITY::Type as TP_CALLBACK_PRIORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TP_POOL_STACK_INFORMATION {
  pub StackReserve: SIZE_T,
  pub StackCommit: SIZE_T,
}
#[test]
fn bindgen_test_layout__TP_POOL_STACK_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TP_POOL_STACK_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_TP_POOL_STACK_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TP_POOL_STACK_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_TP_POOL_STACK_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_POOL_STACK_INFORMATION>())).StackReserve as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_POOL_STACK_INFORMATION),
      "::",
      stringify!(StackReserve)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_POOL_STACK_INFORMATION>())).StackCommit as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_POOL_STACK_INFORMATION),
      "::",
      stringify!(StackCommit)
    )
  );
}
pub type TP_POOL_STACK_INFORMATION = _TP_POOL_STACK_INFORMATION;
pub type PTP_POOL_STACK_INFORMATION = *mut _TP_POOL_STACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {
  _unused: [u8; 0],
}
pub type TP_CLEANUP_GROUP = _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP = *mut _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
  ::core::option::Option<unsafe extern "C" fn(ObjectContext: PVOID, CleanupContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
  pub Version: TP_VERSION,
  pub Pool: PTP_POOL,
  pub CleanupGroup: PTP_CLEANUP_GROUP,
  pub CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
  pub RaceDll: PVOID,
  pub ActivationContext: *mut _ACTIVATION_CONTEXT,
  pub FinalizationCallback: PTP_SIMPLE_CALLBACK,
  pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
  pub CallbackPriority: TP_CALLBACK_PRIORITY,
  pub Size: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
  pub Flags: DWORD,
  pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn LongFunction(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_LongFunction(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Persistent(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Persistent(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Private(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_Private(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    LongFunction: DWORD, Persistent: DWORD, Private: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let LongFunction: u32 = unsafe { ::core::mem::transmute(LongFunction) };
      LongFunction as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let Persistent: u32 = unsafe { ::core::mem::transmute(Persistent) };
      Persistent as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let Private: u32 = unsafe { ::core::mem::transmute(Private) };
      Private as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>())).Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>())).s as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1),
      "::",
      stringify!(s)
    )
  );
}
impl Default for _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3() {
  assert_eq!(
    ::core::mem::size_of::<_TP_CALLBACK_ENVIRON_V3>(),
    72usize,
    concat!("Size of: ", stringify!(_TP_CALLBACK_ENVIRON_V3))
  );
  assert_eq!(
    ::core::mem::align_of::<_TP_CALLBACK_ENVIRON_V3>(),
    8usize,
    concat!("Alignment of ", stringify!(_TP_CALLBACK_ENVIRON_V3))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).Pool as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(Pool)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).CleanupGroup as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(CleanupGroup)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).CleanupGroupCancelCallback as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(CleanupGroupCancelCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).RaceDll as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(RaceDll)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).ActivationContext as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(ActivationContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).FinalizationCallback as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(FinalizationCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).u as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).CallbackPriority as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(CallbackPriority)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).Size as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_TP_CALLBACK_ENVIRON_V3),
      "::",
      stringify!(Size)
    )
  );
}
impl Default for _TP_CALLBACK_ENVIRON_V3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TP_CALLBACK_ENVIRON_V3 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_TP_CALLBACK_ENVIRON_V3 {{ Version: {:?}, Pool: {:?}, CleanupGroup: {:?}, CleanupGroupCancelCallback: {:?}, RaceDll: {:?}, ActivationContext: {:?}, FinalizationCallback: {:?}, u: {:?}, CallbackPriority: {:?}, Size: {:?} }}" , self . Version , self . Pool , self . CleanupGroup , self . CleanupGroupCancelCallback , self . RaceDll , self . ActivationContext , self . FinalizationCallback , self . u , self . CallbackPriority , self . Size )
  }
}
pub type TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3;
pub type TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3;
pub type PTP_CALLBACK_ENVIRON = *mut TP_CALLBACK_ENVIRON_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WORK {
  _unused: [u8; 0],
}
pub type TP_WORK = _TP_WORK;
pub type PTP_WORK = *mut _TP_WORK;
pub type PTP_WORK_CALLBACK = ::core::option::Option<
  unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Work: PTP_WORK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_TIMER {
  _unused: [u8; 0],
}
pub type TP_TIMER = _TP_TIMER;
pub type PTP_TIMER = *mut _TP_TIMER;
pub type PTP_TIMER_CALLBACK = ::core::option::Option<
  unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Timer: PTP_TIMER),
>;
pub type TP_WAIT_RESULT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WAIT {
  _unused: [u8; 0],
}
pub type TP_WAIT = _TP_WAIT;
pub type PTP_WAIT = *mut _TP_WAIT;
pub type PTP_WAIT_CALLBACK = ::core::option::Option<
  unsafe extern "C" fn(
    Instance: PTP_CALLBACK_INSTANCE,
    Context: PVOID,
    Wait: PTP_WAIT,
    WaitResult: TP_WAIT_RESULT,
  ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_IO {
  _unused: [u8; 0],
}
pub type TP_IO = _TP_IO;
pub type PTP_IO = *mut _TP_IO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB {
  _unused: [u8; 0],
}
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
pub type SPHANDLE = *mut HANDLE;
pub type LPHANDLE = *mut HANDLE;
pub type HGLOBAL = HANDLE;
pub type HLOCAL = HANDLE;
pub type GLOBALHANDLE = HANDLE;
pub type LOCALHANDLE = HANDLE;
pub type FARPROC = ::core::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type NEARPROC = ::core::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type PROC = ::core::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type ATOM = WORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HKEY__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HKEY__() {
  assert_eq!(
    ::core::mem::size_of::<HKEY__>(),
    4usize,
    concat!("Size of: ", stringify!(HKEY__))
  );
  assert_eq!(
    ::core::mem::align_of::<HKEY__>(),
    4usize,
    concat!("Alignment of ", stringify!(HKEY__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HKEY__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HKEY__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HKEY = *mut HKEY__;
pub type PHKEY = *mut HKEY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HMETAFILE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HMETAFILE__() {
  assert_eq!(
    ::core::mem::size_of::<HMETAFILE__>(),
    4usize,
    concat!("Size of: ", stringify!(HMETAFILE__))
  );
  assert_eq!(
    ::core::mem::align_of::<HMETAFILE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HMETAFILE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HMETAFILE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HMETAFILE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HMETAFILE = *mut HMETAFILE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HINSTANCE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
  assert_eq!(
    ::core::mem::size_of::<HINSTANCE__>(),
    4usize,
    concat!("Size of: ", stringify!(HINSTANCE__))
  );
  assert_eq!(
    ::core::mem::align_of::<HINSTANCE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HINSTANCE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HINSTANCE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HINSTANCE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HINSTANCE = *mut HINSTANCE__;
pub type HMODULE = HINSTANCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HRGN__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HRGN__() {
  assert_eq!(
    ::core::mem::size_of::<HRGN__>(),
    4usize,
    concat!("Size of: ", stringify!(HRGN__))
  );
  assert_eq!(
    ::core::mem::align_of::<HRGN__>(),
    4usize,
    concat!("Alignment of ", stringify!(HRGN__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HRGN__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HRGN__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HRGN = *mut HRGN__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HRSRC__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HRSRC__() {
  assert_eq!(
    ::core::mem::size_of::<HRSRC__>(),
    4usize,
    concat!("Size of: ", stringify!(HRSRC__))
  );
  assert_eq!(
    ::core::mem::align_of::<HRSRC__>(),
    4usize,
    concat!("Alignment of ", stringify!(HRSRC__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HRSRC__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HRSRC__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HRSRC = *mut HRSRC__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HSPRITE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HSPRITE__() {
  assert_eq!(
    ::core::mem::size_of::<HSPRITE__>(),
    4usize,
    concat!("Size of: ", stringify!(HSPRITE__))
  );
  assert_eq!(
    ::core::mem::align_of::<HSPRITE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HSPRITE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HSPRITE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HSPRITE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HSPRITE = *mut HSPRITE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HLSURF__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HLSURF__() {
  assert_eq!(
    ::core::mem::size_of::<HLSURF__>(),
    4usize,
    concat!("Size of: ", stringify!(HLSURF__))
  );
  assert_eq!(
    ::core::mem::align_of::<HLSURF__>(),
    4usize,
    concat!("Alignment of ", stringify!(HLSURF__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HLSURF__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HLSURF__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HLSURF = *mut HLSURF__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HSTR__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HSTR__() {
  assert_eq!(
    ::core::mem::size_of::<HSTR__>(),
    4usize,
    concat!("Size of: ", stringify!(HSTR__))
  );
  assert_eq!(
    ::core::mem::align_of::<HSTR__>(),
    4usize,
    concat!("Alignment of ", stringify!(HSTR__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HSTR__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HSTR__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HSTR = *mut HSTR__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HTASK__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HTASK__() {
  assert_eq!(
    ::core::mem::size_of::<HTASK__>(),
    4usize,
    concat!("Size of: ", stringify!(HTASK__))
  );
  assert_eq!(
    ::core::mem::align_of::<HTASK__>(),
    4usize,
    concat!("Alignment of ", stringify!(HTASK__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HTASK__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HTASK__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HTASK = *mut HTASK__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HWINSTA__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HWINSTA__() {
  assert_eq!(
    ::core::mem::size_of::<HWINSTA__>(),
    4usize,
    concat!("Size of: ", stringify!(HWINSTA__))
  );
  assert_eq!(
    ::core::mem::align_of::<HWINSTA__>(),
    4usize,
    concat!("Alignment of ", stringify!(HWINSTA__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HWINSTA__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HWINSTA__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HWINSTA = *mut HWINSTA__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HKL__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HKL__() {
  assert_eq!(
    ::core::mem::size_of::<HKL__>(),
    4usize,
    concat!("Size of: ", stringify!(HKL__))
  );
  assert_eq!(
    ::core::mem::align_of::<HKL__>(),
    4usize,
    concat!("Alignment of ", stringify!(HKL__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HKL__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HKL__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HKL = *mut HKL__;
pub type HFILE = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILETIME {
  pub dwLowDateTime: DWORD,
  pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
  assert_eq!(
    ::core::mem::size_of::<_FILETIME>(),
    8usize,
    concat!("Size of: ", stringify!(_FILETIME))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILETIME>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILETIME))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILETIME>())).dwLowDateTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILETIME),
      "::",
      stringify!(dwLowDateTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILETIME>())).dwHighDateTime as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILETIME),
      "::",
      stringify!(dwHighDateTime)
    )
  );
}
pub type FILETIME = _FILETIME;
pub type PFILETIME = *mut _FILETIME;
pub type LPFILETIME = *mut _FILETIME;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HWND__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
  assert_eq!(
    ::core::mem::size_of::<HWND__>(),
    4usize,
    concat!("Size of: ", stringify!(HWND__))
  );
  assert_eq!(
    ::core::mem::align_of::<HWND__>(),
    4usize,
    concat!("Alignment of ", stringify!(HWND__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HWND__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HWND__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HHOOK__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HHOOK__() {
  assert_eq!(
    ::core::mem::size_of::<HHOOK__>(),
    4usize,
    concat!("Size of: ", stringify!(HHOOK__))
  );
  assert_eq!(
    ::core::mem::align_of::<HHOOK__>(),
    4usize,
    concat!("Alignment of ", stringify!(HHOOK__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HHOOK__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HHOOK__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HHOOK = *mut HHOOK__;
pub type HGDIOBJ = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HACCEL__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HACCEL__() {
  assert_eq!(
    ::core::mem::size_of::<HACCEL__>(),
    4usize,
    concat!("Size of: ", stringify!(HACCEL__))
  );
  assert_eq!(
    ::core::mem::align_of::<HACCEL__>(),
    4usize,
    concat!("Alignment of ", stringify!(HACCEL__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HACCEL__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HACCEL__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HACCEL = *mut HACCEL__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HBITMAP__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HBITMAP__() {
  assert_eq!(
    ::core::mem::size_of::<HBITMAP__>(),
    4usize,
    concat!("Size of: ", stringify!(HBITMAP__))
  );
  assert_eq!(
    ::core::mem::align_of::<HBITMAP__>(),
    4usize,
    concat!("Alignment of ", stringify!(HBITMAP__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HBITMAP__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HBITMAP__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HBRUSH__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HBRUSH__() {
  assert_eq!(
    ::core::mem::size_of::<HBRUSH__>(),
    4usize,
    concat!("Size of: ", stringify!(HBRUSH__))
  );
  assert_eq!(
    ::core::mem::align_of::<HBRUSH__>(),
    4usize,
    concat!("Alignment of ", stringify!(HBRUSH__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HBRUSH__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HBRUSH__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HBRUSH = *mut HBRUSH__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HCOLORSPACE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HCOLORSPACE__() {
  assert_eq!(
    ::core::mem::size_of::<HCOLORSPACE__>(),
    4usize,
    concat!("Size of: ", stringify!(HCOLORSPACE__))
  );
  assert_eq!(
    ::core::mem::align_of::<HCOLORSPACE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HCOLORSPACE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HCOLORSPACE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HCOLORSPACE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HCOLORSPACE = *mut HCOLORSPACE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HDC__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HDC__() {
  assert_eq!(
    ::core::mem::size_of::<HDC__>(),
    4usize,
    concat!("Size of: ", stringify!(HDC__))
  );
  assert_eq!(
    ::core::mem::align_of::<HDC__>(),
    4usize,
    concat!("Alignment of ", stringify!(HDC__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HDC__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HDC__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HDC = *mut HDC__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HGLRC__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HGLRC__() {
  assert_eq!(
    ::core::mem::size_of::<HGLRC__>(),
    4usize,
    concat!("Size of: ", stringify!(HGLRC__))
  );
  assert_eq!(
    ::core::mem::align_of::<HGLRC__>(),
    4usize,
    concat!("Alignment of ", stringify!(HGLRC__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HGLRC__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HGLRC__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HGLRC = *mut HGLRC__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HDESK__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HDESK__() {
  assert_eq!(
    ::core::mem::size_of::<HDESK__>(),
    4usize,
    concat!("Size of: ", stringify!(HDESK__))
  );
  assert_eq!(
    ::core::mem::align_of::<HDESK__>(),
    4usize,
    concat!("Alignment of ", stringify!(HDESK__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HDESK__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HDESK__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HDESK = *mut HDESK__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HENHMETAFILE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HENHMETAFILE__() {
  assert_eq!(
    ::core::mem::size_of::<HENHMETAFILE__>(),
    4usize,
    concat!("Size of: ", stringify!(HENHMETAFILE__))
  );
  assert_eq!(
    ::core::mem::align_of::<HENHMETAFILE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HENHMETAFILE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HENHMETAFILE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HENHMETAFILE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HENHMETAFILE = *mut HENHMETAFILE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HFONT__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HFONT__() {
  assert_eq!(
    ::core::mem::size_of::<HFONT__>(),
    4usize,
    concat!("Size of: ", stringify!(HFONT__))
  );
  assert_eq!(
    ::core::mem::align_of::<HFONT__>(),
    4usize,
    concat!("Alignment of ", stringify!(HFONT__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HFONT__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HFONT__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HFONT = *mut HFONT__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HICON__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HICON__() {
  assert_eq!(
    ::core::mem::size_of::<HICON__>(),
    4usize,
    concat!("Size of: ", stringify!(HICON__))
  );
  assert_eq!(
    ::core::mem::align_of::<HICON__>(),
    4usize,
    concat!("Alignment of ", stringify!(HICON__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HICON__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HICON__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HMENU__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HMENU__() {
  assert_eq!(
    ::core::mem::size_of::<HMENU__>(),
    4usize,
    concat!("Size of: ", stringify!(HMENU__))
  );
  assert_eq!(
    ::core::mem::align_of::<HMENU__>(),
    4usize,
    concat!("Alignment of ", stringify!(HMENU__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HMENU__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HMENU__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HMENU = *mut HMENU__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HPALETTE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HPALETTE__() {
  assert_eq!(
    ::core::mem::size_of::<HPALETTE__>(),
    4usize,
    concat!("Size of: ", stringify!(HPALETTE__))
  );
  assert_eq!(
    ::core::mem::align_of::<HPALETTE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HPALETTE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HPALETTE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HPALETTE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HPALETTE = *mut HPALETTE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HPEN__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HPEN__() {
  assert_eq!(
    ::core::mem::size_of::<HPEN__>(),
    4usize,
    concat!("Size of: ", stringify!(HPEN__))
  );
  assert_eq!(
    ::core::mem::align_of::<HPEN__>(),
    4usize,
    concat!("Alignment of ", stringify!(HPEN__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HPEN__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HPEN__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HPEN = *mut HPEN__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HWINEVENTHOOK__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HWINEVENTHOOK__() {
  assert_eq!(
    ::core::mem::size_of::<HWINEVENTHOOK__>(),
    4usize,
    concat!("Size of: ", stringify!(HWINEVENTHOOK__))
  );
  assert_eq!(
    ::core::mem::align_of::<HWINEVENTHOOK__>(),
    4usize,
    concat!("Alignment of ", stringify!(HWINEVENTHOOK__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HWINEVENTHOOK__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HWINEVENTHOOK__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HWINEVENTHOOK = *mut HWINEVENTHOOK__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HMONITOR__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HMONITOR__() {
  assert_eq!(
    ::core::mem::size_of::<HMONITOR__>(),
    4usize,
    concat!("Size of: ", stringify!(HMONITOR__))
  );
  assert_eq!(
    ::core::mem::align_of::<HMONITOR__>(),
    4usize,
    concat!("Alignment of ", stringify!(HMONITOR__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HMONITOR__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HMONITOR__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HMONITOR = *mut HMONITOR__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HUMPD__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HUMPD__() {
  assert_eq!(
    ::core::mem::size_of::<HUMPD__>(),
    4usize,
    concat!("Size of: ", stringify!(HUMPD__))
  );
  assert_eq!(
    ::core::mem::align_of::<HUMPD__>(),
    4usize,
    concat!("Alignment of ", stringify!(HUMPD__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HUMPD__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HUMPD__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HUMPD = *mut HUMPD__;
pub type HCURSOR = HICON;
pub type COLORREF = DWORD;
pub type LPCOLORREF = *mut DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRECT {
  pub left: LONG,
  pub top: LONG,
  pub right: LONG,
  pub bottom: LONG,
}
#[test]
fn bindgen_test_layout_tagRECT() {
  assert_eq!(
    ::core::mem::size_of::<tagRECT>(),
    16usize,
    concat!("Size of: ", stringify!(tagRECT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECT>())).left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(left)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECT>())).top as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(top)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECT>())).right as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(right)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECT>())).bottom as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(bottom)
    )
  );
}
pub type RECT = tagRECT;
pub type PRECT = *mut tagRECT;
pub type NPRECT = *mut tagRECT;
pub type LPRECT = *mut tagRECT;
pub type LPCRECT = *const RECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RECTL {
  pub left: LONG,
  pub top: LONG,
  pub right: LONG,
  pub bottom: LONG,
}
#[test]
fn bindgen_test_layout__RECTL() {
  assert_eq!(
    ::core::mem::size_of::<_RECTL>(),
    16usize,
    concat!("Size of: ", stringify!(_RECTL))
  );
  assert_eq!(
    ::core::mem::align_of::<_RECTL>(),
    4usize,
    concat!("Alignment of ", stringify!(_RECTL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RECTL>())).left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RECTL),
      "::",
      stringify!(left)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RECTL>())).top as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RECTL),
      "::",
      stringify!(top)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RECTL>())).right as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RECTL),
      "::",
      stringify!(right)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RECTL>())).bottom as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_RECTL),
      "::",
      stringify!(bottom)
    )
  );
}
pub type RECTL = _RECTL;
pub type PRECTL = *mut _RECTL;
pub type LPRECTL = *mut _RECTL;
pub type LPCRECTL = *const RECTL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPOINT {
  pub x: LONG,
  pub y: LONG,
}
#[test]
fn bindgen_test_layout_tagPOINT() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINT>(),
    8usize,
    concat!("Size of: ", stringify!(tagPOINT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagPOINT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINT>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINT),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINT>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINT),
      "::",
      stringify!(y)
    )
  );
}
pub type POINT = tagPOINT;
pub type PPOINT = *mut tagPOINT;
pub type NPPOINT = *mut tagPOINT;
pub type LPPOINT = *mut tagPOINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POINTL {
  pub x: LONG,
  pub y: LONG,
}
#[test]
fn bindgen_test_layout__POINTL() {
  assert_eq!(
    ::core::mem::size_of::<_POINTL>(),
    8usize,
    concat!("Size of: ", stringify!(_POINTL))
  );
  assert_eq!(
    ::core::mem::align_of::<_POINTL>(),
    4usize,
    concat!("Alignment of ", stringify!(_POINTL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POINTL>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POINTL),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POINTL>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POINTL),
      "::",
      stringify!(y)
    )
  );
}
pub type POINTL = _POINTL;
pub type PPOINTL = *mut _POINTL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSIZE {
  pub cx: LONG,
  pub cy: LONG,
}
#[test]
fn bindgen_test_layout_tagSIZE() {
  assert_eq!(
    ::core::mem::size_of::<tagSIZE>(),
    8usize,
    concat!("Size of: ", stringify!(tagSIZE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSIZE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSIZE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSIZE>())).cx as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSIZE),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSIZE>())).cy as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSIZE),
      "::",
      stringify!(cy)
    )
  );
}
pub type SIZE = tagSIZE;
pub type PSIZE = *mut tagSIZE;
pub type LPSIZE = *mut tagSIZE;
pub type SIZEL = SIZE;
pub type PSIZEL = *mut SIZE;
pub type LPSIZEL = *mut SIZE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPOINTS {
  pub x: SHORT,
  pub y: SHORT,
}
#[test]
fn bindgen_test_layout_tagPOINTS() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTS>(),
    4usize,
    concat!("Size of: ", stringify!(tagPOINTS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTS>(),
    2usize,
    concat!("Alignment of ", stringify!(tagPOINTS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTS>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTS),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTS>())).y as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTS),
      "::",
      stringify!(y)
    )
  );
}
pub type POINTS = tagPOINTS;
pub type PPOINTS = *mut tagPOINTS;
pub type LPPOINTS = *mut tagPOINTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DPI_AWARENESS_CONTEXT__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_DPI_AWARENESS_CONTEXT__() {
  assert_eq!(
    ::core::mem::size_of::<DPI_AWARENESS_CONTEXT__>(),
    4usize,
    concat!("Size of: ", stringify!(DPI_AWARENESS_CONTEXT__))
  );
  assert_eq!(
    ::core::mem::align_of::<DPI_AWARENESS_CONTEXT__>(),
    4usize,
    concat!("Alignment of ", stringify!(DPI_AWARENESS_CONTEXT__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DPI_AWARENESS_CONTEXT__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DPI_AWARENESS_CONTEXT__),
      "::",
      stringify!(unused)
    )
  );
}
pub type DPI_AWARENESS_CONTEXT = *mut DPI_AWARENESS_CONTEXT__;
pub mod DPI_AWARENESS {
  pub type Type = i32;
  pub const DPI_AWARENESS_INVALID: Type = -1;
  pub const DPI_AWARENESS_UNAWARE: Type = 0;
  pub const DPI_AWARENESS_SYSTEM_AWARE: Type = 1;
  pub const DPI_AWARENESS_PER_MONITOR_AWARE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SECURITY_ATTRIBUTES {
  pub nLength: DWORD,
  pub lpSecurityDescriptor: LPVOID,
  pub bInheritHandle: BOOL,
}
#[test]
fn bindgen_test_layout__SECURITY_ATTRIBUTES() {
  assert_eq!(
    ::core::mem::size_of::<_SECURITY_ATTRIBUTES>(),
    24usize,
    concat!("Size of: ", stringify!(_SECURITY_ATTRIBUTES))
  );
  assert_eq!(
    ::core::mem::align_of::<_SECURITY_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SECURITY_ATTRIBUTES>())).nLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(nLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_ATTRIBUTES>())).lpSecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(lpSecurityDescriptor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SECURITY_ATTRIBUTES>())).bInheritHandle as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(bInheritHandle)
    )
  );
}
impl Default for _SECURITY_ATTRIBUTES {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
pub type PSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
pub type LPSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
  pub Internal: ULONG_PTR,
  pub InternalHigh: ULONG_PTR,
  pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
  pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
  pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
  pub Pointer: PVOID,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
  pub Offset: DWORD,
  pub OffsetHigh: DWORD,
}
#[test]
fn bindgen_test_layout__OVERLAPPED__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>())).Offset as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>())).OffsetHigh as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(OffsetHigh)
    )
  );
}
#[test]
fn bindgen_test_layout__OVERLAPPED__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_OVERLAPPED__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_OVERLAPPED__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_OVERLAPPED__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED__bindgen_ty_1>())).Pointer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1),
      "::",
      stringify!(Pointer)
    )
  );
}
impl Default for _OVERLAPPED__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OVERLAPPED__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_OVERLAPPED__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__OVERLAPPED() {
  assert_eq!(
    ::core::mem::size_of::<_OVERLAPPED>(),
    32usize,
    concat!("Size of: ", stringify!(_OVERLAPPED))
  );
  assert_eq!(
    ::core::mem::align_of::<_OVERLAPPED>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED>())).Internal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(Internal)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED>())).InternalHigh as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(InternalHigh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED>())).hEvent as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(hEvent)
    )
  );
}
impl Default for _OVERLAPPED {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OVERLAPPED {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_OVERLAPPED {{ Internal: {:?}, InternalHigh: {:?}, __bindgen_anon_1: {:?}, hEvent: {:?} }}",
      self.Internal, self.InternalHigh, self.__bindgen_anon_1, self.hEvent
    )
  }
}
pub type OVERLAPPED = _OVERLAPPED;
pub type LPOVERLAPPED = *mut _OVERLAPPED;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _OVERLAPPED_ENTRY {
  pub lpCompletionKey: ULONG_PTR,
  pub lpOverlapped: LPOVERLAPPED,
  pub Internal: ULONG_PTR,
  pub dwNumberOfBytesTransferred: DWORD,
}
#[test]
fn bindgen_test_layout__OVERLAPPED_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_OVERLAPPED_ENTRY>(),
    32usize,
    concat!("Size of: ", stringify!(_OVERLAPPED_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_OVERLAPPED_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED_ENTRY>())).lpCompletionKey as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED_ENTRY),
      "::",
      stringify!(lpCompletionKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED_ENTRY>())).lpOverlapped as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED_ENTRY),
      "::",
      stringify!(lpOverlapped)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OVERLAPPED_ENTRY>())).Internal as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED_ENTRY),
      "::",
      stringify!(Internal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OVERLAPPED_ENTRY>())).dwNumberOfBytesTransferred as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED_ENTRY),
      "::",
      stringify!(dwNumberOfBytesTransferred)
    )
  );
}
impl Default for _OVERLAPPED_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type OVERLAPPED_ENTRY = _OVERLAPPED_ENTRY;
pub type LPOVERLAPPED_ENTRY = *mut _OVERLAPPED_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEMTIME {
  pub wYear: WORD,
  pub wMonth: WORD,
  pub wDayOfWeek: WORD,
  pub wDay: WORD,
  pub wHour: WORD,
  pub wMinute: WORD,
  pub wSecond: WORD,
  pub wMilliseconds: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEMTIME() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEMTIME>(),
    16usize,
    concat!("Size of: ", stringify!(_SYSTEMTIME))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEMTIME>(),
    2usize,
    concat!("Alignment of ", stringify!(_SYSTEMTIME))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wYear as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wYear)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wMonth as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMonth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wDayOfWeek as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wDayOfWeek)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wDay as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wDay)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wHour as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wHour)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wMinute as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMinute)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wSecond as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wSecond)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEMTIME>())).wMilliseconds as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMilliseconds)
    )
  );
}
pub type SYSTEMTIME = _SYSTEMTIME;
pub type PSYSTEMTIME = *mut _SYSTEMTIME;
pub type LPSYSTEMTIME = *mut _SYSTEMTIME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIN32_FIND_DATAA {
  pub dwFileAttributes: DWORD,
  pub ftCreationTime: FILETIME,
  pub ftLastAccessTime: FILETIME,
  pub ftLastWriteTime: FILETIME,
  pub nFileSizeHigh: DWORD,
  pub nFileSizeLow: DWORD,
  pub dwReserved0: DWORD,
  pub dwReserved1: DWORD,
  pub cFileName: [CHAR; 260usize],
  pub cAlternateFileName: [CHAR; 14usize],
}
#[test]
fn bindgen_test_layout__WIN32_FIND_DATAA() {
  assert_eq!(
    ::core::mem::size_of::<_WIN32_FIND_DATAA>(),
    320usize,
    concat!("Size of: ", stringify!(_WIN32_FIND_DATAA))
  );
  assert_eq!(
    ::core::mem::align_of::<_WIN32_FIND_DATAA>(),
    4usize,
    concat!("Alignment of ", stringify!(_WIN32_FIND_DATAA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).dwFileAttributes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(dwFileAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).ftCreationTime as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(ftCreationTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).ftLastAccessTime as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(ftLastAccessTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).ftLastWriteTime as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(ftLastWriteTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).nFileSizeHigh as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(nFileSizeHigh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).nFileSizeLow as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(nFileSizeLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).dwReserved0 as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(dwReserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).dwReserved1 as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(dwReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).cFileName as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(cFileName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FIND_DATAA>())).cAlternateFileName as *const _ as usize
    },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAA),
      "::",
      stringify!(cAlternateFileName)
    )
  );
}
impl Default for _WIN32_FIND_DATAA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WIN32_FIND_DATAA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_WIN32_FIND_DATAA {{ dwFileAttributes: {:?}, ftCreationTime: {:?}, ftLastAccessTime: {:?}, ftLastWriteTime: {:?}, nFileSizeHigh: {:?}, nFileSizeLow: {:?}, dwReserved0: {:?}, dwReserved1: {:?}, cFileName: [...], cAlternateFileName: {:?} }}" , self . dwFileAttributes , self . ftCreationTime , self . ftLastAccessTime , self . ftLastWriteTime , self . nFileSizeHigh , self . nFileSizeLow , self . dwReserved0 , self . dwReserved1 , self . cAlternateFileName )
  }
}
impl ::core::cmp::PartialEq for _WIN32_FIND_DATAA {
  fn eq(&self, other: &_WIN32_FIND_DATAA) -> bool {
    self.dwFileAttributes == other.dwFileAttributes
      && self.ftCreationTime == other.ftCreationTime
      && self.ftLastAccessTime == other.ftLastAccessTime
      && self.ftLastWriteTime == other.ftLastWriteTime
      && self.nFileSizeHigh == other.nFileSizeHigh
      && self.nFileSizeLow == other.nFileSizeLow
      && self.dwReserved0 == other.dwReserved0
      && self.dwReserved1 == other.dwReserved1
      && &self.cFileName[..] == &other.cFileName[..]
      && self.cAlternateFileName == other.cAlternateFileName
  }
}
pub type WIN32_FIND_DATAA = _WIN32_FIND_DATAA;
pub type PWIN32_FIND_DATAA = *mut _WIN32_FIND_DATAA;
pub type LPWIN32_FIND_DATAA = *mut _WIN32_FIND_DATAA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIN32_FIND_DATAW {
  pub dwFileAttributes: DWORD,
  pub ftCreationTime: FILETIME,
  pub ftLastAccessTime: FILETIME,
  pub ftLastWriteTime: FILETIME,
  pub nFileSizeHigh: DWORD,
  pub nFileSizeLow: DWORD,
  pub dwReserved0: DWORD,
  pub dwReserved1: DWORD,
  pub cFileName: [WCHAR; 260usize],
  pub cAlternateFileName: [WCHAR; 14usize],
}
#[test]
fn bindgen_test_layout__WIN32_FIND_DATAW() {
  assert_eq!(
    ::core::mem::size_of::<_WIN32_FIND_DATAW>(),
    592usize,
    concat!("Size of: ", stringify!(_WIN32_FIND_DATAW))
  );
  assert_eq!(
    ::core::mem::align_of::<_WIN32_FIND_DATAW>(),
    4usize,
    concat!("Alignment of ", stringify!(_WIN32_FIND_DATAW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).dwFileAttributes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(dwFileAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).ftCreationTime as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(ftCreationTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).ftLastAccessTime as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(ftLastAccessTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).ftLastWriteTime as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(ftLastWriteTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).nFileSizeHigh as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(nFileSizeHigh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).nFileSizeLow as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(nFileSizeLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).dwReserved0 as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(dwReserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).dwReserved1 as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(dwReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).cFileName as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(cFileName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FIND_DATAW>())).cAlternateFileName as *const _ as usize
    },
    564usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_DATAW),
      "::",
      stringify!(cAlternateFileName)
    )
  );
}
impl Default for _WIN32_FIND_DATAW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WIN32_FIND_DATAW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_WIN32_FIND_DATAW {{ dwFileAttributes: {:?}, ftCreationTime: {:?}, ftLastAccessTime: {:?}, ftLastWriteTime: {:?}, nFileSizeHigh: {:?}, nFileSizeLow: {:?}, dwReserved0: {:?}, dwReserved1: {:?}, cFileName: [...], cAlternateFileName: {:?} }}" , self . dwFileAttributes , self . ftCreationTime , self . ftLastAccessTime , self . ftLastWriteTime , self . nFileSizeHigh , self . nFileSizeLow , self . dwReserved0 , self . dwReserved1 , self . cAlternateFileName )
  }
}
impl ::core::cmp::PartialEq for _WIN32_FIND_DATAW {
  fn eq(&self, other: &_WIN32_FIND_DATAW) -> bool {
    self.dwFileAttributes == other.dwFileAttributes
      && self.ftCreationTime == other.ftCreationTime
      && self.ftLastAccessTime == other.ftLastAccessTime
      && self.ftLastWriteTime == other.ftLastWriteTime
      && self.nFileSizeHigh == other.nFileSizeHigh
      && self.nFileSizeLow == other.nFileSizeLow
      && self.dwReserved0 == other.dwReserved0
      && self.dwReserved1 == other.dwReserved1
      && &self.cFileName[..] == &other.cFileName[..]
      && self.cAlternateFileName == other.cAlternateFileName
  }
}
pub type WIN32_FIND_DATAW = _WIN32_FIND_DATAW;
pub type PWIN32_FIND_DATAW = *mut _WIN32_FIND_DATAW;
pub type LPWIN32_FIND_DATAW = *mut _WIN32_FIND_DATAW;
pub type WIN32_FIND_DATA = WIN32_FIND_DATAA;
pub type PWIN32_FIND_DATA = PWIN32_FIND_DATAA;
pub type LPWIN32_FIND_DATA = LPWIN32_FIND_DATAA;
pub mod _FINDEX_INFO_LEVELS {
  pub type Type = i32;
  pub const FindExInfoStandard: Type = 0;
  pub const FindExInfoBasic: Type = 1;
  pub const FindExInfoMaxInfoLevel: Type = 2;
}
pub use self::_FINDEX_INFO_LEVELS::Type as FINDEX_INFO_LEVELS;
pub mod _FINDEX_SEARCH_OPS {
  pub type Type = i32;
  pub const FindExSearchNameMatch: Type = 0;
  pub const FindExSearchLimitToDirectories: Type = 1;
  pub const FindExSearchLimitToDevices: Type = 2;
  pub const FindExSearchMaxSearchOp: Type = 3;
}
pub use self::_FINDEX_SEARCH_OPS::Type as FINDEX_SEARCH_OPS;
pub mod _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
  pub type Type = i32;
  pub const ReadDirectoryNotifyInformation: Type = 1;
  pub const ReadDirectoryNotifyExtendedInformation: Type = 2;
}
pub use self::_READ_DIRECTORY_NOTIFY_INFORMATION_CLASS::Type as READ_DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub type PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS =
  *mut _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS::Type;
pub mod _GET_FILEEX_INFO_LEVELS {
  pub type Type = i32;
  pub const GetFileExInfoStandard: Type = 0;
  pub const GetFileExMaxInfoLevel: Type = 1;
}
pub use self::_GET_FILEEX_INFO_LEVELS::Type as GET_FILEEX_INFO_LEVELS;
pub mod _FILE_INFO_BY_HANDLE_CLASS {
  pub type Type = i32;
  pub const FileBasicInfo: Type = 0;
  pub const FileStandardInfo: Type = 1;
  pub const FileNameInfo: Type = 2;
  pub const FileRenameInfo: Type = 3;
  pub const FileDispositionInfo: Type = 4;
  pub const FileAllocationInfo: Type = 5;
  pub const FileEndOfFileInfo: Type = 6;
  pub const FileStreamInfo: Type = 7;
  pub const FileCompressionInfo: Type = 8;
  pub const FileAttributeTagInfo: Type = 9;
  pub const FileIdBothDirectoryInfo: Type = 10;
  pub const FileIdBothDirectoryRestartInfo: Type = 11;
  pub const FileIoPriorityHintInfo: Type = 12;
  pub const FileRemoteProtocolInfo: Type = 13;
  pub const FileFullDirectoryInfo: Type = 14;
  pub const FileFullDirectoryRestartInfo: Type = 15;
  pub const FileStorageInfo: Type = 16;
  pub const FileAlignmentInfo: Type = 17;
  pub const FileIdInfo: Type = 18;
  pub const FileIdExtdDirectoryInfo: Type = 19;
  pub const FileIdExtdDirectoryRestartInfo: Type = 20;
  pub const FileDispositionInfoEx: Type = 21;
  pub const FileRenameInfoEx: Type = 22;
  pub const MaximumFileInfoByHandleClass: Type = 23;
}
pub use self::_FILE_INFO_BY_HANDLE_CLASS::Type as FILE_INFO_BY_HANDLE_CLASS;
pub type PFILE_INFO_BY_HANDLE_CLASS = *mut _FILE_INFO_BY_HANDLE_CLASS::Type;
pub type CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub type PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub type LPCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub type CRITICAL_SECTION_DEBUG = RTL_CRITICAL_SECTION_DEBUG;
pub type PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
pub type LPCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
pub type LPOVERLAPPED_COMPLETION_ROUTINE = ::core::option::Option<
  unsafe extern "C" fn(
    dwErrorCode: DWORD,
    dwNumberOfBytesTransfered: DWORD,
    lpOverlapped: LPOVERLAPPED,
  ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_HEAP_ENTRY {
  pub lpData: PVOID,
  pub cbData: DWORD,
  pub cbOverhead: BYTE,
  pub iRegionIndex: BYTE,
  pub wFlags: WORD,
  pub __bindgen_anon_1: _PROCESS_HEAP_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_HEAP_ENTRY__bindgen_ty_1 {
  pub Block: _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
  pub Region: _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  pub hMem: HANDLE,
  pub dwReserved: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1>())).hMem as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hMem)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1>())).dwReserved
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dwReserved)
    )
  );
}
impl Default for _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
  pub dwCommittedSize: DWORD,
  pub dwUnCommittedSize: DWORD,
  pub lpFirstBlock: LPVOID,
  pub lpLastBlock: LPVOID,
}
#[test]
fn bindgen_test_layout__PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2>())).dwCommittedSize
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dwCommittedSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2>())).dwUnCommittedSize
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dwUnCommittedSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2>())).lpFirstBlock
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(lpFirstBlock)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2>())).lpLastBlock
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(lpLastBlock)
    )
  );
}
impl Default for _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout__PROCESS_HEAP_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_HEAP_ENTRY__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_HEAP_ENTRY__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1>())).Block as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1),
      "::",
      stringify!(Block)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY__bindgen_ty_1>())).Region as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY__bindgen_ty_1),
      "::",
      stringify!(Region)
    )
  );
}
impl Default for _PROCESS_HEAP_ENTRY__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_HEAP_ENTRY__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_PROCESS_HEAP_ENTRY__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__PROCESS_HEAP_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_HEAP_ENTRY>(),
    40usize,
    concat!("Size of: ", stringify!(_PROCESS_HEAP_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_HEAP_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESS_HEAP_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY>())).lpData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY),
      "::",
      stringify!(lpData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY>())).cbData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY>())).cbOverhead as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY),
      "::",
      stringify!(cbOverhead)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY>())).iRegionIndex as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY),
      "::",
      stringify!(iRegionIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_HEAP_ENTRY>())).wFlags as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_HEAP_ENTRY),
      "::",
      stringify!(wFlags)
    )
  );
}
impl Default for _PROCESS_HEAP_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _PROCESS_HEAP_ENTRY {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_PROCESS_HEAP_ENTRY {{ lpData: {:?}, cbData: {:?}, cbOverhead: {:?}, iRegionIndex: {:?}, wFlags: {:?}, __bindgen_anon_1: {:?} }}" , self . lpData , self . cbData , self . cbOverhead , self . iRegionIndex , self . wFlags , self . __bindgen_anon_1 )
  }
}
pub type PROCESS_HEAP_ENTRY = _PROCESS_HEAP_ENTRY;
pub type LPPROCESS_HEAP_ENTRY = *mut _PROCESS_HEAP_ENTRY;
pub type PPROCESS_HEAP_ENTRY = *mut _PROCESS_HEAP_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REASON_CONTEXT {
  pub Version: ULONG,
  pub Flags: DWORD,
  pub Reason: _REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REASON_CONTEXT__bindgen_ty_1 {
  pub Detailed: _REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1,
  pub SimpleReasonString: LPWSTR,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
  pub LocalizedReasonModule: HMODULE,
  pub LocalizedReasonId: ULONG,
  pub ReasonStringCount: ULONG,
  pub ReasonStrings: *mut LPWSTR,
}
#[test]
fn bindgen_test_layout__REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).LocalizedReasonModule
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LocalizedReasonModule)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).LocalizedReasonId
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LocalizedReasonId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).ReasonStringCount
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ReasonStringCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).ReasonStrings
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ReasonStrings)
    )
  );
}
impl Default for _REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout__REASON_CONTEXT__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_REASON_CONTEXT__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(_REASON_CONTEXT__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_REASON_CONTEXT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_REASON_CONTEXT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REASON_CONTEXT__bindgen_ty_1>())).Detailed as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1),
      "::",
      stringify!(Detailed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REASON_CONTEXT__bindgen_ty_1>())).SimpleReasonString as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT__bindgen_ty_1),
      "::",
      stringify!(SimpleReasonString)
    )
  );
}
impl Default for _REASON_CONTEXT__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _REASON_CONTEXT__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_REASON_CONTEXT__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__REASON_CONTEXT() {
  assert_eq!(
    ::core::mem::size_of::<_REASON_CONTEXT>(),
    32usize,
    concat!("Size of: ", stringify!(_REASON_CONTEXT))
  );
  assert_eq!(
    ::core::mem::align_of::<_REASON_CONTEXT>(),
    8usize,
    concat!("Alignment of ", stringify!(_REASON_CONTEXT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REASON_CONTEXT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REASON_CONTEXT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REASON_CONTEXT>())).Reason as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_REASON_CONTEXT),
      "::",
      stringify!(Reason)
    )
  );
}
impl Default for _REASON_CONTEXT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _REASON_CONTEXT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_REASON_CONTEXT {{ Version: {:?}, Flags: {:?}, Reason: {:?} }}",
      self.Version, self.Flags, self.Reason
    )
  }
}
pub type REASON_CONTEXT = _REASON_CONTEXT;
pub type PREASON_CONTEXT = *mut _REASON_CONTEXT;
pub type PTHREAD_START_ROUTINE =
  ::core::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> DWORD>;
pub type LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE;
pub type PENCLAVE_ROUTINE =
  ::core::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> LPVOID>;
pub type LPENCLAVE_ROUTINE = PENCLAVE_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _EXCEPTION_DEBUG_INFO {
  pub ExceptionRecord: EXCEPTION_RECORD,
  pub dwFirstChance: DWORD,
}
#[test]
fn bindgen_test_layout__EXCEPTION_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_EXCEPTION_DEBUG_INFO>(),
    160usize,
    concat!("Size of: ", stringify!(_EXCEPTION_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXCEPTION_DEBUG_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_EXCEPTION_DEBUG_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_DEBUG_INFO>())).ExceptionRecord as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_DEBUG_INFO),
      "::",
      stringify!(ExceptionRecord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXCEPTION_DEBUG_INFO>())).dwFirstChance as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXCEPTION_DEBUG_INFO),
      "::",
      stringify!(dwFirstChance)
    )
  );
}
impl Default for _EXCEPTION_DEBUG_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type EXCEPTION_DEBUG_INFO = _EXCEPTION_DEBUG_INFO;
pub type LPEXCEPTION_DEBUG_INFO = *mut _EXCEPTION_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CREATE_THREAD_DEBUG_INFO {
  pub hThread: HANDLE,
  pub lpThreadLocalBase: LPVOID,
  pub lpStartAddress: LPTHREAD_START_ROUTINE,
}
#[test]
fn bindgen_test_layout__CREATE_THREAD_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CREATE_THREAD_DEBUG_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_CREATE_THREAD_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CREATE_THREAD_DEBUG_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_CREATE_THREAD_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CREATE_THREAD_DEBUG_INFO>())).hThread as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_THREAD_DEBUG_INFO),
      "::",
      stringify!(hThread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_THREAD_DEBUG_INFO>())).lpThreadLocalBase as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_THREAD_DEBUG_INFO),
      "::",
      stringify!(lpThreadLocalBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_THREAD_DEBUG_INFO>())).lpStartAddress as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_THREAD_DEBUG_INFO),
      "::",
      stringify!(lpStartAddress)
    )
  );
}
impl Default for _CREATE_THREAD_DEBUG_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CREATE_THREAD_DEBUG_INFO = _CREATE_THREAD_DEBUG_INFO;
pub type LPCREATE_THREAD_DEBUG_INFO = *mut _CREATE_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CREATE_PROCESS_DEBUG_INFO {
  pub hFile: HANDLE,
  pub hProcess: HANDLE,
  pub hThread: HANDLE,
  pub lpBaseOfImage: LPVOID,
  pub dwDebugInfoFileOffset: DWORD,
  pub nDebugInfoSize: DWORD,
  pub lpThreadLocalBase: LPVOID,
  pub lpStartAddress: LPTHREAD_START_ROUTINE,
  pub lpImageName: LPVOID,
  pub fUnicode: WORD,
}
#[test]
fn bindgen_test_layout__CREATE_PROCESS_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CREATE_PROCESS_DEBUG_INFO>(),
    72usize,
    concat!("Size of: ", stringify!(_CREATE_PROCESS_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CREATE_PROCESS_DEBUG_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_CREATE_PROCESS_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).hFile as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(hFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).hProcess as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(hProcess)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).hThread as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(hThread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).lpBaseOfImage as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(lpBaseOfImage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).dwDebugInfoFileOffset as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(dwDebugInfoFileOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).nDebugInfoSize as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(nDebugInfoSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).lpThreadLocalBase as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(lpThreadLocalBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).lpStartAddress as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(lpStartAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).lpImageName as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(lpImageName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATE_PROCESS_DEBUG_INFO>())).fUnicode as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATE_PROCESS_DEBUG_INFO),
      "::",
      stringify!(fUnicode)
    )
  );
}
impl Default for _CREATE_PROCESS_DEBUG_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CREATE_PROCESS_DEBUG_INFO = _CREATE_PROCESS_DEBUG_INFO;
pub type LPCREATE_PROCESS_DEBUG_INFO = *mut _CREATE_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _EXIT_THREAD_DEBUG_INFO {
  pub dwExitCode: DWORD,
}
#[test]
fn bindgen_test_layout__EXIT_THREAD_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_EXIT_THREAD_DEBUG_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_EXIT_THREAD_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXIT_THREAD_DEBUG_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_EXIT_THREAD_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EXIT_THREAD_DEBUG_INFO>())).dwExitCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXIT_THREAD_DEBUG_INFO),
      "::",
      stringify!(dwExitCode)
    )
  );
}
pub type EXIT_THREAD_DEBUG_INFO = _EXIT_THREAD_DEBUG_INFO;
pub type LPEXIT_THREAD_DEBUG_INFO = *mut _EXIT_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _EXIT_PROCESS_DEBUG_INFO {
  pub dwExitCode: DWORD,
}
#[test]
fn bindgen_test_layout__EXIT_PROCESS_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_EXIT_PROCESS_DEBUG_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_EXIT_PROCESS_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_EXIT_PROCESS_DEBUG_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_EXIT_PROCESS_DEBUG_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_EXIT_PROCESS_DEBUG_INFO>())).dwExitCode as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EXIT_PROCESS_DEBUG_INFO),
      "::",
      stringify!(dwExitCode)
    )
  );
}
pub type EXIT_PROCESS_DEBUG_INFO = _EXIT_PROCESS_DEBUG_INFO;
pub type LPEXIT_PROCESS_DEBUG_INFO = *mut _EXIT_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _LOAD_DLL_DEBUG_INFO {
  pub hFile: HANDLE,
  pub lpBaseOfDll: LPVOID,
  pub dwDebugInfoFileOffset: DWORD,
  pub nDebugInfoSize: DWORD,
  pub lpImageName: LPVOID,
  pub fUnicode: WORD,
}
#[test]
fn bindgen_test_layout__LOAD_DLL_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_LOAD_DLL_DEBUG_INFO>(),
    40usize,
    concat!("Size of: ", stringify!(_LOAD_DLL_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_LOAD_DLL_DEBUG_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_LOAD_DLL_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LOAD_DLL_DEBUG_INFO>())).hFile as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(hFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LOAD_DLL_DEBUG_INFO>())).lpBaseOfDll as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(lpBaseOfDll)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LOAD_DLL_DEBUG_INFO>())).dwDebugInfoFileOffset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_LOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(dwDebugInfoFileOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_LOAD_DLL_DEBUG_INFO>())).nDebugInfoSize as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_LOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(nDebugInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LOAD_DLL_DEBUG_INFO>())).lpImageName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_LOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(lpImageName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_LOAD_DLL_DEBUG_INFO>())).fUnicode as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_LOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(fUnicode)
    )
  );
}
impl Default for _LOAD_DLL_DEBUG_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type LOAD_DLL_DEBUG_INFO = _LOAD_DLL_DEBUG_INFO;
pub type LPLOAD_DLL_DEBUG_INFO = *mut _LOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UNLOAD_DLL_DEBUG_INFO {
  pub lpBaseOfDll: LPVOID,
}
#[test]
fn bindgen_test_layout__UNLOAD_DLL_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_UNLOAD_DLL_DEBUG_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_UNLOAD_DLL_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_UNLOAD_DLL_DEBUG_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_UNLOAD_DLL_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_UNLOAD_DLL_DEBUG_INFO>())).lpBaseOfDll as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNLOAD_DLL_DEBUG_INFO),
      "::",
      stringify!(lpBaseOfDll)
    )
  );
}
impl Default for _UNLOAD_DLL_DEBUG_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UNLOAD_DLL_DEBUG_INFO = _UNLOAD_DLL_DEBUG_INFO;
pub type LPUNLOAD_DLL_DEBUG_INFO = *mut _UNLOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _OUTPUT_DEBUG_STRING_INFO {
  pub lpDebugStringData: LPSTR,
  pub fUnicode: WORD,
  pub nDebugStringLength: WORD,
}
#[test]
fn bindgen_test_layout__OUTPUT_DEBUG_STRING_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_OUTPUT_DEBUG_STRING_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_OUTPUT_DEBUG_STRING_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_OUTPUT_DEBUG_STRING_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_OUTPUT_DEBUG_STRING_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTPUT_DEBUG_STRING_INFO>())).lpDebugStringData as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTPUT_DEBUG_STRING_INFO),
      "::",
      stringify!(lpDebugStringData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTPUT_DEBUG_STRING_INFO>())).fUnicode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTPUT_DEBUG_STRING_INFO),
      "::",
      stringify!(fUnicode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTPUT_DEBUG_STRING_INFO>())).nDebugStringLength as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTPUT_DEBUG_STRING_INFO),
      "::",
      stringify!(nDebugStringLength)
    )
  );
}
impl Default for _OUTPUT_DEBUG_STRING_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type OUTPUT_DEBUG_STRING_INFO = _OUTPUT_DEBUG_STRING_INFO;
pub type LPOUTPUT_DEBUG_STRING_INFO = *mut _OUTPUT_DEBUG_STRING_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RIP_INFO {
  pub dwError: DWORD,
  pub dwType: DWORD,
}
#[test]
fn bindgen_test_layout__RIP_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_RIP_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_RIP_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_RIP_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_RIP_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RIP_INFO>())).dwError as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RIP_INFO),
      "::",
      stringify!(dwError)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RIP_INFO>())).dwType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RIP_INFO),
      "::",
      stringify!(dwType)
    )
  );
}
pub type RIP_INFO = _RIP_INFO;
pub type LPRIP_INFO = *mut _RIP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUG_EVENT {
  pub dwDebugEventCode: DWORD,
  pub dwProcessId: DWORD,
  pub dwThreadId: DWORD,
  pub u: _DEBUG_EVENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEBUG_EVENT__bindgen_ty_1 {
  pub Exception: EXCEPTION_DEBUG_INFO,
  pub CreateThread: CREATE_THREAD_DEBUG_INFO,
  pub CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
  pub ExitThread: EXIT_THREAD_DEBUG_INFO,
  pub ExitProcess: EXIT_PROCESS_DEBUG_INFO,
  pub LoadDll: LOAD_DLL_DEBUG_INFO,
  pub UnloadDll: UNLOAD_DLL_DEBUG_INFO,
  pub DebugString: OUTPUT_DEBUG_STRING_INFO,
  pub RipInfo: RIP_INFO,
  _bindgen_union_align: [u64; 20usize],
}
#[test]
fn bindgen_test_layout__DEBUG_EVENT__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_DEBUG_EVENT__bindgen_ty_1>(),
    160usize,
    concat!("Size of: ", stringify!(_DEBUG_EVENT__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_DEBUG_EVENT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_DEBUG_EVENT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).Exception as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(Exception)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).CreateThread as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(CreateThread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).CreateProcessInfo as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(CreateProcessInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).ExitThread as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(ExitThread)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).ExitProcess as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(ExitProcess)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).LoadDll as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(LoadDll)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).UnloadDll as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(UnloadDll)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).DebugString as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(DebugString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DEBUG_EVENT__bindgen_ty_1>())).RipInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT__bindgen_ty_1),
      "::",
      stringify!(RipInfo)
    )
  );
}
impl Default for _DEBUG_EVENT__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DEBUG_EVENT__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_DEBUG_EVENT__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__DEBUG_EVENT() {
  assert_eq!(
    ::core::mem::size_of::<_DEBUG_EVENT>(),
    176usize,
    concat!("Size of: ", stringify!(_DEBUG_EVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<_DEBUG_EVENT>(),
    8usize,
    concat!("Alignment of ", stringify!(_DEBUG_EVENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DEBUG_EVENT>())).dwDebugEventCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT),
      "::",
      stringify!(dwDebugEventCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DEBUG_EVENT>())).dwProcessId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DEBUG_EVENT>())).dwThreadId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT),
      "::",
      stringify!(dwThreadId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DEBUG_EVENT>())).u as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEBUG_EVENT),
      "::",
      stringify!(u)
    )
  );
}
impl Default for _DEBUG_EVENT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DEBUG_EVENT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_DEBUG_EVENT {{ dwDebugEventCode: {:?}, dwProcessId: {:?}, dwThreadId: {:?}, u: {:?} }}",
      self.dwDebugEventCode, self.dwProcessId, self.dwThreadId, self.u
    )
  }
}
pub type DEBUG_EVENT = _DEBUG_EVENT;
pub type LPDEBUG_EVENT = *mut _DEBUG_EVENT;
pub type LPCONTEXT = PCONTEXT;
extern "C" {
  pub fn SetEnvironmentStringsW(NewEnvironment: LPWCH) -> BOOL;
}
extern "C" {
  pub fn GetStdHandle(nStdHandle: DWORD) -> HANDLE;
}
extern "C" {
  pub fn SetStdHandle(nStdHandle: DWORD, hHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetStdHandleEx(nStdHandle: DWORD, hHandle: HANDLE, phPrevValue: PHANDLE) -> BOOL;
}
extern "C" {
  pub fn GetCommandLineA() -> LPSTR;
}
extern "C" {
  pub fn GetCommandLineW() -> LPWSTR;
}
extern "C" {
  pub fn GetEnvironmentStrings() -> LPCH;
}
extern "C" {
  pub fn GetEnvironmentStringsW() -> LPWCH;
}
extern "C" {
  pub fn FreeEnvironmentStringsA(penv: LPCH) -> BOOL;
}
extern "C" {
  pub fn FreeEnvironmentStringsW(penv: LPWCH) -> BOOL;
}
extern "C" {
  pub fn GetEnvironmentVariableA(lpName: LPCSTR, lpBuffer: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetEnvironmentVariableW(lpName: LPCWSTR, lpBuffer: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn SetEnvironmentVariableA(lpName: LPCSTR, lpValue: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetEnvironmentVariableW(lpName: LPCWSTR, lpValue: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn ExpandEnvironmentStringsA(lpSrc: LPCSTR, lpDst: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn ExpandEnvironmentStringsW(lpSrc: LPCWSTR, lpDst: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn SetCurrentDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetCurrentDirectoryA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
  pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
  pub fn SearchPathW(
    lpPath: LPCWSTR, lpFileName: LPCWSTR, lpExtension: LPCWSTR, nBufferLength: DWORD,
    lpBuffer: LPWSTR, lpFilePart: *mut LPWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn SearchPathA(
    lpPath: LPCSTR, lpFileName: LPCSTR, lpExtension: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR,
    lpFilePart: *mut LPSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn NeedCurrentDirectoryForExePathA(ExeName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn NeedCurrentDirectoryForExePathW(ExeName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn CompareFileTime(lpFileTime1: *const FILETIME, lpFileTime2: *const FILETIME) -> LONG;
}
extern "C" {
  pub fn CreateDirectoryA(lpPathName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) -> BOOL;
}
extern "C" {
  pub fn CreateDirectoryW(lpPathName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES)
    -> BOOL;
}
extern "C" {
  pub fn CreateFileA(
    lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD,
    dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateFileW(
    lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD,
    dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE,
  ) -> HANDLE;
}
extern "C" {
  pub fn DefineDosDeviceW(dwFlags: DWORD, lpDeviceName: LPCWSTR, lpTargetPath: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn DeleteFileA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn DeleteFileW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn DeleteVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn FileTimeToLocalFileTime(lpFileTime: *const FILETIME, lpLocalFileTime: LPFILETIME) -> BOOL;
}
extern "C" {
  pub fn FindClose(hFindFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn FindCloseChangeNotification(hChangeHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn FindFirstChangeNotificationA(
    lpPathName: LPCSTR, bWatchSubtree: BOOL, dwNotifyFilter: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstChangeNotificationW(
    lpPathName: LPCWSTR, bWatchSubtree: BOOL, dwNotifyFilter: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstFileA(lpFileName: LPCSTR, lpFindFileData: LPWIN32_FIND_DATAA) -> HANDLE;
}
extern "C" {
  pub fn FindFirstFileW(lpFileName: LPCWSTR, lpFindFileData: LPWIN32_FIND_DATAW) -> HANDLE;
}
extern "C" {
  pub fn FindFirstFileExA(
    lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID,
    fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstFileExW(
    lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID,
    fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstVolumeW(lpszVolumeName: LPWSTR, cchBufferLength: DWORD) -> HANDLE;
}
extern "C" {
  pub fn FindNextChangeNotification(hChangeHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn FindNextFileA(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAA) -> BOOL;
}
extern "C" {
  pub fn FindNextFileW(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAW) -> BOOL;
}
extern "C" {
  pub fn FindNextVolumeW(
    hFindVolume: HANDLE, lpszVolumeName: LPWSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FindVolumeClose(hFindVolume: HANDLE) -> BOOL;
}
extern "C" {
  pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetDiskFreeSpaceA(
    lpRootPathName: LPCSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD,
    lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDiskFreeSpaceW(
    lpRootPathName: LPCWSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD,
    lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDiskFreeSpaceExA(
    lpDirectoryName: LPCSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER,
    lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDiskFreeSpaceExW(
    lpDirectoryName: LPCWSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER,
    lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDriveTypeA(lpRootPathName: LPCSTR) -> UINT;
}
extern "C" {
  pub fn GetDriveTypeW(lpRootPathName: LPCWSTR) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _WIN32_FILE_ATTRIBUTE_DATA {
  pub dwFileAttributes: DWORD,
  pub ftCreationTime: FILETIME,
  pub ftLastAccessTime: FILETIME,
  pub ftLastWriteTime: FILETIME,
  pub nFileSizeHigh: DWORD,
  pub nFileSizeLow: DWORD,
}
#[test]
fn bindgen_test_layout__WIN32_FILE_ATTRIBUTE_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_WIN32_FILE_ATTRIBUTE_DATA>(),
    36usize,
    concat!("Size of: ", stringify!(_WIN32_FILE_ATTRIBUTE_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_WIN32_FILE_ATTRIBUTE_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_WIN32_FILE_ATTRIBUTE_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FILE_ATTRIBUTE_DATA>())).dwFileAttributes as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
      "::",
      stringify!(dwFileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FILE_ATTRIBUTE_DATA>())).ftCreationTime as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
      "::",
      stringify!(ftCreationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FILE_ATTRIBUTE_DATA>())).ftLastAccessTime as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
      "::",
      stringify!(ftLastAccessTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FILE_ATTRIBUTE_DATA>())).ftLastWriteTime as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
      "::",
      stringify!(ftLastWriteTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FILE_ATTRIBUTE_DATA>())).nFileSizeHigh as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
      "::",
      stringify!(nFileSizeHigh)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FILE_ATTRIBUTE_DATA>())).nFileSizeLow as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
      "::",
      stringify!(nFileSizeLow)
    )
  );
}
pub type WIN32_FILE_ATTRIBUTE_DATA = _WIN32_FILE_ATTRIBUTE_DATA;
pub type LPWIN32_FILE_ATTRIBUTE_DATA = *mut _WIN32_FILE_ATTRIBUTE_DATA;
extern "C" {
  pub fn GetFileAttributesA(lpFileName: LPCSTR) -> DWORD;
}
extern "C" {
  pub fn GetFileAttributesW(lpFileName: LPCWSTR) -> DWORD;
}
extern "C" {
  pub fn GetFileAttributesExA(
    lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileAttributesExW(
    lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _BY_HANDLE_FILE_INFORMATION {
  pub dwFileAttributes: DWORD,
  pub ftCreationTime: FILETIME,
  pub ftLastAccessTime: FILETIME,
  pub ftLastWriteTime: FILETIME,
  pub dwVolumeSerialNumber: DWORD,
  pub nFileSizeHigh: DWORD,
  pub nFileSizeLow: DWORD,
  pub nNumberOfLinks: DWORD,
  pub nFileIndexHigh: DWORD,
  pub nFileIndexLow: DWORD,
}
#[test]
fn bindgen_test_layout__BY_HANDLE_FILE_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_BY_HANDLE_FILE_INFORMATION>(),
    52usize,
    concat!("Size of: ", stringify!(_BY_HANDLE_FILE_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_BY_HANDLE_FILE_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_BY_HANDLE_FILE_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).dwFileAttributes as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(dwFileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).ftCreationTime as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(ftCreationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).ftLastAccessTime as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(ftLastAccessTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).ftLastWriteTime as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(ftLastWriteTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).dwVolumeSerialNumber as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(dwVolumeSerialNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).nFileSizeHigh as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(nFileSizeHigh)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).nFileSizeLow as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(nFileSizeLow)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).nNumberOfLinks as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(nNumberOfLinks)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).nFileIndexHigh as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(nFileIndexHigh)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_BY_HANDLE_FILE_INFORMATION>())).nFileIndexLow as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_BY_HANDLE_FILE_INFORMATION),
      "::",
      stringify!(nFileIndexLow)
    )
  );
}
pub type BY_HANDLE_FILE_INFORMATION = _BY_HANDLE_FILE_INFORMATION;
pub type PBY_HANDLE_FILE_INFORMATION = *mut _BY_HANDLE_FILE_INFORMATION;
pub type LPBY_HANDLE_FILE_INFORMATION = *mut _BY_HANDLE_FILE_INFORMATION;
extern "C" {
  pub fn GetFileInformationByHandle(
    hFile: HANDLE, lpFileInformation: LPBY_HANDLE_FILE_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileSize(hFile: HANDLE, lpFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn GetFileSizeEx(hFile: HANDLE, lpFileSize: PLARGE_INTEGER) -> BOOL;
}
extern "C" {
  pub fn GetFileType(hFile: HANDLE) -> DWORD;
}
extern "C" {
  pub fn GetFinalPathNameByHandleA(
    hFile: HANDLE, lpszFilePath: LPSTR, cchFilePath: DWORD, dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFinalPathNameByHandleW(
    hFile: HANDLE, lpszFilePath: LPWSTR, cchFilePath: DWORD, dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFileTime(
    hFile: HANDLE, lpCreationTime: LPFILETIME, lpLastAccessTime: LPFILETIME,
    lpLastWriteTime: LPFILETIME,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFullPathNameW(
    lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: *mut LPWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFullPathNameA(
    lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: *mut LPSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetLogicalDrives() -> DWORD;
}
extern "C" {
  pub fn GetLogicalDriveStringsW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
  pub fn GetLongPathNameA(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetLongPathNameW(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetShortPathNameW(lpszLongPath: LPCWSTR, lpszShortPath: LPWSTR, cchBuffer: DWORD)
    -> DWORD;
}
extern "C" {
  pub fn GetTempFileNameW(
    lpPathName: LPCWSTR, lpPrefixString: LPCWSTR, uUnique: UINT, lpTempFileName: LPWSTR,
  ) -> UINT;
}
extern "C" {
  pub fn GetVolumeInformationByHandleW(
    hFile: HANDLE, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD,
    lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD,
    lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetVolumeInformationW(
    lpRootPathName: LPCWSTR, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD,
    lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD,
    lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetVolumePathNameW(
    lpszFileName: LPCWSTR, lpszVolumePathName: LPWSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LocalFileTimeToFileTime(lpLocalFileTime: *const FILETIME, lpFileTime: LPFILETIME) -> BOOL;
}
extern "C" {
  pub fn LockFile(
    hFile: HANDLE, dwFileOffsetLow: DWORD, dwFileOffsetHigh: DWORD, nNumberOfBytesToLockLow: DWORD,
    nNumberOfBytesToLockHigh: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LockFileEx(
    hFile: HANDLE, dwFlags: DWORD, dwReserved: DWORD, nNumberOfBytesToLockLow: DWORD,
    nNumberOfBytesToLockHigh: DWORD, lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryDosDeviceW(lpDeviceName: LPCWSTR, lpTargetPath: LPWSTR, ucchMax: DWORD) -> DWORD;
}
extern "C" {
  pub fn ReadFile(
    hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD,
    lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadFileEx(
    hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpOverlapped: LPOVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadFileScatter(
    hFile: HANDLE, aSegmentArray: *mut FILE_SEGMENT_ELEMENT, nNumberOfBytesToRead: DWORD,
    lpReserved: LPDWORD, lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn RemoveDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn SetEndOfFile(hFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetFileAttributesA(lpFileName: LPCSTR, dwFileAttributes: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetFileInformationByHandle(
    hFile: HANDLE, FileInformationClass: FILE_INFO_BY_HANDLE_CLASS, lpFileInformation: LPVOID,
    dwBufferSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFilePointer(
    hFile: HANDLE, lDistanceToMove: LONG, lpDistanceToMoveHigh: PLONG, dwMoveMethod: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SetFilePointerEx(
    hFile: HANDLE, liDistanceToMove: LARGE_INTEGER, lpNewFilePointer: PLARGE_INTEGER,
    dwMoveMethod: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFileTime(
    hFile: HANDLE, lpCreationTime: *const FILETIME, lpLastAccessTime: *const FILETIME,
    lpLastWriteTime: *const FILETIME,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFileValidData(hFile: HANDLE, ValidDataLength: LONGLONG) -> BOOL;
}
extern "C" {
  pub fn UnlockFile(
    hFile: HANDLE, dwFileOffsetLow: DWORD, dwFileOffsetHigh: DWORD,
    nNumberOfBytesToUnlockLow: DWORD, nNumberOfBytesToUnlockHigh: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn UnlockFileEx(
    hFile: HANDLE, dwReserved: DWORD, nNumberOfBytesToUnlockLow: DWORD,
    nNumberOfBytesToUnlockHigh: DWORD, lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteFile(
    hFile: HANDLE, lpBuffer: LPCVOID, nNumberOfBytesToWrite: DWORD,
    lpNumberOfBytesWritten: LPDWORD, lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteFileEx(
    hFile: HANDLE, lpBuffer: LPCVOID, nNumberOfBytesToWrite: DWORD, lpOverlapped: LPOVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteFileGather(
    hFile: HANDLE, aSegmentArray: *mut FILE_SEGMENT_ELEMENT, nNumberOfBytesToWrite: DWORD,
    lpReserved: LPDWORD, lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
  pub fn GetVolumeNameForVolumeMountPointW(
    lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPWSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetVolumePathNamesForVolumeNameW(
    lpszVolumeName: LPCWSTR, lpszVolumePathNames: LPWCH, cchBufferLength: DWORD,
    lpcchReturnLength: PDWORD,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CREATEFILE2_EXTENDED_PARAMETERS {
  pub dwSize: DWORD,
  pub dwFileAttributes: DWORD,
  pub dwFileFlags: DWORD,
  pub dwSecurityQosFlags: DWORD,
  pub lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  pub hTemplateFile: HANDLE,
}
#[test]
fn bindgen_test_layout__CREATEFILE2_EXTENDED_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_CREATEFILE2_EXTENDED_PARAMETERS>(),
    32usize,
    concat!("Size of: ", stringify!(_CREATEFILE2_EXTENDED_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_CREATEFILE2_EXTENDED_PARAMETERS>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATEFILE2_EXTENDED_PARAMETERS>())).dwSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATEFILE2_EXTENDED_PARAMETERS>())).dwFileAttributes as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(dwFileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATEFILE2_EXTENDED_PARAMETERS>())).dwFileFlags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(dwFileFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATEFILE2_EXTENDED_PARAMETERS>())).dwSecurityQosFlags as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(dwSecurityQosFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATEFILE2_EXTENDED_PARAMETERS>())).lpSecurityAttributes as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(lpSecurityAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CREATEFILE2_EXTENDED_PARAMETERS>())).hTemplateFile as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_CREATEFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(hTemplateFile)
    )
  );
}
impl Default for _CREATEFILE2_EXTENDED_PARAMETERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CREATEFILE2_EXTENDED_PARAMETERS = _CREATEFILE2_EXTENDED_PARAMETERS;
pub type PCREATEFILE2_EXTENDED_PARAMETERS = *mut _CREATEFILE2_EXTENDED_PARAMETERS;
pub type LPCREATEFILE2_EXTENDED_PARAMETERS = *mut _CREATEFILE2_EXTENDED_PARAMETERS;
extern "C" {
  pub fn CreateFile2(
    lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwCreationDisposition: DWORD,
    pCreateExParams: LPCREATEFILE2_EXTENDED_PARAMETERS,
  ) -> HANDLE;
}
extern "C" {
  pub fn SetFileIoOverlappedRange(
    FileHandle: HANDLE, OverlappedRangeStart: PUCHAR, Length: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCompressedFileSizeA(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn GetCompressedFileSizeW(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD) -> DWORD;
}
pub mod _STREAM_INFO_LEVELS {
  pub type Type = i32;
  pub const FindStreamInfoStandard: Type = 0;
  pub const FindStreamInfoMaxInfoLevel: Type = 1;
}
pub use self::_STREAM_INFO_LEVELS::Type as STREAM_INFO_LEVELS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIN32_FIND_STREAM_DATA {
  pub StreamSize: LARGE_INTEGER,
  pub cStreamName: [WCHAR; 296usize],
}
#[test]
fn bindgen_test_layout__WIN32_FIND_STREAM_DATA() {
  assert_eq!(
    ::core::mem::size_of::<_WIN32_FIND_STREAM_DATA>(),
    600usize,
    concat!("Size of: ", stringify!(_WIN32_FIND_STREAM_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_WIN32_FIND_STREAM_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_WIN32_FIND_STREAM_DATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_FIND_STREAM_DATA>())).StreamSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_STREAM_DATA),
      "::",
      stringify!(StreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_FIND_STREAM_DATA>())).cStreamName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_FIND_STREAM_DATA),
      "::",
      stringify!(cStreamName)
    )
  );
}
impl Default for _WIN32_FIND_STREAM_DATA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WIN32_FIND_STREAM_DATA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_WIN32_FIND_STREAM_DATA {{ StreamSize: {:?}, cStreamName: [...] }}",
      self.StreamSize
    )
  }
}
pub type WIN32_FIND_STREAM_DATA = _WIN32_FIND_STREAM_DATA;
pub type PWIN32_FIND_STREAM_DATA = *mut _WIN32_FIND_STREAM_DATA;
extern "C" {
  pub fn FindFirstStreamW(
    lpFileName: LPCWSTR, InfoLevel: STREAM_INFO_LEVELS, lpFindStreamData: LPVOID, dwFlags: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindNextStreamW(hFindStream: HANDLE, lpFindStreamData: LPVOID) -> BOOL;
}
extern "C" {
  pub fn AreFileApisANSI() -> BOOL;
}
extern "C" {
  pub fn GetTempPathA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
  pub fn FindFirstFileNameW(
    lpFileName: LPCWSTR, dwFlags: DWORD, StringLength: LPDWORD, LinkName: PWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindNextFileNameW(hFindStream: HANDLE, StringLength: LPDWORD, LinkName: PWSTR) -> BOOL;
}
extern "C" {
  pub fn GetVolumeInformationA(
    lpRootPathName: LPCSTR, lpVolumeNameBuffer: LPSTR, nVolumeNameSize: DWORD,
    lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD,
    lpFileSystemNameBuffer: LPSTR, nFileSystemNameSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetTempFileNameA(
    lpPathName: LPCSTR, lpPrefixString: LPCSTR, uUnique: UINT, lpTempFileName: LPSTR,
  ) -> UINT;
}
extern "C" {
  pub fn SetFileApisToOEM();
}
extern "C" {
  pub fn SetFileApisToANSI();
}
extern "C" {
  pub fn IsDebuggerPresent() -> BOOL;
}
extern "C" {
  pub fn DebugBreak();
}
extern "C" {
  pub fn OutputDebugStringA(lpOutputString: LPCSTR);
}
extern "C" {
  pub fn OutputDebugStringW(lpOutputString: LPCWSTR);
}
extern "C" {
  pub fn ContinueDebugEvent(dwProcessId: DWORD, dwThreadId: DWORD, dwContinueStatus: DWORD)
    -> BOOL;
}
extern "C" {
  pub fn WaitForDebugEvent(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;
}
extern "C" {
  pub fn DebugActiveProcess(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
  pub fn DebugActiveProcessStop(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
  pub fn CheckRemoteDebuggerPresent(hProcess: HANDLE, pbDebuggerPresent: PBOOL) -> BOOL;
}
extern "C" {
  pub fn WaitForDebugEventEx(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;
}
extern "C" {
  pub fn EncodePointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
  pub fn DecodePointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
  pub fn EncodeSystemPointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
  pub fn DecodeSystemPointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
  pub fn EncodeRemotePointer(ProcessHandle: HANDLE, Ptr: PVOID, EncodedPtr: *mut PVOID) -> HRESULT;
}
extern "C" {
  pub fn DecodeRemotePointer(ProcessHandle: HANDLE, Ptr: PVOID, DecodedPtr: *mut PVOID) -> HRESULT;
}
extern "C" {
  pub fn Beep(dwFreq: DWORD, dwDuration: DWORD) -> BOOL;
}
extern "C" {
  pub fn CloseHandle(hObject: HANDLE) -> BOOL;
}
extern "C" {
  pub fn DuplicateHandle(
    hSourceProcessHandle: HANDLE, hSourceHandle: HANDLE, hTargetProcessHandle: HANDLE,
    lpTargetHandle: LPHANDLE, dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwOptions: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CompareObjectHandles(hFirstObjectHandle: HANDLE, hSecondObjectHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetHandleInformation(hObject: HANDLE, lpdwFlags: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;
}
pub type PTOP_LEVEL_EXCEPTION_FILTER =
  ::core::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
pub type LPTOP_LEVEL_EXCEPTION_FILTER = PTOP_LEVEL_EXCEPTION_FILTER;
extern "C" {
  pub fn RaiseException(
    dwExceptionCode: DWORD, dwExceptionFlags: DWORD, nNumberOfArguments: DWORD,
    lpArguments: *const ULONG_PTR,
  );
}
extern "C" {
  pub fn UnhandledExceptionFilter(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG;
}
extern "C" {
  pub fn SetUnhandledExceptionFilter(
    lpTopLevelExceptionFilter: LPTOP_LEVEL_EXCEPTION_FILTER,
  ) -> LPTOP_LEVEL_EXCEPTION_FILTER;
}
extern "C" {
  pub fn GetLastError() -> DWORD;
}
extern "C" {
  pub fn SetLastError(dwErrCode: DWORD);
}
extern "C" {
  pub fn GetErrorMode() -> UINT;
}
extern "C" {
  pub fn SetErrorMode(uMode: UINT) -> UINT;
}
extern "C" {
  pub fn AddVectoredExceptionHandler(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER) -> PVOID;
}
extern "C" {
  pub fn RemoveVectoredExceptionHandler(Handle: PVOID) -> ULONG;
}
extern "C" {
  pub fn AddVectoredContinueHandler(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER) -> PVOID;
}
extern "C" {
  pub fn RemoveVectoredContinueHandler(Handle: PVOID) -> ULONG;
}
extern "C" {
  pub fn RaiseFailFastException(
    pExceptionRecord: PEXCEPTION_RECORD, pContextRecord: PCONTEXT, dwFlags: DWORD,
  );
}
extern "C" {
  pub fn FatalAppExitA(uAction: UINT, lpMessageText: LPCSTR);
}
extern "C" {
  pub fn FatalAppExitW(uAction: UINT, lpMessageText: LPCWSTR);
}
extern "C" {
  pub fn GetThreadErrorMode() -> DWORD;
}
extern "C" {
  pub fn SetThreadErrorMode(dwNewMode: DWORD, lpOldMode: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn TerminateProcessOnMemoryExhaustion(FailedAllocationSize: SIZE_T);
}
extern "C" {
  pub fn FlsAlloc(lpCallback: PFLS_CALLBACK_FUNCTION) -> DWORD;
}
extern "C" {
  pub fn FlsGetValue(dwFlsIndex: DWORD) -> PVOID;
}
extern "C" {
  pub fn FlsSetValue(dwFlsIndex: DWORD, lpFlsData: PVOID) -> BOOL;
}
extern "C" {
  pub fn FlsFree(dwFlsIndex: DWORD) -> BOOL;
}
extern "C" {
  pub fn IsThreadAFiber() -> BOOL;
}
extern "C" {
  pub fn CreatePipe(
    hReadPipe: PHANDLE, hWritePipe: PHANDLE, lpPipeAttributes: LPSECURITY_ATTRIBUTES, nSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ConnectNamedPipe(hNamedPipe: HANDLE, lpOverlapped: LPOVERLAPPED) -> BOOL;
}
extern "C" {
  pub fn DisconnectNamedPipe(hNamedPipe: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetNamedPipeHandleState(
    hNamedPipe: HANDLE, lpMode: LPDWORD, lpMaxCollectionCount: LPDWORD,
    lpCollectDataTimeout: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn PeekNamedPipe(
    hNamedPipe: HANDLE, lpBuffer: LPVOID, nBufferSize: DWORD, lpBytesRead: LPDWORD,
    lpTotalBytesAvail: LPDWORD, lpBytesLeftThisMessage: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn TransactNamedPipe(
    hNamedPipe: HANDLE, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID,
    nOutBufferSize: DWORD, lpBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateNamedPipeW(
    lpName: LPCWSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD,
    nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> HANDLE;
}
extern "C" {
  pub fn WaitNamedPipeW(lpNamedPipeName: LPCWSTR, nTimeOut: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeClientComputerNameW(
    Pipe: HANDLE, ClientComputerName: LPWSTR, ClientComputerNameLength: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn ImpersonateNamedPipeClient(hNamedPipe: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeInfo(
    hNamedPipe: HANDLE, lpFlags: LPDWORD, lpOutBufferSize: LPDWORD, lpInBufferSize: LPDWORD,
    lpMaxInstances: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeHandleStateW(
    hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD,
    lpCollectDataTimeout: LPDWORD, lpUserName: LPWSTR, nMaxUserNameSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CallNamedPipeW(
    lpNamedPipeName: LPCWSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID,
    nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;
}
extern "C" {
  pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _HEAP_SUMMARY {
  pub cb: DWORD,
  pub cbAllocated: SIZE_T,
  pub cbCommitted: SIZE_T,
  pub cbReserved: SIZE_T,
  pub cbMaxReserve: SIZE_T,
}
#[test]
fn bindgen_test_layout__HEAP_SUMMARY() {
  assert_eq!(
    ::core::mem::size_of::<_HEAP_SUMMARY>(),
    40usize,
    concat!("Size of: ", stringify!(_HEAP_SUMMARY))
  );
  assert_eq!(
    ::core::mem::align_of::<_HEAP_SUMMARY>(),
    8usize,
    concat!("Alignment of ", stringify!(_HEAP_SUMMARY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HEAP_SUMMARY>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_SUMMARY),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HEAP_SUMMARY>())).cbAllocated as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_SUMMARY),
      "::",
      stringify!(cbAllocated)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HEAP_SUMMARY>())).cbCommitted as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_SUMMARY),
      "::",
      stringify!(cbCommitted)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HEAP_SUMMARY>())).cbReserved as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_SUMMARY),
      "::",
      stringify!(cbReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_HEAP_SUMMARY>())).cbMaxReserve as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_HEAP_SUMMARY),
      "::",
      stringify!(cbMaxReserve)
    )
  );
}
pub type HEAP_SUMMARY = _HEAP_SUMMARY;
pub type PHEAP_SUMMARY = *mut _HEAP_SUMMARY;
pub type LPHEAP_SUMMARY = PHEAP_SUMMARY;
extern "C" {
  pub fn HeapCreate(flOptions: DWORD, dwInitialSize: SIZE_T, dwMaximumSize: SIZE_T) -> HANDLE;
}
extern "C" {
  pub fn HeapDestroy(hHeap: HANDLE) -> BOOL;
}
extern "C" {
  pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;
}
extern "C" {
  pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;
}
extern "C" {
  pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;
}
extern "C" {
  pub fn HeapSize(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID) -> SIZE_T;
}
extern "C" {
  pub fn GetProcessHeap() -> HANDLE;
}
extern "C" {
  pub fn HeapCompact(hHeap: HANDLE, dwFlags: DWORD) -> SIZE_T;
}
extern "C" {
  pub fn HeapSetInformation(
    HeapHandle: HANDLE, HeapInformationClass: HEAP_INFORMATION_CLASS, HeapInformation: PVOID,
    HeapInformationLength: SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn HeapValidate(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID) -> BOOL;
}
extern "C" {
  pub fn HeapSummary(hHeap: HANDLE, dwFlags: DWORD, lpSummary: LPHEAP_SUMMARY) -> BOOL;
}
extern "C" {
  pub fn GetProcessHeaps(NumberOfHeaps: DWORD, ProcessHeaps: PHANDLE) -> DWORD;
}
extern "C" {
  pub fn HeapLock(hHeap: HANDLE) -> BOOL;
}
extern "C" {
  pub fn HeapUnlock(hHeap: HANDLE) -> BOOL;
}
extern "C" {
  pub fn HeapWalk(hHeap: HANDLE, lpEntry: LPPROCESS_HEAP_ENTRY) -> BOOL;
}
extern "C" {
  pub fn HeapQueryInformation(
    HeapHandle: HANDLE, HeapInformationClass: HEAP_INFORMATION_CLASS, HeapInformation: PVOID,
    HeapInformationLength: SIZE_T, ReturnLength: PSIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateIoCompletionPort(
    FileHandle: HANDLE, ExistingCompletionPort: HANDLE, CompletionKey: ULONG_PTR,
    NumberOfConcurrentThreads: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn GetQueuedCompletionStatus(
    CompletionPort: HANDLE, lpNumberOfBytesTransferred: LPDWORD, lpCompletionKey: PULONG_PTR,
    lpOverlapped: *mut LPOVERLAPPED, dwMilliseconds: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetQueuedCompletionStatusEx(
    CompletionPort: HANDLE, lpCompletionPortEntries: LPOVERLAPPED_ENTRY, ulCount: ULONG,
    ulNumEntriesRemoved: PULONG, dwMilliseconds: DWORD, fAlertable: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn PostQueuedCompletionStatus(
    CompletionPort: HANDLE, dwNumberOfBytesTransferred: DWORD, dwCompletionKey: ULONG_PTR,
    lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn DeviceIoControl(
    hDevice: HANDLE, dwIoControlCode: DWORD, lpInBuffer: LPVOID, nInBufferSize: DWORD,
    lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesReturned: LPDWORD,
    lpOverlapped: LPOVERLAPPED,
  ) -> BOOL;
}
extern "C" {
  pub fn GetOverlappedResult(
    hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, bWait: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn CancelIoEx(hFile: HANDLE, lpOverlapped: LPOVERLAPPED) -> BOOL;
}
extern "C" {
  pub fn CancelIo(hFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetOverlappedResultEx(
    hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD,
    dwMilliseconds: DWORD, bAlertable: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn CancelSynchronousIo(hThread: HANDLE) -> BOOL;
}
pub type SRWLOCK = RTL_SRWLOCK;
pub type PSRWLOCK = *mut RTL_SRWLOCK;
extern "C" {
  pub fn InitializeSRWLock(SRWLock: PSRWLOCK);
}
extern "C" {
  pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);
}
extern "C" {
  pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);
}
extern "C" {
  pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);
}
extern "C" {
  pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);
}
extern "C" {
  pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;
}
extern "C" {
  pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;
}
extern "C" {
  pub fn InitializeCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
  pub fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
  pub fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
  pub fn InitializeCriticalSectionAndSpinCount(
    lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn InitializeCriticalSectionEx(
    lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD, Flags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetCriticalSectionSpinCount(
    lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;
}
extern "C" {
  pub fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
pub type INIT_ONCE = RTL_RUN_ONCE;
pub type PINIT_ONCE = PRTL_RUN_ONCE;
pub type LPINIT_ONCE = PRTL_RUN_ONCE;
pub type PINIT_ONCE_FN = ::core::option::Option<
  unsafe extern "C" fn(InitOnce: PINIT_ONCE, Parameter: PVOID, Context: *mut PVOID) -> BOOL,
>;
extern "C" {
  pub fn InitOnceInitialize(InitOnce: PINIT_ONCE);
}
extern "C" {
  pub fn InitOnceExecuteOnce(
    InitOnce: PINIT_ONCE, InitFn: PINIT_ONCE_FN, Parameter: PVOID, Context: *mut LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn InitOnceBeginInitialize(
    lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, fPending: PBOOL, lpContext: *mut LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) -> BOOL;
}
pub type CONDITION_VARIABLE = RTL_CONDITION_VARIABLE;
pub type PCONDITION_VARIABLE = *mut RTL_CONDITION_VARIABLE;
extern "C" {
  pub fn InitializeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
  pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
  pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
  pub fn SleepConditionVariableCS(
    ConditionVariable: PCONDITION_VARIABLE, CriticalSection: PCRITICAL_SECTION,
    dwMilliseconds: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SleepConditionVariableSRW(
    ConditionVariable: PCONDITION_VARIABLE, SRWLock: PSRWLOCK, dwMilliseconds: DWORD, Flags: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
  pub fn ResetEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
  pub fn ReleaseSemaphore(hSemaphore: HANDLE, lReleaseCount: LONG, lpPreviousCount: LPLONG)
    -> BOOL;
}
extern "C" {
  pub fn ReleaseMutex(hMutex: HANDLE) -> BOOL;
}
extern "C" {
  pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
}
extern "C" {
  pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;
}
extern "C" {
  pub fn WaitForSingleObjectEx(hHandle: HANDLE, dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;
}
extern "C" {
  pub fn WaitForMultipleObjectsEx(
    nCount: DWORD, lpHandles: *const HANDLE, bWaitAll: BOOL, dwMilliseconds: DWORD,
    bAlertable: BOOL,
  ) -> DWORD;
}
extern "C" {
  pub fn CreateMutexA(
    lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: BOOL, lpName: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateMutexW(
    lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: BOOL, lpName: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenMutexW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn CreateEventA(
    lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, bInitialState: BOOL,
    lpName: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateEventW(
    lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, bInitialState: BOOL,
    lpName: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenEventA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn OpenEventW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn OpenSemaphoreW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
pub type PTIMERAPCROUTINE = ::core::option::Option<
  unsafe extern "C" fn(
    lpArgToCompletionRoutine: LPVOID,
    dwTimerLowValue: DWORD,
    dwTimerHighValue: DWORD,
  ),
>;
extern "C" {
  pub fn OpenWaitableTimerW(
    dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpTimerName: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn SetWaitableTimerEx(
    hTimer: HANDLE, lpDueTime: *const LARGE_INTEGER, lPeriod: LONG,
    pfnCompletionRoutine: PTIMERAPCROUTINE, lpArgToCompletionRoutine: LPVOID,
    WakeContext: PREASON_CONTEXT, TolerableDelay: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetWaitableTimer(
    hTimer: HANDLE, lpDueTime: *const LARGE_INTEGER, lPeriod: LONG,
    pfnCompletionRoutine: PTIMERAPCROUTINE, lpArgToCompletionRoutine: LPVOID, fResume: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn CancelWaitableTimer(hTimer: HANDLE) -> BOOL;
}
extern "C" {
  pub fn CreateMutexExA(
    lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD,
    dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateMutexExW(
    lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD,
    dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateEventExA(
    lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD,
    dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateEventExW(
    lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD,
    dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateSemaphoreExW(
    lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG,
    lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateWaitableTimerExW(
    lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCWSTR, dwFlags: DWORD,
    dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
pub type SYNCHRONIZATION_BARRIER = RTL_BARRIER;
pub type PSYNCHRONIZATION_BARRIER = PRTL_BARRIER;
pub type LPSYNCHRONIZATION_BARRIER = PRTL_BARRIER;
extern "C" {
  pub fn EnterSynchronizationBarrier(lpBarrier: LPSYNCHRONIZATION_BARRIER, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn InitializeSynchronizationBarrier(
    lpBarrier: LPSYNCHRONIZATION_BARRIER, lTotalThreads: LONG, lSpinCount: LONG,
  ) -> BOOL;
}
extern "C" {
  pub fn DeleteSynchronizationBarrier(lpBarrier: LPSYNCHRONIZATION_BARRIER) -> BOOL;
}
extern "C" {
  pub fn Sleep(dwMilliseconds: DWORD);
}
extern "C" {
  pub fn WaitOnAddress(
    Address: *mut libc::c_void, CompareAddress: PVOID, AddressSize: SIZE_T, dwMilliseconds: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WakeByAddressSingle(Address: PVOID);
}
extern "C" {
  pub fn WakeByAddressAll(Address: PVOID);
}
extern "C" {
  pub fn SignalObjectAndWait(
    hObjectToSignal: HANDLE, hObjectToWaitOn: HANDLE, dwMilliseconds: DWORD, bAlertable: BOOL,
  ) -> DWORD;
}
extern "C" {
  pub fn WaitForMultipleObjects(
    nCount: DWORD, lpHandles: *const HANDLE, bWaitAll: BOOL, dwMilliseconds: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn CreateSemaphoreW(
    lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG,
    lpName: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateWaitableTimerW(
    lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, lpTimerName: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn InitializeSListHead(ListHead: PSLIST_HEADER);
}
extern "C" {
  pub fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn InterlockedPushEntrySList(
    ListHead: PSLIST_HEADER, ListEntry: PSLIST_ENTRY,
  ) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn InterlockedPushListSListEx(
    ListHead: PSLIST_HEADER, List: PSLIST_ENTRY, ListEnd: PSLIST_ENTRY, Count: ULONG,
  ) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn InterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
  pub fn QueryDepthSList(ListHead: PSLIST_HEADER) -> USHORT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _PROCESS_INFORMATION {
  pub hProcess: HANDLE,
  pub hThread: HANDLE,
  pub dwProcessId: DWORD,
  pub dwThreadId: DWORD,
}
#[test]
fn bindgen_test_layout__PROCESS_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_PROCESS_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESS_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_INFORMATION>())).hProcess as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(hProcess)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_INFORMATION>())).hThread as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(hThread)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_INFORMATION>())).dwProcessId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PROCESS_INFORMATION>())).dwThreadId as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(dwThreadId)
    )
  );
}
impl Default for _PROCESS_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PROCESS_INFORMATION = _PROCESS_INFORMATION;
pub type PPROCESS_INFORMATION = *mut _PROCESS_INFORMATION;
pub type LPPROCESS_INFORMATION = *mut _PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _STARTUPINFOA {
  pub cb: DWORD,
  pub lpReserved: LPSTR,
  pub lpDesktop: LPSTR,
  pub lpTitle: LPSTR,
  pub dwX: DWORD,
  pub dwY: DWORD,
  pub dwXSize: DWORD,
  pub dwYSize: DWORD,
  pub dwXCountChars: DWORD,
  pub dwYCountChars: DWORD,
  pub dwFillAttribute: DWORD,
  pub dwFlags: DWORD,
  pub wShowWindow: WORD,
  pub cbReserved2: WORD,
  pub lpReserved2: LPBYTE,
  pub hStdInput: HANDLE,
  pub hStdOutput: HANDLE,
  pub hStdError: HANDLE,
}
#[test]
fn bindgen_test_layout__STARTUPINFOA() {
  assert_eq!(
    ::core::mem::size_of::<_STARTUPINFOA>(),
    104usize,
    concat!("Size of: ", stringify!(_STARTUPINFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<_STARTUPINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).lpReserved as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).lpDesktop as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpDesktop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).lpTitle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwX as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwY as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwXSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwXSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwYSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwYSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwXCountChars as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwXCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwYCountChars as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwYCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwFillAttribute as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwFillAttribute)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).dwFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).wShowWindow as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(wShowWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).cbReserved2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(cbReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).lpReserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).hStdInput as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdInput)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).hStdOutput as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOA>())).hStdError as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdError)
    )
  );
}
impl Default for _STARTUPINFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type STARTUPINFOA = _STARTUPINFOA;
pub type LPSTARTUPINFOA = *mut _STARTUPINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _STARTUPINFOW {
  pub cb: DWORD,
  pub lpReserved: LPWSTR,
  pub lpDesktop: LPWSTR,
  pub lpTitle: LPWSTR,
  pub dwX: DWORD,
  pub dwY: DWORD,
  pub dwXSize: DWORD,
  pub dwYSize: DWORD,
  pub dwXCountChars: DWORD,
  pub dwYCountChars: DWORD,
  pub dwFillAttribute: DWORD,
  pub dwFlags: DWORD,
  pub wShowWindow: WORD,
  pub cbReserved2: WORD,
  pub lpReserved2: LPBYTE,
  pub hStdInput: HANDLE,
  pub hStdOutput: HANDLE,
  pub hStdError: HANDLE,
}
#[test]
fn bindgen_test_layout__STARTUPINFOW() {
  assert_eq!(
    ::core::mem::size_of::<_STARTUPINFOW>(),
    104usize,
    concat!("Size of: ", stringify!(_STARTUPINFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<_STARTUPINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).lpReserved as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).lpDesktop as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpDesktop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).lpTitle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwX as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwY as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwXSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwXSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwYSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwYSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwXCountChars as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwXCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwYCountChars as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwYCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwFillAttribute as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwFillAttribute)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).dwFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).wShowWindow as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(wShowWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).cbReserved2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(cbReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).lpReserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).hStdInput as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdInput)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).hStdOutput as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOW>())).hStdError as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdError)
    )
  );
}
impl Default for _STARTUPINFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type STARTUPINFOW = _STARTUPINFOW;
pub type LPSTARTUPINFOW = *mut _STARTUPINFOW;
pub type STARTUPINFO = STARTUPINFOA;
pub type LPSTARTUPINFO = LPSTARTUPINFOA;
extern "C" {
  pub fn QueueUserAPC(pfnAPC: PAPCFUNC, hThread: HANDLE, dwData: ULONG_PTR) -> DWORD;
}
extern "C" {
  pub fn GetProcessTimes(
    hProcess: HANDLE, lpCreationTime: LPFILETIME, lpExitTime: LPFILETIME, lpKernelTime: LPFILETIME,
    lpUserTime: LPFILETIME,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCurrentProcess() -> HANDLE;
}
extern "C" {
  pub fn GetCurrentProcessId() -> DWORD;
}
extern "C" {
  pub fn ExitProcess(uExitCode: UINT);
}
extern "C" {
  pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;
}
extern "C" {
  pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SwitchToThread() -> BOOL;
}
extern "C" {
  pub fn CreateThread(
    lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T,
    lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD,
    lpThreadId: LPDWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateRemoteThread(
    hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T,
    lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD,
    lpThreadId: LPDWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn GetCurrentThread() -> HANDLE;
}
extern "C" {
  pub fn GetCurrentThreadId() -> DWORD;
}
extern "C" {
  pub fn OpenThread(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwThreadId: DWORD) -> HANDLE;
}
extern "C" {
  pub fn SetThreadPriority(hThread: HANDLE, nPriority: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn SetThreadPriorityBoost(hThread: HANDLE, bDisablePriorityBoost: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetThreadPriorityBoost(hThread: HANDLE, pDisablePriorityBoost: PBOOL) -> BOOL;
}
extern "C" {
  pub fn GetThreadPriority(hThread: HANDLE) -> libc::c_int;
}
extern "C" {
  pub fn ExitThread(dwExitCode: DWORD);
}
extern "C" {
  pub fn TerminateThread(hThread: HANDLE, dwExitCode: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetExitCodeThread(hThread: HANDLE, lpExitCode: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SuspendThread(hThread: HANDLE) -> DWORD;
}
extern "C" {
  pub fn ResumeThread(hThread: HANDLE) -> DWORD;
}
extern "C" {
  pub fn TlsAlloc() -> DWORD;
}
extern "C" {
  pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
}
extern "C" {
  pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsValue: LPVOID) -> BOOL;
}
extern "C" {
  pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
}
extern "C" {
  pub fn CreateProcessA(
    lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES,
    lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: BOOL, dwCreationFlags: DWORD,
    lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA,
    lpProcessInformation: LPPROCESS_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateProcessW(
    lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES,
    lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: BOOL, dwCreationFlags: DWORD,
    lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW,
    lpProcessInformation: LPPROCESS_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn SetProcessShutdownParameters(dwLevel: DWORD, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetProcessVersion(ProcessId: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetStartupInfoW(lpStartupInfo: LPSTARTUPINFOW);
}
extern "C" {
  pub fn CreateProcessAsUserW(
    hToken: HANDLE, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR,
    lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES,
    bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID,
    lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW,
    lpProcessInformation: LPPROCESS_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadToken(Thread: PHANDLE, Token: HANDLE) -> BOOL;
}
extern "C" {
  pub fn OpenProcessToken(
    ProcessHandle: HANDLE, DesiredAccess: DWORD, TokenHandle: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn OpenThreadToken(
    ThreadHandle: HANDLE, DesiredAccess: DWORD, OpenAsSelf: BOOL, TokenHandle: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn SetPriorityClass(hProcess: HANDLE, dwPriorityClass: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetPriorityClass(hProcess: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SetThreadStackGuarantee(StackSizeInBytes: PULONG) -> BOOL;
}
extern "C" {
  pub fn ProcessIdToSessionId(dwProcessId: DWORD, pSessionId: *mut DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE_LIST {
  _unused: [u8; 0],
}
pub type PPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
pub type LPPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
extern "C" {
  pub fn GetProcessId(Process: HANDLE) -> DWORD;
}
extern "C" {
  pub fn GetThreadId(Thread: HANDLE) -> DWORD;
}
extern "C" {
  pub fn FlushProcessWriteBuffers();
}
extern "C" {
  pub fn GetProcessIdOfThread(Thread: HANDLE) -> DWORD;
}
extern "C" {
  pub fn InitializeProcThreadAttributeList(
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, dwAttributeCount: DWORD, dwFlags: DWORD,
    lpSize: PSIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn DeleteProcThreadAttributeList(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST);
}
extern "C" {
  pub fn SetProcessAffinityUpdateMode(hProcess: HANDLE, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn QueryProcessAffinityUpdateMode(hProcess: HANDLE, lpdwFlags: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn UpdateProcThreadAttribute(
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, dwFlags: DWORD, Attribute: DWORD_PTR,
    lpValue: PVOID, cbSize: SIZE_T, lpPreviousValue: PVOID, lpReturnSize: PSIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateRemoteThreadEx(
    hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T,
    lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD,
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, lpThreadId: LPDWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn GetCurrentThreadStackLimits(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR);
}
extern "C" {
  pub fn GetThreadContext(hThread: HANDLE, lpContext: LPCONTEXT) -> BOOL;
}
extern "C" {
  pub fn GetProcessMitigationPolicy(
    hProcess: HANDLE, MitigationPolicy: PROCESS_MITIGATION_POLICY, lpBuffer: PVOID,
    dwLength: SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadContext(hThread: HANDLE, lpContext: *const CONTEXT) -> BOOL;
}
extern "C" {
  pub fn SetProcessMitigationPolicy(
    MitigationPolicy: PROCESS_MITIGATION_POLICY, lpBuffer: PVOID, dwLength: SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn FlushInstructionCache(hProcess: HANDLE, lpBaseAddress: LPCVOID, dwSize: SIZE_T) -> BOOL;
}
extern "C" {
  pub fn GetThreadTimes(
    hThread: HANDLE, lpCreationTime: LPFILETIME, lpExitTime: LPFILETIME, lpKernelTime: LPFILETIME,
    lpUserTime: LPFILETIME,
  ) -> BOOL;
}
extern "C" {
  pub fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) -> HANDLE;
}
extern "C" {
  pub fn IsProcessorFeaturePresent(ProcessorFeature: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetProcessHandleCount(hProcess: HANDLE, pdwHandleCount: PDWORD) -> BOOL;
}
extern "C" {
  pub fn GetCurrentProcessorNumber() -> DWORD;
}
extern "C" {
  pub fn SetThreadIdealProcessorEx(
    hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER,
    lpPreviousIdealProcessor: PPROCESSOR_NUMBER,
  ) -> BOOL;
}
extern "C" {
  pub fn GetThreadIdealProcessorEx(hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER) -> BOOL;
}
extern "C" {
  pub fn GetCurrentProcessorNumberEx(ProcNumber: PPROCESSOR_NUMBER);
}
extern "C" {
  pub fn GetProcessPriorityBoost(hProcess: HANDLE, pDisablePriorityBoost: PBOOL) -> BOOL;
}
extern "C" {
  pub fn SetProcessPriorityBoost(hProcess: HANDLE, bDisablePriorityBoost: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetThreadIOPendingFlag(hThread: HANDLE, lpIOIsPending: PBOOL) -> BOOL;
}
extern "C" {
  pub fn GetSystemTimes(
    lpIdleTime: PFILETIME, lpKernelTime: PFILETIME, lpUserTime: PFILETIME,
  ) -> BOOL;
}
pub mod _THREAD_INFORMATION_CLASS {
  pub type Type = i32;
  pub const ThreadMemoryPriority: Type = 0;
  pub const ThreadAbsoluteCpuPriority: Type = 1;
  pub const ThreadDynamicCodePolicy: Type = 2;
  pub const ThreadPowerThrottling: Type = 3;
  pub const ThreadInformationClassMax: Type = 4;
}
pub use self::_THREAD_INFORMATION_CLASS::Type as THREAD_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MEMORY_PRIORITY_INFORMATION {
  pub MemoryPriority: ULONG,
}
#[test]
fn bindgen_test_layout__MEMORY_PRIORITY_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_MEMORY_PRIORITY_INFORMATION>(),
    4usize,
    concat!("Size of: ", stringify!(_MEMORY_PRIORITY_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_MEMORY_PRIORITY_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_MEMORY_PRIORITY_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORY_PRIORITY_INFORMATION>())).MemoryPriority as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORY_PRIORITY_INFORMATION),
      "::",
      stringify!(MemoryPriority)
    )
  );
}
pub type MEMORY_PRIORITY_INFORMATION = _MEMORY_PRIORITY_INFORMATION;
pub type PMEMORY_PRIORITY_INFORMATION = *mut _MEMORY_PRIORITY_INFORMATION;
extern "C" {
  pub fn GetThreadInformation(
    hThread: HANDLE, ThreadInformationClass: THREAD_INFORMATION_CLASS, ThreadInformation: LPVOID,
    ThreadInformationSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadInformation(
    hThread: HANDLE, ThreadInformationClass: THREAD_INFORMATION_CLASS, ThreadInformation: LPVOID,
    ThreadInformationSize: DWORD,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _THREAD_POWER_THROTTLING_STATE {
  pub Version: ULONG,
  pub ControlMask: ULONG,
  pub StateMask: ULONG,
}
#[test]
fn bindgen_test_layout__THREAD_POWER_THROTTLING_STATE() {
  assert_eq!(
    ::core::mem::size_of::<_THREAD_POWER_THROTTLING_STATE>(),
    12usize,
    concat!("Size of: ", stringify!(_THREAD_POWER_THROTTLING_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<_THREAD_POWER_THROTTLING_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_THREAD_POWER_THROTTLING_STATE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_THREAD_POWER_THROTTLING_STATE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_THREAD_POWER_THROTTLING_STATE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_THREAD_POWER_THROTTLING_STATE>())).ControlMask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_THREAD_POWER_THROTTLING_STATE),
      "::",
      stringify!(ControlMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_THREAD_POWER_THROTTLING_STATE>())).StateMask as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_THREAD_POWER_THROTTLING_STATE),
      "::",
      stringify!(StateMask)
    )
  );
}
pub type THREAD_POWER_THROTTLING_STATE = _THREAD_POWER_THROTTLING_STATE;
extern "C" {
  pub fn IsProcessCritical(hProcess: HANDLE, Critical: PBOOL) -> BOOL;
}
extern "C" {
  pub fn SetProtectedPolicy(
    PolicyGuid: LPCGUID, PolicyValue: ULONG_PTR, OldPolicyValue: PULONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryProtectedPolicy(PolicyGuid: LPCGUID, PolicyValue: PULONG_PTR) -> BOOL;
}
extern "C" {
  pub fn SetThreadIdealProcessor(hThread: HANDLE, dwIdealProcessor: DWORD) -> DWORD;
}
pub mod _PROCESS_INFORMATION_CLASS {
  pub type Type = i32;
  pub const ProcessMemoryPriority: Type = 0;
  pub const ProcessMemoryExhaustionInfo: Type = 1;
  pub const ProcessAppMemoryInfo: Type = 2;
  pub const ProcessInPrivateInfo: Type = 3;
  pub const ProcessPowerThrottling: Type = 4;
  pub const ProcessReservedValue1: Type = 5;
  pub const ProcessTelemetryCoverageInfo: Type = 6;
  pub const ProcessProtectionLevelInfo: Type = 7;
  pub const ProcessInformationClassMax: Type = 8;
}
pub use self::_PROCESS_INFORMATION_CLASS::Type as PROCESS_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _APP_MEMORY_INFORMATION {
  pub AvailableCommit: ULONG64,
  pub PrivateCommitUsage: ULONG64,
  pub PeakPrivateCommitUsage: ULONG64,
  pub TotalCommitUsage: ULONG64,
}
#[test]
fn bindgen_test_layout__APP_MEMORY_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_APP_MEMORY_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(_APP_MEMORY_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_APP_MEMORY_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_APP_MEMORY_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APP_MEMORY_INFORMATION>())).AvailableCommit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_APP_MEMORY_INFORMATION),
      "::",
      stringify!(AvailableCommit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APP_MEMORY_INFORMATION>())).PrivateCommitUsage as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_APP_MEMORY_INFORMATION),
      "::",
      stringify!(PrivateCommitUsage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APP_MEMORY_INFORMATION>())).PeakPrivateCommitUsage as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_APP_MEMORY_INFORMATION),
      "::",
      stringify!(PeakPrivateCommitUsage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_APP_MEMORY_INFORMATION>())).TotalCommitUsage as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_APP_MEMORY_INFORMATION),
      "::",
      stringify!(TotalCommitUsage)
    )
  );
}
pub type APP_MEMORY_INFORMATION = _APP_MEMORY_INFORMATION;
pub type PAPP_MEMORY_INFORMATION = *mut _APP_MEMORY_INFORMATION;
pub mod _PROCESS_MEMORY_EXHAUSTION_TYPE {
  pub type Type = i32;
  pub const PMETypeFailFastOnCommitFailure: Type = 0;
  pub const PMETypeMax: Type = 1;
}
pub use self::_PROCESS_MEMORY_EXHAUSTION_TYPE::Type as PROCESS_MEMORY_EXHAUSTION_TYPE;
pub type PPROCESS_MEMORY_EXHAUSTION_TYPE = *mut _PROCESS_MEMORY_EXHAUSTION_TYPE::Type;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _PROCESS_MEMORY_EXHAUSTION_INFO {
  pub Version: USHORT,
  pub Reserved: USHORT,
  pub Type: PROCESS_MEMORY_EXHAUSTION_TYPE,
  pub Value: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__PROCESS_MEMORY_EXHAUSTION_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_MEMORY_EXHAUSTION_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_PROCESS_MEMORY_EXHAUSTION_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_MEMORY_EXHAUSTION_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESS_MEMORY_EXHAUSTION_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MEMORY_EXHAUSTION_INFO>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MEMORY_EXHAUSTION_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MEMORY_EXHAUSTION_INFO>())).Reserved as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MEMORY_EXHAUSTION_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MEMORY_EXHAUSTION_INFO>())).Type as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MEMORY_EXHAUSTION_INFO),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_MEMORY_EXHAUSTION_INFO>())).Value as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_MEMORY_EXHAUSTION_INFO),
      "::",
      stringify!(Value)
    )
  );
}
impl Default for _PROCESS_MEMORY_EXHAUSTION_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PROCESS_MEMORY_EXHAUSTION_INFO = _PROCESS_MEMORY_EXHAUSTION_INFO;
pub type PPROCESS_MEMORY_EXHAUSTION_INFO = *mut _PROCESS_MEMORY_EXHAUSTION_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PROCESS_POWER_THROTTLING_STATE {
  pub Version: ULONG,
  pub ControlMask: ULONG,
  pub StateMask: ULONG,
}
#[test]
fn bindgen_test_layout__PROCESS_POWER_THROTTLING_STATE() {
  assert_eq!(
    ::core::mem::size_of::<_PROCESS_POWER_THROTTLING_STATE>(),
    12usize,
    concat!("Size of: ", stringify!(_PROCESS_POWER_THROTTLING_STATE))
  );
  assert_eq!(
    ::core::mem::align_of::<_PROCESS_POWER_THROTTLING_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_PROCESS_POWER_THROTTLING_STATE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_POWER_THROTTLING_STATE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_POWER_THROTTLING_STATE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_POWER_THROTTLING_STATE>())).ControlMask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_POWER_THROTTLING_STATE),
      "::",
      stringify!(ControlMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_PROCESS_POWER_THROTTLING_STATE>())).StateMask as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_POWER_THROTTLING_STATE),
      "::",
      stringify!(StateMask)
    )
  );
}
pub type PROCESS_POWER_THROTTLING_STATE = _PROCESS_POWER_THROTTLING_STATE;
pub type PPROCESS_POWER_THROTTLING_STATE = *mut _PROCESS_POWER_THROTTLING_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct PROCESS_PROTECTION_LEVEL_INFORMATION {
  pub ProtectionLevel: DWORD,
}
#[test]
fn bindgen_test_layout_PROCESS_PROTECTION_LEVEL_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<PROCESS_PROTECTION_LEVEL_INFORMATION>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(PROCESS_PROTECTION_LEVEL_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<PROCESS_PROTECTION_LEVEL_INFORMATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(PROCESS_PROTECTION_LEVEL_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<PROCESS_PROTECTION_LEVEL_INFORMATION>())).ProtectionLevel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(PROCESS_PROTECTION_LEVEL_INFORMATION),
      "::",
      stringify!(ProtectionLevel)
    )
  );
}
extern "C" {
  pub fn SetProcessInformation(
    hProcess: HANDLE, ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    ProcessInformation: LPVOID, ProcessInformationSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetProcessInformation(
    hProcess: HANDLE, ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    ProcessInformation: LPVOID, ProcessInformationSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSystemCpuSetInformation(
    Information: PSYSTEM_CPU_SET_INFORMATION, BufferLength: ULONG, ReturnedLength: PULONG,
    Process: HANDLE, Flags: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetProcessDefaultCpuSets(
    Process: HANDLE, CpuSetIds: PULONG, CpuSetIdCount: ULONG, RequiredIdCount: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetProcessDefaultCpuSets(
    Process: HANDLE, CpuSetIds: *const ULONG, CpuSetIdCount: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetThreadSelectedCpuSets(
    Thread: HANDLE, CpuSetIds: PULONG, CpuSetIdCount: ULONG, RequiredIdCount: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadSelectedCpuSets(
    Thread: HANDLE, CpuSetIds: *const ULONG, CpuSetIdCount: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateProcessAsUserA(
    hToken: HANDLE, lpApplicationName: LPCSTR, lpCommandLine: LPSTR,
    lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES,
    bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID,
    lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA,
    lpProcessInformation: LPPROCESS_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn GetProcessShutdownParameters(lpdwLevel: LPDWORD, lpdwFlags: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SetThreadDescription(hThread: HANDLE, lpThreadDescription: PCWSTR) -> HRESULT;
}
extern "C" {
  pub fn GetThreadDescription(hThread: HANDLE, ppszThreadDescription: *mut PWSTR) -> HRESULT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_INFO {
  pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1,
  pub dwPageSize: DWORD,
  pub lpMinimumApplicationAddress: LPVOID,
  pub lpMaximumApplicationAddress: LPVOID,
  pub dwActiveProcessorMask: DWORD_PTR,
  pub dwNumberOfProcessors: DWORD,
  pub dwProcessorType: DWORD,
  pub dwAllocationGranularity: DWORD,
  pub wProcessorLevel: WORD,
  pub wProcessorRevision: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INFO__bindgen_ty_1 {
  pub dwOemId: DWORD,
  pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub wProcessorArchitecture: WORD,
  pub wReserved: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>())).wProcessorArchitecture
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wProcessorArchitecture)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>())).wReserved as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO__bindgen_ty_1>())).dwOemId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1),
      "::",
      stringify!(dwOemId)
    )
  );
}
impl Default for _SYSTEM_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_SYSTEM_INFO__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SYSTEM_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO>())).dwPageSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwPageSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_INFO>())).lpMinimumApplicationAddress as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(lpMinimumApplicationAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_INFO>())).lpMaximumApplicationAddress as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(lpMaximumApplicationAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO>())).dwActiveProcessorMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwActiveProcessorMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO>())).dwNumberOfProcessors as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwNumberOfProcessors)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO>())).dwProcessorType as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwProcessorType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_INFO>())).dwAllocationGranularity as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwAllocationGranularity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO>())).wProcessorLevel as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(wProcessorLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_INFO>())).wProcessorRevision as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(wProcessorRevision)
    )
  );
}
impl Default for _SYSTEM_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SYSTEM_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_SYSTEM_INFO {{ __bindgen_anon_1: {:?}, dwPageSize: {:?}, lpMinimumApplicationAddress: {:?}, lpMaximumApplicationAddress: {:?}, dwActiveProcessorMask: {:?}, dwNumberOfProcessors: {:?}, dwProcessorType: {:?}, dwAllocationGranularity: {:?}, wProcessorLevel: {:?}, wProcessorRevision: {:?} }}" , self . __bindgen_anon_1 , self . dwPageSize , self . lpMinimumApplicationAddress , self . lpMaximumApplicationAddress , self . dwActiveProcessorMask , self . dwNumberOfProcessors , self . dwProcessorType , self . dwAllocationGranularity , self . wProcessorLevel , self . wProcessorRevision )
  }
}
pub type SYSTEM_INFO = _SYSTEM_INFO;
pub type LPSYSTEM_INFO = *mut _SYSTEM_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MEMORYSTATUSEX {
  pub dwLength: DWORD,
  pub dwMemoryLoad: DWORD,
  pub ullTotalPhys: DWORDLONG,
  pub ullAvailPhys: DWORDLONG,
  pub ullTotalPageFile: DWORDLONG,
  pub ullAvailPageFile: DWORDLONG,
  pub ullTotalVirtual: DWORDLONG,
  pub ullAvailVirtual: DWORDLONG,
  pub ullAvailExtendedVirtual: DWORDLONG,
}
#[test]
fn bindgen_test_layout__MEMORYSTATUSEX() {
  assert_eq!(
    ::core::mem::size_of::<_MEMORYSTATUSEX>(),
    64usize,
    concat!("Size of: ", stringify!(_MEMORYSTATUSEX))
  );
  assert_eq!(
    ::core::mem::align_of::<_MEMORYSTATUSEX>(),
    8usize,
    concat!("Alignment of ", stringify!(_MEMORYSTATUSEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).dwLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(dwLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).dwMemoryLoad as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(dwMemoryLoad)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullTotalPhys as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullTotalPhys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullAvailPhys as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullAvailPhys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullTotalPageFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullTotalPageFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullAvailPageFile as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullAvailPageFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullTotalVirtual as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullTotalVirtual)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullAvailVirtual as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullAvailVirtual)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MEMORYSTATUSEX>())).ullAvailExtendedVirtual as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUSEX),
      "::",
      stringify!(ullAvailExtendedVirtual)
    )
  );
}
pub type MEMORYSTATUSEX = _MEMORYSTATUSEX;
pub type LPMEMORYSTATUSEX = *mut _MEMORYSTATUSEX;
extern "C" {
  pub fn GlobalMemoryStatusEx(lpBuffer: LPMEMORYSTATUSEX) -> BOOL;
}
extern "C" {
  pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
}
extern "C" {
  pub fn GetSystemTime(lpSystemTime: LPSYSTEMTIME);
}
extern "C" {
  pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
}
extern "C" {
  pub fn GetLocalTime(lpSystemTime: LPSYSTEMTIME);
}
extern "C" {
  pub fn GetVersion() -> DWORD;
}
extern "C" {
  pub fn SetLocalTime(lpSystemTime: *const SYSTEMTIME) -> BOOL;
}
extern "C" {
  pub fn GetTickCount() -> DWORD;
}
extern "C" {
  pub fn GetTickCount64() -> ULONGLONG;
}
extern "C" {
  pub fn GetSystemTimeAdjustment(
    lpTimeAdjustment: PDWORD, lpTimeIncrement: PDWORD, lpTimeAdjustmentDisabled: PBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSystemDirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn GetWindowsDirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn GetSystemWindowsDirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn GetSystemWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
pub mod _COMPUTER_NAME_FORMAT {
  pub type Type = i32;
  pub const ComputerNameNetBIOS: Type = 0;
  pub const ComputerNameDnsHostname: Type = 1;
  pub const ComputerNameDnsDomain: Type = 2;
  pub const ComputerNameDnsFullyQualified: Type = 3;
  pub const ComputerNamePhysicalNetBIOS: Type = 4;
  pub const ComputerNamePhysicalDnsHostname: Type = 5;
  pub const ComputerNamePhysicalDnsDomain: Type = 6;
  pub const ComputerNamePhysicalDnsFullyQualified: Type = 7;
  pub const ComputerNameMax: Type = 8;
}
pub use self::_COMPUTER_NAME_FORMAT::Type as COMPUTER_NAME_FORMAT;
extern "C" {
  pub fn GetComputerNameExA(
    NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPSTR, nSize: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetComputerNameExW(
    NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPWSTR, nSize: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetComputerNameExW(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn SetSystemTime(lpSystemTime: *const SYSTEMTIME) -> BOOL;
}
extern "C" {
  pub fn GetVersionExA(lpVersionInformation: LPOSVERSIONINFOA) -> BOOL;
}
extern "C" {
  pub fn GetVersionExW(lpVersionInformation: LPOSVERSIONINFOW) -> BOOL;
}
extern "C" {
  pub fn GetLogicalProcessorInformation(
    Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, ReturnedLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetLogicalProcessorInformationEx(
    RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
    Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, ReturnedLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetNativeSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
}
extern "C" {
  pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
}
extern "C" {
  pub fn GetProductInfo(
    dwOSMajorVersion: DWORD, dwOSMinorVersion: DWORD, dwSpMajorVersion: DWORD,
    dwSpMinorVersion: DWORD, pdwReturnedProductType: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetOsSafeBootMode(Flags: PDWORD) -> BOOL;
}
extern "C" {
  pub fn EnumSystemFirmwareTables(
    FirmwareTableProviderSignature: DWORD, pFirmwareTableEnumBuffer: PVOID, BufferSize: DWORD,
  ) -> UINT;
}
extern "C" {
  pub fn GetSystemFirmwareTable(
    FirmwareTableProviderSignature: DWORD, FirmwareTableID: DWORD, pFirmwareTableBuffer: PVOID,
    BufferSize: DWORD,
  ) -> UINT;
}
extern "C" {
  pub fn DnsHostnameToComputerNameExW(
    Hostname: LPCWSTR, ComputerName: LPWSTR, nSize: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPhysicallyInstalledSystemMemory(TotalMemoryInKilobytes: PULONGLONG) -> BOOL;
}
extern "C" {
  pub fn SetComputerNameEx2W(
    NameType: COMPUTER_NAME_FORMAT, Flags: DWORD, lpBuffer: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSystemTimeAdjustment(dwTimeAdjustment: DWORD, bTimeAdjustmentDisabled: BOOL) -> BOOL;
}
extern "C" {
  pub fn InstallELAMCertificateInfo(ELAMFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetProcessorSystemCycleTime(
    Group: USHORT, Buffer: PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, ReturnedLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetOsManufacturingMode(pbEnabled: PBOOL) -> BOOL;
}
extern "C" {
  pub fn GetIntegratedDisplaySize(sizeInInches: *mut f64) -> HRESULT;
}
extern "C" {
  pub fn SetComputerNameA(lpComputerName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetComputerNameW(lpComputerName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn SetComputerNameExA(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn VirtualAlloc(
    lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD,
  ) -> LPVOID;
}
extern "C" {
  pub fn VirtualProtect(
    lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD, lpflOldProtect: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn VirtualFree(lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD) -> BOOL;
}
extern "C" {
  pub fn VirtualQuery(
    lpAddress: LPCVOID, lpBuffer: PMEMORY_BASIC_INFORMATION, dwLength: SIZE_T,
  ) -> SIZE_T;
}
extern "C" {
  pub fn VirtualAllocEx(
    hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD,
  ) -> LPVOID;
}
extern "C" {
  pub fn VirtualFreeEx(
    hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn VirtualProtectEx(
    hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD,
    lpflOldProtect: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn VirtualQueryEx(
    hProcess: HANDLE, lpAddress: LPCVOID, lpBuffer: PMEMORY_BASIC_INFORMATION, dwLength: SIZE_T,
  ) -> SIZE_T;
}
extern "C" {
  pub fn ReadProcessMemory(
    hProcess: HANDLE, lpBaseAddress: LPCVOID, lpBuffer: LPVOID, nSize: SIZE_T,
    lpNumberOfBytesRead: *mut SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteProcessMemory(
    hProcess: HANDLE, lpBaseAddress: LPVOID, lpBuffer: LPCVOID, nSize: SIZE_T,
    lpNumberOfBytesWritten: *mut SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateFileMappingW(
    hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD,
    dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenFileMappingW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn MapViewOfFile(
    hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD,
    dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T,
  ) -> LPVOID;
}
extern "C" {
  pub fn MapViewOfFileEx(
    hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD,
    dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T, lpBaseAddress: LPVOID,
  ) -> LPVOID;
}
extern "C" {
  pub fn FlushViewOfFile(lpBaseAddress: LPCVOID, dwNumberOfBytesToFlush: SIZE_T) -> BOOL;
}
extern "C" {
  pub fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;
}
extern "C" {
  pub fn GetLargePageMinimum() -> SIZE_T;
}
extern "C" {
  pub fn GetProcessWorkingSetSizeEx(
    hProcess: HANDLE, lpMinimumWorkingSetSize: PSIZE_T, lpMaximumWorkingSetSize: PSIZE_T,
    Flags: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetProcessWorkingSetSizeEx(
    hProcess: HANDLE, dwMinimumWorkingSetSize: SIZE_T, dwMaximumWorkingSetSize: SIZE_T,
    Flags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn VirtualLock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;
}
extern "C" {
  pub fn VirtualUnlock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;
}
extern "C" {
  pub fn GetWriteWatch(
    dwFlags: DWORD, lpBaseAddress: PVOID, dwRegionSize: SIZE_T, lpAddresses: *mut PVOID,
    lpdwCount: *mut ULONG_PTR, lpdwGranularity: LPDWORD,
  ) -> UINT;
}
extern "C" {
  pub fn ResetWriteWatch(lpBaseAddress: LPVOID, dwRegionSize: SIZE_T) -> UINT;
}
pub mod _MEMORY_RESOURCE_NOTIFICATION_TYPE {
  pub type Type = i32;
  pub const LowMemoryResourceNotification: Type = 0;
  pub const HighMemoryResourceNotification: Type = 1;
}
pub use self::_MEMORY_RESOURCE_NOTIFICATION_TYPE::Type as MEMORY_RESOURCE_NOTIFICATION_TYPE;
extern "C" {
  pub fn CreateMemoryResourceNotification(
    NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE,
  ) -> HANDLE;
}
extern "C" {
  pub fn QueryMemoryResourceNotification(
    ResourceNotificationHandle: HANDLE, ResourceState: PBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSystemFileCacheSize(
    lpMinimumFileCacheSize: PSIZE_T, lpMaximumFileCacheSize: PSIZE_T, lpFlags: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSystemFileCacheSize(
    MinimumFileCacheSize: SIZE_T, MaximumFileCacheSize: SIZE_T, Flags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateFileMappingNumaW(
    hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD,
    dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR, nndPreferred: DWORD,
  ) -> HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _WIN32_MEMORY_RANGE_ENTRY {
  pub VirtualAddress: PVOID,
  pub NumberOfBytes: SIZE_T,
}
#[test]
fn bindgen_test_layout__WIN32_MEMORY_RANGE_ENTRY() {
  assert_eq!(
    ::core::mem::size_of::<_WIN32_MEMORY_RANGE_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_WIN32_MEMORY_RANGE_ENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<_WIN32_MEMORY_RANGE_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_WIN32_MEMORY_RANGE_ENTRY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_MEMORY_RANGE_ENTRY>())).VirtualAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_MEMORY_RANGE_ENTRY),
      "::",
      stringify!(VirtualAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_MEMORY_RANGE_ENTRY>())).NumberOfBytes as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_MEMORY_RANGE_ENTRY),
      "::",
      stringify!(NumberOfBytes)
    )
  );
}
impl Default for _WIN32_MEMORY_RANGE_ENTRY {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WIN32_MEMORY_RANGE_ENTRY = _WIN32_MEMORY_RANGE_ENTRY;
pub type PWIN32_MEMORY_RANGE_ENTRY = *mut _WIN32_MEMORY_RANGE_ENTRY;
extern "C" {
  pub fn PrefetchVirtualMemory(
    hProcess: HANDLE, NumberOfEntries: ULONG_PTR, VirtualAddresses: PWIN32_MEMORY_RANGE_ENTRY,
    Flags: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateFileMappingFromApp(
    hFile: HANDLE, SecurityAttributes: PSECURITY_ATTRIBUTES, PageProtection: ULONG,
    MaximumSize: ULONG64, Name: PCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn MapViewOfFileFromApp(
    hFileMappingObject: HANDLE, DesiredAccess: ULONG, FileOffset: ULONG64,
    NumberOfBytesToMap: SIZE_T,
  ) -> PVOID;
}
extern "C" {
  pub fn UnmapViewOfFileEx(BaseAddress: PVOID, UnmapFlags: ULONG) -> BOOL;
}
extern "C" {
  pub fn AllocateUserPhysicalPages(
    hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn FreeUserPhysicalPages(
    hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn MapUserPhysicalPages(
    VirtualAddress: PVOID, NumberOfPages: ULONG_PTR, PageArray: PULONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn AllocateUserPhysicalPagesNuma(
    hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR, nndPreferred: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn VirtualAllocExNuma(
    hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD,
    nndPreferred: DWORD,
  ) -> LPVOID;
}
extern "C" {
  pub fn GetMemoryErrorHandlingCapabilities(Capabilities: PULONG) -> BOOL;
}
pub type PBAD_MEMORY_CALLBACK_ROUTINE = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
  pub fn RegisterBadMemoryNotification(Callback: PBAD_MEMORY_CALLBACK_ROUTINE) -> PVOID;
}
extern "C" {
  pub fn UnregisterBadMemoryNotification(RegistrationHandle: PVOID) -> BOOL;
}
pub mod OFFER_PRIORITY {
  pub type Type = i32;
  pub const VmOfferPriorityVeryLow: Type = 1;
  pub const VmOfferPriorityLow: Type = 2;
  pub const VmOfferPriorityBelowNormal: Type = 3;
  pub const VmOfferPriorityNormal: Type = 4;
}
extern "C" {
  pub fn OfferVirtualMemory(
    VirtualAddress: PVOID, Size: SIZE_T, Priority: OFFER_PRIORITY::Type,
  ) -> DWORD;
}
extern "C" {
  pub fn ReclaimVirtualMemory(VirtualAddress: *const libc::c_void, Size: SIZE_T) -> DWORD;
}
extern "C" {
  pub fn DiscardVirtualMemory(VirtualAddress: PVOID, Size: SIZE_T) -> DWORD;
}
extern "C" {
  pub fn SetProcessValidCallTargets(
    hProcess: HANDLE, VirtualAddress: PVOID, RegionSize: SIZE_T, NumberOfOffsets: ULONG,
    OffsetInformation: PCFG_CALL_TARGET_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn VirtualAllocFromApp(
    BaseAddress: PVOID, Size: SIZE_T, AllocationType: ULONG, Protection: ULONG,
  ) -> PVOID;
}
extern "C" {
  pub fn VirtualProtectFromApp(
    Address: PVOID, Size: SIZE_T, NewProtection: ULONG, OldProtection: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn OpenFileMappingFromApp(DesiredAccess: ULONG, InheritHandle: BOOL, Name: PCWSTR) -> HANDLE;
}
pub mod WIN32_MEMORY_INFORMATION_CLASS {
  pub type Type = i32;
  pub const MemoryRegionInfo: Type = 0;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WIN32_MEMORY_REGION_INFORMATION {
  pub AllocationBase: PVOID,
  pub AllocationProtect: ULONG,
  pub __bindgen_anon_1: WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1,
  pub RegionSize: SIZE_T,
  pub CommitSize: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1 {
  pub Flags: ULONG,
  pub __bindgen_anon_1: WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn Private(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Private(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn MappedDataFile(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_MappedDataFile(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn MappedImage(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_MappedImage(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn MappedPageFile(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_MappedPageFile(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn MappedPhysical(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_MappedPhysical(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn DirectMapped(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_DirectMapped(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(6usize, 26u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Private: ULONG, MappedDataFile: ULONG, MappedImage: ULONG, MappedPageFile: ULONG,
    MappedPhysical: ULONG, DirectMapped: ULONG, Reserved: ULONG,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Private: u32 = unsafe { ::core::mem::transmute(Private) };
      Private as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let MappedDataFile: u32 = unsafe { ::core::mem::transmute(MappedDataFile) };
      MappedDataFile as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let MappedImage: u32 = unsafe { ::core::mem::transmute(MappedImage) };
      MappedImage as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let MappedPageFile: u32 = unsafe { ::core::mem::transmute(MappedPageFile) };
      MappedPageFile as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let MappedPhysical: u32 = unsafe { ::core::mem::transmute(MappedPhysical) };
      MappedPhysical as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let DirectMapped: u32 = unsafe { ::core::mem::transmute(DirectMapped) };
      DirectMapped as u64
    });
    __bindgen_bitfield_unit.set(6usize, 26u8, {
      let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1>())).Flags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_WIN32_MEMORY_REGION_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<WIN32_MEMORY_REGION_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(WIN32_MEMORY_REGION_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<WIN32_MEMORY_REGION_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(WIN32_MEMORY_REGION_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<WIN32_MEMORY_REGION_INFORMATION>())).AllocationBase as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION),
      "::",
      stringify!(AllocationBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<WIN32_MEMORY_REGION_INFORMATION>())).AllocationProtect as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION),
      "::",
      stringify!(AllocationProtect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<WIN32_MEMORY_REGION_INFORMATION>())).RegionSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION),
      "::",
      stringify!(RegionSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<WIN32_MEMORY_REGION_INFORMATION>())).CommitSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(WIN32_MEMORY_REGION_INFORMATION),
      "::",
      stringify!(CommitSize)
    )
  );
}
impl Default for WIN32_MEMORY_REGION_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for WIN32_MEMORY_REGION_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "WIN32_MEMORY_REGION_INFORMATION {{ AllocationBase: {:?}, AllocationProtect: {:?}, __bindgen_anon_1: {:?}, RegionSize: {:?}, CommitSize: {:?} }}" , self . AllocationBase , self . AllocationProtect , self . __bindgen_anon_1 , self . RegionSize , self . CommitSize )
  }
}
extern "C" {
  pub fn QueryVirtualMemoryInformation(
    Process: HANDLE, VirtualAddress: *const libc::c_void,
    MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS::Type, MemoryInformation: PVOID,
    MemoryInformationSize: SIZE_T, ReturnSize: PSIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE, ProcessHandle: HANDLE, Offset: ULONG64, BaseAddress: PVOID,
    ViewSize: SIZE_T, AllocationType: ULONG, PageProtection: ULONG, PreferredNode: ULONG,
  ) -> PVOID;
}
extern "C" {
  pub fn UnmapViewOfFile2(ProcessHandle: HANDLE, BaseAddress: PVOID, UnmapFlags: ULONG) -> BOOL;
}
extern "C" {
  pub fn IsEnclaveTypeSupported(flEnclaveType: DWORD) -> BOOL;
}
extern "C" {
  pub fn CreateEnclave(
    hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, dwInitialCommitment: SIZE_T,
    flEnclaveType: DWORD, lpEnclaveInformation: LPCVOID, dwInfoLength: DWORD,
    lpEnclaveError: LPDWORD,
  ) -> LPVOID;
}
extern "C" {
  pub fn LoadEnclaveData(
    hProcess: HANDLE, lpAddress: LPVOID, lpBuffer: LPCVOID, nSize: SIZE_T, flProtect: DWORD,
    lpPageInformation: LPCVOID, dwInfoLength: DWORD, lpNumberOfBytesWritten: PSIZE_T,
    lpEnclaveError: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn InitializeEnclave(
    hProcess: HANDLE, lpAddress: LPVOID, lpEnclaveInformation: LPCVOID, dwInfoLength: DWORD,
    lpEnclaveError: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LoadEnclaveImageA(lpEnclaveAddress: LPVOID, lpImageName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn LoadEnclaveImageW(lpEnclaveAddress: LPVOID, lpImageName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn CallEnclave(
    lpRoutine: LPENCLAVE_ROUTINE, lpParameter: LPVOID, fWaitForThread: BOOL,
    lpReturnValue: *mut LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn TerminateEnclave(lpAddress: LPVOID, fWait: BOOL) -> BOOL;
}
extern "C" {
  pub fn DeleteEnclave(lpAddress: LPVOID) -> BOOL;
}
extern "C" {
  pub fn QueueUserWorkItem(Function: LPTHREAD_START_ROUTINE, Context: PVOID, Flags: ULONG) -> BOOL;
}
extern "C" {
  pub fn UnregisterWaitEx(WaitHandle: HANDLE, CompletionEvent: HANDLE) -> BOOL;
}
extern "C" {
  pub fn CreateTimerQueue() -> HANDLE;
}
extern "C" {
  pub fn CreateTimerQueueTimer(
    phNewTimer: PHANDLE, TimerQueue: HANDLE, Callback: WAITORTIMERCALLBACK, Parameter: PVOID,
    DueTime: DWORD, Period: DWORD, Flags: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn ChangeTimerQueueTimer(
    TimerQueue: HANDLE, Timer: HANDLE, DueTime: ULONG, Period: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn DeleteTimerQueueTimer(TimerQueue: HANDLE, Timer: HANDLE, CompletionEvent: HANDLE) -> BOOL;
}
extern "C" {
  pub fn DeleteTimerQueueEx(TimerQueue: HANDLE, CompletionEvent: HANDLE) -> BOOL;
}
pub type PTP_WIN32_IO_CALLBACK = ::core::option::Option<
  unsafe extern "C" fn(
    Instance: PTP_CALLBACK_INSTANCE,
    Context: PVOID,
    Overlapped: PVOID,
    IoResult: ULONG,
    NumberOfBytesTransferred: ULONG_PTR,
    Io: PTP_IO,
  ),
>;
extern "C" {
  pub fn CreateThreadpool(reserved: PVOID) -> PTP_POOL;
}
extern "C" {
  pub fn SetThreadpoolThreadMaximum(ptpp: PTP_POOL, cthrdMost: DWORD);
}
extern "C" {
  pub fn SetThreadpoolThreadMinimum(ptpp: PTP_POOL, cthrdMic: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetThreadpoolStackInformation(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION) -> BOOL;
}
extern "C" {
  pub fn QueryThreadpoolStackInformation(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION)
    -> BOOL;
}
extern "C" {
  pub fn CloseThreadpool(ptpp: PTP_POOL);
}
extern "C" {
  pub fn CreateThreadpoolCleanupGroup() -> PTP_CLEANUP_GROUP;
}
extern "C" {
  pub fn CloseThreadpoolCleanupGroupMembers(
    ptpcg: PTP_CLEANUP_GROUP, fCancelPendingCallbacks: BOOL, pvCleanupContext: PVOID,
  );
}
extern "C" {
  pub fn CloseThreadpoolCleanupGroup(ptpcg: PTP_CLEANUP_GROUP);
}
extern "C" {
  pub fn SetEventWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, evt: HANDLE);
}
extern "C" {
  pub fn ReleaseSemaphoreWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, sem: HANDLE, crel: DWORD);
}
extern "C" {
  pub fn ReleaseMutexWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, mut_: HANDLE);
}
extern "C" {
  pub fn LeaveCriticalSectionWhenCallbackReturns(
    pci: PTP_CALLBACK_INSTANCE, pcs: PCRITICAL_SECTION,
  );
}
extern "C" {
  pub fn FreeLibraryWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, mod_: HMODULE);
}
extern "C" {
  pub fn CallbackMayRunLong(pci: PTP_CALLBACK_INSTANCE) -> BOOL;
}
extern "C" {
  pub fn DisassociateCurrentThreadFromCallback(pci: PTP_CALLBACK_INSTANCE);
}
extern "C" {
  pub fn TrySubmitThreadpoolCallback(
    pfns: PTP_SIMPLE_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateThreadpoolWork(
    pfnwk: PTP_WORK_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON,
  ) -> PTP_WORK;
}
extern "C" {
  pub fn SubmitThreadpoolWork(pwk: PTP_WORK);
}
extern "C" {
  pub fn WaitForThreadpoolWorkCallbacks(pwk: PTP_WORK, fCancelPendingCallbacks: BOOL);
}
extern "C" {
  pub fn CloseThreadpoolWork(pwk: PTP_WORK);
}
extern "C" {
  pub fn CreateThreadpoolTimer(
    pfnti: PTP_TIMER_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON,
  ) -> PTP_TIMER;
}
extern "C" {
  pub fn SetThreadpoolTimer(
    pti: PTP_TIMER, pftDueTime: PFILETIME, msPeriod: DWORD, msWindowLength: DWORD,
  );
}
extern "C" {
  pub fn IsThreadpoolTimerSet(pti: PTP_TIMER) -> BOOL;
}
extern "C" {
  pub fn WaitForThreadpoolTimerCallbacks(pti: PTP_TIMER, fCancelPendingCallbacks: BOOL);
}
extern "C" {
  pub fn CloseThreadpoolTimer(pti: PTP_TIMER);
}
extern "C" {
  pub fn CreateThreadpoolWait(
    pfnwa: PTP_WAIT_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON,
  ) -> PTP_WAIT;
}
extern "C" {
  pub fn SetThreadpoolWait(pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME);
}
extern "C" {
  pub fn WaitForThreadpoolWaitCallbacks(pwa: PTP_WAIT, fCancelPendingCallbacks: BOOL);
}
extern "C" {
  pub fn CloseThreadpoolWait(pwa: PTP_WAIT);
}
extern "C" {
  pub fn CreateThreadpoolIo(
    fl: HANDLE, pfnio: PTP_WIN32_IO_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON,
  ) -> PTP_IO;
}
extern "C" {
  pub fn StartThreadpoolIo(pio: PTP_IO);
}
extern "C" {
  pub fn CancelThreadpoolIo(pio: PTP_IO);
}
extern "C" {
  pub fn WaitForThreadpoolIoCallbacks(pio: PTP_IO, fCancelPendingCallbacks: BOOL);
}
extern "C" {
  pub fn CloseThreadpoolIo(pio: PTP_IO);
}
extern "C" {
  pub fn SetThreadpoolTimerEx(
    pti: PTP_TIMER, pftDueTime: PFILETIME, msPeriod: DWORD, msWindowLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadpoolWaitEx(
    pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME, Reserved: PVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn IsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE, Result: PBOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
  pub MaxIops: LONG64,
  pub MaxBandwidth: LONG64,
  pub ReservationIops: LONG64,
  pub VolumeName: PCWSTR,
  pub BaseIoSize: ULONG,
  pub ControlFlags: ULONG,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>())).MaxIops as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(MaxIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>())).MaxBandwidth as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(MaxBandwidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>())).ReservationIops as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(ReservationIops)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>())).VolumeName as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(VolumeName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>())).BaseIoSize as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(BaseIoSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION>())).ControlFlags as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION),
      "::",
      stringify!(ControlFlags)
    )
  );
}
impl Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn CreateJobObjectW(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn FreeMemoryJobObject(Buffer: *mut libc::c_void);
}
extern "C" {
  pub fn OpenJobObjectW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;
}
extern "C" {
  pub fn TerminateJobObject(hJob: HANDLE, uExitCode: UINT) -> BOOL;
}
extern "C" {
  pub fn SetInformationJobObject(
    hJob: HANDLE, JobObjectInformationClass: JOBOBJECTINFOCLASS, lpJobObjectInformation: LPVOID,
    cbJobObjectInformationLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetIoRateControlInformationJobObject(
    hJob: HANDLE, IoRateControlInfo: *mut JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
  ) -> DWORD;
}
extern "C" {
  pub fn QueryInformationJobObject(
    hJob: HANDLE, JobObjectInformationClass: JOBOBJECTINFOCLASS, lpJobObjectInformation: LPVOID,
    cbJobObjectInformationLength: DWORD, lpReturnLength: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryIoRateControlInformationJobObject(
    hJob: HANDLE, VolumeName: PCWSTR, InfoBlocks: *mut *mut JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
    InfoBlockCount: *mut ULONG,
  ) -> DWORD;
}
extern "C" {
  pub fn Wow64DisableWow64FsRedirection(OldValue: *mut PVOID) -> BOOL;
}
extern "C" {
  pub fn Wow64RevertWow64FsRedirection(OlValue: PVOID) -> BOOL;
}
extern "C" {
  pub fn IsWow64Process(hProcess: HANDLE, Wow64Process: PBOOL) -> BOOL;
}
extern "C" {
  pub fn GetSystemWow64DirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn GetSystemWow64DirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
extern "C" {
  pub fn Wow64SetThreadDefaultGuestMachine(Machine: USHORT) -> USHORT;
}
extern "C" {
  pub fn IsWow64Process2(
    hProcess: HANDLE, pProcessMachine: *mut USHORT, pNativeMachine: *mut USHORT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSystemWow64Directory2A(
    lpBuffer: LPSTR, uSize: UINT, ImageFileMachineType: WORD,
  ) -> UINT;
}
extern "C" {
  pub fn GetSystemWow64Directory2W(
    lpBuffer: LPWSTR, uSize: UINT, ImageFileMachineType: WORD,
  ) -> UINT;
}
extern "C" {
  pub fn IsWow64GuestMachineSupported(
    WowGuestMachine: USHORT, MachineIsSupported: *mut BOOL,
  ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagENUMUILANG {
  pub NumOfEnumUILang: ULONG,
  pub SizeOfEnumUIBuffer: ULONG,
  pub pEnumUIBuffer: *mut LANGID,
}
#[test]
fn bindgen_test_layout_tagENUMUILANG() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMUILANG>(),
    16usize,
    concat!("Size of: ", stringify!(tagENUMUILANG))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMUILANG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagENUMUILANG))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMUILANG>())).NumOfEnumUILang as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMUILANG),
      "::",
      stringify!(NumOfEnumUILang)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMUILANG>())).SizeOfEnumUIBuffer as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMUILANG),
      "::",
      stringify!(SizeOfEnumUIBuffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMUILANG>())).pEnumUIBuffer as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMUILANG),
      "::",
      stringify!(pEnumUIBuffer)
    )
  );
}
impl Default for tagENUMUILANG {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ENUMUILANG = tagENUMUILANG;
pub type PENUMUILANG = *mut tagENUMUILANG;
pub type ENUMRESLANGPROCA = ::core::option::Option<
  unsafe extern "C" fn(
    hModule: HMODULE,
    lpType: LPCSTR,
    lpName: LPCSTR,
    wLanguage: WORD,
    lParam: LONG_PTR,
  ) -> BOOL,
>;
pub type ENUMRESLANGPROCW = ::core::option::Option<
  unsafe extern "C" fn(
    hModule: HMODULE,
    lpType: LPCWSTR,
    lpName: LPCWSTR,
    wLanguage: WORD,
    lParam: LONG_PTR,
  ) -> BOOL,
>;
pub type ENUMRESNAMEPROCA = ::core::option::Option<
  unsafe extern "C" fn(hModule: HMODULE, lpType: LPCSTR, lpName: LPSTR, lParam: LONG_PTR) -> BOOL,
>;
pub type ENUMRESNAMEPROCW = ::core::option::Option<
  unsafe extern "C" fn(hModule: HMODULE, lpType: LPCWSTR, lpName: LPWSTR, lParam: LONG_PTR) -> BOOL,
>;
pub type ENUMRESTYPEPROCA = ::core::option::Option<
  unsafe extern "C" fn(hModule: HMODULE, lpType: LPSTR, lParam: LONG_PTR) -> BOOL,
>;
pub type ENUMRESTYPEPROCW = ::core::option::Option<
  unsafe extern "C" fn(hModule: HMODULE, lpType: LPWSTR, lParam: LONG_PTR) -> BOOL,
>;
extern "C" {
  pub fn DisableThreadLibraryCalls(hLibModule: HMODULE) -> BOOL;
}
extern "C" {
  pub fn FindResourceExW(
    hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD,
  ) -> HRSRC;
}
extern "C" {
  pub fn FindStringOrdinal(
    dwFindStringOrdinalFlags: DWORD, lpStringSource: LPCWSTR, cchSource: libc::c_int,
    lpStringValue: LPCWSTR, cchValue: libc::c_int, bIgnoreCase: BOOL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn FreeLibrary(hLibModule: HMODULE) -> BOOL;
}
extern "C" {
  pub fn FreeLibraryAndExitThread(hLibModule: HMODULE, dwExitCode: DWORD);
}
extern "C" {
  pub fn FreeResource(hResData: HGLOBAL) -> BOOL;
}
extern "C" {
  pub fn GetModuleFileNameA(hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetModuleFileNameW(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;
}
extern "C" {
  pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
}
pub type PGET_MODULE_HANDLE_EXA = ::core::option::Option<
  unsafe extern "C" fn(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: *mut HMODULE) -> BOOL,
>;
pub type PGET_MODULE_HANDLE_EXW = ::core::option::Option<
  unsafe extern "C" fn(dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: *mut HMODULE) -> BOOL,
>;
extern "C" {
  pub fn GetModuleHandleExA(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: *mut HMODULE) -> BOOL;
}
extern "C" {
  pub fn GetModuleHandleExW(dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: *mut HMODULE) -> BOOL;
}
extern "C" {
  pub fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> FARPROC;
}
extern "C" {
  pub fn LoadLibraryExA(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD) -> HMODULE;
}
extern "C" {
  pub fn LoadLibraryExW(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD) -> HMODULE;
}
extern "C" {
  pub fn LoadResource(hModule: HMODULE, hResInfo: HRSRC) -> HGLOBAL;
}
extern "C" {
  pub fn LoadStringA(
    hInstance: HINSTANCE, uID: UINT, lpBuffer: LPSTR, cchBufferMax: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn LoadStringW(
    hInstance: HINSTANCE, uID: UINT, lpBuffer: LPWSTR, cchBufferMax: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn LockResource(hResData: HGLOBAL) -> LPVOID;
}
extern "C" {
  pub fn SizeofResource(hModule: HMODULE, hResInfo: HRSRC) -> DWORD;
}
pub type DLL_DIRECTORY_COOKIE = PVOID;
pub type PDLL_DIRECTORY_COOKIE = *mut PVOID;
extern "C" {
  pub fn AddDllDirectory(NewDirectory: PCWSTR) -> DLL_DIRECTORY_COOKIE;
}
extern "C" {
  pub fn RemoveDllDirectory(Cookie: DLL_DIRECTORY_COOKIE) -> BOOL;
}
extern "C" {
  pub fn SetDefaultDllDirectories(DirectoryFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn EnumResourceLanguagesExA(
    hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA,
    lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceLanguagesExW(
    hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW,
    lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceNamesExA(
    hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR,
    dwFlags: DWORD, LangId: LANGID,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceNamesExW(
    hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR,
    dwFlags: DWORD, LangId: LANGID,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceTypesExA(
    hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR, dwFlags: DWORD,
    LangId: LANGID,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceTypesExW(
    hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR, dwFlags: DWORD,
    LangId: LANGID,
  ) -> BOOL;
}
extern "C" {
  pub fn FindResourceW(hModule: HMODULE, lpName: LPCWSTR, lpType: LPCWSTR) -> HRSRC;
}
extern "C" {
  pub fn LoadLibraryA(lpLibFileName: LPCSTR) -> HMODULE;
}
extern "C" {
  pub fn LoadLibraryW(lpLibFileName: LPCWSTR) -> HMODULE;
}
extern "C" {
  pub fn EnumResourceNamesW(
    hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheck(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD,
    GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD,
    GrantedAccess: LPDWORD, AccessStatus: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckAndAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR,
    SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD,
    GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD,
    AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByType(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, ClientToken: HANDLE,
    DesiredAccess: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD,
    GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD,
    GrantedAccess: LPDWORD, AccessStatus: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeResultList(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, ClientToken: HANDLE,
    DesiredAccess: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD,
    GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD,
    GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeAndAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR,
    SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD,
    AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST,
    ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL,
    GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeResultListAndAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR,
    SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD,
    AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST,
    ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL,
    GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCWSTR,
    ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID,
    DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD,
    ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD,
    GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccessList: LPDWORD,
    AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAccessAllowedAce(
    pAcl: PACL, dwAceRevision: DWORD, AccessMask: DWORD, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAccessAllowedAceEx(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAccessAllowedObjectAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD,
    ObjectTypeGuid: *mut GUID, InheritedObjectTypeGuid: *mut GUID, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAccessDeniedAce(
    pAcl: PACL, dwAceRevision: DWORD, AccessMask: DWORD, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAccessDeniedAceEx(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAccessDeniedObjectAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD,
    ObjectTypeGuid: *mut GUID, InheritedObjectTypeGuid: *mut GUID, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAce(
    pAcl: PACL, dwAceRevision: DWORD, dwStartingAceIndex: DWORD, pAceList: LPVOID,
    nAceListLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAuditAccessAce(
    pAcl: PACL, dwAceRevision: DWORD, dwAccessMask: DWORD, pSid: PSID, bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAuditAccessAceEx(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, dwAccessMask: DWORD, pSid: PSID,
    bAuditSuccess: BOOL, bAuditFailure: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AddAuditAccessObjectAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD,
    ObjectTypeGuid: *mut GUID, InheritedObjectTypeGuid: *mut GUID, pSid: PSID, bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AddMandatoryAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, MandatoryPolicy: DWORD, pLabelSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AddResourceAttributeAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID,
    pAttributeInfo: PCLAIM_SECURITY_ATTRIBUTES_INFORMATION, pReturnLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn AddScopedPolicyIDAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AdjustTokenGroups(
    TokenHandle: HANDLE, ResetToDefault: BOOL, NewState: PTOKEN_GROUPS, BufferLength: DWORD,
    PreviousState: PTOKEN_GROUPS, ReturnLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn AdjustTokenPrivileges(
    TokenHandle: HANDLE, DisableAllPrivileges: BOOL, NewState: PTOKEN_PRIVILEGES,
    BufferLength: DWORD, PreviousState: PTOKEN_PRIVILEGES, ReturnLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn AllocateAndInitializeSid(
    pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY, nSubAuthorityCount: BYTE,
    nSubAuthority0: DWORD, nSubAuthority1: DWORD, nSubAuthority2: DWORD, nSubAuthority3: DWORD,
    nSubAuthority4: DWORD, nSubAuthority5: DWORD, nSubAuthority6: DWORD, nSubAuthority7: DWORD,
    pSid: *mut PSID,
  ) -> BOOL;
}
extern "C" {
  pub fn AllocateLocallyUniqueId(Luid: PLUID) -> BOOL;
}
extern "C" {
  pub fn AreAllAccessesGranted(GrantedAccess: DWORD, DesiredAccess: DWORD) -> BOOL;
}
extern "C" {
  pub fn AreAnyAccessesGranted(GrantedAccess: DWORD, DesiredAccess: DWORD) -> BOOL;
}
extern "C" {
  pub fn CheckTokenMembership(TokenHandle: HANDLE, SidToCheck: PSID, IsMember: PBOOL) -> BOOL;
}
extern "C" {
  pub fn CheckTokenCapability(
    TokenHandle: HANDLE, CapabilitySidToCheck: PSID, HasCapability: PBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetAppContainerAce(
    Acl: PACL, StartingAceIndex: DWORD, AppContainerAce: *mut PVOID,
    AppContainerAceIndex: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CheckTokenMembershipEx(
    TokenHandle: HANDLE, SidToCheck: PSID, Flags: DWORD, IsMember: PBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor: PSECURITY_DESCRIPTOR, CurrentSecurityDescriptor: PSECURITY_DESCRIPTOR,
    NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR, ObjectType: *mut GUID,
    IsDirectoryObject: BOOLEAN, GenericMapping: PGENERIC_MAPPING,
  ) -> BOOL;
}
extern "C" {
  pub fn CopySid(nDestinationSidLength: DWORD, pDestinationSid: PSID, pSourceSid: PSID) -> BOOL;
}
extern "C" {
  pub fn CreatePrivateObjectSecurity(
    ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR,
    NewDescriptor: *mut PSECURITY_DESCRIPTOR, IsDirectoryObject: BOOL, Token: HANDLE,
    GenericMapping: PGENERIC_MAPPING,
  ) -> BOOL;
}
extern "C" {
  pub fn CreatePrivateObjectSecurityEx(
    ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR,
    NewDescriptor: *mut PSECURITY_DESCRIPTOR, ObjectType: *mut GUID, IsContainerObject: BOOL,
    AutoInheritFlags: ULONG, Token: HANDLE, GenericMapping: PGENERIC_MAPPING,
  ) -> BOOL;
}
extern "C" {
  pub fn CreatePrivateObjectSecurityWithMultipleInheritance(
    ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR,
    NewDescriptor: *mut PSECURITY_DESCRIPTOR, ObjectTypes: *mut *mut GUID, GuidCount: ULONG,
    IsContainerObject: BOOL, AutoInheritFlags: ULONG, Token: HANDLE,
    GenericMapping: PGENERIC_MAPPING,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateRestrictedToken(
    ExistingTokenHandle: HANDLE, Flags: DWORD, DisableSidCount: DWORD,
    SidsToDisable: PSID_AND_ATTRIBUTES, DeletePrivilegeCount: DWORD,
    PrivilegesToDelete: PLUID_AND_ATTRIBUTES, RestrictedSidCount: DWORD,
    SidsToRestrict: PSID_AND_ATTRIBUTES, NewTokenHandle: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateWellKnownSid(
    WellKnownSidType: WELL_KNOWN_SID_TYPE::Type, DomainSid: PSID, pSid: PSID, cbSid: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EqualDomainSid(pSid1: PSID, pSid2: PSID, pfEqual: *mut BOOL) -> BOOL;
}
extern "C" {
  pub fn DeleteAce(pAcl: PACL, dwAceIndex: DWORD) -> BOOL;
}
extern "C" {
  pub fn DestroyPrivateObjectSecurity(ObjectDescriptor: *mut PSECURITY_DESCRIPTOR) -> BOOL;
}
extern "C" {
  pub fn DuplicateToken(
    ExistingTokenHandle: HANDLE, ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    DuplicateTokenHandle: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn DuplicateTokenEx(
    hExistingToken: HANDLE, dwDesiredAccess: DWORD, lpTokenAttributes: LPSECURITY_ATTRIBUTES,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL, TokenType: TOKEN_TYPE, phNewToken: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn EqualPrefixSid(pSid1: PSID, pSid2: PSID) -> BOOL;
}
extern "C" {
  pub fn EqualSid(pSid1: PSID, pSid2: PSID) -> BOOL;
}
extern "C" {
  pub fn FindFirstFreeAce(pAcl: PACL, pAce: *mut LPVOID) -> BOOL;
}
extern "C" {
  pub fn FreeSid(pSid: PSID) -> PVOID;
}
extern "C" {
  pub fn GetAce(pAcl: PACL, dwAceIndex: DWORD, pAce: *mut LPVOID) -> BOOL;
}
extern "C" {
  pub fn GetAclInformation(
    pAcl: PACL, pAclInformation: LPVOID, nAclInformationLength: DWORD,
    dwAclInformationClass: ACL_INFORMATION_CLASS,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileSecurityW(
    lpFileName: LPCWSTR, RequestedInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetKernelObjectSecurity(
    Handle: HANDLE, RequestedInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetLengthSid(pSid: PSID) -> DWORD;
}
extern "C" {
  pub fn GetPrivateObjectSecurity(
    ObjectDescriptor: PSECURITY_DESCRIPTOR, SecurityInformation: SECURITY_INFORMATION,
    ResultantDescriptor: PSECURITY_DESCRIPTOR, DescriptorLength: DWORD, ReturnLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSecurityDescriptorControl(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, pControl: PSECURITY_DESCRIPTOR_CONTROL,
    lpdwRevision: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSecurityDescriptorDacl(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpbDaclPresent: LPBOOL, pDacl: *mut PACL,
    lpbDaclDefaulted: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSecurityDescriptorGroup(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, pGroup: *mut PSID, lpbGroupDefaulted: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSecurityDescriptorLength(pSecurityDescriptor: PSECURITY_DESCRIPTOR) -> DWORD;
}
extern "C" {
  pub fn GetSecurityDescriptorOwner(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, pOwner: *mut PSID, lpbOwnerDefaulted: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSecurityDescriptorRMControl(
    SecurityDescriptor: PSECURITY_DESCRIPTOR, RMControl: PUCHAR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetSecurityDescriptorSacl(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpbSaclPresent: LPBOOL, pSacl: *mut PACL,
    lpbSaclDefaulted: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSidIdentifierAuthority(pSid: PSID) -> PSID_IDENTIFIER_AUTHORITY;
}
extern "C" {
  pub fn GetSidLengthRequired(nSubAuthorityCount: UCHAR) -> DWORD;
}
extern "C" {
  pub fn GetSidSubAuthority(pSid: PSID, nSubAuthority: DWORD) -> PDWORD;
}
extern "C" {
  pub fn GetSidSubAuthorityCount(pSid: PSID) -> PUCHAR;
}
extern "C" {
  pub fn GetTokenInformation(
    TokenHandle: HANDLE, TokenInformationClass: TOKEN_INFORMATION_CLASS, TokenInformation: LPVOID,
    TokenInformationLength: DWORD, ReturnLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetWindowsAccountDomainSid(pSid: PSID, pDomainSid: PSID, cbDomainSid: *mut DWORD) -> BOOL;
}
extern "C" {
  pub fn ImpersonateAnonymousToken(ThreadHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn ImpersonateLoggedOnUser(hToken: HANDLE) -> BOOL;
}
extern "C" {
  pub fn ImpersonateSelf(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL) -> BOOL;
}
extern "C" {
  pub fn InitializeAcl(pAcl: PACL, nAclLength: DWORD, dwAclRevision: DWORD) -> BOOL;
}
extern "C" {
  pub fn InitializeSecurityDescriptor(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, dwRevision: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn InitializeSid(
    Sid: PSID, pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY, nSubAuthorityCount: BYTE,
  ) -> BOOL;
}
extern "C" {
  pub fn IsTokenRestricted(TokenHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn IsValidAcl(pAcl: PACL) -> BOOL;
}
extern "C" {
  pub fn IsValidSecurityDescriptor(pSecurityDescriptor: PSECURITY_DESCRIPTOR) -> BOOL;
}
extern "C" {
  pub fn IsValidSid(pSid: PSID) -> BOOL;
}
extern "C" {
  pub fn IsWellKnownSid(pSid: PSID, WellKnownSidType: WELL_KNOWN_SID_TYPE::Type) -> BOOL;
}
extern "C" {
  pub fn MakeAbsoluteSD(
    pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR, lpdwAbsoluteSecurityDescriptorSize: LPDWORD,
    pDacl: PACL, lpdwDaclSize: LPDWORD, pSacl: PACL, lpdwSaclSize: LPDWORD, pOwner: PSID,
    lpdwOwnerSize: LPDWORD, pPrimaryGroup: PSID, lpdwPrimaryGroupSize: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn MakeSelfRelativeSD(
    pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR, lpdwBufferLength: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn MapGenericMask(AccessMask: PDWORD, GenericMapping: PGENERIC_MAPPING);
}
extern "C" {
  pub fn ObjectCloseAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectDeleteAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectOpenAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD,
    GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: BOOL, AccessGranted: BOOL,
    GenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectPrivilegeAuditAlarmW(
    SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD,
    Privileges: PPRIVILEGE_SET, AccessGranted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn PrivilegeCheck(
    ClientToken: HANDLE, RequiredPrivileges: PPRIVILEGE_SET, pfResult: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn PrivilegedServiceAuditAlarmW(
    SubsystemName: LPCWSTR, ServiceName: LPCWSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET,
    AccessGranted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn QuerySecurityAccessMask(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD);
}
extern "C" {
  pub fn RevertToSelf() -> BOOL;
}
extern "C" {
  pub fn SetAclInformation(
    pAcl: PACL, pAclInformation: LPVOID, nAclInformationLength: DWORD,
    dwAclInformationClass: ACL_INFORMATION_CLASS,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFileSecurityW(
    lpFileName: LPCWSTR, SecurityInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
  ) -> BOOL;
}
extern "C" {
  pub fn SetKernelObjectSecurity(
    Handle: HANDLE, SecurityInformation: SECURITY_INFORMATION,
    SecurityDescriptor: PSECURITY_DESCRIPTOR,
  ) -> BOOL;
}
extern "C" {
  pub fn SetPrivateObjectSecurity(
    SecurityInformation: SECURITY_INFORMATION, ModificationDescriptor: PSECURITY_DESCRIPTOR,
    ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR, GenericMapping: PGENERIC_MAPPING,
    Token: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn SetPrivateObjectSecurityEx(
    SecurityInformation: SECURITY_INFORMATION, ModificationDescriptor: PSECURITY_DESCRIPTOR,
    ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR, AutoInheritFlags: ULONG,
    GenericMapping: PGENERIC_MAPPING, Token: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSecurityAccessMask(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD);
}
extern "C" {
  pub fn SetSecurityDescriptorControl(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, ControlBitsOfInterest: SECURITY_DESCRIPTOR_CONTROL,
    ControlBitsToSet: SECURITY_DESCRIPTOR_CONTROL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSecurityDescriptorDacl(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, bDaclPresent: BOOL, pDacl: PACL,
    bDaclDefaulted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSecurityDescriptorGroup(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, pGroup: PSID, bGroupDefaulted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSecurityDescriptorOwner(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, pOwner: PSID, bOwnerDefaulted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSecurityDescriptorRMControl(
    SecurityDescriptor: PSECURITY_DESCRIPTOR, RMControl: PUCHAR,
  ) -> DWORD;
}
extern "C" {
  pub fn SetSecurityDescriptorSacl(
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, bSaclPresent: BOOL, pSacl: PACL,
    bSaclDefaulted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetTokenInformation(
    TokenHandle: HANDLE, TokenInformationClass: TOKEN_INFORMATION_CLASS, TokenInformation: LPVOID,
    TokenInformationLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetCachedSigningLevel(
    SourceFiles: PHANDLE, SourceFileCount: ULONG, Flags: ULONG, TargetFile: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCachedSigningLevel(
    File: HANDLE, Flags: PULONG, SigningLevel: PULONG, Thumbprint: PUCHAR, ThumbprintSize: PULONG,
    ThumbprintAlgorithm: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn CveEventWrite(CveId: PCWSTR, AdditionalDetails: PCWSTR) -> LONG;
}
extern "C" {
  pub fn DeriveCapabilitySidsFromName(
    CapName: LPCWSTR, CapabilityGroupSids: *mut *mut PSID, CapabilityGroupSidCount: *mut DWORD,
    CapabilitySids: *mut *mut PSID, CapabilitySidCount: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CreatePrivateNamespaceW(
    lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID,
    lpAliasPrefix: LPCWSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenPrivateNamespaceW(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn ClosePrivateNamespace(Handle: HANDLE, Flags: ULONG) -> BOOLEAN;
}
extern "C" {
  pub fn CreateBoundaryDescriptorW(Name: LPCWSTR, Flags: ULONG) -> HANDLE;
}
extern "C" {
  pub fn AddSIDToBoundaryDescriptor(BoundaryDescriptor: *mut HANDLE, RequiredSid: PSID) -> BOOL;
}
extern "C" {
  pub fn DeleteBoundaryDescriptor(BoundaryDescriptor: HANDLE);
}
extern "C" {
  pub fn GetNumaHighestNodeNumber(HighestNodeNumber: PULONG) -> BOOL;
}
extern "C" {
  pub fn GetNumaNodeProcessorMaskEx(Node: USHORT, ProcessorMask: PGROUP_AFFINITY) -> BOOL;
}
extern "C" {
  pub fn GetNumaProximityNodeEx(ProximityId: ULONG, NodeNumber: PUSHORT) -> BOOL;
}
extern "C" {
  pub fn GetProcessGroupAffinity(
    hProcess: HANDLE, GroupCount: PUSHORT, GroupArray: PUSHORT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetThreadGroupAffinity(hThread: HANDLE, GroupAffinity: PGROUP_AFFINITY) -> BOOL;
}
extern "C" {
  pub fn SetThreadGroupAffinity(
    hThread: HANDLE, GroupAffinity: *const GROUP_AFFINITY, PreviousGroupAffinity: PGROUP_AFFINITY,
  ) -> BOOL;
}
extern "C" {
  pub fn GetAppContainerNamedObjectPath(
    Token: HANDLE, AppContainerSid: PSID, ObjectPathLength: ULONG, ObjectPath: LPWSTR,
    ReturnLength: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryThreadCycleTime(ThreadHandle: HANDLE, CycleTime: PULONG64) -> BOOL;
}
extern "C" {
  pub fn QueryProcessCycleTime(ProcessHandle: HANDLE, CycleTime: PULONG64) -> BOOL;
}
extern "C" {
  pub fn QueryIdleProcessorCycleTime(
    BufferLength: PULONG, ProcessorIdleCycleTime: PULONG64,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryIdleProcessorCycleTimeEx(
    Group: USHORT, BufferLength: PULONG, ProcessorIdleCycleTime: PULONG64,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryInterruptTimePrecise(lpInterruptTimePrecise: PULONGLONG);
}
extern "C" {
  pub fn QueryUnbiasedInterruptTimePrecise(lpUnbiasedInterruptTimePrecise: PULONGLONG);
}
extern "C" {
  pub fn QueryInterruptTime(lpInterruptTime: PULONGLONG);
}
extern "C" {
  pub fn QueryUnbiasedInterruptTime(UnbiasedTime: PULONGLONG) -> BOOL;
}
extern "C" {
  pub fn QueryAuxiliaryCounterFrequency(lpAuxiliaryCounterFrequency: PULONGLONG) -> HRESULT;
}
extern "C" {
  pub fn ConvertAuxiliaryCounterToPerformanceCounter(
    ullAuxiliaryCounterValue: ULONGLONG, lpPerformanceCounterValue: PULONGLONG,
    lpConversionError: PULONGLONG,
  ) -> HRESULT;
}
extern "C" {
  pub fn ConvertPerformanceCounterToAuxiliaryCounter(
    ullPerformanceCounterValue: ULONGLONG, lpAuxiliaryCounterValue: PULONGLONG,
    lpConversionError: PULONGLONG,
  ) -> HRESULT;
}
pub type PFIBER_START_ROUTINE =
  ::core::option::Option<unsafe extern "C" fn(lpFiberParameter: LPVOID)>;
pub type LPFIBER_START_ROUTINE = PFIBER_START_ROUTINE;
pub type PFIBER_CALLOUT_ROUTINE =
  ::core::option::Option<unsafe extern "C" fn(lpParameter: LPVOID) -> LPVOID>;
pub type LPLDT_ENTRY = LPVOID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _COMMPROP {
  pub wPacketLength: WORD,
  pub wPacketVersion: WORD,
  pub dwServiceMask: DWORD,
  pub dwReserved1: DWORD,
  pub dwMaxTxQueue: DWORD,
  pub dwMaxRxQueue: DWORD,
  pub dwMaxBaud: DWORD,
  pub dwProvSubType: DWORD,
  pub dwProvCapabilities: DWORD,
  pub dwSettableParams: DWORD,
  pub dwSettableBaud: DWORD,
  pub wSettableData: WORD,
  pub wSettableStopParity: WORD,
  pub dwCurrentTxQueue: DWORD,
  pub dwCurrentRxQueue: DWORD,
  pub dwProvSpec1: DWORD,
  pub dwProvSpec2: DWORD,
  pub wcProvChar: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__COMMPROP() {
  assert_eq!(
    ::core::mem::size_of::<_COMMPROP>(),
    64usize,
    concat!("Size of: ", stringify!(_COMMPROP))
  );
  assert_eq!(
    ::core::mem::align_of::<_COMMPROP>(),
    4usize,
    concat!("Alignment of ", stringify!(_COMMPROP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).wPacketLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(wPacketLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).wPacketVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(wPacketVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwServiceMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwServiceMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwReserved1 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwMaxTxQueue as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwMaxTxQueue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwMaxRxQueue as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwMaxRxQueue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwMaxBaud as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwMaxBaud)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwProvSubType as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwProvSubType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwProvCapabilities as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwProvCapabilities)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwSettableParams as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwSettableParams)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwSettableBaud as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwSettableBaud)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).wSettableData as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(wSettableData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).wSettableStopParity as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(wSettableStopParity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwCurrentTxQueue as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwCurrentTxQueue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwCurrentRxQueue as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwCurrentRxQueue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwProvSpec1 as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwProvSpec1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).dwProvSpec2 as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(dwProvSpec2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMPROP>())).wcProvChar as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMPROP),
      "::",
      stringify!(wcProvChar)
    )
  );
}
pub type COMMPROP = _COMMPROP;
pub type LPCOMMPROP = *mut _COMMPROP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _COMSTAT {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
  pub cbInQue: DWORD,
  pub cbOutQue: DWORD,
}
#[test]
fn bindgen_test_layout__COMSTAT() {
  assert_eq!(
    ::core::mem::size_of::<_COMSTAT>(),
    12usize,
    concat!("Size of: ", stringify!(_COMSTAT))
  );
  assert_eq!(
    ::core::mem::align_of::<_COMSTAT>(),
    4usize,
    concat!("Alignment of ", stringify!(_COMSTAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMSTAT>())).cbInQue as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMSTAT),
      "::",
      stringify!(cbInQue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMSTAT>())).cbOutQue as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMSTAT),
      "::",
      stringify!(cbOutQue)
    )
  );
}
impl _COMSTAT {
  #[inline]
  pub fn fCtsHold(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fCtsHold(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fDsrHold(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fDsrHold(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fRlsdHold(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fRlsdHold(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fXoffHold(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fXoffHold(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fXoffSent(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fXoffSent(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fEof(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fEof(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fTxim(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fTxim(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(6usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fReserved(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
  }
  #[inline]
  pub fn set_fReserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(7usize, 25u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    fCtsHold: DWORD, fDsrHold: DWORD, fRlsdHold: DWORD, fXoffHold: DWORD, fXoffSent: DWORD,
    fEof: DWORD, fTxim: DWORD, fReserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let fCtsHold: u32 = unsafe { ::core::mem::transmute(fCtsHold) };
      fCtsHold as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let fDsrHold: u32 = unsafe { ::core::mem::transmute(fDsrHold) };
      fDsrHold as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let fRlsdHold: u32 = unsafe { ::core::mem::transmute(fRlsdHold) };
      fRlsdHold as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let fXoffHold: u32 = unsafe { ::core::mem::transmute(fXoffHold) };
      fXoffHold as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let fXoffSent: u32 = unsafe { ::core::mem::transmute(fXoffSent) };
      fXoffSent as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let fEof: u32 = unsafe { ::core::mem::transmute(fEof) };
      fEof as u64
    });
    __bindgen_bitfield_unit.set(6usize, 1u8, {
      let fTxim: u32 = unsafe { ::core::mem::transmute(fTxim) };
      fTxim as u64
    });
    __bindgen_bitfield_unit.set(7usize, 25u8, {
      let fReserved: u32 = unsafe { ::core::mem::transmute(fReserved) };
      fReserved as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type COMSTAT = _COMSTAT;
pub type LPCOMSTAT = *mut _COMSTAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _DCB {
  pub DCBlength: DWORD,
  pub BaudRate: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
  pub wReserved: WORD,
  pub XonLim: WORD,
  pub XoffLim: WORD,
  pub ByteSize: BYTE,
  pub Parity: BYTE,
  pub StopBits: BYTE,
  pub XonChar: libc::c_char,
  pub XoffChar: libc::c_char,
  pub ErrorChar: libc::c_char,
  pub EofChar: libc::c_char,
  pub EvtChar: libc::c_char,
  pub wReserved1: WORD,
}
#[test]
fn bindgen_test_layout__DCB() {
  assert_eq!(
    ::core::mem::size_of::<_DCB>(),
    28usize,
    concat!("Size of: ", stringify!(_DCB))
  );
  assert_eq!(
    ::core::mem::align_of::<_DCB>(),
    4usize,
    concat!("Alignment of ", stringify!(_DCB))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).DCBlength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(DCBlength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).BaudRate as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(BaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).wReserved as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(wReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).XonLim as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(XonLim)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).XoffLim as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(XoffLim)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).ByteSize as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(ByteSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).Parity as *const _ as usize },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(Parity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).StopBits as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(StopBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).XonChar as *const _ as usize },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(XonChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).XoffChar as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(XoffChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).ErrorChar as *const _ as usize },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(ErrorChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).EofChar as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(EofChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).EvtChar as *const _ as usize },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(EvtChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DCB>())).wReserved1 as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_DCB),
      "::",
      stringify!(wReserved1)
    )
  );
}
impl _DCB {
  #[inline]
  pub fn fBinary(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fBinary(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fParity(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fParity(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fOutxCtsFlow(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fOutxCtsFlow(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fOutxDsrFlow(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fOutxDsrFlow(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fDtrControl(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
  }
  #[inline]
  pub fn set_fDtrControl(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(4usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn fDsrSensitivity(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fDsrSensitivity(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(6usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fTXContinueOnXoff(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fTXContinueOnXoff(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(7usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fOutX(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fOutX(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(8usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fInX(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fInX(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(9usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fErrorChar(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fErrorChar(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(10usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fNull(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fNull(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(11usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fRtsControl(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
  }
  #[inline]
  pub fn set_fRtsControl(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(12usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn fAbortOnError(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fAbortOnError(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(14usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fDummy2(&self) -> DWORD {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
  }
  #[inline]
  pub fn set_fDummy2(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(15usize, 17u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    fBinary: DWORD, fParity: DWORD, fOutxCtsFlow: DWORD, fOutxDsrFlow: DWORD, fDtrControl: DWORD,
    fDsrSensitivity: DWORD, fTXContinueOnXoff: DWORD, fOutX: DWORD, fInX: DWORD, fErrorChar: DWORD,
    fNull: DWORD, fRtsControl: DWORD, fAbortOnError: DWORD, fDummy2: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let fBinary: u32 = unsafe { ::core::mem::transmute(fBinary) };
      fBinary as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let fParity: u32 = unsafe { ::core::mem::transmute(fParity) };
      fParity as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let fOutxCtsFlow: u32 = unsafe { ::core::mem::transmute(fOutxCtsFlow) };
      fOutxCtsFlow as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let fOutxDsrFlow: u32 = unsafe { ::core::mem::transmute(fOutxDsrFlow) };
      fOutxDsrFlow as u64
    });
    __bindgen_bitfield_unit.set(4usize, 2u8, {
      let fDtrControl: u32 = unsafe { ::core::mem::transmute(fDtrControl) };
      fDtrControl as u64
    });
    __bindgen_bitfield_unit.set(6usize, 1u8, {
      let fDsrSensitivity: u32 = unsafe { ::core::mem::transmute(fDsrSensitivity) };
      fDsrSensitivity as u64
    });
    __bindgen_bitfield_unit.set(7usize, 1u8, {
      let fTXContinueOnXoff: u32 = unsafe { ::core::mem::transmute(fTXContinueOnXoff) };
      fTXContinueOnXoff as u64
    });
    __bindgen_bitfield_unit.set(8usize, 1u8, {
      let fOutX: u32 = unsafe { ::core::mem::transmute(fOutX) };
      fOutX as u64
    });
    __bindgen_bitfield_unit.set(9usize, 1u8, {
      let fInX: u32 = unsafe { ::core::mem::transmute(fInX) };
      fInX as u64
    });
    __bindgen_bitfield_unit.set(10usize, 1u8, {
      let fErrorChar: u32 = unsafe { ::core::mem::transmute(fErrorChar) };
      fErrorChar as u64
    });
    __bindgen_bitfield_unit.set(11usize, 1u8, {
      let fNull: u32 = unsafe { ::core::mem::transmute(fNull) };
      fNull as u64
    });
    __bindgen_bitfield_unit.set(12usize, 2u8, {
      let fRtsControl: u32 = unsafe { ::core::mem::transmute(fRtsControl) };
      fRtsControl as u64
    });
    __bindgen_bitfield_unit.set(14usize, 1u8, {
      let fAbortOnError: u32 = unsafe { ::core::mem::transmute(fAbortOnError) };
      fAbortOnError as u64
    });
    __bindgen_bitfield_unit.set(15usize, 17u8, {
      let fDummy2: u32 = unsafe { ::core::mem::transmute(fDummy2) };
      fDummy2 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type DCB = _DCB;
pub type LPDCB = *mut _DCB;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _COMMTIMEOUTS {
  pub ReadIntervalTimeout: DWORD,
  pub ReadTotalTimeoutMultiplier: DWORD,
  pub ReadTotalTimeoutConstant: DWORD,
  pub WriteTotalTimeoutMultiplier: DWORD,
  pub WriteTotalTimeoutConstant: DWORD,
}
#[test]
fn bindgen_test_layout__COMMTIMEOUTS() {
  assert_eq!(
    ::core::mem::size_of::<_COMMTIMEOUTS>(),
    20usize,
    concat!("Size of: ", stringify!(_COMMTIMEOUTS))
  );
  assert_eq!(
    ::core::mem::align_of::<_COMMTIMEOUTS>(),
    4usize,
    concat!("Alignment of ", stringify!(_COMMTIMEOUTS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMTIMEOUTS>())).ReadIntervalTimeout as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMTIMEOUTS),
      "::",
      stringify!(ReadIntervalTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_COMMTIMEOUTS>())).ReadTotalTimeoutMultiplier as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMTIMEOUTS),
      "::",
      stringify!(ReadTotalTimeoutMultiplier)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_COMMTIMEOUTS>())).ReadTotalTimeoutConstant as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMTIMEOUTS),
      "::",
      stringify!(ReadTotalTimeoutConstant)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_COMMTIMEOUTS>())).WriteTotalTimeoutMultiplier as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMTIMEOUTS),
      "::",
      stringify!(WriteTotalTimeoutMultiplier)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_COMMTIMEOUTS>())).WriteTotalTimeoutConstant as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMTIMEOUTS),
      "::",
      stringify!(WriteTotalTimeoutConstant)
    )
  );
}
pub type COMMTIMEOUTS = _COMMTIMEOUTS;
pub type LPCOMMTIMEOUTS = *mut _COMMTIMEOUTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _COMMCONFIG {
  pub dwSize: DWORD,
  pub wVersion: WORD,
  pub wReserved: WORD,
  pub dcb: DCB,
  pub dwProviderSubType: DWORD,
  pub dwProviderOffset: DWORD,
  pub dwProviderSize: DWORD,
  pub wcProviderData: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__COMMCONFIG() {
  assert_eq!(
    ::core::mem::size_of::<_COMMCONFIG>(),
    52usize,
    concat!("Size of: ", stringify!(_COMMCONFIG))
  );
  assert_eq!(
    ::core::mem::align_of::<_COMMCONFIG>(),
    4usize,
    concat!("Alignment of ", stringify!(_COMMCONFIG))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).wVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(wVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).wReserved as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(wReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).dcb as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(dcb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).dwProviderSubType as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(dwProviderSubType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).dwProviderOffset as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(dwProviderOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).dwProviderSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(dwProviderSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COMMCONFIG>())).wcProviderData as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMMCONFIG),
      "::",
      stringify!(wcProviderData)
    )
  );
}
pub type COMMCONFIG = _COMMCONFIG;
pub type LPCOMMCONFIG = *mut _COMMCONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MEMORYSTATUS {
  pub dwLength: DWORD,
  pub dwMemoryLoad: DWORD,
  pub dwTotalPhys: SIZE_T,
  pub dwAvailPhys: SIZE_T,
  pub dwTotalPageFile: SIZE_T,
  pub dwAvailPageFile: SIZE_T,
  pub dwTotalVirtual: SIZE_T,
  pub dwAvailVirtual: SIZE_T,
}
#[test]
fn bindgen_test_layout__MEMORYSTATUS() {
  assert_eq!(
    ::core::mem::size_of::<_MEMORYSTATUS>(),
    56usize,
    concat!("Size of: ", stringify!(_MEMORYSTATUS))
  );
  assert_eq!(
    ::core::mem::align_of::<_MEMORYSTATUS>(),
    8usize,
    concat!("Alignment of ", stringify!(_MEMORYSTATUS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwMemoryLoad as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwMemoryLoad)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwTotalPhys as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwTotalPhys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwAvailPhys as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwAvailPhys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwTotalPageFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwTotalPageFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwAvailPageFile as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwAvailPageFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwTotalVirtual as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwTotalVirtual)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MEMORYSTATUS>())).dwAvailVirtual as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MEMORYSTATUS),
      "::",
      stringify!(dwAvailVirtual)
    )
  );
}
pub type MEMORYSTATUS = _MEMORYSTATUS;
pub type LPMEMORYSTATUS = *mut _MEMORYSTATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _JIT_DEBUG_INFO {
  pub dwSize: DWORD,
  pub dwProcessorArchitecture: DWORD,
  pub dwThreadID: DWORD,
  pub dwReserved0: DWORD,
  pub lpExceptionAddress: ULONG64,
  pub lpExceptionRecord: ULONG64,
  pub lpContextRecord: ULONG64,
}
#[test]
fn bindgen_test_layout__JIT_DEBUG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_JIT_DEBUG_INFO>(),
    40usize,
    concat!("Size of: ", stringify!(_JIT_DEBUG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_JIT_DEBUG_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_JIT_DEBUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).dwProcessorArchitecture as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(dwProcessorArchitecture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).dwThreadID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(dwThreadID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).dwReserved0 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(dwReserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).lpExceptionAddress as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(lpExceptionAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).lpExceptionRecord as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(lpExceptionRecord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_JIT_DEBUG_INFO>())).lpContextRecord as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_JIT_DEBUG_INFO),
      "::",
      stringify!(lpContextRecord)
    )
  );
}
pub type JIT_DEBUG_INFO = _JIT_DEBUG_INFO;
pub type LPJIT_DEBUG_INFO = *mut _JIT_DEBUG_INFO;
pub type JIT_DEBUG_INFO32 = JIT_DEBUG_INFO;
pub type LPJIT_DEBUG_INFO32 = *mut JIT_DEBUG_INFO;
pub type JIT_DEBUG_INFO64 = JIT_DEBUG_INFO;
pub type LPJIT_DEBUG_INFO64 = *mut JIT_DEBUG_INFO;
pub type LPEXCEPTION_RECORD = PEXCEPTION_RECORD;
pub type LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OFSTRUCT {
  pub cBytes: BYTE,
  pub fFixedDisk: BYTE,
  pub nErrCode: WORD,
  pub Reserved1: WORD,
  pub Reserved2: WORD,
  pub szPathName: [CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OFSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<_OFSTRUCT>(),
    136usize,
    concat!("Size of: ", stringify!(_OFSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<_OFSTRUCT>(),
    2usize,
    concat!("Alignment of ", stringify!(_OFSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OFSTRUCT>())).cBytes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OFSTRUCT),
      "::",
      stringify!(cBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OFSTRUCT>())).fFixedDisk as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_OFSTRUCT),
      "::",
      stringify!(fFixedDisk)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OFSTRUCT>())).nErrCode as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_OFSTRUCT),
      "::",
      stringify!(nErrCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OFSTRUCT>())).Reserved1 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OFSTRUCT),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OFSTRUCT>())).Reserved2 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_OFSTRUCT),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OFSTRUCT>())).szPathName as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OFSTRUCT),
      "::",
      stringify!(szPathName)
    )
  );
}
impl Default for _OFSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _OFSTRUCT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_OFSTRUCT {{ cBytes: {:?}, fFixedDisk: {:?}, nErrCode: {:?}, Reserved1: {:?}, Reserved2: {:?}, szPathName: [...] }}" , self . cBytes , self . fFixedDisk , self . nErrCode , self . Reserved1 , self . Reserved2 )
  }
}
impl ::core::cmp::PartialEq for _OFSTRUCT {
  fn eq(&self, other: &_OFSTRUCT) -> bool {
    self.cBytes == other.cBytes
      && self.fFixedDisk == other.fFixedDisk
      && self.nErrCode == other.nErrCode
      && self.Reserved1 == other.Reserved1
      && self.Reserved2 == other.Reserved2
      && &self.szPathName[..] == &other.szPathName[..]
  }
}
pub type OFSTRUCT = _OFSTRUCT;
pub type LPOFSTRUCT = *mut _OFSTRUCT;
pub type POFSTRUCT = *mut _OFSTRUCT;
extern "C" {
  pub fn WinMain(
    hInstance: HINSTANCE, hPrevInstance: HINSTANCE, lpCmdLine: LPSTR, nShowCmd: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wWinMain(
    hInstance: HINSTANCE, hPrevInstance: HINSTANCE, lpCmdLine: LPWSTR, nShowCmd: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GlobalAlloc(uFlags: UINT, dwBytes: SIZE_T) -> HGLOBAL;
}
extern "C" {
  pub fn GlobalReAlloc(hMem: HGLOBAL, dwBytes: SIZE_T, uFlags: UINT) -> HGLOBAL;
}
extern "C" {
  pub fn GlobalSize(hMem: HGLOBAL) -> SIZE_T;
}
extern "C" {
  pub fn GlobalUnlock(hMem: HGLOBAL) -> BOOL;
}
extern "C" {
  pub fn GlobalLock(hMem: HGLOBAL) -> LPVOID;
}
extern "C" {
  pub fn GlobalFlags(hMem: HGLOBAL) -> UINT;
}
extern "C" {
  pub fn GlobalHandle(pMem: LPCVOID) -> HGLOBAL;
}
extern "C" {
  pub fn GlobalFree(hMem: HGLOBAL) -> HGLOBAL;
}
extern "C" {
  pub fn GlobalCompact(dwMinFree: DWORD) -> SIZE_T;
}
extern "C" {
  pub fn GlobalFix(hMem: HGLOBAL);
}
extern "C" {
  pub fn GlobalUnfix(hMem: HGLOBAL);
}
extern "C" {
  pub fn GlobalWire(hMem: HGLOBAL) -> LPVOID;
}
extern "C" {
  pub fn GlobalUnWire(hMem: HGLOBAL) -> BOOL;
}
extern "C" {
  pub fn GlobalMemoryStatus(lpBuffer: LPMEMORYSTATUS);
}
extern "C" {
  pub fn LocalAlloc(uFlags: UINT, uBytes: SIZE_T) -> HLOCAL;
}
extern "C" {
  pub fn LocalReAlloc(hMem: HLOCAL, uBytes: SIZE_T, uFlags: UINT) -> HLOCAL;
}
extern "C" {
  pub fn LocalLock(hMem: HLOCAL) -> LPVOID;
}
extern "C" {
  pub fn LocalHandle(pMem: LPCVOID) -> HLOCAL;
}
extern "C" {
  pub fn LocalUnlock(hMem: HLOCAL) -> BOOL;
}
extern "C" {
  pub fn LocalSize(hMem: HLOCAL) -> SIZE_T;
}
extern "C" {
  pub fn LocalFlags(hMem: HLOCAL) -> UINT;
}
extern "C" {
  pub fn LocalFree(hMem: HLOCAL) -> HLOCAL;
}
extern "C" {
  pub fn LocalShrink(hMem: HLOCAL, cbNewSize: UINT) -> SIZE_T;
}
extern "C" {
  pub fn LocalCompact(uMinFree: UINT) -> SIZE_T;
}
extern "C" {
  pub fn GetBinaryTypeA(lpApplicationName: LPCSTR, lpBinaryType: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetBinaryTypeW(lpApplicationName: LPCWSTR, lpBinaryType: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetShortPathNameA(lpszLongPath: LPCSTR, lpszShortPath: LPSTR, cchBuffer: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetLongPathNameTransactedA(
    lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD, hTransaction: HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn GetLongPathNameTransactedW(
    lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD, hTransaction: HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn GetProcessAffinityMask(
    hProcess: HANDLE, lpProcessAffinityMask: PDWORD_PTR, lpSystemAffinityMask: PDWORD_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn SetProcessAffinityMask(hProcess: HANDLE, dwProcessAffinityMask: DWORD_PTR) -> BOOL;
}
extern "C" {
  pub fn GetProcessIoCounters(hProcess: HANDLE, lpIoCounters: PIO_COUNTERS) -> BOOL;
}
extern "C" {
  pub fn GetProcessWorkingSetSize(
    hProcess: HANDLE, lpMinimumWorkingSetSize: PSIZE_T, lpMaximumWorkingSetSize: PSIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn SetProcessWorkingSetSize(
    hProcess: HANDLE, dwMinimumWorkingSetSize: SIZE_T, dwMaximumWorkingSetSize: SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn FatalExit(ExitCode: libc::c_int);
}
extern "C" {
  pub fn SetEnvironmentStringsA(NewEnvironment: LPCH) -> BOOL;
}
extern "C" {
  pub fn SwitchToFiber(lpFiber: LPVOID);
}
extern "C" {
  pub fn DeleteFiber(lpFiber: LPVOID);
}
extern "C" {
  pub fn ConvertFiberToThread() -> BOOL;
}
extern "C" {
  pub fn CreateFiberEx(
    dwStackCommitSize: SIZE_T, dwStackReserveSize: SIZE_T, dwFlags: DWORD,
    lpStartAddress: LPFIBER_START_ROUTINE, lpParameter: LPVOID,
  ) -> LPVOID;
}
extern "C" {
  pub fn ConvertThreadToFiberEx(lpParameter: LPVOID, dwFlags: DWORD) -> LPVOID;
}
extern "C" {
  pub fn CreateFiber(
    dwStackSize: SIZE_T, lpStartAddress: LPFIBER_START_ROUTINE, lpParameter: LPVOID,
  ) -> LPVOID;
}
extern "C" {
  pub fn ConvertThreadToFiber(lpParameter: LPVOID) -> LPVOID;
}
pub type PUMS_CONTEXT = *mut libc::c_void;
pub type PUMS_COMPLETION_LIST = *mut libc::c_void;
pub use self::_RTL_UMS_THREAD_INFO_CLASS::Type as UMS_THREAD_INFO_CLASS;
pub type PUMS_THREAD_INFO_CLASS = *mut _RTL_UMS_THREAD_INFO_CLASS::Type;
pub use self::_RTL_UMS_SCHEDULER_REASON::Type as UMS_SCHEDULER_REASON;
pub type PUMS_SCHEDULER_ENTRY_POINT = PRTL_UMS_SCHEDULER_ENTRY_POINT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UMS_SCHEDULER_STARTUP_INFO {
  pub UmsVersion: ULONG,
  pub CompletionList: PUMS_COMPLETION_LIST,
  pub SchedulerProc: PUMS_SCHEDULER_ENTRY_POINT,
  pub SchedulerParam: PVOID,
}
#[test]
fn bindgen_test_layout__UMS_SCHEDULER_STARTUP_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_UMS_SCHEDULER_STARTUP_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_UMS_SCHEDULER_STARTUP_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_UMS_SCHEDULER_STARTUP_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_UMS_SCHEDULER_STARTUP_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_SCHEDULER_STARTUP_INFO>())).UmsVersion as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_SCHEDULER_STARTUP_INFO),
      "::",
      stringify!(UmsVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_SCHEDULER_STARTUP_INFO>())).CompletionList as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_SCHEDULER_STARTUP_INFO),
      "::",
      stringify!(CompletionList)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_SCHEDULER_STARTUP_INFO>())).SchedulerProc as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_SCHEDULER_STARTUP_INFO),
      "::",
      stringify!(SchedulerProc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_SCHEDULER_STARTUP_INFO>())).SchedulerParam as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_SCHEDULER_STARTUP_INFO),
      "::",
      stringify!(SchedulerParam)
    )
  );
}
impl Default for _UMS_SCHEDULER_STARTUP_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UMS_SCHEDULER_STARTUP_INFO = _UMS_SCHEDULER_STARTUP_INFO;
pub type PUMS_SCHEDULER_STARTUP_INFO = *mut _UMS_SCHEDULER_STARTUP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _UMS_SYSTEM_THREAD_INFORMATION {
  pub UmsVersion: ULONG,
  pub __bindgen_anon_1: _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1 {
  pub __bindgen_anon_1: _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  pub ThreadUmsFlags: ULONG,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn IsUmsSchedulerThread(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_IsUmsSchedulerThread(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn IsUmsWorkerThread(&self) -> ULONG {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_IsUmsWorkerThread(&mut self, val: ULONG) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    IsUmsSchedulerThread: ULONG, IsUmsWorkerThread: ULONG,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let IsUmsSchedulerThread: u32 = unsafe { ::core::mem::transmute(IsUmsSchedulerThread) };
      IsUmsSchedulerThread as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let IsUmsWorkerThread: u32 = unsafe { ::core::mem::transmute(IsUmsWorkerThread) };
      IsUmsWorkerThread as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1>())).ThreadUmsFlags
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(ThreadUmsFlags)
    )
  );
}
impl Default for _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__UMS_SYSTEM_THREAD_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_UMS_SYSTEM_THREAD_INFORMATION>(),
    8usize,
    concat!("Size of: ", stringify!(_UMS_SYSTEM_THREAD_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_UMS_SYSTEM_THREAD_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_UMS_SYSTEM_THREAD_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UMS_SYSTEM_THREAD_INFORMATION>())).UmsVersion as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UMS_SYSTEM_THREAD_INFORMATION),
      "::",
      stringify!(UmsVersion)
    )
  );
}
impl Default for _UMS_SYSTEM_THREAD_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _UMS_SYSTEM_THREAD_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_UMS_SYSTEM_THREAD_INFORMATION {{ UmsVersion: {:?}, __bindgen_anon_1: {:?} }}",
      self.UmsVersion, self.__bindgen_anon_1
    )
  }
}
pub type UMS_SYSTEM_THREAD_INFORMATION = _UMS_SYSTEM_THREAD_INFORMATION;
pub type PUMS_SYSTEM_THREAD_INFORMATION = *mut _UMS_SYSTEM_THREAD_INFORMATION;
extern "C" {
  pub fn CreateUmsCompletionList(UmsCompletionList: *mut PUMS_COMPLETION_LIST) -> BOOL;
}
extern "C" {
  pub fn DequeueUmsCompletionListItems(
    UmsCompletionList: PUMS_COMPLETION_LIST, WaitTimeOut: DWORD, UmsThreadList: *mut PUMS_CONTEXT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUmsCompletionListEvent(
    UmsCompletionList: PUMS_COMPLETION_LIST, UmsCompletionEvent: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn ExecuteUmsThread(UmsThread: PUMS_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn UmsThreadYield(SchedulerParam: PVOID) -> BOOL;
}
extern "C" {
  pub fn DeleteUmsCompletionList(UmsCompletionList: PUMS_COMPLETION_LIST) -> BOOL;
}
extern "C" {
  pub fn GetCurrentUmsThread() -> PUMS_CONTEXT;
}
extern "C" {
  pub fn GetNextUmsListItem(UmsContext: PUMS_CONTEXT) -> PUMS_CONTEXT;
}
extern "C" {
  pub fn QueryUmsThreadInformation(
    UmsThread: PUMS_CONTEXT, UmsThreadInfoClass: UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: PVOID, UmsThreadInformationLength: ULONG, ReturnLength: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetUmsThreadInformation(
    UmsThread: PUMS_CONTEXT, UmsThreadInfoClass: UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: PVOID, UmsThreadInformationLength: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn DeleteUmsThreadContext(UmsThread: PUMS_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn CreateUmsThreadContext(lpUmsThread: *mut PUMS_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn EnterUmsSchedulingMode(SchedulerStartupInfo: PUMS_SCHEDULER_STARTUP_INFO) -> BOOL;
}
extern "C" {
  pub fn GetUmsSystemThreadInformation(
    ThreadHandle: HANDLE, SystemThreadInfo: PUMS_SYSTEM_THREAD_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadAffinityMask(hThread: HANDLE, dwThreadAffinityMask: DWORD_PTR) -> DWORD_PTR;
}
extern "C" {
  pub fn SetProcessDEPPolicy(dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetProcessDEPPolicy(hProcess: HANDLE, lpFlags: LPDWORD, lpPermanent: PBOOL) -> BOOL;
}
extern "C" {
  pub fn RequestWakeupLatency(latency: LATENCY_TIME::Type) -> BOOL;
}
extern "C" {
  pub fn IsSystemResumeAutomatic() -> BOOL;
}
extern "C" {
  pub fn GetThreadSelectorEntry(
    hThread: HANDLE, dwSelector: DWORD, lpSelectorEntry: LPLDT_ENTRY,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadExecutionState(esFlags: EXECUTION_STATE) -> EXECUTION_STATE;
}
pub type POWER_REQUEST_CONTEXT = REASON_CONTEXT;
pub type PPOWER_REQUEST_CONTEXT = *mut REASON_CONTEXT;
pub type LPPOWER_REQUEST_CONTEXT = *mut REASON_CONTEXT;
extern "C" {
  pub fn PowerCreateRequest(Context: PREASON_CONTEXT) -> HANDLE;
}
extern "C" {
  pub fn PowerSetRequest(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE) -> BOOL;
}
extern "C" {
  pub fn PowerClearRequest(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE) -> BOOL;
}
extern "C" {
  pub fn SetFileCompletionNotificationModes(FileHandle: HANDLE, Flags: UCHAR) -> BOOL;
}
extern "C" {
  pub fn Wow64GetThreadContext(hThread: HANDLE, lpContext: PWOW64_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn Wow64SetThreadContext(hThread: HANDLE, lpContext: *const WOW64_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn Wow64GetThreadSelectorEntry(
    hThread: HANDLE, dwSelector: DWORD, lpSelectorEntry: PWOW64_LDT_ENTRY,
  ) -> BOOL;
}
extern "C" {
  pub fn Wow64SuspendThread(hThread: HANDLE) -> DWORD;
}
extern "C" {
  pub fn DebugSetProcessKillOnExit(KillOnExit: BOOL) -> BOOL;
}
extern "C" {
  pub fn DebugBreakProcess(Process: HANDLE) -> BOOL;
}
extern "C" {
  pub fn PulseEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GlobalDeleteAtom(nAtom: ATOM) -> ATOM;
}
extern "C" {
  pub fn InitAtomTable(nSize: DWORD) -> BOOL;
}
extern "C" {
  pub fn DeleteAtom(nAtom: ATOM) -> ATOM;
}
extern "C" {
  pub fn SetHandleCount(uNumber: UINT) -> UINT;
}
extern "C" {
  pub fn RequestDeviceWakeup(hDevice: HANDLE) -> BOOL;
}
extern "C" {
  pub fn CancelDeviceWakeupRequest(hDevice: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetDevicePowerState(hDevice: HANDLE, pfOn: *mut BOOL) -> BOOL;
}
extern "C" {
  pub fn SetMessageWaitingIndicator(hMsgIndicator: HANDLE, ulMsgCount: ULONG) -> BOOL;
}
extern "C" {
  pub fn SetFileShortNameA(hFile: HANDLE, lpShortName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetFileShortNameW(hFile: HANDLE, lpShortName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn LoadModule(lpModuleName: LPCSTR, lpParameterBlock: LPVOID) -> DWORD;
}
extern "C" {
  pub fn WinExec(lpCmdLine: LPCSTR, uCmdShow: UINT) -> UINT;
}
extern "C" {
  pub fn ClearCommBreak(hFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn ClearCommError(hFile: HANDLE, lpErrors: LPDWORD, lpStat: LPCOMSTAT) -> BOOL;
}
extern "C" {
  pub fn SetupComm(hFile: HANDLE, dwInQueue: DWORD, dwOutQueue: DWORD) -> BOOL;
}
extern "C" {
  pub fn EscapeCommFunction(hFile: HANDLE, dwFunc: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetCommConfig(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetCommMask(hFile: HANDLE, lpEvtMask: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetCommProperties(hFile: HANDLE, lpCommProp: LPCOMMPROP) -> BOOL;
}
extern "C" {
  pub fn GetCommModemStatus(hFile: HANDLE, lpModemStat: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetCommState(hFile: HANDLE, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
  pub fn GetCommTimeouts(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS) -> BOOL;
}
extern "C" {
  pub fn PurgeComm(hFile: HANDLE, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetCommBreak(hFile: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetCommConfig(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, dwSize: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetCommMask(hFile: HANDLE, dwEvtMask: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetCommState(hFile: HANDLE, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
  pub fn SetCommTimeouts(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS) -> BOOL;
}
extern "C" {
  pub fn TransmitCommChar(hFile: HANDLE, cChar: libc::c_char) -> BOOL;
}
extern "C" {
  pub fn WaitCommEvent(hFile: HANDLE, lpEvtMask: LPDWORD, lpOverlapped: LPOVERLAPPED) -> BOOL;
}
extern "C" {
  pub fn OpenCommPort(
    uPortNumber: ULONG, dwDesiredAccess: DWORD, dwFlagsAndAttributes: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn SetTapePosition(
    hDevice: HANDLE, dwPositionMethod: DWORD, dwPartition: DWORD, dwOffsetLow: DWORD,
    dwOffsetHigh: DWORD, bImmediate: BOOL,
  ) -> DWORD;
}
extern "C" {
  pub fn GetTapePosition(
    hDevice: HANDLE, dwPositionType: DWORD, lpdwPartition: LPDWORD, lpdwOffsetLow: LPDWORD,
    lpdwOffsetHigh: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn PrepareTape(hDevice: HANDLE, dwOperation: DWORD, bImmediate: BOOL) -> DWORD;
}
extern "C" {
  pub fn EraseTape(hDevice: HANDLE, dwEraseType: DWORD, bImmediate: BOOL) -> DWORD;
}
extern "C" {
  pub fn CreateTapePartition(
    hDevice: HANDLE, dwPartitionMethod: DWORD, dwCount: DWORD, dwSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WriteTapemark(
    hDevice: HANDLE, dwTapemarkType: DWORD, dwTapemarkCount: DWORD, bImmediate: BOOL,
  ) -> DWORD;
}
extern "C" {
  pub fn GetTapeStatus(hDevice: HANDLE) -> DWORD;
}
extern "C" {
  pub fn GetTapeParameters(
    hDevice: HANDLE, dwOperation: DWORD, lpdwSize: LPDWORD, lpTapeInformation: LPVOID,
  ) -> DWORD;
}
extern "C" {
  pub fn SetTapeParameters(hDevice: HANDLE, dwOperation: DWORD, lpTapeInformation: LPVOID)
    -> DWORD;
}
extern "C" {
  pub fn MulDiv(
    nNumber: libc::c_int, nNumerator: libc::c_int, nDenominator: libc::c_int,
  ) -> libc::c_int;
}
pub mod _DEP_SYSTEM_POLICY_TYPE {
  pub type Type = i32;
  pub const DEPPolicyAlwaysOff: Type = 0;
  pub const DEPPolicyAlwaysOn: Type = 1;
  pub const DEPPolicyOptIn: Type = 2;
  pub const DEPPolicyOptOut: Type = 3;
  pub const DEPTotalPolicyCount: Type = 4;
}
pub use self::_DEP_SYSTEM_POLICY_TYPE::Type as DEP_SYSTEM_POLICY_TYPE;
extern "C" {
  pub fn GetSystemDEPPolicy() -> DEP_SYSTEM_POLICY_TYPE;
}
extern "C" {
  pub fn GetSystemRegistryQuota(pdwQuotaAllowed: PDWORD, pdwQuotaUsed: PDWORD) -> BOOL;
}
extern "C" {
  pub fn FileTimeToDosDateTime(
    lpFileTime: *const FILETIME, lpFatDate: LPWORD, lpFatTime: LPWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn DosDateTimeToFileTime(wFatDate: WORD, wFatTime: WORD, lpFileTime: LPFILETIME) -> BOOL;
}
extern "C" {
  pub fn FormatMessageA(
    dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPSTR,
    nSize: DWORD, Arguments: *mut va_list,
  ) -> DWORD;
}
extern "C" {
  pub fn FormatMessageW(
    dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPWSTR,
    nSize: DWORD, Arguments: *mut va_list,
  ) -> DWORD;
}
extern "C" {
  pub fn CreateMailslotA(
    lpName: LPCSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateMailslotW(
    lpName: LPCWSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> HANDLE;
}
extern "C" {
  pub fn GetMailslotInfo(
    hMailslot: HANDLE, lpMaxMessageSize: LPDWORD, lpNextSize: LPDWORD, lpMessageCount: LPDWORD,
    lpReadTimeout: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetMailslotInfo(hMailslot: HANDLE, lReadTimeout: DWORD) -> BOOL;
}
extern "C" {
  pub fn EncryptFileA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn EncryptFileW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn DecryptFileA(lpFileName: LPCSTR, dwReserved: DWORD) -> BOOL;
}
extern "C" {
  pub fn DecryptFileW(lpFileName: LPCWSTR, dwReserved: DWORD) -> BOOL;
}
extern "C" {
  pub fn FileEncryptionStatusA(lpFileName: LPCSTR, lpStatus: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn FileEncryptionStatusW(lpFileName: LPCWSTR, lpStatus: LPDWORD) -> BOOL;
}
pub type PFE_EXPORT_FUNC = ::core::option::Option<
  unsafe extern "C" fn(pbData: PBYTE, pvCallbackContext: PVOID, ulLength: ULONG) -> DWORD,
>;
pub type PFE_IMPORT_FUNC = ::core::option::Option<
  unsafe extern "C" fn(pbData: PBYTE, pvCallbackContext: PVOID, ulLength: PULONG) -> DWORD,
>;
extern "C" {
  pub fn OpenEncryptedFileRawA(lpFileName: LPCSTR, ulFlags: ULONG, pvContext: *mut PVOID) -> DWORD;
}
extern "C" {
  pub fn OpenEncryptedFileRawW(lpFileName: LPCWSTR, ulFlags: ULONG, pvContext: *mut PVOID)
    -> DWORD;
}
extern "C" {
  pub fn ReadEncryptedFileRaw(
    pfExportCallback: PFE_EXPORT_FUNC, pvCallbackContext: PVOID, pvContext: PVOID,
  ) -> DWORD;
}
extern "C" {
  pub fn WriteEncryptedFileRaw(
    pfImportCallback: PFE_IMPORT_FUNC, pvCallbackContext: PVOID, pvContext: PVOID,
  ) -> DWORD;
}
extern "C" {
  pub fn CloseEncryptedFileRaw(pvContext: PVOID);
}
extern "C" {
  pub fn lstrcmpA(lpString1: LPCSTR, lpString2: LPCSTR) -> libc::c_int;
}
extern "C" {
  pub fn lstrcmpW(lpString1: LPCWSTR, lpString2: LPCWSTR) -> libc::c_int;
}
extern "C" {
  pub fn lstrcmpiA(lpString1: LPCSTR, lpString2: LPCSTR) -> libc::c_int;
}
extern "C" {
  pub fn lstrcmpiW(lpString1: LPCWSTR, lpString2: LPCWSTR) -> libc::c_int;
}
extern "C" {
  pub fn lstrcpynA(lpString1: LPSTR, lpString2: LPCSTR, iMaxLength: libc::c_int) -> LPSTR;
}
extern "C" {
  pub fn lstrcpynW(lpString1: LPWSTR, lpString2: LPCWSTR, iMaxLength: libc::c_int) -> LPWSTR;
}
extern "C" {
  pub fn lstrcpyA(lpString1: LPSTR, lpString2: LPCSTR) -> LPSTR;
}
extern "C" {
  pub fn lstrcpyW(lpString1: LPWSTR, lpString2: LPCWSTR) -> LPWSTR;
}
extern "C" {
  pub fn lstrcatA(lpString1: LPSTR, lpString2: LPCSTR) -> LPSTR;
}
extern "C" {
  pub fn lstrcatW(lpString1: LPWSTR, lpString2: LPCWSTR) -> LPWSTR;
}
extern "C" {
  pub fn lstrlenA(lpString: LPCSTR) -> libc::c_int;
}
extern "C" {
  pub fn lstrlenW(lpString: LPCWSTR) -> libc::c_int;
}
extern "C" {
  pub fn OpenFile(lpFileName: LPCSTR, lpReOpenBuff: LPOFSTRUCT, uStyle: UINT) -> HFILE;
}
extern "C" {
  pub fn _lopen(lpPathName: LPCSTR, iReadWrite: libc::c_int) -> HFILE;
}
extern "C" {
  pub fn _lcreat(lpPathName: LPCSTR, iAttribute: libc::c_int) -> HFILE;
}
extern "C" {
  pub fn _lread(hFile: HFILE, lpBuffer: LPVOID, uBytes: UINT) -> UINT;
}
extern "C" {
  pub fn _lwrite(hFile: HFILE, lpBuffer: LPCCH, uBytes: UINT) -> UINT;
}
extern "C" {
  pub fn _hread(hFile: HFILE, lpBuffer: LPVOID, lBytes: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _hwrite(hFile: HFILE, lpBuffer: LPCCH, lBytes: libc::c_long) -> libc::c_long;
}
extern "C" {
  pub fn _lclose(hFile: HFILE) -> HFILE;
}
extern "C" {
  pub fn _llseek(hFile: HFILE, lOffset: LONG, iOrigin: libc::c_int) -> LONG;
}
extern "C" {
  pub fn IsTextUnicode(lpv: *const libc::c_void, iSize: libc::c_int, lpiResult: LPINT) -> BOOL;
}
extern "C" {
  pub fn BackupRead(
    hFile: HANDLE, lpBuffer: LPBYTE, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD,
    bAbort: BOOL, bProcessSecurity: BOOL, lpContext: *mut LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn BackupSeek(
    hFile: HANDLE, dwLowBytesToSeek: DWORD, dwHighBytesToSeek: DWORD, lpdwLowByteSeeked: LPDWORD,
    lpdwHighByteSeeked: LPDWORD, lpContext: *mut LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn BackupWrite(
    hFile: HANDLE, lpBuffer: LPBYTE, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD,
    bAbort: BOOL, bProcessSecurity: BOOL, lpContext: *mut LPVOID,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIN32_STREAM_ID {
  pub dwStreamId: DWORD,
  pub dwStreamAttributes: DWORD,
  pub Size: LARGE_INTEGER,
  pub dwStreamNameSize: DWORD,
  pub cStreamName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__WIN32_STREAM_ID() {
  assert_eq!(
    ::core::mem::size_of::<_WIN32_STREAM_ID>(),
    24usize,
    concat!("Size of: ", stringify!(_WIN32_STREAM_ID))
  );
  assert_eq!(
    ::core::mem::align_of::<_WIN32_STREAM_ID>(),
    8usize,
    concat!("Alignment of ", stringify!(_WIN32_STREAM_ID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_STREAM_ID>())).dwStreamId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_STREAM_ID),
      "::",
      stringify!(dwStreamId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_WIN32_STREAM_ID>())).dwStreamAttributes as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_STREAM_ID),
      "::",
      stringify!(dwStreamAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_STREAM_ID>())).Size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_STREAM_ID),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_STREAM_ID>())).dwStreamNameSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_STREAM_ID),
      "::",
      stringify!(dwStreamNameSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WIN32_STREAM_ID>())).cStreamName as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_WIN32_STREAM_ID),
      "::",
      stringify!(cStreamName)
    )
  );
}
impl Default for _WIN32_STREAM_ID {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _WIN32_STREAM_ID {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_WIN32_STREAM_ID {{ dwStreamId: {:?}, dwStreamAttributes: {:?}, Size: {:?}, dwStreamNameSize: {:?}, cStreamName: {:?} }}" , self . dwStreamId , self . dwStreamAttributes , self . Size , self . dwStreamNameSize , self . cStreamName )
  }
}
pub type WIN32_STREAM_ID = _WIN32_STREAM_ID;
pub type LPWIN32_STREAM_ID = *mut _WIN32_STREAM_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _STARTUPINFOEXA {
  pub StartupInfo: STARTUPINFOA,
  pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
#[test]
fn bindgen_test_layout__STARTUPINFOEXA() {
  assert_eq!(
    ::core::mem::size_of::<_STARTUPINFOEXA>(),
    112usize,
    concat!("Size of: ", stringify!(_STARTUPINFOEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<_STARTUPINFOEXA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOEXA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOEXA>())).StartupInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXA),
      "::",
      stringify!(StartupInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOEXA>())).lpAttributeList as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXA),
      "::",
      stringify!(lpAttributeList)
    )
  );
}
impl Default for _STARTUPINFOEXA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type STARTUPINFOEXA = _STARTUPINFOEXA;
pub type LPSTARTUPINFOEXA = *mut _STARTUPINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _STARTUPINFOEXW {
  pub StartupInfo: STARTUPINFOW,
  pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
#[test]
fn bindgen_test_layout__STARTUPINFOEXW() {
  assert_eq!(
    ::core::mem::size_of::<_STARTUPINFOEXW>(),
    112usize,
    concat!("Size of: ", stringify!(_STARTUPINFOEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<_STARTUPINFOEXW>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOEXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOEXW>())).StartupInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXW),
      "::",
      stringify!(StartupInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_STARTUPINFOEXW>())).lpAttributeList as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXW),
      "::",
      stringify!(lpAttributeList)
    )
  );
}
impl Default for _STARTUPINFOEXW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type STARTUPINFOEXW = _STARTUPINFOEXW;
pub type LPSTARTUPINFOEXW = *mut _STARTUPINFOEXW;
pub type STARTUPINFOEX = STARTUPINFOEXA;
pub type LPSTARTUPINFOEX = LPSTARTUPINFOEXA;
extern "C" {
  pub fn OpenMutexA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn CreateSemaphoreA(
    lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG,
    lpName: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenSemaphoreA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn CreateWaitableTimerA(
    lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, lpTimerName: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenWaitableTimerA(
    dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpTimerName: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateSemaphoreExA(
    lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG,
    lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateWaitableTimerExA(
    lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCSTR, dwFlags: DWORD,
    dwDesiredAccess: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateFileMappingA(
    hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD,
    dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateFileMappingNumaA(
    hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD,
    dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR, nndPreferred: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenFileMappingA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn GetLogicalDriveStringsA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
  pub fn LoadPackagedLibrary(lpwLibFileName: LPCWSTR, Reserved: DWORD) -> HMODULE;
}
extern "C" {
  pub fn QueryFullProcessImageNameA(
    hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPSTR, lpdwSize: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryFullProcessImageNameW(
    hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPWSTR, lpdwSize: PDWORD,
  ) -> BOOL;
}
pub mod _PROC_THREAD_ATTRIBUTE_NUM {
  pub type Type = i32;
  pub const ProcThreadAttributeParentProcess: Type = 0;
  pub const ProcThreadAttributeHandleList: Type = 2;
  pub const ProcThreadAttributeGroupAffinity: Type = 3;
  pub const ProcThreadAttributePreferredNode: Type = 4;
  pub const ProcThreadAttributeIdealProcessor: Type = 5;
  pub const ProcThreadAttributeUmsThread: Type = 6;
  pub const ProcThreadAttributeMitigationPolicy: Type = 7;
  pub const ProcThreadAttributeSecurityCapabilities: Type = 9;
  pub const ProcThreadAttributeProtectionLevel: Type = 11;
  pub const ProcThreadAttributeJobList: Type = 13;
  pub const ProcThreadAttributeChildProcessPolicy: Type = 14;
  pub const ProcThreadAttributeAllApplicationPackagesPolicy: Type = 15;
  pub const ProcThreadAttributeWin32kFilter: Type = 16;
  pub const ProcThreadAttributeSafeOpenPromptOriginClaim: Type = 17;
  pub const ProcThreadAttributeDesktopAppPolicy: Type = 18;
}
pub use self::_PROC_THREAD_ATTRIBUTE_NUM::Type as PROC_THREAD_ATTRIBUTE_NUM;
extern "C" {
  pub fn GetStartupInfoA(lpStartupInfo: LPSTARTUPINFOA);
}
extern "C" {
  pub fn GetFirmwareEnvironmentVariableA(
    lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFirmwareEnvironmentVariableW(
    lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFirmwareEnvironmentVariableExA(
    lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFirmwareEnvironmentVariableExW(
    lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SetFirmwareEnvironmentVariableA(
    lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFirmwareEnvironmentVariableW(
    lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFirmwareEnvironmentVariableExA(
    lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFirmwareEnvironmentVariableExW(
    lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFirmwareType(FirmwareType: PFIRMWARE_TYPE) -> BOOL;
}
extern "C" {
  pub fn IsNativeVhdBoot(NativeVhdBoot: PBOOL) -> BOOL;
}
extern "C" {
  pub fn FindResourceA(hModule: HMODULE, lpName: LPCSTR, lpType: LPCSTR) -> HRSRC;
}
extern "C" {
  pub fn FindResourceExA(
    hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD,
  ) -> HRSRC;
}
extern "C" {
  pub fn EnumResourceTypesA(
    hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceTypesW(
    hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceNamesA(
    hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceLanguagesA(
    hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA,
    lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumResourceLanguagesW(
    hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW,
    lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn BeginUpdateResourceA(pFileName: LPCSTR, bDeleteExistingResources: BOOL) -> HANDLE;
}
extern "C" {
  pub fn BeginUpdateResourceW(pFileName: LPCWSTR, bDeleteExistingResources: BOOL) -> HANDLE;
}
extern "C" {
  pub fn UpdateResourceA(
    hUpdate: HANDLE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn UpdateResourceW(
    hUpdate: HANDLE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EndUpdateResourceA(hUpdate: HANDLE, fDiscard: BOOL) -> BOOL;
}
extern "C" {
  pub fn EndUpdateResourceW(hUpdate: HANDLE, fDiscard: BOOL) -> BOOL;
}
extern "C" {
  pub fn GlobalAddAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
  pub fn GlobalAddAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
  pub fn GlobalAddAtomExA(lpString: LPCSTR, Flags: DWORD) -> ATOM;
}
extern "C" {
  pub fn GlobalAddAtomExW(lpString: LPCWSTR, Flags: DWORD) -> ATOM;
}
extern "C" {
  pub fn GlobalFindAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
  pub fn GlobalFindAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
  pub fn GlobalGetAtomNameA(nAtom: ATOM, lpBuffer: LPSTR, nSize: libc::c_int) -> UINT;
}
extern "C" {
  pub fn GlobalGetAtomNameW(nAtom: ATOM, lpBuffer: LPWSTR, nSize: libc::c_int) -> UINT;
}
extern "C" {
  pub fn AddAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
  pub fn AddAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
  pub fn FindAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
  pub fn FindAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
  pub fn GetAtomNameA(nAtom: ATOM, lpBuffer: LPSTR, nSize: libc::c_int) -> UINT;
}
extern "C" {
  pub fn GetAtomNameW(nAtom: ATOM, lpBuffer: LPWSTR, nSize: libc::c_int) -> UINT;
}
extern "C" {
  pub fn GetProfileIntA(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT) -> UINT;
}
extern "C" {
  pub fn GetProfileIntW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT) -> UINT;
}
extern "C" {
  pub fn GetProfileStringA(
    lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetProfileStringW(
    lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR,
    nSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WriteProfileStringA(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn WriteProfileStringW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetProfileSectionA(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetProfileSectionW(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn WriteProfileSectionA(lpAppName: LPCSTR, lpString: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn WriteProfileSectionW(lpAppName: LPCWSTR, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetPrivateProfileIntA(
    lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT, lpFileName: LPCSTR,
  ) -> UINT;
}
extern "C" {
  pub fn GetPrivateProfileIntW(
    lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT, lpFileName: LPCWSTR,
  ) -> UINT;
}
extern "C" {
  pub fn GetPrivateProfileStringA(
    lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD,
    lpFileName: LPCSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetPrivateProfileStringW(
    lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR,
    nSize: DWORD, lpFileName: LPCWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn WritePrivateProfileStringA(
    lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn WritePrivateProfileStringW(
    lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPrivateProfileSectionA(
    lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetPrivateProfileSectionW(
    lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn WritePrivateProfileSectionA(
    lpAppName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn WritePrivateProfileSectionW(
    lpAppName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPrivateProfileSectionNamesA(
    lpszReturnBuffer: LPSTR, nSize: DWORD, lpFileName: LPCSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetPrivateProfileSectionNamesW(
    lpszReturnBuffer: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetPrivateProfileStructA(
    lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPrivateProfileStructW(
    lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn WritePrivateProfileStructA(
    lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn WritePrivateProfileStructW(
    lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn Wow64EnableWow64FsRedirection(Wow64FsEnableRedirection: BOOLEAN) -> BOOLEAN;
}
pub type PGET_SYSTEM_WOW64_DIRECTORY_A =
  ::core::option::Option<unsafe extern "C" fn(lpBuffer: LPSTR, uSize: UINT) -> UINT>;
pub type PGET_SYSTEM_WOW64_DIRECTORY_W =
  ::core::option::Option<unsafe extern "C" fn(lpBuffer: LPWSTR, uSize: UINT) -> UINT>;
extern "C" {
  pub fn SetDllDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetDllDirectoryW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetDllDirectoryA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
  pub fn GetDllDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
  pub fn SetSearchPathMode(Flags: DWORD) -> BOOL;
}
extern "C" {
  pub fn CreateDirectoryExA(
    lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateDirectoryExW(
    lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateDirectoryTransactedA(
    lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateDirectoryTransactedW(
    lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn RemoveDirectoryTransactedA(lpPathName: LPCSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
  pub fn RemoveDirectoryTransactedW(lpPathName: LPCWSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetFullPathNameTransactedA(
    lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: *mut LPSTR,
    hTransaction: HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFullPathNameTransactedW(
    lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: *mut LPWSTR,
    hTransaction: HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn DefineDosDeviceA(dwFlags: DWORD, lpDeviceName: LPCSTR, lpTargetPath: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn QueryDosDeviceA(lpDeviceName: LPCSTR, lpTargetPath: LPSTR, ucchMax: DWORD) -> DWORD;
}
extern "C" {
  pub fn CreateFileTransactedA(
    lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD,
    dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE,
    pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateFileTransactedW(
    lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD,
    dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE,
    pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID,
  ) -> HANDLE;
}
extern "C" {
  pub fn ReOpenFile(
    hOriginalFile: HANDLE, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwFlagsAndAttributes: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn SetFileAttributesTransactedA(
    lpFileName: LPCSTR, dwFileAttributes: DWORD, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFileAttributesTransactedW(
    lpFileName: LPCWSTR, dwFileAttributes: DWORD, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileAttributesTransactedA(
    lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID,
    hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileAttributesTransactedW(
    lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID,
    hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCompressedFileSizeTransactedA(
    lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn GetCompressedFileSizeTransactedW(
    lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn DeleteFileTransactedA(lpFileName: LPCSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
  pub fn DeleteFileTransactedW(lpFileName: LPCWSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
  pub fn CheckNameLegalDOS8Dot3A(
    lpName: LPCSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL,
    pbNameLegal: PBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn CheckNameLegalDOS8Dot3W(
    lpName: LPCWSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL,
    pbNameLegal: PBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn FindFirstFileTransactedA(
    lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID,
    fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD,
    hTransaction: HANDLE,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstFileTransactedW(
    lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID,
    fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD,
    hTransaction: HANDLE,
  ) -> HANDLE;
}
extern "C" {
  pub fn CopyFileA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, bFailIfExists: BOOL) -> BOOL;
}
extern "C" {
  pub fn CopyFileW(
    lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, bFailIfExists: BOOL,
  ) -> BOOL;
}
pub type LPPROGRESS_ROUTINE = ::core::option::Option<
  unsafe extern "C" fn(
    TotalFileSize: LARGE_INTEGER,
    TotalBytesTransferred: LARGE_INTEGER,
    StreamSize: LARGE_INTEGER,
    StreamBytesTransferred: LARGE_INTEGER,
    dwStreamNumber: DWORD,
    dwCallbackReason: DWORD,
    hSourceFile: HANDLE,
    hDestinationFile: HANDLE,
    lpData: LPVOID,
  ) -> DWORD,
>;
extern "C" {
  pub fn CopyFileExA(
    lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CopyFileExW(
    lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CopyFileTransactedA(
    lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn CopyFileTransactedW(
    lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE,
  ) -> BOOL;
}
pub mod _COPYFILE2_MESSAGE_TYPE {
  pub type Type = i32;
  pub const COPYFILE2_CALLBACK_NONE: Type = 0;
  pub const COPYFILE2_CALLBACK_CHUNK_STARTED: Type = 1;
  pub const COPYFILE2_CALLBACK_CHUNK_FINISHED: Type = 2;
  pub const COPYFILE2_CALLBACK_STREAM_STARTED: Type = 3;
  pub const COPYFILE2_CALLBACK_STREAM_FINISHED: Type = 4;
  pub const COPYFILE2_CALLBACK_POLL_CONTINUE: Type = 5;
  pub const COPYFILE2_CALLBACK_ERROR: Type = 6;
  pub const COPYFILE2_CALLBACK_MAX: Type = 7;
}
pub use self::_COPYFILE2_MESSAGE_TYPE::Type as COPYFILE2_MESSAGE_TYPE;
pub mod _COPYFILE2_MESSAGE_ACTION {
  pub type Type = i32;
  pub const COPYFILE2_PROGRESS_CONTINUE: Type = 0;
  pub const COPYFILE2_PROGRESS_CANCEL: Type = 1;
  pub const COPYFILE2_PROGRESS_STOP: Type = 2;
  pub const COPYFILE2_PROGRESS_QUIET: Type = 3;
  pub const COPYFILE2_PROGRESS_PAUSE: Type = 4;
}
pub use self::_COPYFILE2_MESSAGE_ACTION::Type as COPYFILE2_MESSAGE_ACTION;
pub mod _COPYFILE2_COPY_PHASE {
  pub type Type = i32;
  pub const COPYFILE2_PHASE_NONE: Type = 0;
  pub const COPYFILE2_PHASE_PREPARE_SOURCE: Type = 1;
  pub const COPYFILE2_PHASE_PREPARE_DEST: Type = 2;
  pub const COPYFILE2_PHASE_READ_SOURCE: Type = 3;
  pub const COPYFILE2_PHASE_WRITE_DESTINATION: Type = 4;
  pub const COPYFILE2_PHASE_SERVER_COPY: Type = 5;
  pub const COPYFILE2_PHASE_NAMEGRAFT_COPY: Type = 6;
  pub const COPYFILE2_PHASE_MAX: Type = 7;
}
pub use self::_COPYFILE2_COPY_PHASE::Type as COPYFILE2_COPY_PHASE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE {
  pub Type: COPYFILE2_MESSAGE_TYPE,
  pub dwPadding: DWORD,
  pub Info: COPYFILE2_MESSAGE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union COPYFILE2_MESSAGE__bindgen_ty_1 {
  pub ChunkStarted: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1,
  pub ChunkFinished: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2,
  pub StreamStarted: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3,
  pub StreamFinished: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4,
  pub PollContinue: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5,
  pub Error: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6,
  _bindgen_union_align: [u64; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
  pub dwStreamNumber: DWORD,
  pub dwReserved: DWORD,
  pub hSourceFile: HANDLE,
  pub hDestinationFile: HANDLE,
  pub uliChunkNumber: ULARGE_INTEGER,
  pub uliChunkSize: ULARGE_INTEGER,
  pub uliStreamSize: ULARGE_INTEGER,
  pub uliTotalFileSize: ULARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).dwStreamNumber
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dwStreamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).dwReserved
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).hSourceFile
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hSourceFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).hDestinationFile
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hDestinationFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).uliChunkNumber
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uliChunkNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).uliChunkSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uliChunkSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).uliStreamSize
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uliStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1>())).uliTotalFileSize
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uliTotalFileSize)
    )
  );
}
impl Default for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1 {{ dwStreamNumber: {:?}, dwReserved: {:?}, hSourceFile: {:?}, hDestinationFile: {:?}, uliChunkNumber: {:?}, uliChunkSize: {:?}, uliStreamSize: {:?}, uliTotalFileSize: {:?} }}" , self . dwStreamNumber , self . dwReserved , self . hSourceFile , self . hDestinationFile , self . uliChunkNumber , self . uliChunkSize , self . uliStreamSize , self . uliTotalFileSize )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2 {
  pub dwStreamNumber: DWORD,
  pub dwFlags: DWORD,
  pub hSourceFile: HANDLE,
  pub hDestinationFile: HANDLE,
  pub uliChunkNumber: ULARGE_INTEGER,
  pub uliChunkSize: ULARGE_INTEGER,
  pub uliStreamSize: ULARGE_INTEGER,
  pub uliStreamBytesTransferred: ULARGE_INTEGER,
  pub uliTotalFileSize: ULARGE_INTEGER,
  pub uliTotalBytesTransferred: ULARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).dwStreamNumber
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dwStreamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).dwFlags as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).hSourceFile
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(hSourceFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).hDestinationFile
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(hDestinationFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).uliChunkNumber
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(uliChunkNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).uliChunkSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(uliChunkSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).uliStreamSize
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(uliStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>()))
        .uliStreamBytesTransferred as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(uliStreamBytesTransferred)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>())).uliTotalFileSize
        as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(uliTotalFileSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2>()))
        .uliTotalBytesTransferred as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(uliTotalBytesTransferred)
    )
  );
}
impl Default for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2 {{ dwStreamNumber: {:?}, dwFlags: {:?}, hSourceFile: {:?}, hDestinationFile: {:?}, uliChunkNumber: {:?}, uliChunkSize: {:?}, uliStreamSize: {:?}, uliStreamBytesTransferred: {:?}, uliTotalFileSize: {:?}, uliTotalBytesTransferred: {:?} }}" , self . dwStreamNumber , self . dwFlags , self . hSourceFile , self . hDestinationFile , self . uliChunkNumber , self . uliChunkSize , self . uliStreamSize , self . uliStreamBytesTransferred , self . uliTotalFileSize , self . uliTotalBytesTransferred )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3 {
  pub dwStreamNumber: DWORD,
  pub dwReserved: DWORD,
  pub hSourceFile: HANDLE,
  pub hDestinationFile: HANDLE,
  pub uliStreamSize: ULARGE_INTEGER,
  pub uliTotalFileSize: ULARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>())).dwStreamNumber
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(dwStreamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>())).dwReserved
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>())).hSourceFile
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(hSourceFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>())).hDestinationFile
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(hDestinationFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>())).uliStreamSize
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(uliStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3>())).uliTotalFileSize
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(uliTotalFileSize)
    )
  );
}
impl Default for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3 {{ dwStreamNumber: {:?}, dwReserved: {:?}, hSourceFile: {:?}, hDestinationFile: {:?}, uliStreamSize: {:?}, uliTotalFileSize: {:?} }}" , self . dwStreamNumber , self . dwReserved , self . hSourceFile , self . hDestinationFile , self . uliStreamSize , self . uliTotalFileSize )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4 {
  pub dwStreamNumber: DWORD,
  pub dwReserved: DWORD,
  pub hSourceFile: HANDLE,
  pub hDestinationFile: HANDLE,
  pub uliStreamSize: ULARGE_INTEGER,
  pub uliStreamBytesTransferred: ULARGE_INTEGER,
  pub uliTotalFileSize: ULARGE_INTEGER,
  pub uliTotalBytesTransferred: ULARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>())).dwStreamNumber
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(dwStreamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>())).dwReserved
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>())).hSourceFile
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(hSourceFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>())).hDestinationFile
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(hDestinationFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>())).uliStreamSize
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(uliStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>()))
        .uliStreamBytesTransferred as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(uliStreamBytesTransferred)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>())).uliTotalFileSize
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(uliTotalFileSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4>()))
        .uliTotalBytesTransferred as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(uliTotalBytesTransferred)
    )
  );
}
impl Default for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4 {{ dwStreamNumber: {:?}, dwReserved: {:?}, hSourceFile: {:?}, hDestinationFile: {:?}, uliStreamSize: {:?}, uliStreamBytesTransferred: {:?}, uliTotalFileSize: {:?}, uliTotalBytesTransferred: {:?} }}" , self . dwStreamNumber , self . dwReserved , self . hSourceFile , self . hDestinationFile , self . uliStreamSize , self . uliStreamBytesTransferred , self . uliTotalFileSize , self . uliTotalBytesTransferred )
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5 {
  pub dwReserved: DWORD,
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5>())).dwReserved
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5),
      "::",
      stringify!(dwReserved)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6 {
  pub CopyPhase: COPYFILE2_COPY_PHASE,
  pub dwStreamNumber: DWORD,
  pub hrFailure: HRESULT,
  pub dwReserved: DWORD,
  pub uliChunkNumber: ULARGE_INTEGER,
  pub uliStreamSize: ULARGE_INTEGER,
  pub uliStreamBytesTransferred: ULARGE_INTEGER,
  pub uliTotalFileSize: ULARGE_INTEGER,
  pub uliTotalBytesTransferred: ULARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).CopyPhase
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(CopyPhase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).dwStreamNumber
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(dwStreamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).hrFailure
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(hrFailure)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).dwReserved
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).uliChunkNumber
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(uliChunkNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).uliStreamSize
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(uliStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>()))
        .uliStreamBytesTransferred as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(uliStreamBytesTransferred)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>())).uliTotalFileSize
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(uliTotalFileSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6>()))
        .uliTotalBytesTransferred as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6),
      "::",
      stringify!(uliTotalBytesTransferred)
    )
  );
}
impl Default for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6 {{ CopyPhase: {:?}, dwStreamNumber: {:?}, hrFailure: {:?}, dwReserved: {:?}, uliChunkNumber: {:?}, uliStreamSize: {:?}, uliStreamBytesTransferred: {:?}, uliTotalFileSize: {:?}, uliTotalBytesTransferred: {:?} }}" , self . CopyPhase , self . dwStreamNumber , self . hrFailure , self . dwReserved , self . uliChunkNumber , self . uliStreamSize , self . uliStreamBytesTransferred , self . uliTotalFileSize , self . uliTotalBytesTransferred )
  }
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE__bindgen_ty_1>(),
    72usize,
    concat!("Size of: ", stringify!(COPYFILE2_MESSAGE__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(COPYFILE2_MESSAGE__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1>())).ChunkStarted as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1),
      "::",
      stringify!(ChunkStarted)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1>())).ChunkFinished as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1),
      "::",
      stringify!(ChunkFinished)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1>())).StreamStarted as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1),
      "::",
      stringify!(StreamStarted)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1>())).StreamFinished as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1),
      "::",
      stringify!(StreamFinished)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1>())).PollContinue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1),
      "::",
      stringify!(PollContinue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_MESSAGE__bindgen_ty_1>())).Error as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE__bindgen_ty_1),
      "::",
      stringify!(Error)
    )
  );
}
impl Default for COPYFILE2_MESSAGE__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "COPYFILE2_MESSAGE__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_COPYFILE2_MESSAGE() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_MESSAGE>(),
    80usize,
    concat!("Size of: ", stringify!(COPYFILE2_MESSAGE))
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_MESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(COPYFILE2_MESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<COPYFILE2_MESSAGE>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<COPYFILE2_MESSAGE>())).dwPadding as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE),
      "::",
      stringify!(dwPadding)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<COPYFILE2_MESSAGE>())).Info as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_MESSAGE),
      "::",
      stringify!(Info)
    )
  );
}
impl Default for COPYFILE2_MESSAGE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for COPYFILE2_MESSAGE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "COPYFILE2_MESSAGE {{ Type: {:?}, dwPadding: {:?}, Info: {:?} }}",
      self.Type, self.dwPadding, self.Info
    )
  }
}
pub type PCOPYFILE2_PROGRESS_ROUTINE = ::core::option::Option<
  unsafe extern "C" fn(
    pMessage: *const COPYFILE2_MESSAGE,
    pvCallbackContext: PVOID,
  ) -> COPYFILE2_MESSAGE_ACTION,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct COPYFILE2_EXTENDED_PARAMETERS {
  pub dwSize: DWORD,
  pub dwCopyFlags: DWORD,
  pub pfCancel: *mut BOOL,
  pub pProgressRoutine: PCOPYFILE2_PROGRESS_ROUTINE,
  pub pvCallbackContext: PVOID,
}
#[test]
fn bindgen_test_layout_COPYFILE2_EXTENDED_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<COPYFILE2_EXTENDED_PARAMETERS>(),
    32usize,
    concat!("Size of: ", stringify!(COPYFILE2_EXTENDED_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<COPYFILE2_EXTENDED_PARAMETERS>(),
    8usize,
    concat!("Alignment of ", stringify!(COPYFILE2_EXTENDED_PARAMETERS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_EXTENDED_PARAMETERS>())).dwSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_EXTENDED_PARAMETERS>())).dwCopyFlags as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(dwCopyFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_EXTENDED_PARAMETERS>())).pfCancel as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(pfCancel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_EXTENDED_PARAMETERS>())).pProgressRoutine as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(pProgressRoutine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<COPYFILE2_EXTENDED_PARAMETERS>())).pvCallbackContext as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(COPYFILE2_EXTENDED_PARAMETERS),
      "::",
      stringify!(pvCallbackContext)
    )
  );
}
impl Default for COPYFILE2_EXTENDED_PARAMETERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
extern "C" {
  pub fn CopyFile2(
    pwszExistingFileName: PCWSTR, pwszNewFileName: PCWSTR,
    pExtendedParameters: *mut COPYFILE2_EXTENDED_PARAMETERS,
  ) -> HRESULT;
}
extern "C" {
  pub fn MoveFileA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn MoveFileW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn MoveFileExA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn MoveFileWithProgressA(
    lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn MoveFileWithProgressW(
    lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn MoveFileTransactedA(
    lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn MoveFileTransactedW(
    lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn ReplaceFileA(
    lpReplacedFileName: LPCSTR, lpReplacementFileName: LPCSTR, lpBackupFileName: LPCSTR,
    dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn ReplaceFileW(
    lpReplacedFileName: LPCWSTR, lpReplacementFileName: LPCWSTR, lpBackupFileName: LPCWSTR,
    dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateHardLinkA(
    lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateHardLinkW(
    lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateHardLinkTransactedA(
    lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateHardLinkTransactedW(
    lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn FindFirstStreamTransactedW(
    lpFileName: LPCWSTR, InfoLevel: STREAM_INFO_LEVELS, lpFindStreamData: LPVOID, dwFlags: DWORD,
    hTransaction: HANDLE,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstFileNameTransactedW(
    lpFileName: LPCWSTR, dwFlags: DWORD, StringLength: LPDWORD, LinkName: PWSTR,
    hTransaction: HANDLE,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateNamedPipeA(
    lpName: LPCSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD,
    nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> HANDLE;
}
extern "C" {
  pub fn GetNamedPipeHandleStateA(
    hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD,
    lpCollectDataTimeout: LPDWORD, lpUserName: LPSTR, nMaxUserNameSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CallNamedPipeA(
    lpNamedPipeName: LPCSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID,
    nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WaitNamedPipeA(lpNamedPipeName: LPCSTR, nTimeOut: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeClientComputerNameA(
    Pipe: HANDLE, ClientComputerName: LPSTR, ClientComputerNameLength: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeClientProcessId(Pipe: HANDLE, ClientProcessId: PULONG) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeClientSessionId(Pipe: HANDLE, ClientSessionId: PULONG) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeServerProcessId(Pipe: HANDLE, ServerProcessId: PULONG) -> BOOL;
}
extern "C" {
  pub fn GetNamedPipeServerSessionId(Pipe: HANDLE, ServerSessionId: PULONG) -> BOOL;
}
extern "C" {
  pub fn SetVolumeLabelA(lpRootPathName: LPCSTR, lpVolumeName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetVolumeLabelW(lpRootPathName: LPCWSTR, lpVolumeName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn SetFileBandwidthReservation(
    hFile: HANDLE, nPeriodMilliseconds: DWORD, nBytesPerPeriod: DWORD, bDiscardable: BOOL,
    lpTransferSize: LPDWORD, lpNumOutstandingRequests: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileBandwidthReservation(
    hFile: HANDLE, lpPeriodMilliseconds: LPDWORD, lpBytesPerPeriod: LPDWORD, pDiscardable: LPBOOL,
    lpTransferSize: LPDWORD, lpNumOutstandingRequests: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ClearEventLogA(hEventLog: HANDLE, lpBackupFileName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn ClearEventLogW(hEventLog: HANDLE, lpBackupFileName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn BackupEventLogA(hEventLog: HANDLE, lpBackupFileName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn BackupEventLogW(hEventLog: HANDLE, lpBackupFileName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn CloseEventLog(hEventLog: HANDLE) -> BOOL;
}
extern "C" {
  pub fn DeregisterEventSource(hEventLog: HANDLE) -> BOOL;
}
extern "C" {
  pub fn NotifyChangeEventLog(hEventLog: HANDLE, hEvent: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetNumberOfEventLogRecords(hEventLog: HANDLE, NumberOfRecords: PDWORD) -> BOOL;
}
extern "C" {
  pub fn GetOldestEventLogRecord(hEventLog: HANDLE, OldestRecord: PDWORD) -> BOOL;
}
extern "C" {
  pub fn OpenEventLogA(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn OpenEventLogW(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn RegisterEventSourceA(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn RegisterEventSourceW(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn OpenBackupEventLogA(lpUNCServerName: LPCSTR, lpFileName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn OpenBackupEventLogW(lpUNCServerName: LPCWSTR, lpFileName: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn ReadEventLogA(
    hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID,
    nNumberOfBytesToRead: DWORD, pnBytesRead: *mut DWORD, pnMinNumberOfBytesNeeded: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadEventLogW(
    hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID,
    nNumberOfBytesToRead: DWORD, pnBytesRead: *mut DWORD, pnMinNumberOfBytesNeeded: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReportEventA(
    hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID,
    wNumStrings: WORD, dwDataSize: DWORD, lpStrings: *mut LPCSTR, lpRawData: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn ReportEventW(
    hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID,
    wNumStrings: WORD, dwDataSize: DWORD, lpStrings: *mut LPCWSTR, lpRawData: LPVOID,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _EVENTLOG_FULL_INFORMATION {
  pub dwFull: DWORD,
}
#[test]
fn bindgen_test_layout__EVENTLOG_FULL_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_EVENTLOG_FULL_INFORMATION>(),
    4usize,
    concat!("Size of: ", stringify!(_EVENTLOG_FULL_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_EVENTLOG_FULL_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_EVENTLOG_FULL_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_EVENTLOG_FULL_INFORMATION>())).dwFull as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_EVENTLOG_FULL_INFORMATION),
      "::",
      stringify!(dwFull)
    )
  );
}
pub type EVENTLOG_FULL_INFORMATION = _EVENTLOG_FULL_INFORMATION;
pub type LPEVENTLOG_FULL_INFORMATION = *mut _EVENTLOG_FULL_INFORMATION;
extern "C" {
  pub fn GetEventLogInformation(
    hEventLog: HANDLE, dwInfoLevel: DWORD, lpBuffer: LPVOID, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
pub type OPERATION_ID = ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _OPERATION_START_PARAMETERS {
  pub Version: ULONG,
  pub OperationId: OPERATION_ID,
  pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__OPERATION_START_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_OPERATION_START_PARAMETERS>(),
    12usize,
    concat!("Size of: ", stringify!(_OPERATION_START_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_OPERATION_START_PARAMETERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_OPERATION_START_PARAMETERS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OPERATION_START_PARAMETERS>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OPERATION_START_PARAMETERS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OPERATION_START_PARAMETERS>())).OperationId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OPERATION_START_PARAMETERS),
      "::",
      stringify!(OperationId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OPERATION_START_PARAMETERS>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OPERATION_START_PARAMETERS),
      "::",
      stringify!(Flags)
    )
  );
}
pub type OPERATION_START_PARAMETERS = _OPERATION_START_PARAMETERS;
pub type POPERATION_START_PARAMETERS = *mut _OPERATION_START_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _OPERATION_END_PARAMETERS {
  pub Version: ULONG,
  pub OperationId: OPERATION_ID,
  pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__OPERATION_END_PARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_OPERATION_END_PARAMETERS>(),
    12usize,
    concat!("Size of: ", stringify!(_OPERATION_END_PARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_OPERATION_END_PARAMETERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_OPERATION_END_PARAMETERS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OPERATION_END_PARAMETERS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OPERATION_END_PARAMETERS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OPERATION_END_PARAMETERS>())).OperationId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OPERATION_END_PARAMETERS),
      "::",
      stringify!(OperationId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OPERATION_END_PARAMETERS>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OPERATION_END_PARAMETERS),
      "::",
      stringify!(Flags)
    )
  );
}
pub type OPERATION_END_PARAMETERS = _OPERATION_END_PARAMETERS;
pub type POPERATION_END_PARAMETERS = *mut _OPERATION_END_PARAMETERS;
extern "C" {
  pub fn OperationStart(OperationStartParams: *mut OPERATION_START_PARAMETERS) -> BOOL;
}
extern "C" {
  pub fn OperationEnd(OperationEndParams: *mut OPERATION_END_PARAMETERS) -> BOOL;
}
extern "C" {
  pub fn AccessCheckAndAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR,
    SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD,
    GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD,
    AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeAndAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR,
    SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD,
    AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST,
    ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL,
    GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeResultListAndAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR,
    SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD,
    AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST,
    ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL,
    GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCSTR,
    ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID,
    DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD,
    ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD,
    GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD,
    AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectOpenAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD,
    GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: BOOL, AccessGranted: BOOL,
    GenerateOnClose: LPBOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectPrivilegeAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD,
    Privileges: PPRIVILEGE_SET, AccessGranted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectCloseAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn ObjectDeleteAuditAlarmA(
    SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn PrivilegedServiceAuditAlarmA(
    SubsystemName: LPCSTR, ServiceName: LPCSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET,
    AccessGranted: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AddConditionalAce(
    pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AceType: UCHAR, AccessMask: DWORD,
    pSid: PSID, ConditionStr: PWCHAR, ReturnLength: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetFileSecurityA(
    lpFileName: LPCSTR, SecurityInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileSecurityA(
    lpFileName: LPCSTR, RequestedInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadDirectoryChangesW(
    hDirectory: HANDLE, lpBuffer: LPVOID, nBufferLength: DWORD, bWatchSubtree: BOOL,
    dwNotifyFilter: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadDirectoryChangesExW(
    hDirectory: HANDLE, lpBuffer: LPVOID, nBufferLength: DWORD, bWatchSubtree: BOOL,
    dwNotifyFilter: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
    ReadDirectoryNotifyInformationClass: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
  ) -> BOOL;
}
extern "C" {
  pub fn MapViewOfFileExNuma(
    hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD,
    dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T, lpBaseAddress: LPVOID,
    nndPreferred: DWORD,
  ) -> LPVOID;
}
extern "C" {
  pub fn IsBadReadPtr(lp: *const libc::c_void, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn IsBadWritePtr(lp: LPVOID, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn IsBadHugeReadPtr(lp: *const libc::c_void, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn IsBadHugeWritePtr(lp: LPVOID, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn IsBadCodePtr(lpfn: FARPROC) -> BOOL;
}
extern "C" {
  pub fn IsBadStringPtrA(lpsz: LPCSTR, ucchMax: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn IsBadStringPtrW(lpsz: LPCWSTR, ucchMax: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn LookupAccountSidA(
    lpSystemName: LPCSTR, Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR,
    cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountSidW(
    lpSystemName: LPCWSTR, Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR,
    cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountNameA(
    lpSystemName: LPCSTR, lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD,
    ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountNameW(
    lpSystemName: LPCWSTR, lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD,
    ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountNameLocalA(
    lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR,
    cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountNameLocalW(
    lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR,
    cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountSidLocalA(
    Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR,
    cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupAccountSidLocalW(
    Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR,
    cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupPrivilegeValueA(lpSystemName: LPCSTR, lpName: LPCSTR, lpLuid: PLUID) -> BOOL;
}
extern "C" {
  pub fn LookupPrivilegeValueW(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpLuid: PLUID) -> BOOL;
}
extern "C" {
  pub fn LookupPrivilegeNameA(
    lpSystemName: LPCSTR, lpLuid: PLUID, lpName: LPSTR, cchName: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupPrivilegeNameW(
    lpSystemName: LPCWSTR, lpLuid: PLUID, lpName: LPWSTR, cchName: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupPrivilegeDisplayNameA(
    lpSystemName: LPCSTR, lpName: LPCSTR, lpDisplayName: LPSTR, cchDisplayName: LPDWORD,
    lpLanguageId: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LookupPrivilegeDisplayNameW(
    lpSystemName: LPCWSTR, lpName: LPCWSTR, lpDisplayName: LPWSTR, cchDisplayName: LPDWORD,
    lpLanguageId: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn BuildCommDCBA(lpDef: LPCSTR, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
  pub fn BuildCommDCBW(lpDef: LPCWSTR, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
  pub fn BuildCommDCBAndTimeoutsA(
    lpDef: LPCSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS,
  ) -> BOOL;
}
extern "C" {
  pub fn BuildCommDCBAndTimeoutsW(
    lpDef: LPCWSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS,
  ) -> BOOL;
}
extern "C" {
  pub fn CommConfigDialogA(lpszName: LPCSTR, hWnd: HWND, lpCC: LPCOMMCONFIG) -> BOOL;
}
extern "C" {
  pub fn CommConfigDialogW(lpszName: LPCWSTR, hWnd: HWND, lpCC: LPCOMMCONFIG) -> BOOL;
}
extern "C" {
  pub fn GetDefaultCommConfigA(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetDefaultCommConfigW(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SetDefaultCommConfigA(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetDefaultCommConfigW(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetComputerNameA(lpBuffer: LPSTR, nSize: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetComputerNameW(lpBuffer: LPWSTR, nSize: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn DnsHostnameToComputerNameA(Hostname: LPCSTR, ComputerName: LPSTR, nSize: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn DnsHostnameToComputerNameW(
    Hostname: LPCWSTR, ComputerName: LPWSTR, nSize: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUserNameA(lpBuffer: LPSTR, pcbBuffer: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetUserNameW(lpBuffer: LPWSTR, pcbBuffer: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn LogonUserA(
    lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD,
    dwLogonProvider: DWORD, phToken: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn LogonUserW(
    lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD,
    dwLogonProvider: DWORD, phToken: PHANDLE,
  ) -> BOOL;
}
extern "C" {
  pub fn LogonUserExA(
    lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD,
    dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: *mut PSID, ppProfileBuffer: *mut PVOID,
    pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS,
  ) -> BOOL;
}
extern "C" {
  pub fn LogonUserExW(
    lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD,
    dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: *mut PSID, ppProfileBuffer: *mut PVOID,
    pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateProcessWithLogonW(
    lpUsername: LPCWSTR, lpDomain: LPCWSTR, lpPassword: LPCWSTR, dwLogonFlags: DWORD,
    lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, dwCreationFlags: DWORD,
    lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW,
    lpProcessInformation: LPPROCESS_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateProcessWithTokenW(
    hToken: HANDLE, dwLogonFlags: DWORD, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR,
    dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR,
    lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn IsTokenUntrusted(TokenHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn RegisterWaitForSingleObject(
    phNewWaitObject: PHANDLE, hObject: HANDLE, Callback: WAITORTIMERCALLBACK, Context: PVOID,
    dwMilliseconds: ULONG, dwFlags: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn UnregisterWait(WaitHandle: HANDLE) -> BOOL;
}
extern "C" {
  pub fn BindIoCompletionCallback(
    FileHandle: HANDLE, Function: LPOVERLAPPED_COMPLETION_ROUTINE, Flags: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetTimerQueueTimer(
    TimerQueue: HANDLE, Callback: WAITORTIMERCALLBACK, Parameter: PVOID, DueTime: DWORD,
    Period: DWORD, PreferIo: BOOL,
  ) -> HANDLE;
}
extern "C" {
  pub fn CancelTimerQueueTimer(TimerQueue: HANDLE, Timer: HANDLE) -> BOOL;
}
extern "C" {
  pub fn DeleteTimerQueue(TimerQueue: HANDLE) -> BOOL;
}
extern "C" {
  pub fn CreatePrivateNamespaceA(
    lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID,
    lpAliasPrefix: LPCSTR,
  ) -> HANDLE;
}
extern "C" {
  pub fn OpenPrivateNamespaceA(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn CreateBoundaryDescriptorA(Name: LPCSTR, Flags: ULONG) -> HANDLE;
}
extern "C" {
  pub fn AddIntegrityLabelToBoundaryDescriptor(
    BoundaryDescriptor: *mut HANDLE, IntegrityLabel: PSID,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagHW_PROFILE_INFOA {
  pub dwDockInfo: DWORD,
  pub szHwProfileGuid: [CHAR; 39usize],
  pub szHwProfileName: [CHAR; 80usize],
}
#[test]
fn bindgen_test_layout_tagHW_PROFILE_INFOA() {
  assert_eq!(
    ::core::mem::size_of::<tagHW_PROFILE_INFOA>(),
    124usize,
    concat!("Size of: ", stringify!(tagHW_PROFILE_INFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHW_PROFILE_INFOA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagHW_PROFILE_INFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHW_PROFILE_INFOA>())).dwDockInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHW_PROFILE_INFOA),
      "::",
      stringify!(dwDockInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagHW_PROFILE_INFOA>())).szHwProfileGuid as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHW_PROFILE_INFOA),
      "::",
      stringify!(szHwProfileGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagHW_PROFILE_INFOA>())).szHwProfileName as *const _ as usize
    },
    43usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHW_PROFILE_INFOA),
      "::",
      stringify!(szHwProfileName)
    )
  );
}
impl Default for tagHW_PROFILE_INFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagHW_PROFILE_INFOA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagHW_PROFILE_INFOA {{ dwDockInfo: {:?}, szHwProfileGuid: [...], szHwProfileName: [...] }}",
      self.dwDockInfo
    )
  }
}
impl ::core::cmp::PartialEq for tagHW_PROFILE_INFOA {
  fn eq(&self, other: &tagHW_PROFILE_INFOA) -> bool {
    self.dwDockInfo == other.dwDockInfo
      && &self.szHwProfileGuid[..] == &other.szHwProfileGuid[..]
      && &self.szHwProfileName[..] == &other.szHwProfileName[..]
  }
}
pub type HW_PROFILE_INFOA = tagHW_PROFILE_INFOA;
pub type LPHW_PROFILE_INFOA = *mut tagHW_PROFILE_INFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagHW_PROFILE_INFOW {
  pub dwDockInfo: DWORD,
  pub szHwProfileGuid: [WCHAR; 39usize],
  pub szHwProfileName: [WCHAR; 80usize],
}
#[test]
fn bindgen_test_layout_tagHW_PROFILE_INFOW() {
  assert_eq!(
    ::core::mem::size_of::<tagHW_PROFILE_INFOW>(),
    244usize,
    concat!("Size of: ", stringify!(tagHW_PROFILE_INFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHW_PROFILE_INFOW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagHW_PROFILE_INFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHW_PROFILE_INFOW>())).dwDockInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHW_PROFILE_INFOW),
      "::",
      stringify!(dwDockInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagHW_PROFILE_INFOW>())).szHwProfileGuid as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHW_PROFILE_INFOW),
      "::",
      stringify!(szHwProfileGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagHW_PROFILE_INFOW>())).szHwProfileName as *const _ as usize
    },
    82usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHW_PROFILE_INFOW),
      "::",
      stringify!(szHwProfileName)
    )
  );
}
impl Default for tagHW_PROFILE_INFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagHW_PROFILE_INFOW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagHW_PROFILE_INFOW {{ dwDockInfo: {:?}, szHwProfileGuid: [...], szHwProfileName: [...] }}",
      self.dwDockInfo
    )
  }
}
impl ::core::cmp::PartialEq for tagHW_PROFILE_INFOW {
  fn eq(&self, other: &tagHW_PROFILE_INFOW) -> bool {
    self.dwDockInfo == other.dwDockInfo
      && &self.szHwProfileGuid[..] == &other.szHwProfileGuid[..]
      && &self.szHwProfileName[..] == &other.szHwProfileName[..]
  }
}
pub type HW_PROFILE_INFOW = tagHW_PROFILE_INFOW;
pub type LPHW_PROFILE_INFOW = *mut tagHW_PROFILE_INFOW;
pub type HW_PROFILE_INFO = HW_PROFILE_INFOA;
pub type LPHW_PROFILE_INFO = LPHW_PROFILE_INFOA;
extern "C" {
  pub fn GetCurrentHwProfileA(lpHwProfileInfo: LPHW_PROFILE_INFOA) -> BOOL;
}
extern "C" {
  pub fn GetCurrentHwProfileW(lpHwProfileInfo: LPHW_PROFILE_INFOW) -> BOOL;
}
extern "C" {
  pub fn VerifyVersionInfoA(
    lpVersionInformation: LPOSVERSIONINFOEXA, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG,
  ) -> BOOL;
}
extern "C" {
  pub fn VerifyVersionInfoW(
    lpVersionInformation: LPOSVERSIONINFOEXW, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TIME_ZONE_INFORMATION {
  pub Bias: LONG,
  pub StandardName: [WCHAR; 32usize],
  pub StandardDate: SYSTEMTIME,
  pub StandardBias: LONG,
  pub DaylightName: [WCHAR; 32usize],
  pub DaylightDate: SYSTEMTIME,
  pub DaylightBias: LONG,
}
#[test]
fn bindgen_test_layout__TIME_ZONE_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TIME_ZONE_INFORMATION>(),
    172usize,
    concat!("Size of: ", stringify!(_TIME_ZONE_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TIME_ZONE_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_TIME_ZONE_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).Bias as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(Bias)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).StandardName as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(StandardName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).StandardDate as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(StandardDate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).StandardBias as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(StandardBias)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).DaylightName as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(DaylightName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).DaylightDate as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(DaylightDate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_ZONE_INFORMATION>())).DaylightBias as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_ZONE_INFORMATION),
      "::",
      stringify!(DaylightBias)
    )
  );
}
pub type TIME_ZONE_INFORMATION = _TIME_ZONE_INFORMATION;
pub type PTIME_ZONE_INFORMATION = *mut _TIME_ZONE_INFORMATION;
pub type LPTIME_ZONE_INFORMATION = *mut _TIME_ZONE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIME_DYNAMIC_ZONE_INFORMATION {
  pub Bias: LONG,
  pub StandardName: [WCHAR; 32usize],
  pub StandardDate: SYSTEMTIME,
  pub StandardBias: LONG,
  pub DaylightName: [WCHAR; 32usize],
  pub DaylightDate: SYSTEMTIME,
  pub DaylightBias: LONG,
  pub TimeZoneKeyName: [WCHAR; 128usize],
  pub DynamicDaylightTimeDisabled: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TIME_DYNAMIC_ZONE_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_TIME_DYNAMIC_ZONE_INFORMATION>(),
    432usize,
    concat!("Size of: ", stringify!(_TIME_DYNAMIC_ZONE_INFORMATION))
  );
  assert_eq!(
    ::core::mem::align_of::<_TIME_DYNAMIC_ZONE_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_TIME_DYNAMIC_ZONE_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).Bias as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(Bias)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).StandardName as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(StandardName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).StandardDate as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(StandardDate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).StandardBias as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(StandardBias)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).DaylightName as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(DaylightName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).DaylightDate as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(DaylightDate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).DaylightBias as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(DaylightBias)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).TimeZoneKeyName as *const _
        as usize
    },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(TimeZoneKeyName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_TIME_DYNAMIC_ZONE_INFORMATION>())).DynamicDaylightTimeDisabled
        as *const _ as usize
    },
    428usize,
    concat!(
      "Offset of field: ",
      stringify!(_TIME_DYNAMIC_ZONE_INFORMATION),
      "::",
      stringify!(DynamicDaylightTimeDisabled)
    )
  );
}
impl Default for _TIME_DYNAMIC_ZONE_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _TIME_DYNAMIC_ZONE_INFORMATION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_TIME_DYNAMIC_ZONE_INFORMATION {{ Bias: {:?}, StandardName: [...], StandardDate: {:?}, StandardBias: {:?}, DaylightName: [...], DaylightDate: {:?}, DaylightBias: {:?}, TimeZoneKeyName: [...], DynamicDaylightTimeDisabled: {:?} }}" , self . Bias , self . StandardDate , self . StandardBias , self . DaylightDate , self . DaylightBias , self . DynamicDaylightTimeDisabled )
  }
}
impl ::core::cmp::PartialEq for _TIME_DYNAMIC_ZONE_INFORMATION {
  fn eq(&self, other: &_TIME_DYNAMIC_ZONE_INFORMATION) -> bool {
    self.Bias == other.Bias
      && self.StandardName == other.StandardName
      && self.StandardDate == other.StandardDate
      && self.StandardBias == other.StandardBias
      && self.DaylightName == other.DaylightName
      && self.DaylightDate == other.DaylightDate
      && self.DaylightBias == other.DaylightBias
      && &self.TimeZoneKeyName[..] == &other.TimeZoneKeyName[..]
      && self.DynamicDaylightTimeDisabled == other.DynamicDaylightTimeDisabled
  }
}
pub type DYNAMIC_TIME_ZONE_INFORMATION = _TIME_DYNAMIC_ZONE_INFORMATION;
pub type PDYNAMIC_TIME_ZONE_INFORMATION = *mut _TIME_DYNAMIC_ZONE_INFORMATION;
extern "C" {
  pub fn SystemTimeToTzSpecificLocalTime(
    lpTimeZoneInformation: *const TIME_ZONE_INFORMATION, lpUniversalTime: *const SYSTEMTIME,
    lpLocalTime: LPSYSTEMTIME,
  ) -> BOOL;
}
extern "C" {
  pub fn TzSpecificLocalTimeToSystemTime(
    lpTimeZoneInformation: *const TIME_ZONE_INFORMATION, lpLocalTime: *const SYSTEMTIME,
    lpUniversalTime: LPSYSTEMTIME,
  ) -> BOOL;
}
extern "C" {
  pub fn FileTimeToSystemTime(lpFileTime: *const FILETIME, lpSystemTime: LPSYSTEMTIME) -> BOOL;
}
extern "C" {
  pub fn SystemTimeToFileTime(lpSystemTime: *const SYSTEMTIME, lpFileTime: LPFILETIME) -> BOOL;
}
extern "C" {
  pub fn GetTimeZoneInformation(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION) -> DWORD;
}
extern "C" {
  pub fn SetTimeZoneInformation(lpTimeZoneInformation: *const TIME_ZONE_INFORMATION) -> BOOL;
}
extern "C" {
  pub fn SetDynamicTimeZoneInformation(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDynamicTimeZoneInformation(
    pTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION,
  ) -> DWORD;
}
extern "C" {
  pub fn GetTimeZoneInformationForYear(
    wYear: USHORT, pdtzi: PDYNAMIC_TIME_ZONE_INFORMATION, ptzi: LPTIME_ZONE_INFORMATION,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDynamicTimeZoneInformation(
    dwIndex: DWORD, lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION,
  ) -> DWORD;
}
extern "C" {
  pub fn GetDynamicTimeZoneInformationEffectiveYears(
    lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION, FirstYear: LPDWORD, LastYear: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SystemTimeToTzSpecificLocalTimeEx(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
    lpUniversalTime: *const SYSTEMTIME, lpLocalTime: LPSYSTEMTIME,
  ) -> BOOL;
}
extern "C" {
  pub fn TzSpecificLocalTimeToSystemTimeEx(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION, lpLocalTime: *const SYSTEMTIME,
    lpUniversalTime: LPSYSTEMTIME,
  ) -> BOOL;
}
extern "C" {
  pub fn SetSystemPowerState(fSuspend: BOOL, fForce: BOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SYSTEM_POWER_STATUS {
  pub ACLineStatus: BYTE,
  pub BatteryFlag: BYTE,
  pub BatteryLifePercent: BYTE,
  pub SystemStatusFlag: BYTE,
  pub BatteryLifeTime: DWORD,
  pub BatteryFullLifeTime: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATUS() {
  assert_eq!(
    ::core::mem::size_of::<_SYSTEM_POWER_STATUS>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_POWER_STATUS))
  );
  assert_eq!(
    ::core::mem::align_of::<_SYSTEM_POWER_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_STATUS>())).ACLineStatus as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(ACLineStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryFlag as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryFlag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryLifePercent as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryLifePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_STATUS>())).SystemStatusFlag as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(SystemStatusFlag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryLifeTime as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryLifeTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryFullLifeTime as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryFullLifeTime)
    )
  );
}
pub type SYSTEM_POWER_STATUS = _SYSTEM_POWER_STATUS;
pub type LPSYSTEM_POWER_STATUS = *mut _SYSTEM_POWER_STATUS;
extern "C" {
  pub fn GetSystemPowerStatus(lpSystemPowerStatus: LPSYSTEM_POWER_STATUS) -> BOOL;
}
extern "C" {
  pub fn MapUserPhysicalPagesScatter(
    VirtualAddresses: *mut PVOID, NumberOfPages: ULONG_PTR, PageArray: PULONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateJobObjectA(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn OpenJobObjectA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn CreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) -> BOOL;
}
extern "C" {
  pub fn FindFirstVolumeA(lpszVolumeName: LPSTR, cchBufferLength: DWORD) -> HANDLE;
}
extern "C" {
  pub fn FindNextVolumeA(
    hFindVolume: HANDLE, lpszVolumeName: LPSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FindFirstVolumeMountPointA(
    lpszRootPathName: LPCSTR, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindFirstVolumeMountPointW(
    lpszRootPathName: LPCWSTR, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn FindNextVolumeMountPointA(
    hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FindNextVolumeMountPointW(
    hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FindVolumeMountPointClose(hFindVolumeMountPoint: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetVolumeMountPointA(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn DeleteVolumeMountPointA(lpszVolumeMountPoint: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn GetVolumeNameForVolumeMountPointA(
    lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetVolumePathNameA(
    lpszFileName: LPCSTR, lpszVolumePathName: LPSTR, cchBufferLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetVolumePathNamesForVolumeNameA(
    lpszVolumeName: LPCSTR, lpszVolumePathNames: LPCH, cchBufferLength: DWORD,
    lpcchReturnLength: PDWORD,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagACTCTXA {
  pub cbSize: ULONG,
  pub dwFlags: DWORD,
  pub lpSource: LPCSTR,
  pub wProcessorArchitecture: USHORT,
  pub wLangId: LANGID,
  pub lpAssemblyDirectory: LPCSTR,
  pub lpResourceName: LPCSTR,
  pub lpApplicationName: LPCSTR,
  pub hModule: HMODULE,
}
#[test]
fn bindgen_test_layout_tagACTCTXA() {
  assert_eq!(
    ::core::mem::size_of::<tagACTCTXA>(),
    56usize,
    concat!("Size of: ", stringify!(tagACTCTXA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagACTCTXA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagACTCTXA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).lpSource as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(lpSource)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).wProcessorArchitecture as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(wProcessorArchitecture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).wLangId as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(wLangId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).lpAssemblyDirectory as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(lpAssemblyDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).lpResourceName as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(lpResourceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).lpApplicationName as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(lpApplicationName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXA>())).hModule as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXA),
      "::",
      stringify!(hModule)
    )
  );
}
impl Default for tagACTCTXA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTCTXA = tagACTCTXA;
pub type PACTCTXA = *mut tagACTCTXA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagACTCTXW {
  pub cbSize: ULONG,
  pub dwFlags: DWORD,
  pub lpSource: LPCWSTR,
  pub wProcessorArchitecture: USHORT,
  pub wLangId: LANGID,
  pub lpAssemblyDirectory: LPCWSTR,
  pub lpResourceName: LPCWSTR,
  pub lpApplicationName: LPCWSTR,
  pub hModule: HMODULE,
}
#[test]
fn bindgen_test_layout_tagACTCTXW() {
  assert_eq!(
    ::core::mem::size_of::<tagACTCTXW>(),
    56usize,
    concat!("Size of: ", stringify!(tagACTCTXW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagACTCTXW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagACTCTXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).lpSource as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(lpSource)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).wProcessorArchitecture as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(wProcessorArchitecture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).wLangId as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(wLangId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).lpAssemblyDirectory as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(lpAssemblyDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).lpResourceName as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(lpResourceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).lpApplicationName as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(lpApplicationName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACTCTXW>())).hModule as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTXW),
      "::",
      stringify!(hModule)
    )
  );
}
impl Default for tagACTCTXW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTCTXW = tagACTCTXW;
pub type PACTCTXW = *mut tagACTCTXW;
pub type ACTCTX = ACTCTXA;
pub type PACTCTX = PACTCTXA;
pub type PCACTCTXA = *const ACTCTXA;
pub type PCACTCTXW = *const ACTCTXW;
pub type PCACTCTX = PCACTCTXA;
extern "C" {
  pub fn CreateActCtxA(pActCtx: PCACTCTXA) -> HANDLE;
}
extern "C" {
  pub fn CreateActCtxW(pActCtx: PCACTCTXW) -> HANDLE;
}
extern "C" {
  pub fn AddRefActCtx(hActCtx: HANDLE);
}
extern "C" {
  pub fn ReleaseActCtx(hActCtx: HANDLE);
}
extern "C" {
  pub fn ZombifyActCtx(hActCtx: HANDLE) -> BOOL;
}
extern "C" {
  pub fn ActivateActCtx(hActCtx: HANDLE, lpCookie: *mut ULONG_PTR) -> BOOL;
}
extern "C" {
  pub fn DeactivateActCtx(dwFlags: DWORD, ulCookie: ULONG_PTR) -> BOOL;
}
extern "C" {
  pub fn GetCurrentActCtx(lphActCtx: *mut HANDLE) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagACTCTX_SECTION_KEYED_DATA_2600 {
  pub cbSize: ULONG,
  pub ulDataFormatVersion: ULONG,
  pub lpData: PVOID,
  pub ulLength: ULONG,
  pub lpSectionGlobalData: PVOID,
  pub ulSectionGlobalDataLength: ULONG,
  pub lpSectionBase: PVOID,
  pub ulSectionTotalLength: ULONG,
  pub hActCtx: HANDLE,
  pub ulAssemblyRosterIndex: ULONG,
}
#[test]
fn bindgen_test_layout_tagACTCTX_SECTION_KEYED_DATA_2600() {
  assert_eq!(
    ::core::mem::size_of::<tagACTCTX_SECTION_KEYED_DATA_2600>(),
    72usize,
    concat!("Size of: ", stringify!(tagACTCTX_SECTION_KEYED_DATA_2600))
  );
  assert_eq!(
    ::core::mem::align_of::<tagACTCTX_SECTION_KEYED_DATA_2600>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).cbSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).ulDataFormatVersion as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(ulDataFormatVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).lpData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(lpData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).ulLength as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(ulLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).lpSectionGlobalData as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(lpSectionGlobalData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).ulSectionGlobalDataLength
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(ulSectionGlobalDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).lpSectionBase as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(lpSectionBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).ulSectionTotalLength
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(ulSectionTotalLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).hActCtx as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(hActCtx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_2600>())).ulAssemblyRosterIndex
        as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_2600),
      "::",
      stringify!(ulAssemblyRosterIndex)
    )
  );
}
impl Default for tagACTCTX_SECTION_KEYED_DATA_2600 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTCTX_SECTION_KEYED_DATA_2600 = tagACTCTX_SECTION_KEYED_DATA_2600;
pub type PACTCTX_SECTION_KEYED_DATA_2600 = *mut tagACTCTX_SECTION_KEYED_DATA_2600;
pub type PCACTCTX_SECTION_KEYED_DATA_2600 = *const ACTCTX_SECTION_KEYED_DATA_2600;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
  pub lpInformation: PVOID,
  pub lpSectionBase: PVOID,
  pub ulSectionLength: ULONG,
  pub lpSectionGlobalDataBase: PVOID,
  pub ulSectionGlobalDataLength: ULONG,
}
#[test]
fn bindgen_test_layout_tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA() {
  assert_eq!(
    ::core::mem::size_of::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>())).lpInformation
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA),
      "::",
      stringify!(lpInformation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>())).lpSectionBase
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA),
      "::",
      stringify!(lpSectionBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>())).ulSectionLength
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA),
      "::",
      stringify!(ulSectionLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>()))
        .lpSectionGlobalDataBase as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA),
      "::",
      stringify!(lpSectionGlobalDataBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA>()))
        .ulSectionGlobalDataLength as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA),
      "::",
      stringify!(ulSectionGlobalDataLength)
    )
  );
}
impl Default for tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
  tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub type PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
  *mut tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub type PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
  *const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagACTCTX_SECTION_KEYED_DATA {
  pub cbSize: ULONG,
  pub ulDataFormatVersion: ULONG,
  pub lpData: PVOID,
  pub ulLength: ULONG,
  pub lpSectionGlobalData: PVOID,
  pub ulSectionGlobalDataLength: ULONG,
  pub lpSectionBase: PVOID,
  pub ulSectionTotalLength: ULONG,
  pub hActCtx: HANDLE,
  pub ulAssemblyRosterIndex: ULONG,
  pub ulFlags: ULONG,
  pub AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
}
#[test]
fn bindgen_test_layout_tagACTCTX_SECTION_KEYED_DATA() {
  assert_eq!(
    ::core::mem::size_of::<tagACTCTX_SECTION_KEYED_DATA>(),
    112usize,
    concat!("Size of: ", stringify!(tagACTCTX_SECTION_KEYED_DATA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagACTCTX_SECTION_KEYED_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagACTCTX_SECTION_KEYED_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).cbSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).ulDataFormatVersion as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(ulDataFormatVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).lpData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(lpData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).ulLength as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(ulLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).lpSectionGlobalData as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(lpSectionGlobalData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).ulSectionGlobalDataLength
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(ulSectionGlobalDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).lpSectionBase as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(lpSectionBase)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).ulSectionTotalLength as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(ulSectionTotalLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).hActCtx as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(hActCtx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).ulAssemblyRosterIndex as *const _
        as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(ulAssemblyRosterIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).ulFlags as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(ulFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagACTCTX_SECTION_KEYED_DATA>())).AssemblyMetadata as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACTCTX_SECTION_KEYED_DATA),
      "::",
      stringify!(AssemblyMetadata)
    )
  );
}
impl Default for tagACTCTX_SECTION_KEYED_DATA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTCTX_SECTION_KEYED_DATA = tagACTCTX_SECTION_KEYED_DATA;
pub type PACTCTX_SECTION_KEYED_DATA = *mut tagACTCTX_SECTION_KEYED_DATA;
pub type PCACTCTX_SECTION_KEYED_DATA = *const ACTCTX_SECTION_KEYED_DATA;
extern "C" {
  pub fn FindActCtxSectionStringA(
    dwFlags: DWORD, lpExtensionGuid: *const GUID, ulSectionId: ULONG, lpStringToFind: LPCSTR,
    ReturnedData: PACTCTX_SECTION_KEYED_DATA,
  ) -> BOOL;
}
extern "C" {
  pub fn FindActCtxSectionStringW(
    dwFlags: DWORD, lpExtensionGuid: *const GUID, ulSectionId: ULONG, lpStringToFind: LPCWSTR,
    ReturnedData: PACTCTX_SECTION_KEYED_DATA,
  ) -> BOOL;
}
extern "C" {
  pub fn FindActCtxSectionGuid(
    dwFlags: DWORD, lpExtensionGuid: *const GUID, ulSectionId: ULONG, lpGuidToFind: *const GUID,
    ReturnedData: PACTCTX_SECTION_KEYED_DATA,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
  pub hActCtx: HANDLE,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_BASIC_INFORMATION() {
  assert_eq!(
    ::core::mem::size_of::<_ACTIVATION_CONTEXT_BASIC_INFORMATION>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_ACTIVATION_CONTEXT_BASIC_INFORMATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_ACTIVATION_CONTEXT_BASIC_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_ACTIVATION_CONTEXT_BASIC_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_BASIC_INFORMATION>())).hActCtx as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_BASIC_INFORMATION),
      "::",
      stringify!(hActCtx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ACTIVATION_CONTEXT_BASIC_INFORMATION>())).dwFlags as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACTIVATION_CONTEXT_BASIC_INFORMATION),
      "::",
      stringify!(dwFlags)
    )
  );
}
impl Default for _ACTIVATION_CONTEXT_BASIC_INFORMATION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ACTIVATION_CONTEXT_BASIC_INFORMATION = _ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub type PACTIVATION_CONTEXT_BASIC_INFORMATION = *mut _ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub type PCACTIVATION_CONTEXT_BASIC_INFORMATION = *const _ACTIVATION_CONTEXT_BASIC_INFORMATION;
extern "C" {
  pub fn QueryActCtxW(
    dwFlags: DWORD, hActCtx: HANDLE, pvSubInstance: PVOID, ulInfoClass: ULONG, pvBuffer: PVOID,
    cbBuffer: SIZE_T, pcbWrittenOrRequired: *mut SIZE_T,
  ) -> BOOL;
}
pub type PQUERYACTCTXW_FUNC = ::core::option::Option<
  unsafe extern "C" fn(
    dwFlags: DWORD,
    hActCtx: HANDLE,
    pvSubInstance: PVOID,
    ulInfoClass: ULONG,
    pvBuffer: PVOID,
    cbBuffer: SIZE_T,
    pcbWrittenOrRequired: *mut SIZE_T,
  ) -> BOOL,
>;
extern "C" {
  pub fn WTSGetActiveConsoleSessionId() -> DWORD;
}
extern "C" {
  pub fn WTSGetServiceSessionId() -> DWORD;
}
extern "C" {
  pub fn WTSIsServerContainer() -> BOOLEAN;
}
extern "C" {
  pub fn GetActiveProcessorGroupCount() -> WORD;
}
extern "C" {
  pub fn GetMaximumProcessorGroupCount() -> WORD;
}
extern "C" {
  pub fn GetActiveProcessorCount(GroupNumber: WORD) -> DWORD;
}
extern "C" {
  pub fn GetMaximumProcessorCount(GroupNumber: WORD) -> DWORD;
}
extern "C" {
  pub fn GetNumaProcessorNode(Processor: UCHAR, NodeNumber: PUCHAR) -> BOOL;
}
extern "C" {
  pub fn GetNumaNodeNumberFromHandle(hFile: HANDLE, NodeNumber: PUSHORT) -> BOOL;
}
extern "C" {
  pub fn GetNumaProcessorNodeEx(Processor: PPROCESSOR_NUMBER, NodeNumber: PUSHORT) -> BOOL;
}
extern "C" {
  pub fn GetNumaNodeProcessorMask(Node: UCHAR, ProcessorMask: PULONGLONG) -> BOOL;
}
extern "C" {
  pub fn GetNumaAvailableMemoryNode(Node: UCHAR, AvailableBytes: PULONGLONG) -> BOOL;
}
extern "C" {
  pub fn GetNumaAvailableMemoryNodeEx(Node: USHORT, AvailableBytes: PULONGLONG) -> BOOL;
}
extern "C" {
  pub fn GetNumaProximityNode(ProximityId: ULONG, NodeNumber: PUCHAR) -> BOOL;
}
pub type APPLICATION_RECOVERY_CALLBACK =
  ::core::option::Option<unsafe extern "C" fn(pvParameter: PVOID) -> DWORD>;
extern "C" {
  pub fn RegisterApplicationRecoveryCallback(
    pRecoveyCallback: APPLICATION_RECOVERY_CALLBACK, pvParameter: PVOID, dwPingInterval: DWORD,
    dwFlags: DWORD,
  ) -> HRESULT;
}
extern "C" {
  pub fn UnregisterApplicationRecoveryCallback() -> HRESULT;
}
extern "C" {
  pub fn RegisterApplicationRestart(pwzCommandline: PCWSTR, dwFlags: DWORD) -> HRESULT;
}
extern "C" {
  pub fn UnregisterApplicationRestart() -> HRESULT;
}
extern "C" {
  pub fn GetApplicationRecoveryCallback(
    hProcess: HANDLE, pRecoveryCallback: *mut APPLICATION_RECOVERY_CALLBACK,
    ppvParameter: *mut PVOID, pdwPingInterval: PDWORD, pdwFlags: PDWORD,
  ) -> HRESULT;
}
extern "C" {
  pub fn GetApplicationRestartSettings(
    hProcess: HANDLE, pwzCommandline: PWSTR, pcchSize: PDWORD, pdwFlags: PDWORD,
  ) -> HRESULT;
}
extern "C" {
  pub fn ApplicationRecoveryInProgress(pbCancelled: PBOOL) -> HRESULT;
}
extern "C" {
  pub fn ApplicationRecoveryFinished(bSuccess: BOOL);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFO {
  pub CreationTime: LARGE_INTEGER,
  pub LastAccessTime: LARGE_INTEGER,
  pub LastWriteTime: LARGE_INTEGER,
  pub ChangeTime: LARGE_INTEGER,
  pub FileAttributes: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_BASIC_INFO>(),
    40usize,
    concat!("Size of: ", stringify!(_FILE_BASIC_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_BASIC_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_BASIC_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFO>())).CreationTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_BASIC_INFO),
      "::",
      stringify!(CreationTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFO>())).LastAccessTime as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_BASIC_INFO),
      "::",
      stringify!(LastAccessTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFO>())).LastWriteTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_BASIC_INFO),
      "::",
      stringify!(LastWriteTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFO>())).ChangeTime as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_BASIC_INFO),
      "::",
      stringify!(ChangeTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFO>())).FileAttributes as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_BASIC_INFO),
      "::",
      stringify!(FileAttributes)
    )
  );
}
impl Default for _FILE_BASIC_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_BASIC_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_BASIC_INFO {{ CreationTime: {:?}, LastAccessTime: {:?}, LastWriteTime: {:?}, ChangeTime: {:?}, FileAttributes: {:?} }}" , self . CreationTime , self . LastAccessTime , self . LastWriteTime , self . ChangeTime , self . FileAttributes )
  }
}
pub type FILE_BASIC_INFO = _FILE_BASIC_INFO;
pub type PFILE_BASIC_INFO = *mut _FILE_BASIC_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFO {
  pub AllocationSize: LARGE_INTEGER,
  pub EndOfFile: LARGE_INTEGER,
  pub NumberOfLinks: DWORD,
  pub DeletePending: BOOLEAN,
  pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_STANDARD_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_FILE_STANDARD_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_STANDARD_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_STANDARD_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFO>())).AllocationSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STANDARD_INFO),
      "::",
      stringify!(AllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFO>())).EndOfFile as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STANDARD_INFO),
      "::",
      stringify!(EndOfFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFO>())).NumberOfLinks as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STANDARD_INFO),
      "::",
      stringify!(NumberOfLinks)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFO>())).DeletePending as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STANDARD_INFO),
      "::",
      stringify!(DeletePending)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFO>())).Directory as *const _ as usize },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STANDARD_INFO),
      "::",
      stringify!(Directory)
    )
  );
}
impl Default for _FILE_STANDARD_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_STANDARD_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_STANDARD_INFO {{ AllocationSize: {:?}, EndOfFile: {:?}, NumberOfLinks: {:?}, DeletePending: {:?}, Directory: {:?} }}" , self . AllocationSize , self . EndOfFile , self . NumberOfLinks , self . DeletePending , self . Directory )
  }
}
pub type FILE_STANDARD_INFO = _FILE_STANDARD_INFO;
pub type PFILE_STANDARD_INFO = *mut _FILE_STANDARD_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_NAME_INFO {
  pub FileNameLength: DWORD,
  pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAME_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_NAME_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_FILE_NAME_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_NAME_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_NAME_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_NAME_INFO>())).FileNameLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NAME_INFO),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_NAME_INFO>())).FileName as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_NAME_INFO),
      "::",
      stringify!(FileName)
    )
  );
}
pub type FILE_NAME_INFO = _FILE_NAME_INFO;
pub type PFILE_NAME_INFO = *mut _FILE_NAME_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_RENAME_INFO {
  pub __bindgen_anon_1: _FILE_RENAME_INFO__bindgen_ty_1,
  pub RootDirectory: HANDLE,
  pub FileNameLength: DWORD,
  pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_RENAME_INFO__bindgen_ty_1 {
  pub ReplaceIfExists: BOOLEAN,
  pub Flags: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__FILE_RENAME_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_RENAME_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_FILE_RENAME_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_RENAME_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_RENAME_INFO__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_RENAME_INFO__bindgen_ty_1>())).ReplaceIfExists as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_RENAME_INFO__bindgen_ty_1),
      "::",
      stringify!(ReplaceIfExists)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_RENAME_INFO__bindgen_ty_1>())).Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_RENAME_INFO__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
impl Default for _FILE_RENAME_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_RENAME_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_FILE_RENAME_INFO__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__FILE_RENAME_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_RENAME_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_FILE_RENAME_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_RENAME_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_RENAME_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_RENAME_INFO>())).RootDirectory as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_RENAME_INFO),
      "::",
      stringify!(RootDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_RENAME_INFO>())).FileNameLength as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_RENAME_INFO),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_RENAME_INFO>())).FileName as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_RENAME_INFO),
      "::",
      stringify!(FileName)
    )
  );
}
impl Default for _FILE_RENAME_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_RENAME_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_RENAME_INFO {{ __bindgen_anon_1: {:?}, RootDirectory: {:?}, FileNameLength: {:?}, FileName: {:?} }}" , self . __bindgen_anon_1 , self . RootDirectory , self . FileNameLength , self . FileName )
  }
}
pub type FILE_RENAME_INFO = _FILE_RENAME_INFO;
pub type PFILE_RENAME_INFO = *mut _FILE_RENAME_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFO {
  pub AllocationSize: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_ALLOCATION_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ALLOCATION_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_FILE_ALLOCATION_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ALLOCATION_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_ALLOCATION_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ALLOCATION_INFO>())).AllocationSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ALLOCATION_INFO),
      "::",
      stringify!(AllocationSize)
    )
  );
}
impl Default for _FILE_ALLOCATION_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_ALLOCATION_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_FILE_ALLOCATION_INFO {{ AllocationSize: {:?} }}",
      self.AllocationSize
    )
  }
}
pub type FILE_ALLOCATION_INFO = _FILE_ALLOCATION_INFO;
pub type PFILE_ALLOCATION_INFO = *mut _FILE_ALLOCATION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFO {
  pub EndOfFile: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_END_OF_FILE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_END_OF_FILE_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_FILE_END_OF_FILE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_END_OF_FILE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_END_OF_FILE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_END_OF_FILE_INFO>())).EndOfFile as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_END_OF_FILE_INFO),
      "::",
      stringify!(EndOfFile)
    )
  );
}
impl Default for _FILE_END_OF_FILE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_END_OF_FILE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_FILE_END_OF_FILE_INFO {{ EndOfFile: {:?} }}",
      self.EndOfFile
    )
  }
}
pub type FILE_END_OF_FILE_INFO = _FILE_END_OF_FILE_INFO;
pub type PFILE_END_OF_FILE_INFO = *mut _FILE_END_OF_FILE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFO {
  pub NextEntryOffset: DWORD,
  pub StreamNameLength: DWORD,
  pub StreamSize: LARGE_INTEGER,
  pub StreamAllocationSize: LARGE_INTEGER,
  pub StreamName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_STREAM_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_STREAM_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_FILE_STREAM_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_STREAM_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_STREAM_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STREAM_INFO>())).NextEntryOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STREAM_INFO),
      "::",
      stringify!(NextEntryOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STREAM_INFO>())).StreamNameLength as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STREAM_INFO),
      "::",
      stringify!(StreamNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STREAM_INFO>())).StreamSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STREAM_INFO),
      "::",
      stringify!(StreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STREAM_INFO>())).StreamAllocationSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STREAM_INFO),
      "::",
      stringify!(StreamAllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STREAM_INFO>())).StreamName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STREAM_INFO),
      "::",
      stringify!(StreamName)
    )
  );
}
impl Default for _FILE_STREAM_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_STREAM_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_STREAM_INFO {{ NextEntryOffset: {:?}, StreamNameLength: {:?}, StreamSize: {:?}, StreamAllocationSize: {:?}, StreamName: {:?} }}" , self . NextEntryOffset , self . StreamNameLength , self . StreamSize , self . StreamAllocationSize , self . StreamName )
  }
}
pub type FILE_STREAM_INFO = _FILE_STREAM_INFO;
pub type PFILE_STREAM_INFO = *mut _FILE_STREAM_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFO {
  pub CompressedFileSize: LARGE_INTEGER,
  pub CompressionFormat: WORD,
  pub CompressionUnitShift: UCHAR,
  pub ChunkShift: UCHAR,
  pub ClusterShift: UCHAR,
  pub Reserved: [UCHAR; 3usize],
}
#[test]
fn bindgen_test_layout__FILE_COMPRESSION_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_COMPRESSION_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_FILE_COMPRESSION_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_COMPRESSION_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_COMPRESSION_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_COMPRESSION_INFO>())).CompressedFileSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_COMPRESSION_INFO),
      "::",
      stringify!(CompressedFileSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_COMPRESSION_INFO>())).CompressionFormat as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_COMPRESSION_INFO),
      "::",
      stringify!(CompressionFormat)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_COMPRESSION_INFO>())).CompressionUnitShift as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_COMPRESSION_INFO),
      "::",
      stringify!(CompressionUnitShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_COMPRESSION_INFO>())).ChunkShift as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_COMPRESSION_INFO),
      "::",
      stringify!(ChunkShift)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_COMPRESSION_INFO>())).ClusterShift as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_COMPRESSION_INFO),
      "::",
      stringify!(ClusterShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_COMPRESSION_INFO>())).Reserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_COMPRESSION_INFO),
      "::",
      stringify!(Reserved)
    )
  );
}
impl Default for _FILE_COMPRESSION_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_COMPRESSION_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_COMPRESSION_INFO {{ CompressedFileSize: {:?}, CompressionFormat: {:?}, CompressionUnitShift: {:?}, ChunkShift: {:?}, ClusterShift: {:?}, Reserved: {:?} }}" , self . CompressedFileSize , self . CompressionFormat , self . CompressionUnitShift , self . ChunkShift , self . ClusterShift , self . Reserved )
  }
}
pub type FILE_COMPRESSION_INFO = _FILE_COMPRESSION_INFO;
pub type PFILE_COMPRESSION_INFO = *mut _FILE_COMPRESSION_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_ATTRIBUTE_TAG_INFO {
  pub FileAttributes: DWORD,
  pub ReparseTag: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_ATTRIBUTE_TAG_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ATTRIBUTE_TAG_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_FILE_ATTRIBUTE_TAG_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ATTRIBUTE_TAG_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_ATTRIBUTE_TAG_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ATTRIBUTE_TAG_INFO>())).FileAttributes as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ATTRIBUTE_TAG_INFO),
      "::",
      stringify!(FileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ATTRIBUTE_TAG_INFO>())).ReparseTag as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ATTRIBUTE_TAG_INFO),
      "::",
      stringify!(ReparseTag)
    )
  );
}
pub type FILE_ATTRIBUTE_TAG_INFO = _FILE_ATTRIBUTE_TAG_INFO;
pub type PFILE_ATTRIBUTE_TAG_INFO = *mut _FILE_ATTRIBUTE_TAG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_DISPOSITION_INFO {
  pub DeleteFileA: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_DISPOSITION_INFO>(),
    1usize,
    concat!("Size of: ", stringify!(_FILE_DISPOSITION_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_DISPOSITION_INFO>(),
    1usize,
    concat!("Alignment of ", stringify!(_FILE_DISPOSITION_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_DISPOSITION_INFO>())).DeleteFileA as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_DISPOSITION_INFO),
      "::",
      stringify!(DeleteFileA)
    )
  );
}
pub type FILE_DISPOSITION_INFO = _FILE_DISPOSITION_INFO;
pub type PFILE_DISPOSITION_INFO = *mut _FILE_DISPOSITION_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_DISPOSITION_INFO_EX {
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFO_EX() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_DISPOSITION_INFO_EX>(),
    4usize,
    concat!("Size of: ", stringify!(_FILE_DISPOSITION_INFO_EX))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_DISPOSITION_INFO_EX>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_DISPOSITION_INFO_EX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_DISPOSITION_INFO_EX>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_DISPOSITION_INFO_EX),
      "::",
      stringify!(Flags)
    )
  );
}
pub type FILE_DISPOSITION_INFO_EX = _FILE_DISPOSITION_INFO_EX;
pub type PFILE_DISPOSITION_INFO_EX = *mut _FILE_DISPOSITION_INFO_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFO {
  pub NextEntryOffset: DWORD,
  pub FileIndex: DWORD,
  pub CreationTime: LARGE_INTEGER,
  pub LastAccessTime: LARGE_INTEGER,
  pub LastWriteTime: LARGE_INTEGER,
  pub ChangeTime: LARGE_INTEGER,
  pub EndOfFile: LARGE_INTEGER,
  pub AllocationSize: LARGE_INTEGER,
  pub FileAttributes: DWORD,
  pub FileNameLength: DWORD,
  pub EaSize: DWORD,
  pub ShortNameLength: CCHAR,
  pub ShortName: [WCHAR; 12usize],
  pub FileId: LARGE_INTEGER,
  pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_BOTH_DIR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ID_BOTH_DIR_INFO>(),
    112usize,
    concat!("Size of: ", stringify!(_FILE_ID_BOTH_DIR_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ID_BOTH_DIR_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_ID_BOTH_DIR_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).NextEntryOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(NextEntryOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).FileIndex as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(FileIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).CreationTime as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(CreationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).LastAccessTime as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(LastAccessTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).LastWriteTime as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(LastWriteTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).ChangeTime as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(ChangeTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).EndOfFile as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(EndOfFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).AllocationSize as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(AllocationSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).FileAttributes as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(FileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).FileNameLength as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).EaSize as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(EaSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).ShortNameLength as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(ShortNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).ShortName as *const _ as usize },
    70usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(ShortName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).FileId as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(FileId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_BOTH_DIR_INFO>())).FileName as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_BOTH_DIR_INFO),
      "::",
      stringify!(FileName)
    )
  );
}
impl Default for _FILE_ID_BOTH_DIR_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_ID_BOTH_DIR_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_ID_BOTH_DIR_INFO {{ NextEntryOffset: {:?}, FileIndex: {:?}, CreationTime: {:?}, LastAccessTime: {:?}, LastWriteTime: {:?}, ChangeTime: {:?}, EndOfFile: {:?}, AllocationSize: {:?}, FileAttributes: {:?}, FileNameLength: {:?}, EaSize: {:?}, ShortNameLength: {:?}, ShortName: {:?}, FileId: {:?}, FileName: {:?} }}" , self . NextEntryOffset , self . FileIndex , self . CreationTime , self . LastAccessTime , self . LastWriteTime , self . ChangeTime , self . EndOfFile , self . AllocationSize , self . FileAttributes , self . FileNameLength , self . EaSize , self . ShortNameLength , self . ShortName , self . FileId , self . FileName )
  }
}
pub type FILE_ID_BOTH_DIR_INFO = _FILE_ID_BOTH_DIR_INFO;
pub type PFILE_ID_BOTH_DIR_INFO = *mut _FILE_ID_BOTH_DIR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFO {
  pub NextEntryOffset: ULONG,
  pub FileIndex: ULONG,
  pub CreationTime: LARGE_INTEGER,
  pub LastAccessTime: LARGE_INTEGER,
  pub LastWriteTime: LARGE_INTEGER,
  pub ChangeTime: LARGE_INTEGER,
  pub EndOfFile: LARGE_INTEGER,
  pub AllocationSize: LARGE_INTEGER,
  pub FileAttributes: ULONG,
  pub FileNameLength: ULONG,
  pub EaSize: ULONG,
  pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_DIR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_FULL_DIR_INFO>(),
    72usize,
    concat!("Size of: ", stringify!(_FILE_FULL_DIR_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_FULL_DIR_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_FULL_DIR_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).NextEntryOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(NextEntryOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).FileIndex as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(FileIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).CreationTime as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(CreationTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).LastAccessTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(LastAccessTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).LastWriteTime as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(LastWriteTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).ChangeTime as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(ChangeTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).EndOfFile as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(EndOfFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).AllocationSize as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(AllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).FileAttributes as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(FileAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).FileNameLength as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).EaSize as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(EaSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_FULL_DIR_INFO>())).FileName as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_FULL_DIR_INFO),
      "::",
      stringify!(FileName)
    )
  );
}
impl Default for _FILE_FULL_DIR_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_FULL_DIR_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_FULL_DIR_INFO {{ NextEntryOffset: {:?}, FileIndex: {:?}, CreationTime: {:?}, LastAccessTime: {:?}, LastWriteTime: {:?}, ChangeTime: {:?}, EndOfFile: {:?}, AllocationSize: {:?}, FileAttributes: {:?}, FileNameLength: {:?}, EaSize: {:?}, FileName: {:?} }}" , self . NextEntryOffset , self . FileIndex , self . CreationTime , self . LastAccessTime , self . LastWriteTime , self . ChangeTime , self . EndOfFile , self . AllocationSize , self . FileAttributes , self . FileNameLength , self . EaSize , self . FileName )
  }
}
pub type FILE_FULL_DIR_INFO = _FILE_FULL_DIR_INFO;
pub type PFILE_FULL_DIR_INFO = *mut _FILE_FULL_DIR_INFO;
pub mod _PRIORITY_HINT {
  pub type Type = i32;
  pub const IoPriorityHintVeryLow: Type = 0;
  pub const IoPriorityHintLow: Type = 1;
  pub const IoPriorityHintNormal: Type = 2;
  pub const MaximumIoPriorityHintType: Type = 3;
}
pub use self::_PRIORITY_HINT::Type as PRIORITY_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _FILE_IO_PRIORITY_HINT_INFO {
  pub PriorityHint: PRIORITY_HINT,
}
#[test]
fn bindgen_test_layout__FILE_IO_PRIORITY_HINT_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_IO_PRIORITY_HINT_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_FILE_IO_PRIORITY_HINT_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_IO_PRIORITY_HINT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_IO_PRIORITY_HINT_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_IO_PRIORITY_HINT_INFO>())).PriorityHint as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_IO_PRIORITY_HINT_INFO),
      "::",
      stringify!(PriorityHint)
    )
  );
}
impl Default for _FILE_IO_PRIORITY_HINT_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type FILE_IO_PRIORITY_HINT_INFO = _FILE_IO_PRIORITY_HINT_INFO;
pub type PFILE_IO_PRIORITY_HINT_INFO = *mut _FILE_IO_PRIORITY_HINT_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_ALIGNMENT_INFO {
  pub AlignmentRequirement: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ALIGNMENT_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ALIGNMENT_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_FILE_ALIGNMENT_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ALIGNMENT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_ALIGNMENT_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ALIGNMENT_INFO>())).AlignmentRequirement as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ALIGNMENT_INFO),
      "::",
      stringify!(AlignmentRequirement)
    )
  );
}
pub type FILE_ALIGNMENT_INFO = _FILE_ALIGNMENT_INFO;
pub type PFILE_ALIGNMENT_INFO = *mut _FILE_ALIGNMENT_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_STORAGE_INFO {
  pub LogicalBytesPerSector: ULONG,
  pub PhysicalBytesPerSectorForAtomicity: ULONG,
  pub PhysicalBytesPerSectorForPerformance: ULONG,
  pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
  pub Flags: ULONG,
  pub ByteOffsetForSectorAlignment: ULONG,
  pub ByteOffsetForPartitionAlignment: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_STORAGE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_STORAGE_INFO>(),
    28usize,
    concat!("Size of: ", stringify!(_FILE_STORAGE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_STORAGE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_STORAGE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STORAGE_INFO>())).LogicalBytesPerSector as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(LogicalBytesPerSector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STORAGE_INFO>())).PhysicalBytesPerSectorForAtomicity as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(PhysicalBytesPerSectorForAtomicity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STORAGE_INFO>())).PhysicalBytesPerSectorForPerformance
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(PhysicalBytesPerSectorForPerformance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STORAGE_INFO>()))
        .FileSystemEffectivePhysicalBytesPerSectorForAtomicity as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(FileSystemEffectivePhysicalBytesPerSectorForAtomicity)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_STORAGE_INFO>())).Flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STORAGE_INFO>())).ByteOffsetForSectorAlignment as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(ByteOffsetForSectorAlignment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_STORAGE_INFO>())).ByteOffsetForPartitionAlignment as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_STORAGE_INFO),
      "::",
      stringify!(ByteOffsetForPartitionAlignment)
    )
  );
}
pub type FILE_STORAGE_INFO = _FILE_STORAGE_INFO;
pub type PFILE_STORAGE_INFO = *mut _FILE_STORAGE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_ID_INFO {
  pub VolumeSerialNumber: ULONGLONG,
  pub FileId: FILE_ID_128,
}
#[test]
fn bindgen_test_layout__FILE_ID_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ID_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_FILE_ID_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ID_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_ID_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_INFO>())).VolumeSerialNumber as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_INFO),
      "::",
      stringify!(VolumeSerialNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_INFO>())).FileId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_INFO),
      "::",
      stringify!(FileId)
    )
  );
}
pub type FILE_ID_INFO = _FILE_ID_INFO;
pub type PFILE_ID_INFO = *mut _FILE_ID_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_DIR_INFO {
  pub NextEntryOffset: ULONG,
  pub FileIndex: ULONG,
  pub CreationTime: LARGE_INTEGER,
  pub LastAccessTime: LARGE_INTEGER,
  pub LastWriteTime: LARGE_INTEGER,
  pub ChangeTime: LARGE_INTEGER,
  pub EndOfFile: LARGE_INTEGER,
  pub AllocationSize: LARGE_INTEGER,
  pub FileAttributes: ULONG,
  pub FileNameLength: ULONG,
  pub EaSize: ULONG,
  pub ReparsePointTag: ULONG,
  pub FileId: FILE_ID_128,
  pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_EXTD_DIR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_ID_EXTD_DIR_INFO>(),
    96usize,
    concat!("Size of: ", stringify!(_FILE_ID_EXTD_DIR_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_ID_EXTD_DIR_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_FILE_ID_EXTD_DIR_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).NextEntryOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(NextEntryOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).FileIndex as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(FileIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).CreationTime as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(CreationTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).LastAccessTime as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(LastAccessTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).LastWriteTime as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(LastWriteTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).ChangeTime as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(ChangeTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).EndOfFile as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(EndOfFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).AllocationSize as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(AllocationSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).FileAttributes as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(FileAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).FileNameLength as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(FileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).EaSize as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(EaSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).ReparsePointTag as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(ReparsePointTag)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).FileId as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(FileId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_ID_EXTD_DIR_INFO>())).FileName as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_ID_EXTD_DIR_INFO),
      "::",
      stringify!(FileName)
    )
  );
}
impl Default for _FILE_ID_EXTD_DIR_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_ID_EXTD_DIR_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_ID_EXTD_DIR_INFO {{ NextEntryOffset: {:?}, FileIndex: {:?}, CreationTime: {:?}, LastAccessTime: {:?}, LastWriteTime: {:?}, ChangeTime: {:?}, EndOfFile: {:?}, AllocationSize: {:?}, FileAttributes: {:?}, FileNameLength: {:?}, EaSize: {:?}, ReparsePointTag: {:?}, FileId: {:?}, FileName: {:?} }}" , self . NextEntryOffset , self . FileIndex , self . CreationTime , self . LastAccessTime , self . LastWriteTime , self . ChangeTime , self . EndOfFile , self . AllocationSize , self . FileAttributes , self . FileNameLength , self . EaSize , self . ReparsePointTag , self . FileId , self . FileName )
  }
}
pub type FILE_ID_EXTD_DIR_INFO = _FILE_ID_EXTD_DIR_INFO;
pub type PFILE_ID_EXTD_DIR_INFO = *mut _FILE_ID_EXTD_DIR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO {
  pub StructureVersion: USHORT,
  pub StructureSize: USHORT,
  pub Protocol: ULONG,
  pub ProtocolMajorVersion: USHORT,
  pub ProtocolMinorVersion: USHORT,
  pub ProtocolRevision: USHORT,
  pub Reserved: USHORT,
  pub Flags: ULONG,
  pub GenericReserved: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1,
  pub ProtocolSpecific: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1 {
  pub Reserved: [ULONG; 8usize],
}
#[test]
fn bindgen_test_layout__FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1>())).Reserved as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2 {
  pub Smb2: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1,
  pub Reserved: [ULONG; 16usize],
  _bindgen_union_align: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1 {
  pub Server: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
  pub Share: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
  pub Capabilities: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(
      )))
      .Capabilities as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Capabilities)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
  pub Capabilities: ULONG,
  pub CachingFlags: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(
      )))
      .Capabilities as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Capabilities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(
      )))
      .CachingFlags as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(CachingFlags)
    )
  );
}
#[test]
fn bindgen_test_layout__FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1>())).Server
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Server)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1>())).Share
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Share)
    )
  );
}
#[test]
fn bindgen_test_layout__FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2>(),
    64usize,
    concat!(
      "Size of: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2>())).Smb2 as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2),
      "::",
      stringify!(Smb2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2>())).Reserved as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2),
      "::",
      stringify!(Reserved)
    )
  );
}
impl Default for _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__FILE_REMOTE_PROTOCOL_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILE_REMOTE_PROTOCOL_INFO>(),
    116usize,
    concat!("Size of: ", stringify!(_FILE_REMOTE_PROTOCOL_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILE_REMOTE_PROTOCOL_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILE_REMOTE_PROTOCOL_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).StructureVersion as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(StructureVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).StructureSize as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(StructureSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).Protocol as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(Protocol)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).ProtocolMajorVersion as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(ProtocolMajorVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).ProtocolMinorVersion as *const _
        as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(ProtocolMinorVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).ProtocolRevision as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(ProtocolRevision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).Reserved as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).Flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).GenericReserved as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(GenericReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_FILE_REMOTE_PROTOCOL_INFO>())).ProtocolSpecific as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILE_REMOTE_PROTOCOL_INFO),
      "::",
      stringify!(ProtocolSpecific)
    )
  );
}
impl Default for _FILE_REMOTE_PROTOCOL_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _FILE_REMOTE_PROTOCOL_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_FILE_REMOTE_PROTOCOL_INFO {{ StructureVersion: {:?}, StructureSize: {:?}, Protocol: {:?}, ProtocolMajorVersion: {:?}, ProtocolMinorVersion: {:?}, ProtocolRevision: {:?}, Reserved: {:?}, Flags: {:?}, GenericReserved: {:?}, ProtocolSpecific: {:?} }}" , self . StructureVersion , self . StructureSize , self . Protocol , self . ProtocolMajorVersion , self . ProtocolMinorVersion , self . ProtocolRevision , self . Reserved , self . Flags , self . GenericReserved , self . ProtocolSpecific )
  }
}
pub type FILE_REMOTE_PROTOCOL_INFO = _FILE_REMOTE_PROTOCOL_INFO;
pub type PFILE_REMOTE_PROTOCOL_INFO = *mut _FILE_REMOTE_PROTOCOL_INFO;
extern "C" {
  pub fn GetFileInformationByHandleEx(
    hFile: HANDLE, FileInformationClass: FILE_INFO_BY_HANDLE_CLASS, lpFileInformation: LPVOID,
    dwBufferSize: DWORD,
  ) -> BOOL;
}
pub mod _FILE_ID_TYPE {
  pub type Type = i32;
  pub const FileIdType: Type = 0;
  pub const ObjectIdType: Type = 1;
  pub const ExtendedFileIdType: Type = 2;
  pub const MaximumFileIdType: Type = 3;
}
pub use self::_FILE_ID_TYPE::Type as FILE_ID_TYPE;
pub type PFILE_ID_TYPE = *mut _FILE_ID_TYPE::Type;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FILE_ID_DESCRIPTOR {
  pub dwSize: DWORD,
  pub Type: FILE_ID_TYPE,
  pub __bindgen_anon_1: FILE_ID_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FILE_ID_DESCRIPTOR__bindgen_ty_1 {
  pub FileId: LARGE_INTEGER,
  pub ObjectId: GUID,
  pub ExtendedFileId: FILE_ID_128,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_FILE_ID_DESCRIPTOR__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<FILE_ID_DESCRIPTOR__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(FILE_ID_DESCRIPTOR__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<FILE_ID_DESCRIPTOR__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FILE_ID_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<FILE_ID_DESCRIPTOR__bindgen_ty_1>())).FileId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FILE_ID_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(FileId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<FILE_ID_DESCRIPTOR__bindgen_ty_1>())).ObjectId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FILE_ID_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(ObjectId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<FILE_ID_DESCRIPTOR__bindgen_ty_1>())).ExtendedFileId as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FILE_ID_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(ExtendedFileId)
    )
  );
}
impl Default for FILE_ID_DESCRIPTOR__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for FILE_ID_DESCRIPTOR__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "FILE_ID_DESCRIPTOR__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_FILE_ID_DESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<FILE_ID_DESCRIPTOR>(),
    24usize,
    concat!("Size of: ", stringify!(FILE_ID_DESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<FILE_ID_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(FILE_ID_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FILE_ID_DESCRIPTOR>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FILE_ID_DESCRIPTOR),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FILE_ID_DESCRIPTOR>())).Type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(FILE_ID_DESCRIPTOR),
      "::",
      stringify!(Type)
    )
  );
}
impl Default for FILE_ID_DESCRIPTOR {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for FILE_ID_DESCRIPTOR {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "FILE_ID_DESCRIPTOR {{ dwSize: {:?}, Type: {:?}, __bindgen_anon_1: {:?} }}",
      self.dwSize, self.Type, self.__bindgen_anon_1
    )
  }
}
pub type LPFILE_ID_DESCRIPTOR = *mut FILE_ID_DESCRIPTOR;
extern "C" {
  pub fn OpenFileById(
    hVolumeHint: HANDLE, lpFileId: LPFILE_ID_DESCRIPTOR, dwDesiredAccess: DWORD,
    dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwFlagsAndAttributes: DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn CreateSymbolicLinkA(
    lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD,
  ) -> BOOLEAN;
}
extern "C" {
  pub fn CreateSymbolicLinkW(
    lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD,
  ) -> BOOLEAN;
}
extern "C" {
  pub fn QueryActCtxSettingsW(
    dwFlags: DWORD, hActCtx: HANDLE, settingsNameSpace: PCWSTR, settingName: PCWSTR,
    pvBuffer: PWSTR, dwBuffer: SIZE_T, pdwWrittenOrRequired: *mut SIZE_T,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateSymbolicLinkTransactedA(
    lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD, hTransaction: HANDLE,
  ) -> BOOLEAN;
}
extern "C" {
  pub fn CreateSymbolicLinkTransactedW(
    lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD, hTransaction: HANDLE,
  ) -> BOOLEAN;
}
extern "C" {
  pub fn ReplacePartitionUnit(TargetPartition: PWSTR, SparePartition: PWSTR, Flags: ULONG) -> BOOL;
}
extern "C" {
  pub fn AddSecureMemoryCacheCallback(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK) -> BOOL;
}
extern "C" {
  pub fn RemoveSecureMemoryCacheCallback(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK) -> BOOL;
}
extern "C" {
  pub fn CopyContext(Destination: PCONTEXT, ContextFlags: DWORD, Source: PCONTEXT) -> BOOL;
}
extern "C" {
  pub fn InitializeContext(
    Buffer: PVOID, ContextFlags: DWORD, Context: *mut PCONTEXT, ContextLength: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetEnabledXStateFeatures() -> DWORD64;
}
extern "C" {
  pub fn GetXStateFeaturesMask(Context: PCONTEXT, FeatureMask: PDWORD64) -> BOOL;
}
extern "C" {
  pub fn LocateXStateFeature(Context: PCONTEXT, FeatureId: DWORD, Length: PDWORD) -> PVOID;
}
extern "C" {
  pub fn SetXStateFeaturesMask(Context: PCONTEXT, FeatureMask: DWORD64) -> BOOL;
}
extern "C" {
  pub fn EnableThreadProfiling(
    ThreadHandle: HANDLE, Flags: DWORD, HardwareCounters: DWORD64,
    PerformanceDataHandle: *mut HANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn DisableThreadProfiling(PerformanceDataHandle: HANDLE) -> DWORD;
}
extern "C" {
  pub fn QueryThreadProfiling(ThreadHandle: HANDLE, Enabled: PBOOLEAN) -> DWORD;
}
extern "C" {
  pub fn ReadThreadProfilingData(
    PerformanceDataHandle: HANDLE, Flags: DWORD, PerformanceData: PPERFORMANCE_DATA,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _DRAWPATRECT {
  pub ptPosition: POINT,
  pub ptSize: POINT,
  pub wStyle: WORD,
  pub wPattern: WORD,
}
#[test]
fn bindgen_test_layout__DRAWPATRECT() {
  assert_eq!(
    ::core::mem::size_of::<_DRAWPATRECT>(),
    20usize,
    concat!("Size of: ", stringify!(_DRAWPATRECT))
  );
  assert_eq!(
    ::core::mem::align_of::<_DRAWPATRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(_DRAWPATRECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DRAWPATRECT>())).ptPosition as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRAWPATRECT),
      "::",
      stringify!(ptPosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DRAWPATRECT>())).ptSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRAWPATRECT),
      "::",
      stringify!(ptSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DRAWPATRECT>())).wStyle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRAWPATRECT),
      "::",
      stringify!(wStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DRAWPATRECT>())).wPattern as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRAWPATRECT),
      "::",
      stringify!(wPattern)
    )
  );
}
pub type DRAWPATRECT = _DRAWPATRECT;
pub type PDRAWPATRECT = *mut _DRAWPATRECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PSINJECTDATA {
  pub DataBytes: DWORD,
  pub InjectionPoint: WORD,
  pub PageNumber: WORD,
}
#[test]
fn bindgen_test_layout__PSINJECTDATA() {
  assert_eq!(
    ::core::mem::size_of::<_PSINJECTDATA>(),
    8usize,
    concat!("Size of: ", stringify!(_PSINJECTDATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_PSINJECTDATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_PSINJECTDATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSINJECTDATA>())).DataBytes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSINJECTDATA),
      "::",
      stringify!(DataBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSINJECTDATA>())).InjectionPoint as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSINJECTDATA),
      "::",
      stringify!(InjectionPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSINJECTDATA>())).PageNumber as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSINJECTDATA),
      "::",
      stringify!(PageNumber)
    )
  );
}
pub type PSINJECTDATA = _PSINJECTDATA;
pub type PPSINJECTDATA = *mut _PSINJECTDATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PSFEATURE_OUTPUT {
  pub bPageIndependent: BOOL,
  pub bSetPageDevice: BOOL,
}
#[test]
fn bindgen_test_layout__PSFEATURE_OUTPUT() {
  assert_eq!(
    ::core::mem::size_of::<_PSFEATURE_OUTPUT>(),
    8usize,
    concat!("Size of: ", stringify!(_PSFEATURE_OUTPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<_PSFEATURE_OUTPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_PSFEATURE_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_OUTPUT>())).bPageIndependent as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_OUTPUT),
      "::",
      stringify!(bPageIndependent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_OUTPUT>())).bSetPageDevice as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_OUTPUT),
      "::",
      stringify!(bSetPageDevice)
    )
  );
}
pub type PSFEATURE_OUTPUT = _PSFEATURE_OUTPUT;
pub type PPSFEATURE_OUTPUT = *mut _PSFEATURE_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _PSFEATURE_CUSTPAPER {
  pub lOrientation: LONG,
  pub lWidth: LONG,
  pub lHeight: LONG,
  pub lWidthOffset: LONG,
  pub lHeightOffset: LONG,
}
#[test]
fn bindgen_test_layout__PSFEATURE_CUSTPAPER() {
  assert_eq!(
    ::core::mem::size_of::<_PSFEATURE_CUSTPAPER>(),
    20usize,
    concat!("Size of: ", stringify!(_PSFEATURE_CUSTPAPER))
  );
  assert_eq!(
    ::core::mem::align_of::<_PSFEATURE_CUSTPAPER>(),
    4usize,
    concat!("Alignment of ", stringify!(_PSFEATURE_CUSTPAPER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_CUSTPAPER>())).lOrientation as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_CUSTPAPER),
      "::",
      stringify!(lOrientation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_CUSTPAPER>())).lWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_CUSTPAPER),
      "::",
      stringify!(lWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_CUSTPAPER>())).lHeight as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_CUSTPAPER),
      "::",
      stringify!(lHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_CUSTPAPER>())).lWidthOffset as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_CUSTPAPER),
      "::",
      stringify!(lWidthOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_PSFEATURE_CUSTPAPER>())).lHeightOffset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PSFEATURE_CUSTPAPER),
      "::",
      stringify!(lHeightOffset)
    )
  );
}
pub type PSFEATURE_CUSTPAPER = _PSFEATURE_CUSTPAPER;
pub type PPSFEATURE_CUSTPAPER = *mut _PSFEATURE_CUSTPAPER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagXFORM {
  pub eM11: FLOAT,
  pub eM12: FLOAT,
  pub eM21: FLOAT,
  pub eM22: FLOAT,
  pub eDx: FLOAT,
  pub eDy: FLOAT,
}
#[test]
fn bindgen_test_layout_tagXFORM() {
  assert_eq!(
    ::core::mem::size_of::<tagXFORM>(),
    24usize,
    concat!("Size of: ", stringify!(tagXFORM))
  );
  assert_eq!(
    ::core::mem::align_of::<tagXFORM>(),
    4usize,
    concat!("Alignment of ", stringify!(tagXFORM))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagXFORM>())).eM11 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagXFORM),
      "::",
      stringify!(eM11)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagXFORM>())).eM12 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagXFORM),
      "::",
      stringify!(eM12)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagXFORM>())).eM21 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagXFORM),
      "::",
      stringify!(eM21)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagXFORM>())).eM22 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagXFORM),
      "::",
      stringify!(eM22)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagXFORM>())).eDx as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagXFORM),
      "::",
      stringify!(eDx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagXFORM>())).eDy as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagXFORM),
      "::",
      stringify!(eDy)
    )
  );
}
pub type XFORM = tagXFORM;
pub type PXFORM = *mut tagXFORM;
pub type LPXFORM = *mut tagXFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagBITMAP {
  pub bmType: LONG,
  pub bmWidth: LONG,
  pub bmHeight: LONG,
  pub bmWidthBytes: LONG,
  pub bmPlanes: WORD,
  pub bmBitsPixel: WORD,
  pub bmBits: LPVOID,
}
#[test]
fn bindgen_test_layout_tagBITMAP() {
  assert_eq!(
    ::core::mem::size_of::<tagBITMAP>(),
    32usize,
    concat!("Size of: ", stringify!(tagBITMAP))
  );
  assert_eq!(
    ::core::mem::align_of::<tagBITMAP>(),
    8usize,
    concat!("Alignment of ", stringify!(tagBITMAP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmHeight as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmWidthBytes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmWidthBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmPlanes as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmPlanes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmBitsPixel as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmBitsPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAP>())).bmBits as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAP),
      "::",
      stringify!(bmBits)
    )
  );
}
impl Default for tagBITMAP {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type BITMAP = tagBITMAP;
pub type PBITMAP = *mut tagBITMAP;
pub type NPBITMAP = *mut tagBITMAP;
pub type LPBITMAP = *mut tagBITMAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRGBTRIPLE {
  pub rgbtBlue: BYTE,
  pub rgbtGreen: BYTE,
  pub rgbtRed: BYTE,
}
#[test]
fn bindgen_test_layout_tagRGBTRIPLE() {
  assert_eq!(
    ::core::mem::size_of::<tagRGBTRIPLE>(),
    3usize,
    concat!("Size of: ", stringify!(tagRGBTRIPLE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRGBTRIPLE>(),
    1usize,
    concat!("Alignment of ", stringify!(tagRGBTRIPLE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBTRIPLE>())).rgbtBlue as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBTRIPLE),
      "::",
      stringify!(rgbtBlue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBTRIPLE>())).rgbtGreen as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBTRIPLE),
      "::",
      stringify!(rgbtGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBTRIPLE>())).rgbtRed as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBTRIPLE),
      "::",
      stringify!(rgbtRed)
    )
  );
}
pub type RGBTRIPLE = tagRGBTRIPLE;
pub type PRGBTRIPLE = *mut tagRGBTRIPLE;
pub type NPRGBTRIPLE = *mut tagRGBTRIPLE;
pub type LPRGBTRIPLE = *mut tagRGBTRIPLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRGBQUAD {
  pub rgbBlue: BYTE,
  pub rgbGreen: BYTE,
  pub rgbRed: BYTE,
  pub rgbReserved: BYTE,
}
#[test]
fn bindgen_test_layout_tagRGBQUAD() {
  assert_eq!(
    ::core::mem::size_of::<tagRGBQUAD>(),
    4usize,
    concat!("Size of: ", stringify!(tagRGBQUAD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRGBQUAD>(),
    1usize,
    concat!("Alignment of ", stringify!(tagRGBQUAD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBQUAD>())).rgbBlue as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBQUAD),
      "::",
      stringify!(rgbBlue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBQUAD>())).rgbGreen as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBQUAD),
      "::",
      stringify!(rgbGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBQUAD>())).rgbRed as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBQUAD),
      "::",
      stringify!(rgbRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRGBQUAD>())).rgbReserved as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRGBQUAD),
      "::",
      stringify!(rgbReserved)
    )
  );
}
pub type RGBQUAD = tagRGBQUAD;
pub type LPRGBQUAD = *mut RGBQUAD;
pub type LCSCSTYPE = LONG;
pub type LCSGAMUTMATCH = LONG;
pub type FXPT16DOT16 = libc::c_long;
pub type LPFXPT16DOT16 = *mut libc::c_long;
pub type FXPT2DOT30 = libc::c_long;
pub type LPFXPT2DOT30 = *mut libc::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCIEXYZ {
  pub ciexyzX: FXPT2DOT30,
  pub ciexyzY: FXPT2DOT30,
  pub ciexyzZ: FXPT2DOT30,
}
#[test]
fn bindgen_test_layout_tagCIEXYZ() {
  assert_eq!(
    ::core::mem::size_of::<tagCIEXYZ>(),
    12usize,
    concat!("Size of: ", stringify!(tagCIEXYZ))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCIEXYZ>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCIEXYZ))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCIEXYZ>())).ciexyzX as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCIEXYZ),
      "::",
      stringify!(ciexyzX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCIEXYZ>())).ciexyzY as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCIEXYZ),
      "::",
      stringify!(ciexyzY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCIEXYZ>())).ciexyzZ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCIEXYZ),
      "::",
      stringify!(ciexyzZ)
    )
  );
}
pub type CIEXYZ = tagCIEXYZ;
pub type LPCIEXYZ = *mut CIEXYZ;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagICEXYZTRIPLE {
  pub ciexyzRed: CIEXYZ,
  pub ciexyzGreen: CIEXYZ,
  pub ciexyzBlue: CIEXYZ,
}
#[test]
fn bindgen_test_layout_tagICEXYZTRIPLE() {
  assert_eq!(
    ::core::mem::size_of::<tagICEXYZTRIPLE>(),
    36usize,
    concat!("Size of: ", stringify!(tagICEXYZTRIPLE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagICEXYZTRIPLE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagICEXYZTRIPLE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICEXYZTRIPLE>())).ciexyzRed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICEXYZTRIPLE),
      "::",
      stringify!(ciexyzRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICEXYZTRIPLE>())).ciexyzGreen as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICEXYZTRIPLE),
      "::",
      stringify!(ciexyzGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICEXYZTRIPLE>())).ciexyzBlue as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICEXYZTRIPLE),
      "::",
      stringify!(ciexyzBlue)
    )
  );
}
pub type CIEXYZTRIPLE = tagICEXYZTRIPLE;
pub type LPCIEXYZTRIPLE = *mut CIEXYZTRIPLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagLOGCOLORSPACEA {
  pub lcsSignature: DWORD,
  pub lcsVersion: DWORD,
  pub lcsSize: DWORD,
  pub lcsCSType: LCSCSTYPE,
  pub lcsIntent: LCSGAMUTMATCH,
  pub lcsEndpoints: CIEXYZTRIPLE,
  pub lcsGammaRed: DWORD,
  pub lcsGammaGreen: DWORD,
  pub lcsGammaBlue: DWORD,
  pub lcsFilename: [CHAR; 260usize],
}
#[test]
fn bindgen_test_layout_tagLOGCOLORSPACEA() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGCOLORSPACEA>(),
    328usize,
    concat!("Size of: ", stringify!(tagLOGCOLORSPACEA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGCOLORSPACEA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOGCOLORSPACEA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsSignature as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsSignature)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsCSType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsCSType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsIntent as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsIntent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsEndpoints as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsEndpoints)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsGammaRed as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsGammaRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsGammaGreen as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsGammaGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsGammaBlue as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsGammaBlue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEA>())).lcsFilename as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEA),
      "::",
      stringify!(lcsFilename)
    )
  );
}
impl Default for tagLOGCOLORSPACEA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagLOGCOLORSPACEA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagLOGCOLORSPACEA {{ lcsSignature: {:?}, lcsVersion: {:?}, lcsSize: {:?}, lcsCSType: {:?}, lcsIntent: {:?}, lcsEndpoints: {:?}, lcsGammaRed: {:?}, lcsGammaGreen: {:?}, lcsGammaBlue: {:?}, lcsFilename: [...] }}" , self . lcsSignature , self . lcsVersion , self . lcsSize , self . lcsCSType , self . lcsIntent , self . lcsEndpoints , self . lcsGammaRed , self . lcsGammaGreen , self . lcsGammaBlue )
  }
}
impl ::core::cmp::PartialEq for tagLOGCOLORSPACEA {
  fn eq(&self, other: &tagLOGCOLORSPACEA) -> bool {
    self.lcsSignature == other.lcsSignature
      && self.lcsVersion == other.lcsVersion
      && self.lcsSize == other.lcsSize
      && self.lcsCSType == other.lcsCSType
      && self.lcsIntent == other.lcsIntent
      && self.lcsEndpoints == other.lcsEndpoints
      && self.lcsGammaRed == other.lcsGammaRed
      && self.lcsGammaGreen == other.lcsGammaGreen
      && self.lcsGammaBlue == other.lcsGammaBlue
      && &self.lcsFilename[..] == &other.lcsFilename[..]
  }
}
pub type LOGCOLORSPACEA = tagLOGCOLORSPACEA;
pub type LPLOGCOLORSPACEA = *mut tagLOGCOLORSPACEA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagLOGCOLORSPACEW {
  pub lcsSignature: DWORD,
  pub lcsVersion: DWORD,
  pub lcsSize: DWORD,
  pub lcsCSType: LCSCSTYPE,
  pub lcsIntent: LCSGAMUTMATCH,
  pub lcsEndpoints: CIEXYZTRIPLE,
  pub lcsGammaRed: DWORD,
  pub lcsGammaGreen: DWORD,
  pub lcsGammaBlue: DWORD,
  pub lcsFilename: [WCHAR; 260usize],
}
#[test]
fn bindgen_test_layout_tagLOGCOLORSPACEW() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGCOLORSPACEW>(),
    588usize,
    concat!("Size of: ", stringify!(tagLOGCOLORSPACEW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGCOLORSPACEW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOGCOLORSPACEW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsSignature as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsSignature)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsCSType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsCSType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsIntent as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsIntent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsEndpoints as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsEndpoints)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsGammaRed as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsGammaRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsGammaGreen as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsGammaGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsGammaBlue as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsGammaBlue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGCOLORSPACEW>())).lcsFilename as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGCOLORSPACEW),
      "::",
      stringify!(lcsFilename)
    )
  );
}
impl Default for tagLOGCOLORSPACEW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagLOGCOLORSPACEW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagLOGCOLORSPACEW {{ lcsSignature: {:?}, lcsVersion: {:?}, lcsSize: {:?}, lcsCSType: {:?}, lcsIntent: {:?}, lcsEndpoints: {:?}, lcsGammaRed: {:?}, lcsGammaGreen: {:?}, lcsGammaBlue: {:?}, lcsFilename: [...] }}" , self . lcsSignature , self . lcsVersion , self . lcsSize , self . lcsCSType , self . lcsIntent , self . lcsEndpoints , self . lcsGammaRed , self . lcsGammaGreen , self . lcsGammaBlue )
  }
}
impl ::core::cmp::PartialEq for tagLOGCOLORSPACEW {
  fn eq(&self, other: &tagLOGCOLORSPACEW) -> bool {
    self.lcsSignature == other.lcsSignature
      && self.lcsVersion == other.lcsVersion
      && self.lcsSize == other.lcsSize
      && self.lcsCSType == other.lcsCSType
      && self.lcsIntent == other.lcsIntent
      && self.lcsEndpoints == other.lcsEndpoints
      && self.lcsGammaRed == other.lcsGammaRed
      && self.lcsGammaGreen == other.lcsGammaGreen
      && self.lcsGammaBlue == other.lcsGammaBlue
      && &self.lcsFilename[..] == &other.lcsFilename[..]
  }
}
pub type LOGCOLORSPACEW = tagLOGCOLORSPACEW;
pub type LPLOGCOLORSPACEW = *mut tagLOGCOLORSPACEW;
pub type LOGCOLORSPACE = LOGCOLORSPACEA;
pub type LPLOGCOLORSPACE = LPLOGCOLORSPACEA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagBITMAPCOREHEADER {
  pub bcSize: DWORD,
  pub bcWidth: WORD,
  pub bcHeight: WORD,
  pub bcPlanes: WORD,
  pub bcBitCount: WORD,
}
#[test]
fn bindgen_test_layout_tagBITMAPCOREHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagBITMAPCOREHEADER>(),
    12usize,
    concat!("Size of: ", stringify!(tagBITMAPCOREHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagBITMAPCOREHEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(tagBITMAPCOREHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREHEADER>())).bcSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREHEADER),
      "::",
      stringify!(bcSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREHEADER>())).bcWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREHEADER),
      "::",
      stringify!(bcWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREHEADER>())).bcHeight as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREHEADER),
      "::",
      stringify!(bcHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREHEADER>())).bcPlanes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREHEADER),
      "::",
      stringify!(bcPlanes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREHEADER>())).bcBitCount as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREHEADER),
      "::",
      stringify!(bcBitCount)
    )
  );
}
pub type BITMAPCOREHEADER = tagBITMAPCOREHEADER;
pub type LPBITMAPCOREHEADER = *mut tagBITMAPCOREHEADER;
pub type PBITMAPCOREHEADER = *mut tagBITMAPCOREHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagBITMAPINFOHEADER {
  pub biSize: DWORD,
  pub biWidth: LONG,
  pub biHeight: LONG,
  pub biPlanes: WORD,
  pub biBitCount: WORD,
  pub biCompression: DWORD,
  pub biSizeImage: DWORD,
  pub biXPelsPerMeter: LONG,
  pub biYPelsPerMeter: LONG,
  pub biClrUsed: DWORD,
  pub biClrImportant: DWORD,
}
#[test]
fn bindgen_test_layout_tagBITMAPINFOHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagBITMAPINFOHEADER>(),
    40usize,
    concat!("Size of: ", stringify!(tagBITMAPINFOHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagBITMAPINFOHEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(tagBITMAPINFOHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biHeight as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biPlanes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biPlanes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biBitCount as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biBitCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biCompression as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biCompression)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biSizeImage as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biSizeImage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biXPelsPerMeter as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biXPelsPerMeter)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biYPelsPerMeter as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biYPelsPerMeter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biClrUsed as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biClrUsed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFOHEADER>())).biClrImportant as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFOHEADER),
      "::",
      stringify!(biClrImportant)
    )
  );
}
pub type BITMAPINFOHEADER = tagBITMAPINFOHEADER;
pub type LPBITMAPINFOHEADER = *mut tagBITMAPINFOHEADER;
pub type PBITMAPINFOHEADER = *mut tagBITMAPINFOHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BITMAPV4HEADER {
  pub bV4Size: DWORD,
  pub bV4Width: LONG,
  pub bV4Height: LONG,
  pub bV4Planes: WORD,
  pub bV4BitCount: WORD,
  pub bV4V4Compression: DWORD,
  pub bV4SizeImage: DWORD,
  pub bV4XPelsPerMeter: LONG,
  pub bV4YPelsPerMeter: LONG,
  pub bV4ClrUsed: DWORD,
  pub bV4ClrImportant: DWORD,
  pub bV4RedMask: DWORD,
  pub bV4GreenMask: DWORD,
  pub bV4BlueMask: DWORD,
  pub bV4AlphaMask: DWORD,
  pub bV4CSType: DWORD,
  pub bV4Endpoints: CIEXYZTRIPLE,
  pub bV4GammaRed: DWORD,
  pub bV4GammaGreen: DWORD,
  pub bV4GammaBlue: DWORD,
}
#[test]
fn bindgen_test_layout_BITMAPV4HEADER() {
  assert_eq!(
    ::core::mem::size_of::<BITMAPV4HEADER>(),
    108usize,
    concat!("Size of: ", stringify!(BITMAPV4HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<BITMAPV4HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(BITMAPV4HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4Width as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4Width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4Height as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4Height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4Planes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4Planes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4BitCount as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4BitCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4V4Compression as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4V4Compression)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4SizeImage as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4SizeImage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4XPelsPerMeter as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4XPelsPerMeter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4YPelsPerMeter as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4YPelsPerMeter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4ClrUsed as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4ClrUsed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4ClrImportant as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4ClrImportant)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4RedMask as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4RedMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4GreenMask as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4GreenMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4BlueMask as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4BlueMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4AlphaMask as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4AlphaMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4CSType as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4CSType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4Endpoints as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4Endpoints)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4GammaRed as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4GammaRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4GammaGreen as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4GammaGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV4HEADER>())).bV4GammaBlue as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV4HEADER),
      "::",
      stringify!(bV4GammaBlue)
    )
  );
}
pub type LPBITMAPV4HEADER = *mut BITMAPV4HEADER;
pub type PBITMAPV4HEADER = *mut BITMAPV4HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct BITMAPV5HEADER {
  pub bV5Size: DWORD,
  pub bV5Width: LONG,
  pub bV5Height: LONG,
  pub bV5Planes: WORD,
  pub bV5BitCount: WORD,
  pub bV5Compression: DWORD,
  pub bV5SizeImage: DWORD,
  pub bV5XPelsPerMeter: LONG,
  pub bV5YPelsPerMeter: LONG,
  pub bV5ClrUsed: DWORD,
  pub bV5ClrImportant: DWORD,
  pub bV5RedMask: DWORD,
  pub bV5GreenMask: DWORD,
  pub bV5BlueMask: DWORD,
  pub bV5AlphaMask: DWORD,
  pub bV5CSType: DWORD,
  pub bV5Endpoints: CIEXYZTRIPLE,
  pub bV5GammaRed: DWORD,
  pub bV5GammaGreen: DWORD,
  pub bV5GammaBlue: DWORD,
  pub bV5Intent: DWORD,
  pub bV5ProfileData: DWORD,
  pub bV5ProfileSize: DWORD,
  pub bV5Reserved: DWORD,
}
#[test]
fn bindgen_test_layout_BITMAPV5HEADER() {
  assert_eq!(
    ::core::mem::size_of::<BITMAPV5HEADER>(),
    124usize,
    concat!("Size of: ", stringify!(BITMAPV5HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<BITMAPV5HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(BITMAPV5HEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Width as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Height as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Planes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Planes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5BitCount as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5BitCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Compression as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Compression)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5SizeImage as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5SizeImage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5XPelsPerMeter as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5XPelsPerMeter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5YPelsPerMeter as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5YPelsPerMeter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5ClrUsed as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5ClrUsed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5ClrImportant as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5ClrImportant)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5RedMask as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5RedMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5GreenMask as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5GreenMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5BlueMask as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5BlueMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5AlphaMask as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5AlphaMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5CSType as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5CSType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Endpoints as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Endpoints)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5GammaRed as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5GammaRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5GammaGreen as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5GammaGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5GammaBlue as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5GammaBlue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Intent as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Intent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5ProfileData as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5ProfileData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5ProfileSize as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5ProfileSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BITMAPV5HEADER>())).bV5Reserved as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(BITMAPV5HEADER),
      "::",
      stringify!(bV5Reserved)
    )
  );
}
pub type LPBITMAPV5HEADER = *mut BITMAPV5HEADER;
pub type PBITMAPV5HEADER = *mut BITMAPV5HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagBITMAPINFO {
  pub bmiHeader: BITMAPINFOHEADER,
  pub bmiColors: [RGBQUAD; 1usize],
}
#[test]
fn bindgen_test_layout_tagBITMAPINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagBITMAPINFO>(),
    44usize,
    concat!("Size of: ", stringify!(tagBITMAPINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagBITMAPINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagBITMAPINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFO>())).bmiHeader as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFO),
      "::",
      stringify!(bmiHeader)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPINFO>())).bmiColors as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPINFO),
      "::",
      stringify!(bmiColors)
    )
  );
}
pub type BITMAPINFO = tagBITMAPINFO;
pub type LPBITMAPINFO = *mut tagBITMAPINFO;
pub type PBITMAPINFO = *mut tagBITMAPINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagBITMAPCOREINFO {
  pub bmciHeader: BITMAPCOREHEADER,
  pub bmciColors: [RGBTRIPLE; 1usize],
}
#[test]
fn bindgen_test_layout_tagBITMAPCOREINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagBITMAPCOREINFO>(),
    16usize,
    concat!("Size of: ", stringify!(tagBITMAPCOREINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagBITMAPCOREINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagBITMAPCOREINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREINFO>())).bmciHeader as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREINFO),
      "::",
      stringify!(bmciHeader)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPCOREINFO>())).bmciColors as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPCOREINFO),
      "::",
      stringify!(bmciColors)
    )
  );
}
pub type BITMAPCOREINFO = tagBITMAPCOREINFO;
pub type LPBITMAPCOREINFO = *mut tagBITMAPCOREINFO;
pub type PBITMAPCOREINFO = *mut tagBITMAPCOREINFO;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagBITMAPFILEHEADER {
  pub bfType: WORD,
  pub bfSize: DWORD,
  pub bfReserved1: WORD,
  pub bfReserved2: WORD,
  pub bfOffBits: DWORD,
}
#[test]
fn bindgen_test_layout_tagBITMAPFILEHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagBITMAPFILEHEADER>(),
    14usize,
    concat!("Size of: ", stringify!(tagBITMAPFILEHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagBITMAPFILEHEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(tagBITMAPFILEHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPFILEHEADER>())).bfType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPFILEHEADER),
      "::",
      stringify!(bfType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPFILEHEADER>())).bfSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPFILEHEADER),
      "::",
      stringify!(bfSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPFILEHEADER>())).bfReserved1 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPFILEHEADER),
      "::",
      stringify!(bfReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPFILEHEADER>())).bfReserved2 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPFILEHEADER),
      "::",
      stringify!(bfReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagBITMAPFILEHEADER>())).bfOffBits as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBITMAPFILEHEADER),
      "::",
      stringify!(bfOffBits)
    )
  );
}
pub type BITMAPFILEHEADER = tagBITMAPFILEHEADER;
pub type LPBITMAPFILEHEADER = *mut tagBITMAPFILEHEADER;
pub type PBITMAPFILEHEADER = *mut tagBITMAPFILEHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagFONTSIGNATURE {
  pub fsUsb: [DWORD; 4usize],
  pub fsCsb: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout_tagFONTSIGNATURE() {
  assert_eq!(
    ::core::mem::size_of::<tagFONTSIGNATURE>(),
    24usize,
    concat!("Size of: ", stringify!(tagFONTSIGNATURE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagFONTSIGNATURE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagFONTSIGNATURE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFONTSIGNATURE>())).fsUsb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFONTSIGNATURE),
      "::",
      stringify!(fsUsb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFONTSIGNATURE>())).fsCsb as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFONTSIGNATURE),
      "::",
      stringify!(fsCsb)
    )
  );
}
pub type FONTSIGNATURE = tagFONTSIGNATURE;
pub type PFONTSIGNATURE = *mut tagFONTSIGNATURE;
pub type LPFONTSIGNATURE = *mut tagFONTSIGNATURE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCHARSETINFO {
  pub ciCharset: UINT,
  pub ciACP: UINT,
  pub fs: FONTSIGNATURE,
}
#[test]
fn bindgen_test_layout_tagCHARSETINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagCHARSETINFO>(),
    32usize,
    concat!("Size of: ", stringify!(tagCHARSETINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCHARSETINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCHARSETINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCHARSETINFO>())).ciCharset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCHARSETINFO),
      "::",
      stringify!(ciCharset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCHARSETINFO>())).ciACP as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCHARSETINFO),
      "::",
      stringify!(ciACP)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCHARSETINFO>())).fs as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCHARSETINFO),
      "::",
      stringify!(fs)
    )
  );
}
pub type CHARSETINFO = tagCHARSETINFO;
pub type PCHARSETINFO = *mut tagCHARSETINFO;
pub type NPCHARSETINFO = *mut tagCHARSETINFO;
pub type LPCHARSETINFO = *mut tagCHARSETINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOCALESIGNATURE {
  pub lsUsb: [DWORD; 4usize],
  pub lsCsbDefault: [DWORD; 2usize],
  pub lsCsbSupported: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout_tagLOCALESIGNATURE() {
  assert_eq!(
    ::core::mem::size_of::<tagLOCALESIGNATURE>(),
    32usize,
    concat!("Size of: ", stringify!(tagLOCALESIGNATURE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOCALESIGNATURE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOCALESIGNATURE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOCALESIGNATURE>())).lsUsb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOCALESIGNATURE),
      "::",
      stringify!(lsUsb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOCALESIGNATURE>())).lsCsbDefault as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOCALESIGNATURE),
      "::",
      stringify!(lsCsbDefault)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOCALESIGNATURE>())).lsCsbSupported as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOCALESIGNATURE),
      "::",
      stringify!(lsCsbSupported)
    )
  );
}
pub type LOCALESIGNATURE = tagLOCALESIGNATURE;
pub type PLOCALESIGNATURE = *mut tagLOCALESIGNATURE;
pub type LPLOCALESIGNATURE = *mut tagLOCALESIGNATURE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagHANDLETABLE {
  pub objectHandle: [HGDIOBJ; 1usize],
}
#[test]
fn bindgen_test_layout_tagHANDLETABLE() {
  assert_eq!(
    ::core::mem::size_of::<tagHANDLETABLE>(),
    8usize,
    concat!("Size of: ", stringify!(tagHANDLETABLE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHANDLETABLE>(),
    8usize,
    concat!("Alignment of ", stringify!(tagHANDLETABLE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHANDLETABLE>())).objectHandle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHANDLETABLE),
      "::",
      stringify!(objectHandle)
    )
  );
}
impl Default for tagHANDLETABLE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type HANDLETABLE = tagHANDLETABLE;
pub type PHANDLETABLE = *mut tagHANDLETABLE;
pub type LPHANDLETABLE = *mut tagHANDLETABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMETARECORD {
  pub rdSize: DWORD,
  pub rdFunction: WORD,
  pub rdParm: [WORD; 1usize],
}
#[test]
fn bindgen_test_layout_tagMETARECORD() {
  assert_eq!(
    ::core::mem::size_of::<tagMETARECORD>(),
    8usize,
    concat!("Size of: ", stringify!(tagMETARECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMETARECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMETARECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETARECORD>())).rdSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETARECORD),
      "::",
      stringify!(rdSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETARECORD>())).rdFunction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETARECORD),
      "::",
      stringify!(rdFunction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETARECORD>())).rdParm as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETARECORD),
      "::",
      stringify!(rdParm)
    )
  );
}
pub type METARECORD = tagMETARECORD;
pub type PMETARECORD = *mut tagMETARECORD;
pub type LPMETARECORD = *mut tagMETARECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMETAFILEPICT {
  pub mm: LONG,
  pub xExt: LONG,
  pub yExt: LONG,
  pub hMF: HMETAFILE,
}
#[test]
fn bindgen_test_layout_tagMETAFILEPICT() {
  assert_eq!(
    ::core::mem::size_of::<tagMETAFILEPICT>(),
    24usize,
    concat!("Size of: ", stringify!(tagMETAFILEPICT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMETAFILEPICT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMETAFILEPICT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAFILEPICT>())).mm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAFILEPICT),
      "::",
      stringify!(mm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAFILEPICT>())).xExt as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAFILEPICT),
      "::",
      stringify!(xExt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAFILEPICT>())).yExt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAFILEPICT),
      "::",
      stringify!(yExt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAFILEPICT>())).hMF as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAFILEPICT),
      "::",
      stringify!(hMF)
    )
  );
}
impl Default for tagMETAFILEPICT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type METAFILEPICT = tagMETAFILEPICT;
pub type LPMETAFILEPICT = *mut tagMETAFILEPICT;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMETAHEADER {
  pub mtType: WORD,
  pub mtHeaderSize: WORD,
  pub mtVersion: WORD,
  pub mtSize: DWORD,
  pub mtNoObjects: WORD,
  pub mtMaxRecord: DWORD,
  pub mtNoParameters: WORD,
}
#[test]
fn bindgen_test_layout_tagMETAHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagMETAHEADER>(),
    18usize,
    concat!("Size of: ", stringify!(tagMETAHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMETAHEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(tagMETAHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtHeaderSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtHeaderSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtSize as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtNoObjects as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtNoObjects)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtMaxRecord as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtMaxRecord)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMETAHEADER>())).mtNoParameters as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMETAHEADER),
      "::",
      stringify!(mtNoParameters)
    )
  );
}
pub type METAHEADER = tagMETAHEADER;
pub type PMETAHEADER = *mut tagMETAHEADER;
pub type LPMETAHEADER = *mut tagMETAHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagENHMETARECORD {
  pub iType: DWORD,
  pub nSize: DWORD,
  pub dParm: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout_tagENHMETARECORD() {
  assert_eq!(
    ::core::mem::size_of::<tagENHMETARECORD>(),
    12usize,
    concat!("Size of: ", stringify!(tagENHMETARECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENHMETARECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENHMETARECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETARECORD>())).iType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETARECORD),
      "::",
      stringify!(iType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETARECORD>())).nSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETARECORD),
      "::",
      stringify!(nSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETARECORD>())).dParm as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETARECORD),
      "::",
      stringify!(dParm)
    )
  );
}
pub type ENHMETARECORD = tagENHMETARECORD;
pub type PENHMETARECORD = *mut tagENHMETARECORD;
pub type LPENHMETARECORD = *mut tagENHMETARECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagENHMETAHEADER {
  pub iType: DWORD,
  pub nSize: DWORD,
  pub rclBounds: RECTL,
  pub rclFrame: RECTL,
  pub dSignature: DWORD,
  pub nVersion: DWORD,
  pub nBytes: DWORD,
  pub nRecords: DWORD,
  pub nHandles: WORD,
  pub sReserved: WORD,
  pub nDescription: DWORD,
  pub offDescription: DWORD,
  pub nPalEntries: DWORD,
  pub szlDevice: SIZEL,
  pub szlMillimeters: SIZEL,
  pub cbPixelFormat: DWORD,
  pub offPixelFormat: DWORD,
  pub bOpenGL: DWORD,
  pub szlMicrometers: SIZEL,
}
#[test]
fn bindgen_test_layout_tagENHMETAHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagENHMETAHEADER>(),
    108usize,
    concat!("Size of: ", stringify!(tagENHMETAHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENHMETAHEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENHMETAHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).iType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(iType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).rclFrame as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(rclFrame)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).dSignature as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(dSignature)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nVersion as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nBytes as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nRecords as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nRecords)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nHandles as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nHandles)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).sReserved as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(sReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nDescription as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nDescription)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).offDescription as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(offDescription)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).nPalEntries as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(nPalEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).szlDevice as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(szlDevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).szlMillimeters as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(szlMillimeters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).cbPixelFormat as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(cbPixelFormat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).offPixelFormat as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(offPixelFormat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).bOpenGL as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(bOpenGL)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENHMETAHEADER>())).szlMicrometers as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENHMETAHEADER),
      "::",
      stringify!(szlMicrometers)
    )
  );
}
pub type ENHMETAHEADER = tagENHMETAHEADER;
pub type PENHMETAHEADER = *mut tagENHMETAHEADER;
pub type LPENHMETAHEADER = *mut tagENHMETAHEADER;
pub type BCHAR = BYTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTEXTMETRICA {
  pub tmHeight: LONG,
  pub tmAscent: LONG,
  pub tmDescent: LONG,
  pub tmInternalLeading: LONG,
  pub tmExternalLeading: LONG,
  pub tmAveCharWidth: LONG,
  pub tmMaxCharWidth: LONG,
  pub tmWeight: LONG,
  pub tmOverhang: LONG,
  pub tmDigitizedAspectX: LONG,
  pub tmDigitizedAspectY: LONG,
  pub tmFirstChar: BYTE,
  pub tmLastChar: BYTE,
  pub tmDefaultChar: BYTE,
  pub tmBreakChar: BYTE,
  pub tmItalic: BYTE,
  pub tmUnderlined: BYTE,
  pub tmStruckOut: BYTE,
  pub tmPitchAndFamily: BYTE,
  pub tmCharSet: BYTE,
}
#[test]
fn bindgen_test_layout_tagTEXTMETRICA() {
  assert_eq!(
    ::core::mem::size_of::<tagTEXTMETRICA>(),
    56usize,
    concat!("Size of: ", stringify!(tagTEXTMETRICA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTEXTMETRICA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTEXTMETRICA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmHeight as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmAscent as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmDescent as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmDescent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmInternalLeading as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmInternalLeading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmExternalLeading as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmExternalLeading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmAveCharWidth as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmAveCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmMaxCharWidth as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmMaxCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmWeight as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmOverhang as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmOverhang)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmDigitizedAspectX as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmDigitizedAspectX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmDigitizedAspectY as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmDigitizedAspectY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmFirstChar as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmFirstChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmLastChar as *const _ as usize },
    45usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmLastChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmDefaultChar as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmDefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmBreakChar as *const _ as usize },
    47usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmBreakChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmItalic as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmItalic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmUnderlined as *const _ as usize },
    49usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmUnderlined)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmStruckOut as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmStruckOut)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmPitchAndFamily as *const _ as usize },
    51usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmPitchAndFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICA>())).tmCharSet as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICA),
      "::",
      stringify!(tmCharSet)
    )
  );
}
pub type TEXTMETRICA = tagTEXTMETRICA;
pub type PTEXTMETRICA = *mut tagTEXTMETRICA;
pub type NPTEXTMETRICA = *mut tagTEXTMETRICA;
pub type LPTEXTMETRICA = *mut tagTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTEXTMETRICW {
  pub tmHeight: LONG,
  pub tmAscent: LONG,
  pub tmDescent: LONG,
  pub tmInternalLeading: LONG,
  pub tmExternalLeading: LONG,
  pub tmAveCharWidth: LONG,
  pub tmMaxCharWidth: LONG,
  pub tmWeight: LONG,
  pub tmOverhang: LONG,
  pub tmDigitizedAspectX: LONG,
  pub tmDigitizedAspectY: LONG,
  pub tmFirstChar: WCHAR,
  pub tmLastChar: WCHAR,
  pub tmDefaultChar: WCHAR,
  pub tmBreakChar: WCHAR,
  pub tmItalic: BYTE,
  pub tmUnderlined: BYTE,
  pub tmStruckOut: BYTE,
  pub tmPitchAndFamily: BYTE,
  pub tmCharSet: BYTE,
}
#[test]
fn bindgen_test_layout_tagTEXTMETRICW() {
  assert_eq!(
    ::core::mem::size_of::<tagTEXTMETRICW>(),
    60usize,
    concat!("Size of: ", stringify!(tagTEXTMETRICW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTEXTMETRICW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTEXTMETRICW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmHeight as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmAscent as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmDescent as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmDescent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmInternalLeading as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmInternalLeading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmExternalLeading as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmExternalLeading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmAveCharWidth as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmAveCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmMaxCharWidth as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmMaxCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmWeight as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmOverhang as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmOverhang)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmDigitizedAspectX as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmDigitizedAspectX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmDigitizedAspectY as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmDigitizedAspectY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmFirstChar as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmFirstChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmLastChar as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmLastChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmDefaultChar as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmDefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmBreakChar as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmBreakChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmItalic as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmItalic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmUnderlined as *const _ as usize },
    53usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmUnderlined)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmStruckOut as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmStruckOut)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmPitchAndFamily as *const _ as usize },
    55usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmPitchAndFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTEXTMETRICW>())).tmCharSet as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTEXTMETRICW),
      "::",
      stringify!(tmCharSet)
    )
  );
}
pub type TEXTMETRICW = tagTEXTMETRICW;
pub type PTEXTMETRICW = *mut tagTEXTMETRICW;
pub type NPTEXTMETRICW = *mut tagTEXTMETRICW;
pub type LPTEXTMETRICW = *mut tagTEXTMETRICW;
pub type TEXTMETRIC = TEXTMETRICA;
pub type PTEXTMETRIC = PTEXTMETRICA;
pub type NPTEXTMETRIC = NPTEXTMETRICA;
pub type LPTEXTMETRIC = LPTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagNEWTEXTMETRICA {
  pub tmHeight: LONG,
  pub tmAscent: LONG,
  pub tmDescent: LONG,
  pub tmInternalLeading: LONG,
  pub tmExternalLeading: LONG,
  pub tmAveCharWidth: LONG,
  pub tmMaxCharWidth: LONG,
  pub tmWeight: LONG,
  pub tmOverhang: LONG,
  pub tmDigitizedAspectX: LONG,
  pub tmDigitizedAspectY: LONG,
  pub tmFirstChar: BYTE,
  pub tmLastChar: BYTE,
  pub tmDefaultChar: BYTE,
  pub tmBreakChar: BYTE,
  pub tmItalic: BYTE,
  pub tmUnderlined: BYTE,
  pub tmStruckOut: BYTE,
  pub tmPitchAndFamily: BYTE,
  pub tmCharSet: BYTE,
  pub ntmFlags: DWORD,
  pub ntmSizeEM: UINT,
  pub ntmCellHeight: UINT,
  pub ntmAvgWidth: UINT,
}
#[test]
fn bindgen_test_layout_tagNEWTEXTMETRICA() {
  assert_eq!(
    ::core::mem::size_of::<tagNEWTEXTMETRICA>(),
    72usize,
    concat!("Size of: ", stringify!(tagNEWTEXTMETRICA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNEWTEXTMETRICA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagNEWTEXTMETRICA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmHeight as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmAscent as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmDescent as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmDescent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmInternalLeading as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmInternalLeading)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmExternalLeading as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmExternalLeading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmAveCharWidth as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmAveCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmMaxCharWidth as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmMaxCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmWeight as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmOverhang as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmOverhang)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmDigitizedAspectX as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmDigitizedAspectX)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmDigitizedAspectY as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmDigitizedAspectY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmFirstChar as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmFirstChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmLastChar as *const _ as usize },
    45usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmLastChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmDefaultChar as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmDefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmBreakChar as *const _ as usize },
    47usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmBreakChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmItalic as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmItalic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmUnderlined as *const _ as usize },
    49usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmUnderlined)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmStruckOut as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmStruckOut)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmPitchAndFamily as *const _ as usize },
    51usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmPitchAndFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).tmCharSet as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(tmCharSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).ntmFlags as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(ntmFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).ntmSizeEM as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(ntmSizeEM)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).ntmCellHeight as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(ntmCellHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICA>())).ntmAvgWidth as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICA),
      "::",
      stringify!(ntmAvgWidth)
    )
  );
}
pub type NEWTEXTMETRICA = tagNEWTEXTMETRICA;
pub type PNEWTEXTMETRICA = *mut tagNEWTEXTMETRICA;
pub type NPNEWTEXTMETRICA = *mut tagNEWTEXTMETRICA;
pub type LPNEWTEXTMETRICA = *mut tagNEWTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagNEWTEXTMETRICW {
  pub tmHeight: LONG,
  pub tmAscent: LONG,
  pub tmDescent: LONG,
  pub tmInternalLeading: LONG,
  pub tmExternalLeading: LONG,
  pub tmAveCharWidth: LONG,
  pub tmMaxCharWidth: LONG,
  pub tmWeight: LONG,
  pub tmOverhang: LONG,
  pub tmDigitizedAspectX: LONG,
  pub tmDigitizedAspectY: LONG,
  pub tmFirstChar: WCHAR,
  pub tmLastChar: WCHAR,
  pub tmDefaultChar: WCHAR,
  pub tmBreakChar: WCHAR,
  pub tmItalic: BYTE,
  pub tmUnderlined: BYTE,
  pub tmStruckOut: BYTE,
  pub tmPitchAndFamily: BYTE,
  pub tmCharSet: BYTE,
  pub ntmFlags: DWORD,
  pub ntmSizeEM: UINT,
  pub ntmCellHeight: UINT,
  pub ntmAvgWidth: UINT,
}
#[test]
fn bindgen_test_layout_tagNEWTEXTMETRICW() {
  assert_eq!(
    ::core::mem::size_of::<tagNEWTEXTMETRICW>(),
    76usize,
    concat!("Size of: ", stringify!(tagNEWTEXTMETRICW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNEWTEXTMETRICW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagNEWTEXTMETRICW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmHeight as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmAscent as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmDescent as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmDescent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmInternalLeading as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmInternalLeading)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmExternalLeading as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmExternalLeading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmAveCharWidth as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmAveCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmMaxCharWidth as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmMaxCharWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmWeight as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmOverhang as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmOverhang)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmDigitizedAspectX as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmDigitizedAspectX)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmDigitizedAspectY as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmDigitizedAspectY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmFirstChar as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmFirstChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmLastChar as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmLastChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmDefaultChar as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmDefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmBreakChar as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmBreakChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmItalic as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmItalic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmUnderlined as *const _ as usize },
    53usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmUnderlined)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmStruckOut as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmStruckOut)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmPitchAndFamily as *const _ as usize },
    55usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmPitchAndFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).tmCharSet as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(tmCharSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).ntmFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(ntmFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).ntmSizeEM as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(ntmSizeEM)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).ntmCellHeight as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(ntmCellHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICW>())).ntmAvgWidth as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICW),
      "::",
      stringify!(ntmAvgWidth)
    )
  );
}
pub type NEWTEXTMETRICW = tagNEWTEXTMETRICW;
pub type PNEWTEXTMETRICW = *mut tagNEWTEXTMETRICW;
pub type NPNEWTEXTMETRICW = *mut tagNEWTEXTMETRICW;
pub type LPNEWTEXTMETRICW = *mut tagNEWTEXTMETRICW;
pub type NEWTEXTMETRIC = NEWTEXTMETRICA;
pub type PNEWTEXTMETRIC = PNEWTEXTMETRICA;
pub type NPNEWTEXTMETRIC = NPNEWTEXTMETRICA;
pub type LPNEWTEXTMETRIC = LPNEWTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagNEWTEXTMETRICEXA {
  pub ntmTm: NEWTEXTMETRICA,
  pub ntmFontSig: FONTSIGNATURE,
}
#[test]
fn bindgen_test_layout_tagNEWTEXTMETRICEXA() {
  assert_eq!(
    ::core::mem::size_of::<tagNEWTEXTMETRICEXA>(),
    96usize,
    concat!("Size of: ", stringify!(tagNEWTEXTMETRICEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNEWTEXTMETRICEXA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagNEWTEXTMETRICEXA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICEXA>())).ntmTm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICEXA),
      "::",
      stringify!(ntmTm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICEXA>())).ntmFontSig as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICEXA),
      "::",
      stringify!(ntmFontSig)
    )
  );
}
pub type NEWTEXTMETRICEXA = tagNEWTEXTMETRICEXA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagNEWTEXTMETRICEXW {
  pub ntmTm: NEWTEXTMETRICW,
  pub ntmFontSig: FONTSIGNATURE,
}
#[test]
fn bindgen_test_layout_tagNEWTEXTMETRICEXW() {
  assert_eq!(
    ::core::mem::size_of::<tagNEWTEXTMETRICEXW>(),
    100usize,
    concat!("Size of: ", stringify!(tagNEWTEXTMETRICEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNEWTEXTMETRICEXW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagNEWTEXTMETRICEXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICEXW>())).ntmTm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICEXW),
      "::",
      stringify!(ntmTm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNEWTEXTMETRICEXW>())).ntmFontSig as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNEWTEXTMETRICEXW),
      "::",
      stringify!(ntmFontSig)
    )
  );
}
pub type NEWTEXTMETRICEXW = tagNEWTEXTMETRICEXW;
pub type NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPELARRAY {
  pub paXCount: LONG,
  pub paYCount: LONG,
  pub paXExt: LONG,
  pub paYExt: LONG,
  pub paRGBs: BYTE,
}
#[test]
fn bindgen_test_layout_tagPELARRAY() {
  assert_eq!(
    ::core::mem::size_of::<tagPELARRAY>(),
    20usize,
    concat!("Size of: ", stringify!(tagPELARRAY))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPELARRAY>(),
    4usize,
    concat!("Alignment of ", stringify!(tagPELARRAY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPELARRAY>())).paXCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPELARRAY),
      "::",
      stringify!(paXCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPELARRAY>())).paYCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPELARRAY),
      "::",
      stringify!(paYCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPELARRAY>())).paXExt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPELARRAY),
      "::",
      stringify!(paXExt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPELARRAY>())).paYExt as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPELARRAY),
      "::",
      stringify!(paYExt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPELARRAY>())).paRGBs as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPELARRAY),
      "::",
      stringify!(paRGBs)
    )
  );
}
pub type PELARRAY = tagPELARRAY;
pub type PPELARRAY = *mut tagPELARRAY;
pub type NPPELARRAY = *mut tagPELARRAY;
pub type LPPELARRAY = *mut tagPELARRAY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOGBRUSH {
  pub lbStyle: UINT,
  pub lbColor: COLORREF,
  pub lbHatch: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagLOGBRUSH() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGBRUSH>(),
    16usize,
    concat!("Size of: ", stringify!(tagLOGBRUSH))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGBRUSH>(),
    8usize,
    concat!("Alignment of ", stringify!(tagLOGBRUSH))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGBRUSH>())).lbStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGBRUSH),
      "::",
      stringify!(lbStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGBRUSH>())).lbColor as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGBRUSH),
      "::",
      stringify!(lbColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGBRUSH>())).lbHatch as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGBRUSH),
      "::",
      stringify!(lbHatch)
    )
  );
}
pub type LOGBRUSH = tagLOGBRUSH;
pub type PLOGBRUSH = *mut tagLOGBRUSH;
pub type NPLOGBRUSH = *mut tagLOGBRUSH;
pub type LPLOGBRUSH = *mut tagLOGBRUSH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOGBRUSH32 {
  pub lbStyle: UINT,
  pub lbColor: COLORREF,
  pub lbHatch: ULONG,
}
#[test]
fn bindgen_test_layout_tagLOGBRUSH32() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGBRUSH32>(),
    12usize,
    concat!("Size of: ", stringify!(tagLOGBRUSH32))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGBRUSH32>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOGBRUSH32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGBRUSH32>())).lbStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGBRUSH32),
      "::",
      stringify!(lbStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGBRUSH32>())).lbColor as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGBRUSH32),
      "::",
      stringify!(lbColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGBRUSH32>())).lbHatch as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGBRUSH32),
      "::",
      stringify!(lbHatch)
    )
  );
}
pub type LOGBRUSH32 = tagLOGBRUSH32;
pub type PLOGBRUSH32 = *mut tagLOGBRUSH32;
pub type NPLOGBRUSH32 = *mut tagLOGBRUSH32;
pub type LPLOGBRUSH32 = *mut tagLOGBRUSH32;
pub type PATTERN = LOGBRUSH;
pub type PPATTERN = *mut PATTERN;
pub type NPPATTERN = *mut PATTERN;
pub type LPPATTERN = *mut PATTERN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOGPEN {
  pub lopnStyle: UINT,
  pub lopnWidth: POINT,
  pub lopnColor: COLORREF,
}
#[test]
fn bindgen_test_layout_tagLOGPEN() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGPEN>(),
    16usize,
    concat!("Size of: ", stringify!(tagLOGPEN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGPEN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOGPEN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGPEN>())).lopnStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGPEN),
      "::",
      stringify!(lopnStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGPEN>())).lopnWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGPEN),
      "::",
      stringify!(lopnWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGPEN>())).lopnColor as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGPEN),
      "::",
      stringify!(lopnColor)
    )
  );
}
pub type LOGPEN = tagLOGPEN;
pub type PLOGPEN = *mut tagLOGPEN;
pub type NPLOGPEN = *mut tagLOGPEN;
pub type LPLOGPEN = *mut tagLOGPEN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEXTLOGPEN {
  pub elpPenStyle: DWORD,
  pub elpWidth: DWORD,
  pub elpBrushStyle: UINT,
  pub elpColor: COLORREF,
  pub elpHatch: ULONG_PTR,
  pub elpNumEntries: DWORD,
  pub elpStyleEntry: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout_tagEXTLOGPEN() {
  assert_eq!(
    ::core::mem::size_of::<tagEXTLOGPEN>(),
    32usize,
    concat!("Size of: ", stringify!(tagEXTLOGPEN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEXTLOGPEN>(),
    8usize,
    concat!("Alignment of ", stringify!(tagEXTLOGPEN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpPenStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpPenStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpBrushStyle as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpBrushStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpColor as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpHatch as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpHatch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpNumEntries as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpNumEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN>())).elpStyleEntry as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN),
      "::",
      stringify!(elpStyleEntry)
    )
  );
}
pub type EXTLOGPEN = tagEXTLOGPEN;
pub type PEXTLOGPEN = *mut tagEXTLOGPEN;
pub type NPEXTLOGPEN = *mut tagEXTLOGPEN;
pub type LPEXTLOGPEN = *mut tagEXTLOGPEN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEXTLOGPEN32 {
  pub elpPenStyle: DWORD,
  pub elpWidth: DWORD,
  pub elpBrushStyle: UINT,
  pub elpColor: COLORREF,
  pub elpHatch: ULONG,
  pub elpNumEntries: DWORD,
  pub elpStyleEntry: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout_tagEXTLOGPEN32() {
  assert_eq!(
    ::core::mem::size_of::<tagEXTLOGPEN32>(),
    28usize,
    concat!("Size of: ", stringify!(tagEXTLOGPEN32))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEXTLOGPEN32>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEXTLOGPEN32))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpPenStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpPenStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpBrushStyle as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpBrushStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpColor as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpHatch as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpHatch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpNumEntries as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpNumEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGPEN32>())).elpStyleEntry as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGPEN32),
      "::",
      stringify!(elpStyleEntry)
    )
  );
}
pub type EXTLOGPEN32 = tagEXTLOGPEN32;
pub type PEXTLOGPEN32 = *mut tagEXTLOGPEN32;
pub type NPEXTLOGPEN32 = *mut tagEXTLOGPEN32;
pub type LPEXTLOGPEN32 = *mut tagEXTLOGPEN32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPALETTEENTRY {
  pub peRed: BYTE,
  pub peGreen: BYTE,
  pub peBlue: BYTE,
  pub peFlags: BYTE,
}
#[test]
fn bindgen_test_layout_tagPALETTEENTRY() {
  assert_eq!(
    ::core::mem::size_of::<tagPALETTEENTRY>(),
    4usize,
    concat!("Size of: ", stringify!(tagPALETTEENTRY))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPALETTEENTRY>(),
    1usize,
    concat!("Alignment of ", stringify!(tagPALETTEENTRY))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPALETTEENTRY>())).peRed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPALETTEENTRY),
      "::",
      stringify!(peRed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPALETTEENTRY>())).peGreen as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPALETTEENTRY),
      "::",
      stringify!(peGreen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPALETTEENTRY>())).peBlue as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPALETTEENTRY),
      "::",
      stringify!(peBlue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPALETTEENTRY>())).peFlags as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPALETTEENTRY),
      "::",
      stringify!(peFlags)
    )
  );
}
pub type PALETTEENTRY = tagPALETTEENTRY;
pub type PPALETTEENTRY = *mut tagPALETTEENTRY;
pub type LPPALETTEENTRY = *mut tagPALETTEENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOGPALETTE {
  pub palVersion: WORD,
  pub palNumEntries: WORD,
  pub palPalEntry: [PALETTEENTRY; 1usize],
}
#[test]
fn bindgen_test_layout_tagLOGPALETTE() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGPALETTE>(),
    8usize,
    concat!("Size of: ", stringify!(tagLOGPALETTE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGPALETTE>(),
    2usize,
    concat!("Alignment of ", stringify!(tagLOGPALETTE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGPALETTE>())).palVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGPALETTE),
      "::",
      stringify!(palVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGPALETTE>())).palNumEntries as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGPALETTE),
      "::",
      stringify!(palNumEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGPALETTE>())).palPalEntry as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGPALETTE),
      "::",
      stringify!(palPalEntry)
    )
  );
}
pub type LOGPALETTE = tagLOGPALETTE;
pub type PLOGPALETTE = *mut tagLOGPALETTE;
pub type NPLOGPALETTE = *mut tagLOGPALETTE;
pub type LPLOGPALETTE = *mut tagLOGPALETTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOGFONTA {
  pub lfHeight: LONG,
  pub lfWidth: LONG,
  pub lfEscapement: LONG,
  pub lfOrientation: LONG,
  pub lfWeight: LONG,
  pub lfItalic: BYTE,
  pub lfUnderline: BYTE,
  pub lfStrikeOut: BYTE,
  pub lfCharSet: BYTE,
  pub lfOutPrecision: BYTE,
  pub lfClipPrecision: BYTE,
  pub lfQuality: BYTE,
  pub lfPitchAndFamily: BYTE,
  pub lfFaceName: [CHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagLOGFONTA() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGFONTA>(),
    60usize,
    concat!("Size of: ", stringify!(tagLOGFONTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGFONTA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOGFONTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfHeight as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfEscapement as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfEscapement)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfOrientation as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfOrientation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfWeight as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfItalic as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfItalic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfUnderline as *const _ as usize },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfUnderline)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfStrikeOut as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfStrikeOut)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfCharSet as *const _ as usize },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfCharSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfOutPrecision as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfOutPrecision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfClipPrecision as *const _ as usize },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfClipPrecision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfQuality as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfQuality)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfPitchAndFamily as *const _ as usize },
    27usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfPitchAndFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTA>())).lfFaceName as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTA),
      "::",
      stringify!(lfFaceName)
    )
  );
}
pub type LOGFONTA = tagLOGFONTA;
pub type PLOGFONTA = *mut tagLOGFONTA;
pub type NPLOGFONTA = *mut tagLOGFONTA;
pub type LPLOGFONTA = *mut tagLOGFONTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLOGFONTW {
  pub lfHeight: LONG,
  pub lfWidth: LONG,
  pub lfEscapement: LONG,
  pub lfOrientation: LONG,
  pub lfWeight: LONG,
  pub lfItalic: BYTE,
  pub lfUnderline: BYTE,
  pub lfStrikeOut: BYTE,
  pub lfCharSet: BYTE,
  pub lfOutPrecision: BYTE,
  pub lfClipPrecision: BYTE,
  pub lfQuality: BYTE,
  pub lfPitchAndFamily: BYTE,
  pub lfFaceName: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagLOGFONTW() {
  assert_eq!(
    ::core::mem::size_of::<tagLOGFONTW>(),
    92usize,
    concat!("Size of: ", stringify!(tagLOGFONTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLOGFONTW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLOGFONTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfHeight as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfEscapement as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfEscapement)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfOrientation as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfOrientation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfWeight as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfItalic as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfItalic)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfUnderline as *const _ as usize },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfUnderline)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfStrikeOut as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfStrikeOut)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfCharSet as *const _ as usize },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfCharSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfOutPrecision as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfOutPrecision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfClipPrecision as *const _ as usize },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfClipPrecision)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfQuality as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfQuality)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfPitchAndFamily as *const _ as usize },
    27usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfPitchAndFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLOGFONTW>())).lfFaceName as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLOGFONTW),
      "::",
      stringify!(lfFaceName)
    )
  );
}
pub type LOGFONTW = tagLOGFONTW;
pub type PLOGFONTW = *mut tagLOGFONTW;
pub type NPLOGFONTW = *mut tagLOGFONTW;
pub type LPLOGFONTW = *mut tagLOGFONTW;
pub type LOGFONT = LOGFONTA;
pub type PLOGFONT = PLOGFONTA;
pub type NPLOGFONT = NPLOGFONTA;
pub type LPLOGFONT = LPLOGFONTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagENUMLOGFONTA {
  pub elfLogFont: LOGFONTA,
  pub elfFullName: [BYTE; 64usize],
  pub elfStyle: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_tagENUMLOGFONTA() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMLOGFONTA>(),
    156usize,
    concat!("Size of: ", stringify!(tagENUMLOGFONTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMLOGFONTA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMLOGFONTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTA>())).elfLogFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTA),
      "::",
      stringify!(elfLogFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTA>())).elfFullName as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTA),
      "::",
      stringify!(elfFullName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTA>())).elfStyle as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTA),
      "::",
      stringify!(elfStyle)
    )
  );
}
impl Default for tagENUMLOGFONTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagENUMLOGFONTA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagENUMLOGFONTA {{ elfLogFont: {:?}, elfFullName: [...], elfStyle: [...] }}",
      self.elfLogFont
    )
  }
}
impl ::core::cmp::PartialEq for tagENUMLOGFONTA {
  fn eq(&self, other: &tagENUMLOGFONTA) -> bool {
    self.elfLogFont == other.elfLogFont
      && &self.elfFullName[..] == &other.elfFullName[..]
      && self.elfStyle == other.elfStyle
  }
}
pub type ENUMLOGFONTA = tagENUMLOGFONTA;
pub type LPENUMLOGFONTA = *mut tagENUMLOGFONTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagENUMLOGFONTW {
  pub elfLogFont: LOGFONTW,
  pub elfFullName: [WCHAR; 64usize],
  pub elfStyle: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagENUMLOGFONTW() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMLOGFONTW>(),
    284usize,
    concat!("Size of: ", stringify!(tagENUMLOGFONTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMLOGFONTW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMLOGFONTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTW>())).elfLogFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTW),
      "::",
      stringify!(elfLogFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTW>())).elfFullName as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTW),
      "::",
      stringify!(elfFullName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTW>())).elfStyle as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTW),
      "::",
      stringify!(elfStyle)
    )
  );
}
impl Default for tagENUMLOGFONTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagENUMLOGFONTW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagENUMLOGFONTW {{ elfLogFont: {:?}, elfFullName: [...], elfStyle: [...] }}",
      self.elfLogFont
    )
  }
}
impl ::core::cmp::PartialEq for tagENUMLOGFONTW {
  fn eq(&self, other: &tagENUMLOGFONTW) -> bool {
    self.elfLogFont == other.elfLogFont
      && &self.elfFullName[..] == &other.elfFullName[..]
      && self.elfStyle == other.elfStyle
  }
}
pub type ENUMLOGFONTW = tagENUMLOGFONTW;
pub type LPENUMLOGFONTW = *mut tagENUMLOGFONTW;
pub type ENUMLOGFONT = ENUMLOGFONTA;
pub type LPENUMLOGFONT = LPENUMLOGFONTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagENUMLOGFONTEXA {
  pub elfLogFont: LOGFONTA,
  pub elfFullName: [BYTE; 64usize],
  pub elfStyle: [BYTE; 32usize],
  pub elfScript: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_tagENUMLOGFONTEXA() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMLOGFONTEXA>(),
    188usize,
    concat!("Size of: ", stringify!(tagENUMLOGFONTEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMLOGFONTEXA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMLOGFONTEXA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXA>())).elfLogFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXA),
      "::",
      stringify!(elfLogFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXA>())).elfFullName as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXA),
      "::",
      stringify!(elfFullName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXA>())).elfStyle as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXA),
      "::",
      stringify!(elfStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXA>())).elfScript as *const _ as usize },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXA),
      "::",
      stringify!(elfScript)
    )
  );
}
impl Default for tagENUMLOGFONTEXA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagENUMLOGFONTEXA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagENUMLOGFONTEXA {{ elfLogFont: {:?}, elfFullName: [...], elfStyle: [...], elfScript: [...] }}" , self . elfLogFont )
  }
}
impl ::core::cmp::PartialEq for tagENUMLOGFONTEXA {
  fn eq(&self, other: &tagENUMLOGFONTEXA) -> bool {
    self.elfLogFont == other.elfLogFont
      && &self.elfFullName[..] == &other.elfFullName[..]
      && self.elfStyle == other.elfStyle
      && self.elfScript == other.elfScript
  }
}
pub type ENUMLOGFONTEXA = tagENUMLOGFONTEXA;
pub type LPENUMLOGFONTEXA = *mut tagENUMLOGFONTEXA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagENUMLOGFONTEXW {
  pub elfLogFont: LOGFONTW,
  pub elfFullName: [WCHAR; 64usize],
  pub elfStyle: [WCHAR; 32usize],
  pub elfScript: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagENUMLOGFONTEXW() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMLOGFONTEXW>(),
    348usize,
    concat!("Size of: ", stringify!(tagENUMLOGFONTEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMLOGFONTEXW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMLOGFONTEXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXW>())).elfLogFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXW),
      "::",
      stringify!(elfLogFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXW>())).elfFullName as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXW),
      "::",
      stringify!(elfFullName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXW>())).elfStyle as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXW),
      "::",
      stringify!(elfStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMLOGFONTEXW>())).elfScript as *const _ as usize },
    284usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXW),
      "::",
      stringify!(elfScript)
    )
  );
}
impl Default for tagENUMLOGFONTEXW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagENUMLOGFONTEXW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagENUMLOGFONTEXW {{ elfLogFont: {:?}, elfFullName: [...], elfStyle: [...], elfScript: [...] }}" , self . elfLogFont )
  }
}
impl ::core::cmp::PartialEq for tagENUMLOGFONTEXW {
  fn eq(&self, other: &tagENUMLOGFONTEXW) -> bool {
    self.elfLogFont == other.elfLogFont
      && &self.elfFullName[..] == &other.elfFullName[..]
      && self.elfStyle == other.elfStyle
      && self.elfScript == other.elfScript
  }
}
pub type ENUMLOGFONTEXW = tagENUMLOGFONTEXW;
pub type LPENUMLOGFONTEXW = *mut tagENUMLOGFONTEXW;
pub type ENUMLOGFONTEX = ENUMLOGFONTEXA;
pub type LPENUMLOGFONTEX = LPENUMLOGFONTEXA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPANOSE {
  pub bFamilyType: BYTE,
  pub bSerifStyle: BYTE,
  pub bWeight: BYTE,
  pub bProportion: BYTE,
  pub bContrast: BYTE,
  pub bStrokeVariation: BYTE,
  pub bArmStyle: BYTE,
  pub bLetterform: BYTE,
  pub bMidline: BYTE,
  pub bXHeight: BYTE,
}
#[test]
fn bindgen_test_layout_tagPANOSE() {
  assert_eq!(
    ::core::mem::size_of::<tagPANOSE>(),
    10usize,
    concat!("Size of: ", stringify!(tagPANOSE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPANOSE>(),
    1usize,
    concat!("Alignment of ", stringify!(tagPANOSE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bFamilyType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bFamilyType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bSerifStyle as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bSerifStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bWeight as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bProportion as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bProportion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bContrast as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bContrast)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bStrokeVariation as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bStrokeVariation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bArmStyle as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bArmStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bLetterform as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bLetterform)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bMidline as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bMidline)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPANOSE>())).bXHeight as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPANOSE),
      "::",
      stringify!(bXHeight)
    )
  );
}
pub type PANOSE = tagPANOSE;
pub type LPPANOSE = *mut tagPANOSE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagEXTLOGFONTA {
  pub elfLogFont: LOGFONTA,
  pub elfFullName: [BYTE; 64usize],
  pub elfStyle: [BYTE; 32usize],
  pub elfVersion: DWORD,
  pub elfStyleSize: DWORD,
  pub elfMatch: DWORD,
  pub elfReserved: DWORD,
  pub elfVendorId: [BYTE; 4usize],
  pub elfCulture: DWORD,
  pub elfPanose: PANOSE,
}
#[test]
fn bindgen_test_layout_tagEXTLOGFONTA() {
  assert_eq!(
    ::core::mem::size_of::<tagEXTLOGFONTA>(),
    192usize,
    concat!("Size of: ", stringify!(tagEXTLOGFONTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEXTLOGFONTA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEXTLOGFONTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfLogFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfLogFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfFullName as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfFullName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfStyle as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfVersion as *const _ as usize },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfStyleSize as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfStyleSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfMatch as *const _ as usize },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfMatch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfReserved as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfVendorId as *const _ as usize },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfVendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfCulture as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfCulture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTA>())).elfPanose as *const _ as usize },
    180usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTA),
      "::",
      stringify!(elfPanose)
    )
  );
}
impl Default for tagEXTLOGFONTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagEXTLOGFONTA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagEXTLOGFONTA {{ elfLogFont: {:?}, elfFullName: [...], elfStyle: [...], elfVersion: {:?}, elfStyleSize: {:?}, elfMatch: {:?}, elfReserved: {:?}, elfVendorId: {:?}, elfCulture: {:?}, elfPanose: {:?} }}" , self . elfLogFont , self . elfVersion , self . elfStyleSize , self . elfMatch , self . elfReserved , self . elfVendorId , self . elfCulture , self . elfPanose )
  }
}
impl ::core::cmp::PartialEq for tagEXTLOGFONTA {
  fn eq(&self, other: &tagEXTLOGFONTA) -> bool {
    self.elfLogFont == other.elfLogFont
      && &self.elfFullName[..] == &other.elfFullName[..]
      && self.elfStyle == other.elfStyle
      && self.elfVersion == other.elfVersion
      && self.elfStyleSize == other.elfStyleSize
      && self.elfMatch == other.elfMatch
      && self.elfReserved == other.elfReserved
      && self.elfVendorId == other.elfVendorId
      && self.elfCulture == other.elfCulture
      && self.elfPanose == other.elfPanose
  }
}
pub type EXTLOGFONTA = tagEXTLOGFONTA;
pub type PEXTLOGFONTA = *mut tagEXTLOGFONTA;
pub type NPEXTLOGFONTA = *mut tagEXTLOGFONTA;
pub type LPEXTLOGFONTA = *mut tagEXTLOGFONTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagEXTLOGFONTW {
  pub elfLogFont: LOGFONTW,
  pub elfFullName: [WCHAR; 64usize],
  pub elfStyle: [WCHAR; 32usize],
  pub elfVersion: DWORD,
  pub elfStyleSize: DWORD,
  pub elfMatch: DWORD,
  pub elfReserved: DWORD,
  pub elfVendorId: [BYTE; 4usize],
  pub elfCulture: DWORD,
  pub elfPanose: PANOSE,
}
#[test]
fn bindgen_test_layout_tagEXTLOGFONTW() {
  assert_eq!(
    ::core::mem::size_of::<tagEXTLOGFONTW>(),
    320usize,
    concat!("Size of: ", stringify!(tagEXTLOGFONTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEXTLOGFONTW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEXTLOGFONTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfLogFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfLogFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfFullName as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfFullName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfStyle as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfVersion as *const _ as usize },
    284usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfStyleSize as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfStyleSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfMatch as *const _ as usize },
    292usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfMatch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfReserved as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfVendorId as *const _ as usize },
    300usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfVendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfCulture as *const _ as usize },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfCulture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEXTLOGFONTW>())).elfPanose as *const _ as usize },
    308usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXTLOGFONTW),
      "::",
      stringify!(elfPanose)
    )
  );
}
impl Default for tagEXTLOGFONTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagEXTLOGFONTW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagEXTLOGFONTW {{ elfLogFont: {:?}, elfFullName: [...], elfStyle: [...], elfVersion: {:?}, elfStyleSize: {:?}, elfMatch: {:?}, elfReserved: {:?}, elfVendorId: {:?}, elfCulture: {:?}, elfPanose: {:?} }}" , self . elfLogFont , self . elfVersion , self . elfStyleSize , self . elfMatch , self . elfReserved , self . elfVendorId , self . elfCulture , self . elfPanose )
  }
}
impl ::core::cmp::PartialEq for tagEXTLOGFONTW {
  fn eq(&self, other: &tagEXTLOGFONTW) -> bool {
    self.elfLogFont == other.elfLogFont
      && &self.elfFullName[..] == &other.elfFullName[..]
      && self.elfStyle == other.elfStyle
      && self.elfVersion == other.elfVersion
      && self.elfStyleSize == other.elfStyleSize
      && self.elfMatch == other.elfMatch
      && self.elfReserved == other.elfReserved
      && self.elfVendorId == other.elfVendorId
      && self.elfCulture == other.elfCulture
      && self.elfPanose == other.elfPanose
  }
}
pub type EXTLOGFONTW = tagEXTLOGFONTW;
pub type PEXTLOGFONTW = *mut tagEXTLOGFONTW;
pub type NPEXTLOGFONTW = *mut tagEXTLOGFONTW;
pub type LPEXTLOGFONTW = *mut tagEXTLOGFONTW;
pub type EXTLOGFONT = EXTLOGFONTA;
pub type PEXTLOGFONT = PEXTLOGFONTA;
pub type NPEXTLOGFONT = NPEXTLOGFONTA;
pub type LPEXTLOGFONT = LPEXTLOGFONTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _devicemodeA {
  pub dmDeviceName: [BYTE; 32usize],
  pub dmSpecVersion: WORD,
  pub dmDriverVersion: WORD,
  pub dmSize: WORD,
  pub dmDriverExtra: WORD,
  pub dmFields: DWORD,
  pub __bindgen_anon_1: _devicemodeA__bindgen_ty_1,
  pub dmColor: libc::c_short,
  pub dmDuplex: libc::c_short,
  pub dmYResolution: libc::c_short,
  pub dmTTOption: libc::c_short,
  pub dmCollate: libc::c_short,
  pub dmFormName: [BYTE; 32usize],
  pub dmLogPixels: WORD,
  pub dmBitsPerPel: DWORD,
  pub dmPelsWidth: DWORD,
  pub dmPelsHeight: DWORD,
  pub __bindgen_anon_2: _devicemodeA__bindgen_ty_2,
  pub dmDisplayFrequency: DWORD,
  pub dmICMMethod: DWORD,
  pub dmICMIntent: DWORD,
  pub dmMediaType: DWORD,
  pub dmDitherType: DWORD,
  pub dmReserved1: DWORD,
  pub dmReserved2: DWORD,
  pub dmPanningWidth: DWORD,
  pub dmPanningHeight: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeA__bindgen_ty_1 {
  pub __bindgen_anon_1: _devicemodeA__bindgen_ty_1__bindgen_ty_1,
  pub __bindgen_anon_2: _devicemodeA__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _devicemodeA__bindgen_ty_1__bindgen_ty_1 {
  pub dmOrientation: libc::c_short,
  pub dmPaperSize: libc::c_short,
  pub dmPaperLength: libc::c_short,
  pub dmPaperWidth: libc::c_short,
  pub dmScale: libc::c_short,
  pub dmCopies: libc::c_short,
  pub dmDefaultSource: libc::c_short,
  pub dmPrintQuality: libc::c_short,
}
#[test]
fn bindgen_test_layout__devicemodeA__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmOrientation
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmOrientation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmPaperSize as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPaperSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmPaperLength
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPaperLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmPaperWidth as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPaperWidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmScale as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmScale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmCopies as *const _
        as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmCopies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmDefaultSource
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmDefaultSource)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_1>())).dmPrintQuality
        as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPrintQuality)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _devicemodeA__bindgen_ty_1__bindgen_ty_2 {
  pub dmPosition: POINTL,
  pub dmDisplayOrientation: DWORD,
  pub dmDisplayFixedOutput: DWORD,
}
#[test]
fn bindgen_test_layout__devicemodeA__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeA__bindgen_ty_1__bindgen_ty_2>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeA__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_2>())).dmPosition as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dmPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_2>())).dmDisplayOrientation
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dmDisplayOrientation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_1__bindgen_ty_2>())).dmDisplayFixedOutput
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dmDisplayFixedOutput)
    )
  );
}
#[test]
fn bindgen_test_layout__devicemodeA__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeA__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_devicemodeA__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeA__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_devicemodeA__bindgen_ty_1))
  );
}
impl Default for _devicemodeA__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _devicemodeA__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_devicemodeA__bindgen_ty_1 {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeA__bindgen_ty_2 {
  pub dmDisplayFlags: DWORD,
  pub dmNup: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__devicemodeA__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeA__bindgen_ty_2>(),
    4usize,
    concat!("Size of: ", stringify!(_devicemodeA__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeA__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_devicemodeA__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_2>())).dmDisplayFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_2),
      "::",
      stringify!(dmDisplayFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA__bindgen_ty_2>())).dmNup as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA__bindgen_ty_2),
      "::",
      stringify!(dmNup)
    )
  );
}
impl Default for _devicemodeA__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _devicemodeA__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_devicemodeA__bindgen_ty_2 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__devicemodeA() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeA>(),
    156usize,
    concat!("Size of: ", stringify!(_devicemodeA))
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeA>(),
    4usize,
    concat!("Alignment of ", stringify!(_devicemodeA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmDeviceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmDeviceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmSpecVersion as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmSpecVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmDriverVersion as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmDriverVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmSize as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmDriverExtra as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmDriverExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmFields as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmFields)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmColor as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmDuplex as *const _ as usize },
    62usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmDuplex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmYResolution as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmYResolution)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmTTOption as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmTTOption)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmCollate as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmCollate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmFormName as *const _ as usize },
    70usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmFormName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmLogPixels as *const _ as usize },
    102usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmLogPixels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmBitsPerPel as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmBitsPerPel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmPelsWidth as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmPelsWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmPelsHeight as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmPelsHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmDisplayFrequency as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmDisplayFrequency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmICMMethod as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmICMMethod)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmICMIntent as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmICMIntent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmMediaType as *const _ as usize },
    132usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmMediaType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmDitherType as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmDitherType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmReserved1 as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmReserved2 as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmPanningWidth as *const _ as usize },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmPanningWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeA>())).dmPanningHeight as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeA),
      "::",
      stringify!(dmPanningHeight)
    )
  );
}
impl Default for _devicemodeA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _devicemodeA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_devicemodeA {{ dmDeviceName: [...], dmSpecVersion: {:?}, dmDriverVersion: {:?}, dmSize: {:?}, dmDriverExtra: {:?}, dmFields: {:?}, __bindgen_anon_1: {:?}, dmColor: {:?}, dmDuplex: {:?}, dmYResolution: {:?}, dmTTOption: {:?}, dmCollate: {:?}, dmFormName: [...], dmLogPixels: {:?}, dmBitsPerPel: {:?}, dmPelsWidth: {:?}, dmPelsHeight: {:?}, __bindgen_anon_2: {:?}, dmDisplayFrequency: {:?}, dmICMMethod: {:?}, dmICMIntent: {:?}, dmMediaType: {:?}, dmDitherType: {:?}, dmReserved1: {:?}, dmReserved2: {:?}, dmPanningWidth: {:?}, dmPanningHeight: {:?} }}" , self . dmSpecVersion , self . dmDriverVersion , self . dmSize , self . dmDriverExtra , self . dmFields , self . __bindgen_anon_1 , self . dmColor , self . dmDuplex , self . dmYResolution , self . dmTTOption , self . dmCollate , self . dmLogPixels , self . dmBitsPerPel , self . dmPelsWidth , self . dmPelsHeight , self . __bindgen_anon_2 , self . dmDisplayFrequency , self . dmICMMethod , self . dmICMIntent , self . dmMediaType , self . dmDitherType , self . dmReserved1 , self . dmReserved2 , self . dmPanningWidth , self . dmPanningHeight )
  }
}
pub type DEVMODEA = _devicemodeA;
pub type PDEVMODEA = *mut _devicemodeA;
pub type NPDEVMODEA = *mut _devicemodeA;
pub type LPDEVMODEA = *mut _devicemodeA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _devicemodeW {
  pub dmDeviceName: [WCHAR; 32usize],
  pub dmSpecVersion: WORD,
  pub dmDriverVersion: WORD,
  pub dmSize: WORD,
  pub dmDriverExtra: WORD,
  pub dmFields: DWORD,
  pub __bindgen_anon_1: _devicemodeW__bindgen_ty_1,
  pub dmColor: libc::c_short,
  pub dmDuplex: libc::c_short,
  pub dmYResolution: libc::c_short,
  pub dmTTOption: libc::c_short,
  pub dmCollate: libc::c_short,
  pub dmFormName: [WCHAR; 32usize],
  pub dmLogPixels: WORD,
  pub dmBitsPerPel: DWORD,
  pub dmPelsWidth: DWORD,
  pub dmPelsHeight: DWORD,
  pub __bindgen_anon_2: _devicemodeW__bindgen_ty_2,
  pub dmDisplayFrequency: DWORD,
  pub dmICMMethod: DWORD,
  pub dmICMIntent: DWORD,
  pub dmMediaType: DWORD,
  pub dmDitherType: DWORD,
  pub dmReserved1: DWORD,
  pub dmReserved2: DWORD,
  pub dmPanningWidth: DWORD,
  pub dmPanningHeight: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeW__bindgen_ty_1 {
  pub __bindgen_anon_1: _devicemodeW__bindgen_ty_1__bindgen_ty_1,
  pub __bindgen_anon_2: _devicemodeW__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _devicemodeW__bindgen_ty_1__bindgen_ty_1 {
  pub dmOrientation: libc::c_short,
  pub dmPaperSize: libc::c_short,
  pub dmPaperLength: libc::c_short,
  pub dmPaperWidth: libc::c_short,
  pub dmScale: libc::c_short,
  pub dmCopies: libc::c_short,
  pub dmDefaultSource: libc::c_short,
  pub dmPrintQuality: libc::c_short,
}
#[test]
fn bindgen_test_layout__devicemodeW__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmOrientation
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmOrientation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmPaperSize as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPaperSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmPaperLength
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPaperLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmPaperWidth as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPaperWidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmScale as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmScale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmCopies as *const _
        as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmCopies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmDefaultSource
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmDefaultSource)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_1>())).dmPrintQuality
        as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dmPrintQuality)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _devicemodeW__bindgen_ty_1__bindgen_ty_2 {
  pub dmPosition: POINTL,
  pub dmDisplayOrientation: DWORD,
  pub dmDisplayFixedOutput: DWORD,
}
#[test]
fn bindgen_test_layout__devicemodeW__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeW__bindgen_ty_1__bindgen_ty_2>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeW__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_2>())).dmPosition as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dmPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_2>())).dmDisplayOrientation
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dmDisplayOrientation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_1__bindgen_ty_2>())).dmDisplayFixedOutput
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(dmDisplayFixedOutput)
    )
  );
}
#[test]
fn bindgen_test_layout__devicemodeW__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeW__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_devicemodeW__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeW__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_devicemodeW__bindgen_ty_1))
  );
}
impl Default for _devicemodeW__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _devicemodeW__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_devicemodeW__bindgen_ty_1 {{ union }}")
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeW__bindgen_ty_2 {
  pub dmDisplayFlags: DWORD,
  pub dmNup: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__devicemodeW__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeW__bindgen_ty_2>(),
    4usize,
    concat!("Size of: ", stringify!(_devicemodeW__bindgen_ty_2))
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeW__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_devicemodeW__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_2>())).dmDisplayFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_2),
      "::",
      stringify!(dmDisplayFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW__bindgen_ty_2>())).dmNup as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW__bindgen_ty_2),
      "::",
      stringify!(dmNup)
    )
  );
}
impl Default for _devicemodeW__bindgen_ty_2 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _devicemodeW__bindgen_ty_2 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_devicemodeW__bindgen_ty_2 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__devicemodeW() {
  assert_eq!(
    ::core::mem::size_of::<_devicemodeW>(),
    220usize,
    concat!("Size of: ", stringify!(_devicemodeW))
  );
  assert_eq!(
    ::core::mem::align_of::<_devicemodeW>(),
    4usize,
    concat!("Alignment of ", stringify!(_devicemodeW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmDeviceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmDeviceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmSpecVersion as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmSpecVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmDriverVersion as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmDriverVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmSize as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmDriverExtra as *const _ as usize },
    70usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmDriverExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmFields as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmFields)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmColor as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmDuplex as *const _ as usize },
    94usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmDuplex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmYResolution as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmYResolution)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmTTOption as *const _ as usize },
    98usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmTTOption)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmCollate as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmCollate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmFormName as *const _ as usize },
    102usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmFormName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmLogPixels as *const _ as usize },
    166usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmLogPixels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmBitsPerPel as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmBitsPerPel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmPelsWidth as *const _ as usize },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmPelsWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmPelsHeight as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmPelsHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmDisplayFrequency as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmDisplayFrequency)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmICMMethod as *const _ as usize },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmICMMethod)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmICMIntent as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmICMIntent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmMediaType as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmMediaType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmDitherType as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmDitherType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmReserved1 as *const _ as usize },
    204usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmReserved2 as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmPanningWidth as *const _ as usize },
    212usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmPanningWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_devicemodeW>())).dmPanningHeight as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_devicemodeW),
      "::",
      stringify!(dmPanningHeight)
    )
  );
}
impl Default for _devicemodeW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _devicemodeW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_devicemodeW {{ dmDeviceName: [...], dmSpecVersion: {:?}, dmDriverVersion: {:?}, dmSize: {:?}, dmDriverExtra: {:?}, dmFields: {:?}, __bindgen_anon_1: {:?}, dmColor: {:?}, dmDuplex: {:?}, dmYResolution: {:?}, dmTTOption: {:?}, dmCollate: {:?}, dmFormName: [...], dmLogPixels: {:?}, dmBitsPerPel: {:?}, dmPelsWidth: {:?}, dmPelsHeight: {:?}, __bindgen_anon_2: {:?}, dmDisplayFrequency: {:?}, dmICMMethod: {:?}, dmICMIntent: {:?}, dmMediaType: {:?}, dmDitherType: {:?}, dmReserved1: {:?}, dmReserved2: {:?}, dmPanningWidth: {:?}, dmPanningHeight: {:?} }}" , self . dmSpecVersion , self . dmDriverVersion , self . dmSize , self . dmDriverExtra , self . dmFields , self . __bindgen_anon_1 , self . dmColor , self . dmDuplex , self . dmYResolution , self . dmTTOption , self . dmCollate , self . dmLogPixels , self . dmBitsPerPel , self . dmPelsWidth , self . dmPelsHeight , self . __bindgen_anon_2 , self . dmDisplayFrequency , self . dmICMMethod , self . dmICMIntent , self . dmMediaType , self . dmDitherType , self . dmReserved1 , self . dmReserved2 , self . dmPanningWidth , self . dmPanningHeight )
  }
}
pub type DEVMODEW = _devicemodeW;
pub type PDEVMODEW = *mut _devicemodeW;
pub type NPDEVMODEW = *mut _devicemodeW;
pub type LPDEVMODEW = *mut _devicemodeW;
pub type DEVMODE = DEVMODEA;
pub type PDEVMODE = PDEVMODEA;
pub type NPDEVMODE = NPDEVMODEA;
pub type LPDEVMODE = LPDEVMODEA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAY_DEVICEA {
  pub cb: DWORD,
  pub DeviceName: [CHAR; 32usize],
  pub DeviceString: [CHAR; 128usize],
  pub StateFlags: DWORD,
  pub DeviceID: [CHAR; 128usize],
  pub DeviceKey: [CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__DISPLAY_DEVICEA() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAY_DEVICEA>(),
    424usize,
    concat!("Size of: ", stringify!(_DISPLAY_DEVICEA))
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAY_DEVICEA>(),
    4usize,
    concat!("Alignment of ", stringify!(_DISPLAY_DEVICEA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEA>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEA),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEA>())).DeviceName as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEA),
      "::",
      stringify!(DeviceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEA>())).DeviceString as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEA),
      "::",
      stringify!(DeviceString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEA>())).StateFlags as *const _ as usize },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEA),
      "::",
      stringify!(StateFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEA>())).DeviceID as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEA),
      "::",
      stringify!(DeviceID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEA>())).DeviceKey as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEA),
      "::",
      stringify!(DeviceKey)
    )
  );
}
impl Default for _DISPLAY_DEVICEA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DISPLAY_DEVICEA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_DISPLAY_DEVICEA {{ cb: {:?}, DeviceName: [...], DeviceString: [...], StateFlags: {:?}, DeviceID: [...], DeviceKey: [...] }}" , self . cb , self . StateFlags )
  }
}
impl ::core::cmp::PartialEq for _DISPLAY_DEVICEA {
  fn eq(&self, other: &_DISPLAY_DEVICEA) -> bool {
    self.cb == other.cb
      && self.DeviceName == other.DeviceName
      && &self.DeviceString[..] == &other.DeviceString[..]
      && self.StateFlags == other.StateFlags
      && &self.DeviceID[..] == &other.DeviceID[..]
      && &self.DeviceKey[..] == &other.DeviceKey[..]
  }
}
pub type DISPLAY_DEVICEA = _DISPLAY_DEVICEA;
pub type PDISPLAY_DEVICEA = *mut _DISPLAY_DEVICEA;
pub type LPDISPLAY_DEVICEA = *mut _DISPLAY_DEVICEA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAY_DEVICEW {
  pub cb: DWORD,
  pub DeviceName: [WCHAR; 32usize],
  pub DeviceString: [WCHAR; 128usize],
  pub StateFlags: DWORD,
  pub DeviceID: [WCHAR; 128usize],
  pub DeviceKey: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__DISPLAY_DEVICEW() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAY_DEVICEW>(),
    840usize,
    concat!("Size of: ", stringify!(_DISPLAY_DEVICEW))
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAY_DEVICEW>(),
    4usize,
    concat!("Alignment of ", stringify!(_DISPLAY_DEVICEW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEW>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEW),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEW>())).DeviceName as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEW),
      "::",
      stringify!(DeviceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEW>())).DeviceString as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEW),
      "::",
      stringify!(DeviceString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEW>())).StateFlags as *const _ as usize },
    324usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEW),
      "::",
      stringify!(StateFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEW>())).DeviceID as *const _ as usize },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEW),
      "::",
      stringify!(DeviceID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISPLAY_DEVICEW>())).DeviceKey as *const _ as usize },
    584usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAY_DEVICEW),
      "::",
      stringify!(DeviceKey)
    )
  );
}
impl Default for _DISPLAY_DEVICEW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DISPLAY_DEVICEW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_DISPLAY_DEVICEW {{ cb: {:?}, DeviceName: [...], DeviceString: [...], StateFlags: {:?}, DeviceID: [...], DeviceKey: [...] }}" , self . cb , self . StateFlags )
  }
}
impl ::core::cmp::PartialEq for _DISPLAY_DEVICEW {
  fn eq(&self, other: &_DISPLAY_DEVICEW) -> bool {
    self.cb == other.cb
      && self.DeviceName == other.DeviceName
      && &self.DeviceString[..] == &other.DeviceString[..]
      && self.StateFlags == other.StateFlags
      && &self.DeviceID[..] == &other.DeviceID[..]
      && &self.DeviceKey[..] == &other.DeviceKey[..]
  }
}
pub type DISPLAY_DEVICEW = _DISPLAY_DEVICEW;
pub type PDISPLAY_DEVICEW = *mut _DISPLAY_DEVICEW;
pub type LPDISPLAY_DEVICEW = *mut _DISPLAY_DEVICEW;
pub type DISPLAY_DEVICE = DISPLAY_DEVICEA;
pub type PDISPLAY_DEVICE = PDISPLAY_DEVICEA;
pub type LPDISPLAY_DEVICE = LPDISPLAY_DEVICEA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_RATIONAL {
  pub Numerator: UINT32,
  pub Denominator: UINT32,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_RATIONAL() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_RATIONAL>(),
    8usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_RATIONAL))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_RATIONAL>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_RATIONAL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_RATIONAL>())).Numerator as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_RATIONAL),
      "::",
      stringify!(Numerator)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_RATIONAL>())).Denominator as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_RATIONAL),
      "::",
      stringify!(Denominator)
    )
  );
}
pub mod DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY {
  pub type Type = i32;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER: Type = -1;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15: Type = 0;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO: Type = 1;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO: Type = 2;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO: Type = 3;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI: Type = 4;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI: Type = 5;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS: Type = 6;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN: Type = 8;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI: Type = 9;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL: Type = 10;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED: Type = 11;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL: Type = 12;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED: Type = 13;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE: Type = 14;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST: Type = 15;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED: Type = 16;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL: Type = -2147483648;
  pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32: Type = -1;
}
pub mod DISPLAYCONFIG_SCANLINE_ORDERING {
  pub type Type = i32;
  pub const DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED: Type = 0;
  pub const DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE: Type = 1;
  pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED: Type = 2;
  pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST: Type = 2;
  pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST: Type = 3;
  pub const DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32: Type = -1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_2DREGION {
  pub cx: UINT32,
  pub cy: UINT32,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_2DREGION() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_2DREGION>(),
    8usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_2DREGION))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_2DREGION>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_2DREGION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_2DREGION>())).cx as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_2DREGION),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_2DREGION>())).cy as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_2DREGION),
      "::",
      stringify!(cy)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
  pub pixelRate: UINT64,
  pub hSyncFreq: DISPLAYCONFIG_RATIONAL,
  pub vSyncFreq: DISPLAYCONFIG_RATIONAL,
  pub activeSize: DISPLAYCONFIG_2DREGION,
  pub totalSize: DISPLAYCONFIG_2DREGION,
  pub __bindgen_anon_1: DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1,
  pub scanLineOrdering: DISPLAYCONFIG_SCANLINE_ORDERING::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1 {
  pub AdditionalSignalInfo: DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1,
  pub videoStandard: UINT32,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn videoStandard(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_videoStandard(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn vSyncFreqDivider(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
  }
  #[inline]
  pub fn set_vSyncFreqDivider(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 6u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(22usize, 10u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    videoStandard: UINT32, vSyncFreqDivider: UINT32, reserved: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let videoStandard: u32 = unsafe { ::core::mem::transmute(videoStandard) };
      videoStandard as u64
    });
    __bindgen_bitfield_unit.set(16usize, 6u8, {
      let vSyncFreqDivider: u32 = unsafe { ::core::mem::transmute(vSyncFreqDivider) };
      vSyncFreqDivider as u64
    });
    __bindgen_bitfield_unit.set(22usize, 10u8, {
      let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1>()))
        .AdditionalSignalInfo as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1),
      "::",
      stringify!(AdditionalSignalInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1>())).videoStandard
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1),
      "::",
      stringify!(videoStandard)
    )
  );
}
impl Default for DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_VIDEO_SIGNAL_INFO() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>())).pixelRate as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO),
      "::",
      stringify!(pixelRate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>())).hSyncFreq as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO),
      "::",
      stringify!(hSyncFreq)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>())).vSyncFreq as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO),
      "::",
      stringify!(vSyncFreq)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>())).activeSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO),
      "::",
      stringify!(activeSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>())).totalSize as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO),
      "::",
      stringify!(totalSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_VIDEO_SIGNAL_INFO>())).scanLineOrdering as *const _
        as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_VIDEO_SIGNAL_INFO),
      "::",
      stringify!(scanLineOrdering)
    )
  );
}
impl Default for DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "DISPLAYCONFIG_VIDEO_SIGNAL_INFO {{ pixelRate: {:?}, hSyncFreq: {:?}, vSyncFreq: {:?}, activeSize: {:?}, totalSize: {:?}, __bindgen_anon_1: {:?}, scanLineOrdering: {:?} }}" , self . pixelRate , self . hSyncFreq , self . vSyncFreq , self . activeSize , self . totalSize , self . __bindgen_anon_1 , self . scanLineOrdering )
  }
}
pub mod DISPLAYCONFIG_SCALING {
  pub type Type = i32;
  pub const DISPLAYCONFIG_SCALING_IDENTITY: Type = 1;
  pub const DISPLAYCONFIG_SCALING_CENTERED: Type = 2;
  pub const DISPLAYCONFIG_SCALING_STRETCHED: Type = 3;
  pub const DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX: Type = 4;
  pub const DISPLAYCONFIG_SCALING_CUSTOM: Type = 5;
  pub const DISPLAYCONFIG_SCALING_PREFERRED: Type = 128;
  pub const DISPLAYCONFIG_SCALING_FORCE_UINT32: Type = -1;
}
pub mod DISPLAYCONFIG_ROTATION {
  pub type Type = i32;
  pub const DISPLAYCONFIG_ROTATION_IDENTITY: Type = 1;
  pub const DISPLAYCONFIG_ROTATION_ROTATE90: Type = 2;
  pub const DISPLAYCONFIG_ROTATION_ROTATE180: Type = 3;
  pub const DISPLAYCONFIG_ROTATION_ROTATE270: Type = 4;
  pub const DISPLAYCONFIG_ROTATION_FORCE_UINT32: Type = -1;
}
pub mod DISPLAYCONFIG_MODE_INFO_TYPE {
  pub type Type = i32;
  pub const DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE: Type = 1;
  pub const DISPLAYCONFIG_MODE_INFO_TYPE_TARGET: Type = 2;
  pub const DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE: Type = 3;
  pub const DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32: Type = -1;
}
pub mod DISPLAYCONFIG_PIXELFORMAT {
  pub type Type = i32;
  pub const DISPLAYCONFIG_PIXELFORMAT_8BPP: Type = 1;
  pub const DISPLAYCONFIG_PIXELFORMAT_16BPP: Type = 2;
  pub const DISPLAYCONFIG_PIXELFORMAT_24BPP: Type = 3;
  pub const DISPLAYCONFIG_PIXELFORMAT_32BPP: Type = 4;
  pub const DISPLAYCONFIG_PIXELFORMAT_NONGDI: Type = 5;
  pub const DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32: Type = -1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_SOURCE_MODE {
  pub width: UINT32,
  pub height: UINT32,
  pub pixelFormat: DISPLAYCONFIG_PIXELFORMAT::Type,
  pub position: POINTL,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SOURCE_MODE() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SOURCE_MODE>(),
    20usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_SOURCE_MODE))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SOURCE_MODE>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_SOURCE_MODE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_SOURCE_MODE>())).width as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SOURCE_MODE),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_SOURCE_MODE>())).height as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SOURCE_MODE),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SOURCE_MODE>())).pixelFormat as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SOURCE_MODE),
      "::",
      stringify!(pixelFormat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_SOURCE_MODE>())).position as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SOURCE_MODE),
      "::",
      stringify!(position)
    )
  );
}
impl Default for DISPLAYCONFIG_SOURCE_MODE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_MODE {
  pub targetVideoSignalInfo: DISPLAYCONFIG_VIDEO_SIGNAL_INFO,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_MODE() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_MODE>(),
    48usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_TARGET_MODE))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_MODE>(),
    8usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_TARGET_MODE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_MODE>())).targetVideoSignalInfo as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_MODE),
      "::",
      stringify!(targetVideoSignalInfo)
    )
  );
}
impl Default for DISPLAYCONFIG_TARGET_MODE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_TARGET_MODE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_TARGET_MODE {{ targetVideoSignalInfo: {:?} }}",
      self.targetVideoSignalInfo
    )
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO {
  pub PathSourceSize: POINTL,
  pub DesktopImageRegion: RECTL,
  pub DesktopImageClip: RECTL,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_DESKTOP_IMAGE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_DESKTOP_IMAGE_INFO>(),
    40usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_DESKTOP_IMAGE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_DESKTOP_IMAGE_INFO>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_DESKTOP_IMAGE_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DESKTOP_IMAGE_INFO>())).PathSourceSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DESKTOP_IMAGE_INFO),
      "::",
      stringify!(PathSourceSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DESKTOP_IMAGE_INFO>())).DesktopImageRegion as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DESKTOP_IMAGE_INFO),
      "::",
      stringify!(DesktopImageRegion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DESKTOP_IMAGE_INFO>())).DesktopImageClip as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DESKTOP_IMAGE_INFO),
      "::",
      stringify!(DesktopImageClip)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_MODE_INFO {
  pub infoType: DISPLAYCONFIG_MODE_INFO_TYPE::Type,
  pub id: UINT32,
  pub adapterId: LUID,
  pub __bindgen_anon_1: DISPLAYCONFIG_MODE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_MODE_INFO__bindgen_ty_1 {
  pub targetMode: DISPLAYCONFIG_TARGET_MODE,
  pub sourceMode: DISPLAYCONFIG_SOURCE_MODE,
  pub desktopImageInfo: DISPLAYCONFIG_DESKTOP_IMAGE_INFO,
  _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_MODE_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_MODE_INFO__bindgen_ty_1>(),
    48usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_MODE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_MODE_INFO__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_MODE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_MODE_INFO__bindgen_ty_1>())).targetMode as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_MODE_INFO__bindgen_ty_1),
      "::",
      stringify!(targetMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_MODE_INFO__bindgen_ty_1>())).sourceMode as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_MODE_INFO__bindgen_ty_1),
      "::",
      stringify!(sourceMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_MODE_INFO__bindgen_ty_1>())).desktopImageInfo
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_MODE_INFO__bindgen_ty_1),
      "::",
      stringify!(desktopImageInfo)
    )
  );
}
impl Default for DISPLAYCONFIG_MODE_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_MODE_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "DISPLAYCONFIG_MODE_INFO__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_MODE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_MODE_INFO>(),
    64usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_MODE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_MODE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_MODE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_MODE_INFO>())).infoType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_MODE_INFO),
      "::",
      stringify!(infoType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_MODE_INFO>())).id as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_MODE_INFO),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_MODE_INFO>())).adapterId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_MODE_INFO),
      "::",
      stringify!(adapterId)
    )
  );
}
impl Default for DISPLAYCONFIG_MODE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_MODE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "DISPLAYCONFIG_MODE_INFO {{ infoType: {:?}, id: {:?}, adapterId: {:?}, __bindgen_anon_1: {:?} }}" , self . infoType , self . id , self . adapterId , self . __bindgen_anon_1 )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_SOURCE_INFO {
  pub adapterId: LUID,
  pub id: UINT32,
  pub __bindgen_anon_1: DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1,
  pub statusFlags: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1 {
  pub modeInfoIdx: UINT32,
  pub __bindgen_anon_1: DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn cloneGroupId(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_cloneGroupId(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn sourceModeInfoIdx(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_sourceModeInfoIdx(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    cloneGroupId: UINT32, sourceModeInfoIdx: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let cloneGroupId: u32 = unsafe { ::core::mem::transmute(cloneGroupId) };
      cloneGroupId as u64
    });
    __bindgen_bitfield_unit.set(16usize, 16u8, {
      let sourceModeInfoIdx: u32 = unsafe { ::core::mem::transmute(sourceModeInfoIdx) };
      sourceModeInfoIdx as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1>())).modeInfoIdx
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1),
      "::",
      stringify!(modeInfoIdx)
    )
  );
}
impl Default for DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_SOURCE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_SOURCE_INFO>(),
    20usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_SOURCE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_SOURCE_INFO>())).adapterId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO),
      "::",
      stringify!(adapterId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_SOURCE_INFO>())).id as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_SOURCE_INFO>())).statusFlags as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_SOURCE_INFO),
      "::",
      stringify!(statusFlags)
    )
  );
}
impl Default for DISPLAYCONFIG_PATH_SOURCE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_PATH_SOURCE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "DISPLAYCONFIG_PATH_SOURCE_INFO {{ adapterId: {:?}, id: {:?}, __bindgen_anon_1: {:?}, statusFlags: {:?} }}" , self . adapterId , self . id , self . __bindgen_anon_1 , self . statusFlags )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_TARGET_INFO {
  pub adapterId: LUID,
  pub id: UINT32,
  pub __bindgen_anon_1: DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1,
  pub outputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY::Type,
  pub rotation: DISPLAYCONFIG_ROTATION::Type,
  pub scaling: DISPLAYCONFIG_SCALING::Type,
  pub refreshRate: DISPLAYCONFIG_RATIONAL,
  pub scanLineOrdering: DISPLAYCONFIG_SCANLINE_ORDERING::Type,
  pub targetAvailable: BOOL,
  pub statusFlags: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1 {
  pub modeInfoIdx: UINT32,
  pub __bindgen_anon_1: DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn desktopModeInfoIdx(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_desktopModeInfoIdx(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn targetModeInfoIdx(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_targetModeInfoIdx(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(16usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    desktopModeInfoIdx: UINT32, targetModeInfoIdx: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let desktopModeInfoIdx: u32 = unsafe { ::core::mem::transmute(desktopModeInfoIdx) };
      desktopModeInfoIdx as u64
    });
    __bindgen_bitfield_unit.set(16usize, 16u8, {
      let targetModeInfoIdx: u32 = unsafe { ::core::mem::transmute(targetModeInfoIdx) };
      targetModeInfoIdx as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1>())).modeInfoIdx
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1),
      "::",
      stringify!(modeInfoIdx)
    )
  );
}
impl Default for DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_TARGET_INFO() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_TARGET_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_PATH_TARGET_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_TARGET_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_PATH_TARGET_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).adapterId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(adapterId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).id as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).outputTechnology as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(outputTechnology)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).rotation as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(rotation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).scaling as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(scaling)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).refreshRate as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(refreshRate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).scanLineOrdering as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(scanLineOrdering)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).targetAvailable as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(targetAvailable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_TARGET_INFO>())).statusFlags as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_TARGET_INFO),
      "::",
      stringify!(statusFlags)
    )
  );
}
impl Default for DISPLAYCONFIG_PATH_TARGET_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_PATH_TARGET_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "DISPLAYCONFIG_PATH_TARGET_INFO {{ adapterId: {:?}, id: {:?}, __bindgen_anon_1: {:?}, outputTechnology: {:?}, rotation: {:?}, scaling: {:?}, refreshRate: {:?}, scanLineOrdering: {:?}, targetAvailable: {:?}, statusFlags: {:?} }}" , self . adapterId , self . id , self . __bindgen_anon_1 , self . outputTechnology , self . rotation , self . scaling , self . refreshRate , self . scanLineOrdering , self . targetAvailable , self . statusFlags )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_INFO {
  pub sourceInfo: DISPLAYCONFIG_PATH_SOURCE_INFO,
  pub targetInfo: DISPLAYCONFIG_PATH_TARGET_INFO,
  pub flags: UINT32,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_PATH_INFO() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_PATH_INFO>(),
    72usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_PATH_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_PATH_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_PATH_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_INFO>())).sourceInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_INFO),
      "::",
      stringify!(sourceInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_INFO>())).targetInfo as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_INFO),
      "::",
      stringify!(targetInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_PATH_INFO>())).flags as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_PATH_INFO),
      "::",
      stringify!(flags)
    )
  );
}
impl Default for DISPLAYCONFIG_PATH_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_PATH_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_PATH_INFO {{ sourceInfo: {:?}, targetInfo: {:?}, flags: {:?} }}",
      self.sourceInfo, self.targetInfo, self.flags
    )
  }
}
pub mod DISPLAYCONFIG_TOPOLOGY_ID {
  pub type Type = i32;
  pub const DISPLAYCONFIG_TOPOLOGY_INTERNAL: Type = 1;
  pub const DISPLAYCONFIG_TOPOLOGY_CLONE: Type = 2;
  pub const DISPLAYCONFIG_TOPOLOGY_EXTEND: Type = 4;
  pub const DISPLAYCONFIG_TOPOLOGY_EXTERNAL: Type = 8;
  pub const DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32: Type = -1;
}
pub mod DISPLAYCONFIG_DEVICE_INFO_TYPE {
  pub type Type = i32;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME: Type = 1;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME: Type = 2;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE: Type = 3;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME: Type = 4;
  pub const DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE: Type = 5;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE: Type = 6;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION: Type = 7;
  pub const DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION: Type = 8;
  pub const DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO: Type = 9;
  pub const DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE: Type = 10;
  pub const DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32: Type = -1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_DEVICE_INFO_HEADER {
  pub type_: DISPLAYCONFIG_DEVICE_INFO_TYPE::Type,
  pub size: UINT32,
  pub adapterId: LUID,
  pub id: UINT32,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_DEVICE_INFO_HEADER() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_DEVICE_INFO_HEADER>(),
    20usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_DEVICE_INFO_HEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_DEVICE_INFO_HEADER>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_DEVICE_INFO_HEADER)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DEVICE_INFO_HEADER>())).type_ as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DEVICE_INFO_HEADER),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DEVICE_INFO_HEADER>())).size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DEVICE_INFO_HEADER),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DEVICE_INFO_HEADER>())).adapterId as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DEVICE_INFO_HEADER),
      "::",
      stringify!(adapterId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_DEVICE_INFO_HEADER>())).id as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_DEVICE_INFO_HEADER),
      "::",
      stringify!(id)
    )
  );
}
impl Default for DISPLAYCONFIG_DEVICE_INFO_HEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_SOURCE_DEVICE_NAME {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub viewGdiDeviceName: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SOURCE_DEVICE_NAME() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SOURCE_DEVICE_NAME>(),
    84usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_SOURCE_DEVICE_NAME))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SOURCE_DEVICE_NAME>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SOURCE_DEVICE_NAME)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SOURCE_DEVICE_NAME>())).header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SOURCE_DEVICE_NAME),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SOURCE_DEVICE_NAME>())).viewGdiDeviceName as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SOURCE_DEVICE_NAME),
      "::",
      stringify!(viewGdiDeviceName)
    )
  );
}
impl Default for DISPLAYCONFIG_SOURCE_DEVICE_NAME {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
  pub __bindgen_anon_1: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1 {
  pub __bindgen_anon_1: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1,
  pub value: UINT32,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn friendlyNameFromEdid(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_friendlyNameFromEdid(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn friendlyNameForced(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_friendlyNameForced(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn edidIdsValid(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_edidIdsValid(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 29u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    friendlyNameFromEdid: UINT32, friendlyNameForced: UINT32, edidIdsValid: UINT32,
    reserved: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let friendlyNameFromEdid: u32 = unsafe { ::core::mem::transmute(friendlyNameFromEdid) };
      friendlyNameFromEdid as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let friendlyNameForced: u32 = unsafe { ::core::mem::transmute(friendlyNameForced) };
      friendlyNameForced as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let edidIdsValid: u32 = unsafe { ::core::mem::transmute(edidIdsValid) };
      edidIdsValid as u64
    });
    __bindgen_bitfield_unit.set(3usize, 29u8, {
      let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1>())).value
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1),
      "::",
      stringify!(value)
    )
  );
}
impl Default for DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS)
    )
  );
}
impl Default for DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_DEVICE_NAME {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub flags: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS,
  pub outputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY::Type,
  pub edidManufactureId: UINT16,
  pub edidProductCodeId: UINT16,
  pub connectorInstance: UINT32,
  pub monitorFriendlyDeviceName: [WCHAR; 64usize],
  pub monitorDevicePath: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_DEVICE_NAME() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME>(),
    420usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_DEVICE_NAME>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).flags as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).outputTechnology as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(outputTechnology)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).edidManufactureId as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(edidManufactureId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).edidProductCodeId as *const _
        as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(edidProductCodeId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).connectorInstance as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(connectorInstance)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).monitorFriendlyDeviceName
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(monitorFriendlyDeviceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_DEVICE_NAME>())).monitorDevicePath as *const _
        as usize
    },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_DEVICE_NAME),
      "::",
      stringify!(monitorDevicePath)
    )
  );
}
impl Default for DISPLAYCONFIG_TARGET_DEVICE_NAME {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_TARGET_DEVICE_NAME {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "DISPLAYCONFIG_TARGET_DEVICE_NAME {{ header: {:?}, flags: {:?}, outputTechnology: {:?}, edidManufactureId: {:?}, edidProductCodeId: {:?}, connectorInstance: {:?}, monitorFriendlyDeviceName: [...], monitorDevicePath: [...] }}" , self . header , self . flags , self . outputTechnology , self . edidManufactureId , self . edidProductCodeId , self . connectorInstance )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_PREFERRED_MODE {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub width: UINT32,
  pub height: UINT32,
  pub targetMode: DISPLAYCONFIG_TARGET_MODE,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_PREFERRED_MODE() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_PREFERRED_MODE>(),
    80usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_TARGET_PREFERRED_MODE))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_PREFERRED_MODE>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_TARGET_PREFERRED_MODE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_PREFERRED_MODE>())).header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_PREFERRED_MODE),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_PREFERRED_MODE>())).width as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_PREFERRED_MODE),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_PREFERRED_MODE>())).height as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_PREFERRED_MODE),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_PREFERRED_MODE>())).targetMode as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_PREFERRED_MODE),
      "::",
      stringify!(targetMode)
    )
  );
}
impl Default for DISPLAYCONFIG_TARGET_PREFERRED_MODE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_TARGET_PREFERRED_MODE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "DISPLAYCONFIG_TARGET_PREFERRED_MODE {{ header: {:?}, width: {:?}, height: {:?}, targetMode: {:?} }}" , self . header , self . width , self . height , self . targetMode )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_ADAPTER_NAME {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub adapterDevicePath: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_ADAPTER_NAME() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_ADAPTER_NAME>(),
    276usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_ADAPTER_NAME))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_ADAPTER_NAME>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_ADAPTER_NAME))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DISPLAYCONFIG_ADAPTER_NAME>())).header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_ADAPTER_NAME),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_ADAPTER_NAME>())).adapterDevicePath as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_ADAPTER_NAME),
      "::",
      stringify!(adapterDevicePath)
    )
  );
}
impl Default for DISPLAYCONFIG_ADAPTER_NAME {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_ADAPTER_NAME {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_ADAPTER_NAME {{ header: {:?}, adapterDevicePath: [...] }}",
      self.header
    )
  }
}
impl ::core::cmp::PartialEq for DISPLAYCONFIG_ADAPTER_NAME {
  fn eq(&self, other: &DISPLAYCONFIG_ADAPTER_NAME) -> bool {
    self.header == other.header && &self.adapterDevicePath[..] == &other.adapterDevicePath[..]
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_TARGET_BASE_TYPE {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub baseOutputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY::Type,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_TARGET_BASE_TYPE() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_TARGET_BASE_TYPE>(),
    24usize,
    concat!("Size of: ", stringify!(DISPLAYCONFIG_TARGET_BASE_TYPE))
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_TARGET_BASE_TYPE>(),
    4usize,
    concat!("Alignment of ", stringify!(DISPLAYCONFIG_TARGET_BASE_TYPE))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_BASE_TYPE>())).header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_BASE_TYPE),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_TARGET_BASE_TYPE>())).baseOutputTechnology as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_TARGET_BASE_TYPE),
      "::",
      stringify!(baseOutputTechnology)
    )
  );
}
impl Default for DISPLAYCONFIG_TARGET_BASE_TYPE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub __bindgen_anon_1: DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1 {
  pub __bindgen_anon_1: DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1,
  pub value: UINT32,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn bootPersistenceOn(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_bootPersistenceOn(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    bootPersistenceOn: UINT32, reserved: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let bootPersistenceOn: u32 = unsafe { ::core::mem::transmute(bootPersistenceOn) };
      bootPersistenceOn as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1>())).value
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1),
      "::",
      stringify!(value)
    )
  );
}
impl Default for DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SET_TARGET_PERSISTENCE() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SET_TARGET_PERSISTENCE>())).header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SET_TARGET_PERSISTENCE),
      "::",
      stringify!(header)
    )
  );
}
impl Default for DISPLAYCONFIG_SET_TARGET_PERSISTENCE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_SET_TARGET_PERSISTENCE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_SET_TARGET_PERSISTENCE {{ header: {:?}, __bindgen_anon_1: {:?} }}",
      self.header, self.__bindgen_anon_1
    )
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub __bindgen_anon_1: DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1 {
  pub __bindgen_anon_1: DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1,
  pub value: UINT32,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn disableMonitorVirtualResolution(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_disableMonitorVirtualResolution(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    disableMonitorVirtualResolution: UINT32, reserved: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let disableMonitorVirtualResolution: u32 =
        unsafe { ::core::mem::transmute(disableMonitorVirtualResolution) };
      disableMonitorVirtualResolution as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1>())).value
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1),
      "::",
      stringify!(value)
    )
  );
}
impl Default for DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout_DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION() {
  assert_eq!(
    ::core::mem::size_of::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION>())).header as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION),
      "::",
      stringify!(header)
    )
  );
}
impl Default for DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION {{ header: {:?}, __bindgen_anon_1: {:?} }}",
      self.header, self.__bindgen_anon_1
    )
  }
}
pub mod _DISPLAYCONFIG_COLOR_ENCODING {
  pub type Type = i32;
  pub const DISPLAYCONFIG_COLOR_ENCODING_RGB: Type = 0;
  pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR444: Type = 1;
  pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR422: Type = 2;
  pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR420: Type = 3;
  pub const DISPLAYCONFIG_COLOR_ENCODING_INTENSITY: Type = 4;
  pub const DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32: Type = -1;
}
pub use self::_DISPLAYCONFIG_COLOR_ENCODING::Type as DISPLAYCONFIG_COLOR_ENCODING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub __bindgen_anon_1: _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1,
  pub colorEncoding: DISPLAYCONFIG_COLOR_ENCODING,
  pub bitsPerColorChannel: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1 {
  pub __bindgen_anon_1: _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1,
  pub value: UINT32,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn advancedColorSupported(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_advancedColorSupported(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn advancedColorEnabled(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_advancedColorEnabled(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn wideColorEnforced(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_wideColorEnforced(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(3usize, 29u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    advancedColorSupported: UINT32, advancedColorEnabled: UINT32, wideColorEnforced: UINT32,
    reserved: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let advancedColorSupported: u32 = unsafe { ::core::mem::transmute(advancedColorSupported) };
      advancedColorSupported as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let advancedColorEnabled: u32 = unsafe { ::core::mem::transmute(advancedColorEnabled) };
      advancedColorEnabled as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let wideColorEnforced: u32 = unsafe { ::core::mem::transmute(wideColorEnforced) };
      wideColorEnforced as u64
    });
    __bindgen_bitfield_unit.set(3usize, 29u8, {
      let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1>())).value
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1),
      "::",
      stringify!(value)
    )
  );
}
impl Default for _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO>())).header as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO>())).colorEncoding as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO),
      "::",
      stringify!(colorEncoding)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO>())).bitsPerColorChannel
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO),
      "::",
      stringify!(bitsPerColorChannel)
    )
  );
}
impl Default for _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO {{ header: {:?}, __bindgen_anon_1: {:?}, colorEncoding: {:?}, bitsPerColorChannel: {:?} }}" , self . header , self . __bindgen_anon_1 , self . colorEncoding , self . bitsPerColorChannel )
  }
}
pub type DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO = _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE {
  pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
  pub __bindgen_anon_1: _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1 {
  pub __bindgen_anon_1: _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1,
  pub value: UINT32,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1)
    )
  );
}
impl _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn enableAdvancedColor(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_enableAdvancedColor(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn reserved(&self) -> UINT32 {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: UINT32) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    enableAdvancedColor: UINT32, reserved: UINT32,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let enableAdvancedColor: u32 = unsafe { ::core::mem::transmute(enableAdvancedColor) };
      enableAdvancedColor as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1>())).value
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1),
      "::",
      stringify!(value)
    )
  );
}
impl Default for _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE() {
  assert_eq!(
    ::core::mem::size_of::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE>())).header as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE),
      "::",
      stringify!(header)
    )
  );
}
impl Default for _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE {{ header: {:?}, __bindgen_anon_1: {:?} }}",
      self.header, self.__bindgen_anon_1
    )
  }
}
pub type DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE = _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RGNDATAHEADER {
  pub dwSize: DWORD,
  pub iType: DWORD,
  pub nCount: DWORD,
  pub nRgnSize: DWORD,
  pub rcBound: RECT,
}
#[test]
fn bindgen_test_layout__RGNDATAHEADER() {
  assert_eq!(
    ::core::mem::size_of::<_RGNDATAHEADER>(),
    32usize,
    concat!("Size of: ", stringify!(_RGNDATAHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<_RGNDATAHEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_RGNDATAHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATAHEADER>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATAHEADER),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATAHEADER>())).iType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATAHEADER),
      "::",
      stringify!(iType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATAHEADER>())).nCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATAHEADER),
      "::",
      stringify!(nCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATAHEADER>())).nRgnSize as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATAHEADER),
      "::",
      stringify!(nRgnSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATAHEADER>())).rcBound as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATAHEADER),
      "::",
      stringify!(rcBound)
    )
  );
}
pub type RGNDATAHEADER = _RGNDATAHEADER;
pub type PRGNDATAHEADER = *mut _RGNDATAHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RGNDATA {
  pub rdh: RGNDATAHEADER,
  pub Buffer: [libc::c_char; 1usize],
}
#[test]
fn bindgen_test_layout__RGNDATA() {
  assert_eq!(
    ::core::mem::size_of::<_RGNDATA>(),
    36usize,
    concat!("Size of: ", stringify!(_RGNDATA))
  );
  assert_eq!(
    ::core::mem::align_of::<_RGNDATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_RGNDATA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATA>())).rdh as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATA),
      "::",
      stringify!(rdh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RGNDATA>())).Buffer as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_RGNDATA),
      "::",
      stringify!(Buffer)
    )
  );
}
pub type RGNDATA = _RGNDATA;
pub type PRGNDATA = *mut _RGNDATA;
pub type NPRGNDATA = *mut _RGNDATA;
pub type LPRGNDATA = *mut _RGNDATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ABC {
  pub abcA: libc::c_int,
  pub abcB: UINT,
  pub abcC: libc::c_int,
}
#[test]
fn bindgen_test_layout__ABC() {
  assert_eq!(
    ::core::mem::size_of::<_ABC>(),
    12usize,
    concat!("Size of: ", stringify!(_ABC))
  );
  assert_eq!(
    ::core::mem::align_of::<_ABC>(),
    4usize,
    concat!("Alignment of ", stringify!(_ABC))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ABC>())).abcA as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ABC),
      "::",
      stringify!(abcA)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ABC>())).abcB as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ABC),
      "::",
      stringify!(abcB)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ABC>())).abcC as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ABC),
      "::",
      stringify!(abcC)
    )
  );
}
pub type ABC = _ABC;
pub type PABC = *mut _ABC;
pub type NPABC = *mut _ABC;
pub type LPABC = *mut _ABC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ABCFLOAT {
  pub abcfA: FLOAT,
  pub abcfB: FLOAT,
  pub abcfC: FLOAT,
}
#[test]
fn bindgen_test_layout__ABCFLOAT() {
  assert_eq!(
    ::core::mem::size_of::<_ABCFLOAT>(),
    12usize,
    concat!("Size of: ", stringify!(_ABCFLOAT))
  );
  assert_eq!(
    ::core::mem::align_of::<_ABCFLOAT>(),
    4usize,
    concat!("Alignment of ", stringify!(_ABCFLOAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ABCFLOAT>())).abcfA as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ABCFLOAT),
      "::",
      stringify!(abcfA)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ABCFLOAT>())).abcfB as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ABCFLOAT),
      "::",
      stringify!(abcfB)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ABCFLOAT>())).abcfC as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ABCFLOAT),
      "::",
      stringify!(abcfC)
    )
  );
}
pub type ABCFLOAT = _ABCFLOAT;
pub type PABCFLOAT = *mut _ABCFLOAT;
pub type NPABCFLOAT = *mut _ABCFLOAT;
pub type LPABCFLOAT = *mut _ABCFLOAT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _OUTLINETEXTMETRICA {
  pub otmSize: UINT,
  pub otmTextMetrics: TEXTMETRICA,
  pub otmFiller: BYTE,
  pub otmPanoseNumber: PANOSE,
  pub otmfsSelection: UINT,
  pub otmfsType: UINT,
  pub otmsCharSlopeRise: libc::c_int,
  pub otmsCharSlopeRun: libc::c_int,
  pub otmItalicAngle: libc::c_int,
  pub otmEMSquare: UINT,
  pub otmAscent: libc::c_int,
  pub otmDescent: libc::c_int,
  pub otmLineGap: UINT,
  pub otmsCapEmHeight: UINT,
  pub otmsXHeight: UINT,
  pub otmrcFontBox: RECT,
  pub otmMacAscent: libc::c_int,
  pub otmMacDescent: libc::c_int,
  pub otmMacLineGap: UINT,
  pub otmusMinimumPPEM: UINT,
  pub otmptSubscriptSize: POINT,
  pub otmptSubscriptOffset: POINT,
  pub otmptSuperscriptSize: POINT,
  pub otmptSuperscriptOffset: POINT,
  pub otmsStrikeoutSize: UINT,
  pub otmsStrikeoutPosition: libc::c_int,
  pub otmsUnderscoreSize: libc::c_int,
  pub otmsUnderscorePosition: libc::c_int,
  pub otmpFamilyName: PSTR,
  pub otmpFaceName: PSTR,
  pub otmpStyleName: PSTR,
  pub otmpFullName: PSTR,
}
#[test]
fn bindgen_test_layout__OUTLINETEXTMETRICA() {
  assert_eq!(
    ::core::mem::size_of::<_OUTLINETEXTMETRICA>(),
    232usize,
    concat!("Size of: ", stringify!(_OUTLINETEXTMETRICA))
  );
  assert_eq!(
    ::core::mem::align_of::<_OUTLINETEXTMETRICA>(),
    8usize,
    concat!("Alignment of ", stringify!(_OUTLINETEXTMETRICA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmTextMetrics as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmTextMetrics)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmFiller as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmFiller)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmPanoseNumber as *const _ as usize
    },
    61usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmPanoseNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmfsSelection as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmfsSelection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmfsType as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmfsType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsCharSlopeRise as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsCharSlopeRise)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsCharSlopeRun as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsCharSlopeRun)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmItalicAngle as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmItalicAngle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmEMSquare as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmEMSquare)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmAscent as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmDescent as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmDescent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmLineGap as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmLineGap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsCapEmHeight as *const _ as usize
    },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsCapEmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsXHeight as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsXHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmrcFontBox as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmrcFontBox)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmMacAscent as *const _ as usize },
    132usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmMacAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmMacDescent as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmMacDescent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmMacLineGap as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmMacLineGap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmusMinimumPPEM as *const _ as usize
    },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmusMinimumPPEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmptSubscriptSize as *const _ as usize
    },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmptSubscriptSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmptSubscriptOffset as *const _ as usize
    },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmptSubscriptOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmptSuperscriptSize as *const _ as usize
    },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmptSuperscriptSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmptSuperscriptOffset as *const _ as usize
    },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmptSuperscriptOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsStrikeoutSize as *const _ as usize
    },
    180usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsStrikeoutSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsStrikeoutPosition as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsStrikeoutPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsUnderscoreSize as *const _ as usize
    },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsUnderscoreSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmsUnderscorePosition as *const _ as usize
    },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmsUnderscorePosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmpFamilyName as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmpFamilyName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmpFaceName as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmpFaceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmpStyleName as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmpStyleName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICA>())).otmpFullName as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICA),
      "::",
      stringify!(otmpFullName)
    )
  );
}
impl Default for _OUTLINETEXTMETRICA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type OUTLINETEXTMETRICA = _OUTLINETEXTMETRICA;
pub type POUTLINETEXTMETRICA = *mut _OUTLINETEXTMETRICA;
pub type NPOUTLINETEXTMETRICA = *mut _OUTLINETEXTMETRICA;
pub type LPOUTLINETEXTMETRICA = *mut _OUTLINETEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _OUTLINETEXTMETRICW {
  pub otmSize: UINT,
  pub otmTextMetrics: TEXTMETRICW,
  pub otmFiller: BYTE,
  pub otmPanoseNumber: PANOSE,
  pub otmfsSelection: UINT,
  pub otmfsType: UINT,
  pub otmsCharSlopeRise: libc::c_int,
  pub otmsCharSlopeRun: libc::c_int,
  pub otmItalicAngle: libc::c_int,
  pub otmEMSquare: UINT,
  pub otmAscent: libc::c_int,
  pub otmDescent: libc::c_int,
  pub otmLineGap: UINT,
  pub otmsCapEmHeight: UINT,
  pub otmsXHeight: UINT,
  pub otmrcFontBox: RECT,
  pub otmMacAscent: libc::c_int,
  pub otmMacDescent: libc::c_int,
  pub otmMacLineGap: UINT,
  pub otmusMinimumPPEM: UINT,
  pub otmptSubscriptSize: POINT,
  pub otmptSubscriptOffset: POINT,
  pub otmptSuperscriptSize: POINT,
  pub otmptSuperscriptOffset: POINT,
  pub otmsStrikeoutSize: UINT,
  pub otmsStrikeoutPosition: libc::c_int,
  pub otmsUnderscoreSize: libc::c_int,
  pub otmsUnderscorePosition: libc::c_int,
  pub otmpFamilyName: PSTR,
  pub otmpFaceName: PSTR,
  pub otmpStyleName: PSTR,
  pub otmpFullName: PSTR,
}
#[test]
fn bindgen_test_layout__OUTLINETEXTMETRICW() {
  assert_eq!(
    ::core::mem::size_of::<_OUTLINETEXTMETRICW>(),
    232usize,
    concat!("Size of: ", stringify!(_OUTLINETEXTMETRICW))
  );
  assert_eq!(
    ::core::mem::align_of::<_OUTLINETEXTMETRICW>(),
    8usize,
    concat!("Alignment of ", stringify!(_OUTLINETEXTMETRICW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmTextMetrics as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmTextMetrics)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmFiller as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmFiller)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmPanoseNumber as *const _ as usize
    },
    65usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmPanoseNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmfsSelection as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmfsSelection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmfsType as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmfsType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsCharSlopeRise as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsCharSlopeRise)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsCharSlopeRun as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsCharSlopeRun)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmItalicAngle as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmItalicAngle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmEMSquare as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmEMSquare)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmAscent as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmDescent as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmDescent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmLineGap as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmLineGap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsCapEmHeight as *const _ as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsCapEmHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsXHeight as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsXHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmrcFontBox as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmrcFontBox)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmMacAscent as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmMacAscent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmMacDescent as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmMacDescent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmMacLineGap as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmMacLineGap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmusMinimumPPEM as *const _ as usize
    },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmusMinimumPPEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmptSubscriptSize as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmptSubscriptSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmptSubscriptOffset as *const _ as usize
    },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmptSubscriptOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmptSuperscriptSize as *const _ as usize
    },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmptSuperscriptSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmptSuperscriptOffset as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmptSuperscriptOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsStrikeoutSize as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsStrikeoutSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsStrikeoutPosition as *const _ as usize
    },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsStrikeoutPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsUnderscoreSize as *const _ as usize
    },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsUnderscoreSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmsUnderscorePosition as *const _ as usize
    },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmsUnderscorePosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmpFamilyName as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmpFamilyName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmpFaceName as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmpFaceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmpStyleName as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmpStyleName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_OUTLINETEXTMETRICW>())).otmpFullName as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_OUTLINETEXTMETRICW),
      "::",
      stringify!(otmpFullName)
    )
  );
}
impl Default for _OUTLINETEXTMETRICW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type OUTLINETEXTMETRICW = _OUTLINETEXTMETRICW;
pub type POUTLINETEXTMETRICW = *mut _OUTLINETEXTMETRICW;
pub type NPOUTLINETEXTMETRICW = *mut _OUTLINETEXTMETRICW;
pub type LPOUTLINETEXTMETRICW = *mut _OUTLINETEXTMETRICW;
pub type OUTLINETEXTMETRIC = OUTLINETEXTMETRICA;
pub type POUTLINETEXTMETRIC = POUTLINETEXTMETRICA;
pub type NPOUTLINETEXTMETRIC = NPOUTLINETEXTMETRICA;
pub type LPOUTLINETEXTMETRIC = LPOUTLINETEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPOLYTEXTA {
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub n: UINT,
  pub lpstr: LPCSTR,
  pub uiFlags: UINT,
  pub rcl: RECT,
  pub pdx: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_tagPOLYTEXTA() {
  assert_eq!(
    ::core::mem::size_of::<tagPOLYTEXTA>(),
    56usize,
    concat!("Size of: ", stringify!(tagPOLYTEXTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOLYTEXTA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOLYTEXTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).n as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(n)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).lpstr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(lpstr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).uiFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(uiFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).rcl as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(rcl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTA>())).pdx as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTA),
      "::",
      stringify!(pdx)
    )
  );
}
impl Default for tagPOLYTEXTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POLYTEXTA = tagPOLYTEXTA;
pub type PPOLYTEXTA = *mut tagPOLYTEXTA;
pub type NPPOLYTEXTA = *mut tagPOLYTEXTA;
pub type LPPOLYTEXTA = *mut tagPOLYTEXTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPOLYTEXTW {
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub n: UINT,
  pub lpstr: LPCWSTR,
  pub uiFlags: UINT,
  pub rcl: RECT,
  pub pdx: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_tagPOLYTEXTW() {
  assert_eq!(
    ::core::mem::size_of::<tagPOLYTEXTW>(),
    56usize,
    concat!("Size of: ", stringify!(tagPOLYTEXTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOLYTEXTW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOLYTEXTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).n as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(n)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).lpstr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(lpstr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).uiFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(uiFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).rcl as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(rcl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOLYTEXTW>())).pdx as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOLYTEXTW),
      "::",
      stringify!(pdx)
    )
  );
}
impl Default for tagPOLYTEXTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POLYTEXTW = tagPOLYTEXTW;
pub type PPOLYTEXTW = *mut tagPOLYTEXTW;
pub type NPPOLYTEXTW = *mut tagPOLYTEXTW;
pub type LPPOLYTEXTW = *mut tagPOLYTEXTW;
pub type POLYTEXT = POLYTEXTA;
pub type PPOLYTEXT = PPOLYTEXTA;
pub type NPPOLYTEXT = NPPOLYTEXTA;
pub type LPPOLYTEXT = LPPOLYTEXTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FIXED {
  pub fract: WORD,
  pub value: libc::c_short,
}
#[test]
fn bindgen_test_layout__FIXED() {
  assert_eq!(
    ::core::mem::size_of::<_FIXED>(),
    4usize,
    concat!("Size of: ", stringify!(_FIXED))
  );
  assert_eq!(
    ::core::mem::align_of::<_FIXED>(),
    2usize,
    concat!("Alignment of ", stringify!(_FIXED))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FIXED>())).fract as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FIXED),
      "::",
      stringify!(fract)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FIXED>())).value as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_FIXED),
      "::",
      stringify!(value)
    )
  );
}
pub type FIXED = _FIXED;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MAT2 {
  pub eM11: FIXED,
  pub eM12: FIXED,
  pub eM21: FIXED,
  pub eM22: FIXED,
}
#[test]
fn bindgen_test_layout__MAT2() {
  assert_eq!(
    ::core::mem::size_of::<_MAT2>(),
    16usize,
    concat!("Size of: ", stringify!(_MAT2))
  );
  assert_eq!(
    ::core::mem::align_of::<_MAT2>(),
    2usize,
    concat!("Alignment of ", stringify!(_MAT2))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MAT2>())).eM11 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MAT2),
      "::",
      stringify!(eM11)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MAT2>())).eM12 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MAT2),
      "::",
      stringify!(eM12)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MAT2>())).eM21 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MAT2),
      "::",
      stringify!(eM21)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MAT2>())).eM22 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_MAT2),
      "::",
      stringify!(eM22)
    )
  );
}
pub type MAT2 = _MAT2;
pub type LPMAT2 = *mut _MAT2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GLYPHMETRICS {
  pub gmBlackBoxX: UINT,
  pub gmBlackBoxY: UINT,
  pub gmptGlyphOrigin: POINT,
  pub gmCellIncX: libc::c_short,
  pub gmCellIncY: libc::c_short,
}
#[test]
fn bindgen_test_layout__GLYPHMETRICS() {
  assert_eq!(
    ::core::mem::size_of::<_GLYPHMETRICS>(),
    20usize,
    concat!("Size of: ", stringify!(_GLYPHMETRICS))
  );
  assert_eq!(
    ::core::mem::align_of::<_GLYPHMETRICS>(),
    4usize,
    concat!("Alignment of ", stringify!(_GLYPHMETRICS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICS>())).gmBlackBoxX as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICS),
      "::",
      stringify!(gmBlackBoxX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICS>())).gmBlackBoxY as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICS),
      "::",
      stringify!(gmBlackBoxY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICS>())).gmptGlyphOrigin as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICS),
      "::",
      stringify!(gmptGlyphOrigin)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICS>())).gmCellIncX as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICS),
      "::",
      stringify!(gmCellIncX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICS>())).gmCellIncY as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICS),
      "::",
      stringify!(gmCellIncY)
    )
  );
}
pub type GLYPHMETRICS = _GLYPHMETRICS;
pub type LPGLYPHMETRICS = *mut _GLYPHMETRICS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPOINTFX {
  pub x: FIXED,
  pub y: FIXED,
}
#[test]
fn bindgen_test_layout_tagPOINTFX() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTFX>(),
    8usize,
    concat!("Size of: ", stringify!(tagPOINTFX))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTFX>(),
    2usize,
    concat!("Alignment of ", stringify!(tagPOINTFX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTFX>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTFX),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTFX>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTFX),
      "::",
      stringify!(y)
    )
  );
}
pub type POINTFX = tagPOINTFX;
pub type LPPOINTFX = *mut tagPOINTFX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTTPOLYCURVE {
  pub wType: WORD,
  pub cpfx: WORD,
  pub apfx: [POINTFX; 1usize],
}
#[test]
fn bindgen_test_layout_tagTTPOLYCURVE() {
  assert_eq!(
    ::core::mem::size_of::<tagTTPOLYCURVE>(),
    12usize,
    concat!("Size of: ", stringify!(tagTTPOLYCURVE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTTPOLYCURVE>(),
    2usize,
    concat!("Alignment of ", stringify!(tagTTPOLYCURVE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTTPOLYCURVE>())).wType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTTPOLYCURVE),
      "::",
      stringify!(wType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTTPOLYCURVE>())).cpfx as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTTPOLYCURVE),
      "::",
      stringify!(cpfx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTTPOLYCURVE>())).apfx as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTTPOLYCURVE),
      "::",
      stringify!(apfx)
    )
  );
}
pub type TTPOLYCURVE = tagTTPOLYCURVE;
pub type LPTTPOLYCURVE = *mut tagTTPOLYCURVE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTTPOLYGONHEADER {
  pub cb: DWORD,
  pub dwType: DWORD,
  pub pfxStart: POINTFX,
}
#[test]
fn bindgen_test_layout_tagTTPOLYGONHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagTTPOLYGONHEADER>(),
    16usize,
    concat!("Size of: ", stringify!(tagTTPOLYGONHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTTPOLYGONHEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTTPOLYGONHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTTPOLYGONHEADER>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTTPOLYGONHEADER),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTTPOLYGONHEADER>())).dwType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTTPOLYGONHEADER),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTTPOLYGONHEADER>())).pfxStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTTPOLYGONHEADER),
      "::",
      stringify!(pfxStart)
    )
  );
}
pub type TTPOLYGONHEADER = tagTTPOLYGONHEADER;
pub type LPTTPOLYGONHEADER = *mut tagTTPOLYGONHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagGCP_RESULTSA {
  pub lStructSize: DWORD,
  pub lpOutString: LPSTR,
  pub lpOrder: *mut UINT,
  pub lpDx: *mut libc::c_int,
  pub lpCaretPos: *mut libc::c_int,
  pub lpClass: LPSTR,
  pub lpGlyphs: LPWSTR,
  pub nGlyphs: UINT,
  pub nMaxFit: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagGCP_RESULTSA() {
  assert_eq!(
    ::core::mem::size_of::<tagGCP_RESULTSA>(),
    64usize,
    concat!("Size of: ", stringify!(tagGCP_RESULTSA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGCP_RESULTSA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagGCP_RESULTSA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lpOutString as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lpOutString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lpOrder as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lpOrder)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lpDx as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lpDx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lpCaretPos as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lpCaretPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lpClass as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lpClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).lpGlyphs as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(lpGlyphs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).nGlyphs as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(nGlyphs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSA>())).nMaxFit as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSA),
      "::",
      stringify!(nMaxFit)
    )
  );
}
impl Default for tagGCP_RESULTSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type GCP_RESULTSA = tagGCP_RESULTSA;
pub type LPGCP_RESULTSA = *mut tagGCP_RESULTSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagGCP_RESULTSW {
  pub lStructSize: DWORD,
  pub lpOutString: LPWSTR,
  pub lpOrder: *mut UINT,
  pub lpDx: *mut libc::c_int,
  pub lpCaretPos: *mut libc::c_int,
  pub lpClass: LPSTR,
  pub lpGlyphs: LPWSTR,
  pub nGlyphs: UINT,
  pub nMaxFit: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagGCP_RESULTSW() {
  assert_eq!(
    ::core::mem::size_of::<tagGCP_RESULTSW>(),
    64usize,
    concat!("Size of: ", stringify!(tagGCP_RESULTSW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGCP_RESULTSW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagGCP_RESULTSW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lpOutString as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lpOutString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lpOrder as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lpOrder)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lpDx as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lpDx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lpCaretPos as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lpCaretPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lpClass as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lpClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).lpGlyphs as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(lpGlyphs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).nGlyphs as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(nGlyphs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGCP_RESULTSW>())).nMaxFit as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGCP_RESULTSW),
      "::",
      stringify!(nMaxFit)
    )
  );
}
impl Default for tagGCP_RESULTSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type GCP_RESULTSW = tagGCP_RESULTSW;
pub type LPGCP_RESULTSW = *mut tagGCP_RESULTSW;
pub type GCP_RESULTS = GCP_RESULTSA;
pub type LPGCP_RESULTS = LPGCP_RESULTSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _RASTERIZER_STATUS {
  pub nSize: libc::c_short,
  pub wFlags: libc::c_short,
  pub nLanguageID: libc::c_short,
}
#[test]
fn bindgen_test_layout__RASTERIZER_STATUS() {
  assert_eq!(
    ::core::mem::size_of::<_RASTERIZER_STATUS>(),
    6usize,
    concat!("Size of: ", stringify!(_RASTERIZER_STATUS))
  );
  assert_eq!(
    ::core::mem::align_of::<_RASTERIZER_STATUS>(),
    2usize,
    concat!("Alignment of ", stringify!(_RASTERIZER_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RASTERIZER_STATUS>())).nSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RASTERIZER_STATUS),
      "::",
      stringify!(nSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RASTERIZER_STATUS>())).wFlags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_RASTERIZER_STATUS),
      "::",
      stringify!(wFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_RASTERIZER_STATUS>())).nLanguageID as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RASTERIZER_STATUS),
      "::",
      stringify!(nLanguageID)
    )
  );
}
pub type RASTERIZER_STATUS = _RASTERIZER_STATUS;
pub type LPRASTERIZER_STATUS = *mut _RASTERIZER_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPIXELFORMATDESCRIPTOR {
  pub nSize: WORD,
  pub nVersion: WORD,
  pub dwFlags: DWORD,
  pub iPixelType: BYTE,
  pub cColorBits: BYTE,
  pub cRedBits: BYTE,
  pub cRedShift: BYTE,
  pub cGreenBits: BYTE,
  pub cGreenShift: BYTE,
  pub cBlueBits: BYTE,
  pub cBlueShift: BYTE,
  pub cAlphaBits: BYTE,
  pub cAlphaShift: BYTE,
  pub cAccumBits: BYTE,
  pub cAccumRedBits: BYTE,
  pub cAccumGreenBits: BYTE,
  pub cAccumBlueBits: BYTE,
  pub cAccumAlphaBits: BYTE,
  pub cDepthBits: BYTE,
  pub cStencilBits: BYTE,
  pub cAuxBuffers: BYTE,
  pub iLayerType: BYTE,
  pub bReserved: BYTE,
  pub dwLayerMask: DWORD,
  pub dwVisibleMask: DWORD,
  pub dwDamageMask: DWORD,
}
#[test]
fn bindgen_test_layout_tagPIXELFORMATDESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<tagPIXELFORMATDESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(tagPIXELFORMATDESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPIXELFORMATDESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagPIXELFORMATDESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).nSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(nSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).nVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(nVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).iPixelType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(iPixelType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cColorBits as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cRedBits as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cRedBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cRedShift as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cRedShift)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cGreenBits as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cGreenBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cGreenShift as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cGreenShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cBlueBits as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cBlueBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cBlueShift as *const _ as usize
    },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cBlueShift)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAlphaBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAlphaBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAlphaShift as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAlphaShift)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAccumBits as *const _ as usize
    },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAccumBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAccumRedBits as *const _ as usize
    },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAccumRedBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAccumGreenBits as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAccumGreenBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAccumBlueBits as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAccumBlueBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAccumAlphaBits as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAccumAlphaBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cDepthBits as *const _ as usize
    },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cDepthBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cStencilBits as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cStencilBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).cAuxBuffers as *const _ as usize
    },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(cAuxBuffers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).iLayerType as *const _ as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(iLayerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).bReserved as *const _ as usize },
    27usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).dwLayerMask as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(dwLayerMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).dwVisibleMask as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(dwVisibleMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPIXELFORMATDESCRIPTOR>())).dwDamageMask as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPIXELFORMATDESCRIPTOR),
      "::",
      stringify!(dwDamageMask)
    )
  );
}
pub type PIXELFORMATDESCRIPTOR = tagPIXELFORMATDESCRIPTOR;
pub type PPIXELFORMATDESCRIPTOR = *mut tagPIXELFORMATDESCRIPTOR;
pub type LPPIXELFORMATDESCRIPTOR = *mut tagPIXELFORMATDESCRIPTOR;
pub type OLDFONTENUMPROCA = ::core::option::Option<
  unsafe extern "C" fn(
    arg1: *const LOGFONTA,
    arg2: *const TEXTMETRICA,
    arg3: DWORD,
    arg4: LPARAM,
  ) -> libc::c_int,
>;
pub type OLDFONTENUMPROCW = ::core::option::Option<
  unsafe extern "C" fn(
    arg1: *const LOGFONTW,
    arg2: *const TEXTMETRICW,
    arg3: DWORD,
    arg4: LPARAM,
  ) -> libc::c_int,
>;
pub type FONTENUMPROCA = OLDFONTENUMPROCA;
pub type FONTENUMPROCW = OLDFONTENUMPROCW;
pub type FONTENUMPROC = FONTENUMPROCA;
pub type GOBJENUMPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPVOID, arg2: LPARAM) -> libc::c_int>;
pub type LINEDDAPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int, arg2: libc::c_int, arg3: LPARAM)>;
extern "C" {
  pub fn AddFontResourceA(arg1: LPCSTR) -> libc::c_int;
}
extern "C" {
  pub fn AddFontResourceW(arg1: LPCWSTR) -> libc::c_int;
}
extern "C" {
  pub fn AnimatePalette(
    hPal: HPALETTE, iStartIndex: UINT, cEntries: UINT, ppe: *const PALETTEENTRY,
  ) -> BOOL;
}
extern "C" {
  pub fn Arc(
    hdc: HDC, x1: libc::c_int, y1: libc::c_int, x2: libc::c_int, y2: libc::c_int, x3: libc::c_int,
    y3: libc::c_int, x4: libc::c_int, y4: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn BitBlt(
    hdc: HDC, x: libc::c_int, y: libc::c_int, cx: libc::c_int, cy: libc::c_int, hdcSrc: HDC,
    x1: libc::c_int, y1: libc::c_int, rop: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CancelDC(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn Chord(
    hdc: HDC, x1: libc::c_int, y1: libc::c_int, x2: libc::c_int, y2: libc::c_int, x3: libc::c_int,
    y3: libc::c_int, x4: libc::c_int, y4: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn ChoosePixelFormat(hdc: HDC, ppfd: *const PIXELFORMATDESCRIPTOR) -> libc::c_int;
}
extern "C" {
  pub fn CloseMetaFile(hdc: HDC) -> HMETAFILE;
}
extern "C" {
  pub fn CombineRgn(
    hrgnDst: HRGN, hrgnSrc1: HRGN, hrgnSrc2: HRGN, iMode: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CopyMetaFileA(arg1: HMETAFILE, arg2: LPCSTR) -> HMETAFILE;
}
extern "C" {
  pub fn CopyMetaFileW(arg1: HMETAFILE, arg2: LPCWSTR) -> HMETAFILE;
}
extern "C" {
  pub fn CreateBitmap(
    nWidth: libc::c_int, nHeight: libc::c_int, nPlanes: UINT, nBitCount: UINT,
    lpBits: *const libc::c_void,
  ) -> HBITMAP;
}
extern "C" {
  pub fn CreateBitmapIndirect(pbm: *const BITMAP) -> HBITMAP;
}
extern "C" {
  pub fn CreateBrushIndirect(plbrush: *const LOGBRUSH) -> HBRUSH;
}
extern "C" {
  pub fn CreateCompatibleBitmap(hdc: HDC, cx: libc::c_int, cy: libc::c_int) -> HBITMAP;
}
extern "C" {
  pub fn CreateDiscardableBitmap(hdc: HDC, cx: libc::c_int, cy: libc::c_int) -> HBITMAP;
}
extern "C" {
  pub fn CreateCompatibleDC(hdc: HDC) -> HDC;
}
extern "C" {
  pub fn CreateDCA(
    pwszDriver: LPCSTR, pwszDevice: LPCSTR, pszPort: LPCSTR, pdm: *const DEVMODEA,
  ) -> HDC;
}
extern "C" {
  pub fn CreateDCW(
    pwszDriver: LPCWSTR, pwszDevice: LPCWSTR, pszPort: LPCWSTR, pdm: *const DEVMODEW,
  ) -> HDC;
}
extern "C" {
  pub fn CreateDIBitmap(
    hdc: HDC, pbmih: *const BITMAPINFOHEADER, flInit: DWORD, pjBits: *const libc::c_void,
    pbmi: *const BITMAPINFO, iUsage: UINT,
  ) -> HBITMAP;
}
extern "C" {
  pub fn CreateDIBPatternBrush(h: HGLOBAL, iUsage: UINT) -> HBRUSH;
}
extern "C" {
  pub fn CreateDIBPatternBrushPt(lpPackedDIB: *const libc::c_void, iUsage: UINT) -> HBRUSH;
}
extern "C" {
  pub fn CreateEllipticRgn(
    x1: libc::c_int, y1: libc::c_int, x2: libc::c_int, y2: libc::c_int,
  ) -> HRGN;
}
extern "C" {
  pub fn CreateEllipticRgnIndirect(lprect: *const RECT) -> HRGN;
}
extern "C" {
  pub fn CreateFontIndirectA(lplf: *const LOGFONTA) -> HFONT;
}
extern "C" {
  pub fn CreateFontIndirectW(lplf: *const LOGFONTW) -> HFONT;
}
extern "C" {
  pub fn CreateFontA(
    cHeight: libc::c_int, cWidth: libc::c_int, cEscapement: libc::c_int, cOrientation: libc::c_int,
    cWeight: libc::c_int, bItalic: DWORD, bUnderline: DWORD, bStrikeOut: DWORD, iCharSet: DWORD,
    iOutPrecision: DWORD, iClipPrecision: DWORD, iQuality: DWORD, iPitchAndFamily: DWORD,
    pszFaceName: LPCSTR,
  ) -> HFONT;
}
extern "C" {
  pub fn CreateFontW(
    cHeight: libc::c_int, cWidth: libc::c_int, cEscapement: libc::c_int, cOrientation: libc::c_int,
    cWeight: libc::c_int, bItalic: DWORD, bUnderline: DWORD, bStrikeOut: DWORD, iCharSet: DWORD,
    iOutPrecision: DWORD, iClipPrecision: DWORD, iQuality: DWORD, iPitchAndFamily: DWORD,
    pszFaceName: LPCWSTR,
  ) -> HFONT;
}
extern "C" {
  pub fn CreateHatchBrush(iHatch: libc::c_int, color: COLORREF) -> HBRUSH;
}
extern "C" {
  pub fn CreateICA(
    pszDriver: LPCSTR, pszDevice: LPCSTR, pszPort: LPCSTR, pdm: *const DEVMODEA,
  ) -> HDC;
}
extern "C" {
  pub fn CreateICW(
    pszDriver: LPCWSTR, pszDevice: LPCWSTR, pszPort: LPCWSTR, pdm: *const DEVMODEW,
  ) -> HDC;
}
extern "C" {
  pub fn CreateMetaFileA(pszFile: LPCSTR) -> HDC;
}
extern "C" {
  pub fn CreateMetaFileW(pszFile: LPCWSTR) -> HDC;
}
extern "C" {
  pub fn CreatePalette(plpal: *const LOGPALETTE) -> HPALETTE;
}
extern "C" {
  pub fn CreatePen(iStyle: libc::c_int, cWidth: libc::c_int, color: COLORREF) -> HPEN;
}
extern "C" {
  pub fn CreatePenIndirect(plpen: *const LOGPEN) -> HPEN;
}
extern "C" {
  pub fn CreatePolyPolygonRgn(
    pptl: *const POINT, pc: *const INT, cPoly: libc::c_int, iMode: libc::c_int,
  ) -> HRGN;
}
extern "C" {
  pub fn CreatePatternBrush(hbm: HBITMAP) -> HBRUSH;
}
extern "C" {
  pub fn CreateRectRgn(x1: libc::c_int, y1: libc::c_int, x2: libc::c_int, y2: libc::c_int) -> HRGN;
}
extern "C" {
  pub fn CreateRectRgnIndirect(lprect: *const RECT) -> HRGN;
}
extern "C" {
  pub fn CreateRoundRectRgn(
    x1: libc::c_int, y1: libc::c_int, x2: libc::c_int, y2: libc::c_int, w: libc::c_int,
    h: libc::c_int,
  ) -> HRGN;
}
extern "C" {
  pub fn CreateScalableFontResourceA(
    fdwHidden: DWORD, lpszFont: LPCSTR, lpszFile: LPCSTR, lpszPath: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateScalableFontResourceW(
    fdwHidden: DWORD, lpszFont: LPCWSTR, lpszFile: LPCWSTR, lpszPath: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateSolidBrush(color: COLORREF) -> HBRUSH;
}
extern "C" {
  pub fn DeleteDC(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn DeleteMetaFile(hmf: HMETAFILE) -> BOOL;
}
extern "C" {
  pub fn DeleteObject(ho: HGDIOBJ) -> BOOL;
}
extern "C" {
  pub fn DescribePixelFormat(
    hdc: HDC, iPixelFormat: libc::c_int, nBytes: UINT, ppfd: LPPIXELFORMATDESCRIPTOR,
  ) -> libc::c_int;
}
pub type LPFNDEVMODE = ::core::option::Option<
  unsafe extern "C" fn(
    arg1: HWND,
    arg2: HMODULE,
    arg3: LPDEVMODE,
    arg4: LPSTR,
    arg5: LPSTR,
    arg6: LPDEVMODE,
    arg7: LPSTR,
    arg8: UINT,
  ) -> UINT,
>;
pub type LPFNDEVCAPS = ::core::option::Option<
  unsafe extern "C" fn(arg1: LPSTR, arg2: LPSTR, arg3: UINT, arg4: LPSTR, arg5: LPDEVMODE) -> DWORD,
>;
extern "C" {
  pub fn DeviceCapabilitiesA(
    pDevice: LPCSTR, pPort: LPCSTR, fwCapability: WORD, pOutput: LPSTR, pDevMode: *const DEVMODEA,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DeviceCapabilitiesW(
    pDevice: LPCWSTR, pPort: LPCWSTR, fwCapability: WORD, pOutput: LPWSTR,
    pDevMode: *const DEVMODEW,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DrawEscape(hdc: HDC, iEscape: libc::c_int, cjIn: libc::c_int, lpIn: LPCSTR)
    -> libc::c_int;
}
extern "C" {
  pub fn Ellipse(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumFontFamiliesExA(
    hdc: HDC, lpLogfont: LPLOGFONTA, lpProc: FONTENUMPROCA, lParam: LPARAM, dwFlags: DWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumFontFamiliesExW(
    hdc: HDC, lpLogfont: LPLOGFONTW, lpProc: FONTENUMPROCW, lParam: LPARAM, dwFlags: DWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumFontFamiliesA(
    hdc: HDC, lpLogfont: LPCSTR, lpProc: FONTENUMPROCA, lParam: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumFontFamiliesW(
    hdc: HDC, lpLogfont: LPCWSTR, lpProc: FONTENUMPROCW, lParam: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumFontsA(
    hdc: HDC, lpLogfont: LPCSTR, lpProc: FONTENUMPROCA, lParam: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumFontsW(
    hdc: HDC, lpLogfont: LPCWSTR, lpProc: FONTENUMPROCW, lParam: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumObjects(
    hdc: HDC, nType: libc::c_int, lpFunc: GOBJENUMPROC, lParam: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EqualRgn(hrgn1: HRGN, hrgn2: HRGN) -> BOOL;
}
extern "C" {
  pub fn Escape(
    hdc: HDC, iEscape: libc::c_int, cjIn: libc::c_int, pvIn: LPCSTR, pvOut: LPVOID,
  ) -> libc::c_int;
}
extern "C" {
  pub fn ExtEscape(
    hdc: HDC, iEscape: libc::c_int, cjInput: libc::c_int, lpInData: LPCSTR, cjOutput: libc::c_int,
    lpOutData: LPSTR,
  ) -> libc::c_int;
}
extern "C" {
  pub fn ExcludeClipRect(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn ExtCreateRegion(lpx: *const XFORM, nCount: DWORD, lpData: *const RGNDATA) -> HRGN;
}
extern "C" {
  pub fn ExtFloodFill(
    hdc: HDC, x: libc::c_int, y: libc::c_int, color: COLORREF, type_: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn FillRgn(hdc: HDC, hrgn: HRGN, hbr: HBRUSH) -> BOOL;
}
extern "C" {
  pub fn FloodFill(hdc: HDC, x: libc::c_int, y: libc::c_int, color: COLORREF) -> BOOL;
}
extern "C" {
  pub fn FrameRgn(hdc: HDC, hrgn: HRGN, hbr: HBRUSH, w: libc::c_int, h: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn GetROP2(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetAspectRatioFilterEx(hdc: HDC, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetBkColor(hdc: HDC) -> COLORREF;
}
extern "C" {
  pub fn GetDCBrushColor(hdc: HDC) -> COLORREF;
}
extern "C" {
  pub fn GetDCPenColor(hdc: HDC) -> COLORREF;
}
extern "C" {
  pub fn GetBkMode(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetBitmapBits(hbit: HBITMAP, cb: LONG, lpvBits: LPVOID) -> LONG;
}
extern "C" {
  pub fn GetBitmapDimensionEx(hbit: HBITMAP, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetBoundsRect(hdc: HDC, lprect: LPRECT, flags: UINT) -> UINT;
}
extern "C" {
  pub fn GetBrushOrgEx(hdc: HDC, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn GetCharWidthA(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
  pub fn GetCharWidthW(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
  pub fn GetCharWidth32A(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
  pub fn GetCharWidth32W(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
  pub fn GetCharWidthFloatA(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: PFLOAT) -> BOOL;
}
extern "C" {
  pub fn GetCharWidthFloatW(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: PFLOAT) -> BOOL;
}
extern "C" {
  pub fn GetCharABCWidthsA(hdc: HDC, wFirst: UINT, wLast: UINT, lpABC: LPABC) -> BOOL;
}
extern "C" {
  pub fn GetCharABCWidthsW(hdc: HDC, wFirst: UINT, wLast: UINT, lpABC: LPABC) -> BOOL;
}
extern "C" {
  pub fn GetCharABCWidthsFloatA(hdc: HDC, iFirst: UINT, iLast: UINT, lpABC: LPABCFLOAT) -> BOOL;
}
extern "C" {
  pub fn GetCharABCWidthsFloatW(hdc: HDC, iFirst: UINT, iLast: UINT, lpABC: LPABCFLOAT) -> BOOL;
}
extern "C" {
  pub fn GetClipBox(hdc: HDC, lprect: LPRECT) -> libc::c_int;
}
extern "C" {
  pub fn GetClipRgn(hdc: HDC, hrgn: HRGN) -> libc::c_int;
}
extern "C" {
  pub fn GetMetaRgn(hdc: HDC, hrgn: HRGN) -> libc::c_int;
}
extern "C" {
  pub fn GetCurrentObject(hdc: HDC, type_: UINT) -> HGDIOBJ;
}
extern "C" {
  pub fn GetCurrentPositionEx(hdc: HDC, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn GetDeviceCaps(hdc: HDC, index: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetDIBits(
    hdc: HDC, hbm: HBITMAP, start: UINT, cLines: UINT, lpvBits: LPVOID, lpbmi: LPBITMAPINFO,
    usage: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetFontData(
    hdc: HDC, dwTable: DWORD, dwOffset: DWORD, pvBuffer: PVOID, cjBuffer: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetGlyphOutlineA(
    hdc: HDC, uChar: UINT, fuFormat: UINT, lpgm: LPGLYPHMETRICS, cjBuffer: DWORD, pvBuffer: LPVOID,
    lpmat2: *const MAT2,
  ) -> DWORD;
}
extern "C" {
  pub fn GetGlyphOutlineW(
    hdc: HDC, uChar: UINT, fuFormat: UINT, lpgm: LPGLYPHMETRICS, cjBuffer: DWORD, pvBuffer: LPVOID,
    lpmat2: *const MAT2,
  ) -> DWORD;
}
extern "C" {
  pub fn GetGraphicsMode(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetMapMode(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetMetaFileBitsEx(hMF: HMETAFILE, cbBuffer: UINT, lpData: LPVOID) -> UINT;
}
extern "C" {
  pub fn GetMetaFileA(lpName: LPCSTR) -> HMETAFILE;
}
extern "C" {
  pub fn GetMetaFileW(lpName: LPCWSTR) -> HMETAFILE;
}
extern "C" {
  pub fn GetNearestColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
  pub fn GetNearestPaletteIndex(h: HPALETTE, color: COLORREF) -> UINT;
}
extern "C" {
  pub fn GetObjectType(h: HGDIOBJ) -> DWORD;
}
extern "C" {
  pub fn GetOutlineTextMetricsA(hdc: HDC, cjCopy: UINT, potm: LPOUTLINETEXTMETRICA) -> UINT;
}
extern "C" {
  pub fn GetOutlineTextMetricsW(hdc: HDC, cjCopy: UINT, potm: LPOUTLINETEXTMETRICW) -> UINT;
}
extern "C" {
  pub fn GetPaletteEntries(
    hpal: HPALETTE, iStart: UINT, cEntries: UINT, pPalEntries: LPPALETTEENTRY,
  ) -> UINT;
}
extern "C" {
  pub fn GetPixel(hdc: HDC, x: libc::c_int, y: libc::c_int) -> COLORREF;
}
extern "C" {
  pub fn GetPixelFormat(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetPolyFillMode(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetRasterizerCaps(lpraststat: LPRASTERIZER_STATUS, cjBytes: UINT) -> BOOL;
}
extern "C" {
  pub fn GetRandomRgn(hdc: HDC, hrgn: HRGN, i: INT) -> libc::c_int;
}
extern "C" {
  pub fn GetRegionData(hrgn: HRGN, nCount: DWORD, lpRgnData: LPRGNDATA) -> DWORD;
}
extern "C" {
  pub fn GetRgnBox(hrgn: HRGN, lprc: LPRECT) -> libc::c_int;
}
extern "C" {
  pub fn GetStockObject(i: libc::c_int) -> HGDIOBJ;
}
extern "C" {
  pub fn GetStretchBltMode(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetSystemPaletteEntries(
    hdc: HDC, iStart: UINT, cEntries: UINT, pPalEntries: LPPALETTEENTRY,
  ) -> UINT;
}
extern "C" {
  pub fn GetSystemPaletteUse(hdc: HDC) -> UINT;
}
extern "C" {
  pub fn GetTextCharacterExtra(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetTextAlign(hdc: HDC) -> UINT;
}
extern "C" {
  pub fn GetTextColor(hdc: HDC) -> COLORREF;
}
extern "C" {
  pub fn GetTextExtentPointA(hdc: HDC, lpString: LPCSTR, c: libc::c_int, lpsz: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetTextExtentPointW(hdc: HDC, lpString: LPCWSTR, c: libc::c_int, lpsz: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetTextExtentPoint32A(hdc: HDC, lpString: LPCSTR, c: libc::c_int, psizl: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetTextExtentPoint32W(hdc: HDC, lpString: LPCWSTR, c: libc::c_int, psizl: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetTextExtentExPointA(
    hdc: HDC, lpszString: LPCSTR, cchString: libc::c_int, nMaxExtent: libc::c_int, lpnFit: LPINT,
    lpnDx: LPINT, lpSize: LPSIZE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetTextExtentExPointW(
    hdc: HDC, lpszString: LPCWSTR, cchString: libc::c_int, nMaxExtent: libc::c_int, lpnFit: LPINT,
    lpnDx: LPINT, lpSize: LPSIZE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetTextCharset(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetTextCharsetInfo(hdc: HDC, lpSig: LPFONTSIGNATURE, dwFlags: DWORD) -> libc::c_int;
}
extern "C" {
  pub fn TranslateCharsetInfo(lpSrc: *mut DWORD, lpCs: LPCHARSETINFO, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetFontLanguageInfo(hdc: HDC) -> DWORD;
}
extern "C" {
  pub fn GetCharacterPlacementA(
    hdc: HDC, lpString: LPCSTR, nCount: libc::c_int, nMexExtent: libc::c_int,
    lpResults: LPGCP_RESULTSA, dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetCharacterPlacementW(
    hdc: HDC, lpString: LPCWSTR, nCount: libc::c_int, nMexExtent: libc::c_int,
    lpResults: LPGCP_RESULTSW, dwFlags: DWORD,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagWCRANGE {
  pub wcLow: WCHAR,
  pub cGlyphs: USHORT,
}
#[test]
fn bindgen_test_layout_tagWCRANGE() {
  assert_eq!(
    ::core::mem::size_of::<tagWCRANGE>(),
    4usize,
    concat!("Size of: ", stringify!(tagWCRANGE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWCRANGE>(),
    2usize,
    concat!("Alignment of ", stringify!(tagWCRANGE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWCRANGE>())).wcLow as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWCRANGE),
      "::",
      stringify!(wcLow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWCRANGE>())).cGlyphs as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWCRANGE),
      "::",
      stringify!(cGlyphs)
    )
  );
}
pub type WCRANGE = tagWCRANGE;
pub type PWCRANGE = *mut tagWCRANGE;
pub type LPWCRANGE = *mut tagWCRANGE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagGLYPHSET {
  pub cbThis: DWORD,
  pub flAccel: DWORD,
  pub cGlyphsSupported: DWORD,
  pub cRanges: DWORD,
  pub ranges: [WCRANGE; 1usize],
}
#[test]
fn bindgen_test_layout_tagGLYPHSET() {
  assert_eq!(
    ::core::mem::size_of::<tagGLYPHSET>(),
    20usize,
    concat!("Size of: ", stringify!(tagGLYPHSET))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGLYPHSET>(),
    4usize,
    concat!("Alignment of ", stringify!(tagGLYPHSET))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGLYPHSET>())).cbThis as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGLYPHSET),
      "::",
      stringify!(cbThis)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGLYPHSET>())).flAccel as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGLYPHSET),
      "::",
      stringify!(flAccel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGLYPHSET>())).cGlyphsSupported as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGLYPHSET),
      "::",
      stringify!(cGlyphsSupported)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGLYPHSET>())).cRanges as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGLYPHSET),
      "::",
      stringify!(cRanges)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGLYPHSET>())).ranges as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGLYPHSET),
      "::",
      stringify!(ranges)
    )
  );
}
pub type GLYPHSET = tagGLYPHSET;
pub type PGLYPHSET = *mut tagGLYPHSET;
pub type LPGLYPHSET = *mut tagGLYPHSET;
extern "C" {
  pub fn GetFontUnicodeRanges(hdc: HDC, lpgs: LPGLYPHSET) -> DWORD;
}
extern "C" {
  pub fn GetGlyphIndicesA(hdc: HDC, lpstr: LPCSTR, c: libc::c_int, pgi: LPWORD, fl: DWORD)
    -> DWORD;
}
extern "C" {
  pub fn GetGlyphIndicesW(
    hdc: HDC, lpstr: LPCWSTR, c: libc::c_int, pgi: LPWORD, fl: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetTextExtentPointI(hdc: HDC, pgiIn: LPWORD, cgi: libc::c_int, psize: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetTextExtentExPointI(
    hdc: HDC, lpwszString: LPWORD, cwchString: libc::c_int, nMaxExtent: libc::c_int, lpnFit: LPINT,
    lpnDx: LPINT, lpSize: LPSIZE,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCharWidthI(hdc: HDC, giFirst: UINT, cgi: UINT, pgi: LPWORD, piWidths: LPINT) -> BOOL;
}
extern "C" {
  pub fn GetCharABCWidthsI(hdc: HDC, giFirst: UINT, cgi: UINT, pgi: LPWORD, pabc: LPABC) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagDESIGNVECTOR {
  pub dvReserved: DWORD,
  pub dvNumAxes: DWORD,
  pub dvValues: [LONG; 16usize],
}
#[test]
fn bindgen_test_layout_tagDESIGNVECTOR() {
  assert_eq!(
    ::core::mem::size_of::<tagDESIGNVECTOR>(),
    72usize,
    concat!("Size of: ", stringify!(tagDESIGNVECTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDESIGNVECTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagDESIGNVECTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDESIGNVECTOR>())).dvReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDESIGNVECTOR),
      "::",
      stringify!(dvReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDESIGNVECTOR>())).dvNumAxes as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDESIGNVECTOR),
      "::",
      stringify!(dvNumAxes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDESIGNVECTOR>())).dvValues as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDESIGNVECTOR),
      "::",
      stringify!(dvValues)
    )
  );
}
pub type DESIGNVECTOR = tagDESIGNVECTOR;
pub type PDESIGNVECTOR = *mut tagDESIGNVECTOR;
pub type LPDESIGNVECTOR = *mut tagDESIGNVECTOR;
extern "C" {
  pub fn AddFontResourceExA(name: LPCSTR, fl: DWORD, res: PVOID) -> libc::c_int;
}
extern "C" {
  pub fn AddFontResourceExW(name: LPCWSTR, fl: DWORD, res: PVOID) -> libc::c_int;
}
extern "C" {
  pub fn RemoveFontResourceExA(name: LPCSTR, fl: DWORD, pdv: PVOID) -> BOOL;
}
extern "C" {
  pub fn RemoveFontResourceExW(name: LPCWSTR, fl: DWORD, pdv: PVOID) -> BOOL;
}
extern "C" {
  pub fn AddFontMemResourceEx(
    pFileView: PVOID, cjSize: DWORD, pvResrved: PVOID, pNumFonts: *mut DWORD,
  ) -> HANDLE;
}
extern "C" {
  pub fn RemoveFontMemResourceEx(h: HANDLE) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagAXISINFOA {
  pub axMinValue: LONG,
  pub axMaxValue: LONG,
  pub axAxisName: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_tagAXISINFOA() {
  assert_eq!(
    ::core::mem::size_of::<tagAXISINFOA>(),
    24usize,
    concat!("Size of: ", stringify!(tagAXISINFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagAXISINFOA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagAXISINFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXISINFOA>())).axMinValue as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXISINFOA),
      "::",
      stringify!(axMinValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXISINFOA>())).axMaxValue as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXISINFOA),
      "::",
      stringify!(axMaxValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXISINFOA>())).axAxisName as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXISINFOA),
      "::",
      stringify!(axAxisName)
    )
  );
}
pub type AXISINFOA = tagAXISINFOA;
pub type PAXISINFOA = *mut tagAXISINFOA;
pub type LPAXISINFOA = *mut tagAXISINFOA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagAXISINFOW {
  pub axMinValue: LONG,
  pub axMaxValue: LONG,
  pub axAxisName: [WCHAR; 16usize],
}
#[test]
fn bindgen_test_layout_tagAXISINFOW() {
  assert_eq!(
    ::core::mem::size_of::<tagAXISINFOW>(),
    40usize,
    concat!("Size of: ", stringify!(tagAXISINFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagAXISINFOW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagAXISINFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXISINFOW>())).axMinValue as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXISINFOW),
      "::",
      stringify!(axMinValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXISINFOW>())).axMaxValue as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXISINFOW),
      "::",
      stringify!(axMaxValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXISINFOW>())).axAxisName as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXISINFOW),
      "::",
      stringify!(axAxisName)
    )
  );
}
pub type AXISINFOW = tagAXISINFOW;
pub type PAXISINFOW = *mut tagAXISINFOW;
pub type LPAXISINFOW = *mut tagAXISINFOW;
pub type AXISINFO = AXISINFOA;
pub type PAXISINFO = PAXISINFOA;
pub type LPAXISINFO = LPAXISINFOA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagAXESLISTA {
  pub axlReserved: DWORD,
  pub axlNumAxes: DWORD,
  pub axlAxisInfo: [AXISINFOA; 16usize],
}
#[test]
fn bindgen_test_layout_tagAXESLISTA() {
  assert_eq!(
    ::core::mem::size_of::<tagAXESLISTA>(),
    392usize,
    concat!("Size of: ", stringify!(tagAXESLISTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagAXESLISTA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagAXESLISTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXESLISTA>())).axlReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXESLISTA),
      "::",
      stringify!(axlReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXESLISTA>())).axlNumAxes as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXESLISTA),
      "::",
      stringify!(axlNumAxes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXESLISTA>())).axlAxisInfo as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXESLISTA),
      "::",
      stringify!(axlAxisInfo)
    )
  );
}
pub type AXESLISTA = tagAXESLISTA;
pub type PAXESLISTA = *mut tagAXESLISTA;
pub type LPAXESLISTA = *mut tagAXESLISTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagAXESLISTW {
  pub axlReserved: DWORD,
  pub axlNumAxes: DWORD,
  pub axlAxisInfo: [AXISINFOW; 16usize],
}
#[test]
fn bindgen_test_layout_tagAXESLISTW() {
  assert_eq!(
    ::core::mem::size_of::<tagAXESLISTW>(),
    648usize,
    concat!("Size of: ", stringify!(tagAXESLISTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagAXESLISTW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagAXESLISTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXESLISTW>())).axlReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXESLISTW),
      "::",
      stringify!(axlReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXESLISTW>())).axlNumAxes as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXESLISTW),
      "::",
      stringify!(axlNumAxes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAXESLISTW>())).axlAxisInfo as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAXESLISTW),
      "::",
      stringify!(axlAxisInfo)
    )
  );
}
pub type AXESLISTW = tagAXESLISTW;
pub type PAXESLISTW = *mut tagAXESLISTW;
pub type LPAXESLISTW = *mut tagAXESLISTW;
pub type AXESLIST = AXESLISTA;
pub type PAXESLIST = PAXESLISTA;
pub type LPAXESLIST = LPAXESLISTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagENUMLOGFONTEXDVA {
  pub elfEnumLogfontEx: ENUMLOGFONTEXA,
  pub elfDesignVector: DESIGNVECTOR,
}
#[test]
fn bindgen_test_layout_tagENUMLOGFONTEXDVA() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMLOGFONTEXDVA>(),
    260usize,
    concat!("Size of: ", stringify!(tagENUMLOGFONTEXDVA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMLOGFONTEXDVA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMLOGFONTEXDVA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagENUMLOGFONTEXDVA>())).elfEnumLogfontEx as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXDVA),
      "::",
      stringify!(elfEnumLogfontEx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagENUMLOGFONTEXDVA>())).elfDesignVector as *const _ as usize
    },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXDVA),
      "::",
      stringify!(elfDesignVector)
    )
  );
}
impl Default for tagENUMLOGFONTEXDVA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagENUMLOGFONTEXDVA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagENUMLOGFONTEXDVA {{ elfEnumLogfontEx: {:?}, elfDesignVector: {:?} }}",
      self.elfEnumLogfontEx, self.elfDesignVector
    )
  }
}
impl ::core::cmp::PartialEq for tagENUMLOGFONTEXDVA {
  fn eq(&self, other: &tagENUMLOGFONTEXDVA) -> bool {
    self.elfEnumLogfontEx == other.elfEnumLogfontEx && self.elfDesignVector == other.elfDesignVector
  }
}
pub type ENUMLOGFONTEXDVA = tagENUMLOGFONTEXDVA;
pub type PENUMLOGFONTEXDVA = *mut tagENUMLOGFONTEXDVA;
pub type LPENUMLOGFONTEXDVA = *mut tagENUMLOGFONTEXDVA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagENUMLOGFONTEXDVW {
  pub elfEnumLogfontEx: ENUMLOGFONTEXW,
  pub elfDesignVector: DESIGNVECTOR,
}
#[test]
fn bindgen_test_layout_tagENUMLOGFONTEXDVW() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMLOGFONTEXDVW>(),
    420usize,
    concat!("Size of: ", stringify!(tagENUMLOGFONTEXDVW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMLOGFONTEXDVW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMLOGFONTEXDVW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagENUMLOGFONTEXDVW>())).elfEnumLogfontEx as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXDVW),
      "::",
      stringify!(elfEnumLogfontEx)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagENUMLOGFONTEXDVW>())).elfDesignVector as *const _ as usize
    },
    348usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMLOGFONTEXDVW),
      "::",
      stringify!(elfDesignVector)
    )
  );
}
impl Default for tagENUMLOGFONTEXDVW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagENUMLOGFONTEXDVW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagENUMLOGFONTEXDVW {{ elfEnumLogfontEx: {:?}, elfDesignVector: {:?} }}",
      self.elfEnumLogfontEx, self.elfDesignVector
    )
  }
}
impl ::core::cmp::PartialEq for tagENUMLOGFONTEXDVW {
  fn eq(&self, other: &tagENUMLOGFONTEXDVW) -> bool {
    self.elfEnumLogfontEx == other.elfEnumLogfontEx && self.elfDesignVector == other.elfDesignVector
  }
}
pub type ENUMLOGFONTEXDVW = tagENUMLOGFONTEXDVW;
pub type PENUMLOGFONTEXDVW = *mut tagENUMLOGFONTEXDVW;
pub type LPENUMLOGFONTEXDVW = *mut tagENUMLOGFONTEXDVW;
pub type ENUMLOGFONTEXDV = ENUMLOGFONTEXDVA;
pub type PENUMLOGFONTEXDV = PENUMLOGFONTEXDVA;
pub type LPENUMLOGFONTEXDV = LPENUMLOGFONTEXDVA;
extern "C" {
  pub fn CreateFontIndirectExA(arg1: *const ENUMLOGFONTEXDVA) -> HFONT;
}
extern "C" {
  pub fn CreateFontIndirectExW(arg1: *const ENUMLOGFONTEXDVW) -> HFONT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagENUMTEXTMETRICA {
  pub etmNewTextMetricEx: NEWTEXTMETRICEXA,
  pub etmAxesList: AXESLISTA,
}
#[test]
fn bindgen_test_layout_tagENUMTEXTMETRICA() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMTEXTMETRICA>(),
    488usize,
    concat!("Size of: ", stringify!(tagENUMTEXTMETRICA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMTEXTMETRICA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMTEXTMETRICA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagENUMTEXTMETRICA>())).etmNewTextMetricEx as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMTEXTMETRICA),
      "::",
      stringify!(etmNewTextMetricEx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMTEXTMETRICA>())).etmAxesList as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMTEXTMETRICA),
      "::",
      stringify!(etmAxesList)
    )
  );
}
pub type ENUMTEXTMETRICA = tagENUMTEXTMETRICA;
pub type PENUMTEXTMETRICA = *mut tagENUMTEXTMETRICA;
pub type LPENUMTEXTMETRICA = *mut tagENUMTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagENUMTEXTMETRICW {
  pub etmNewTextMetricEx: NEWTEXTMETRICEXW,
  pub etmAxesList: AXESLISTW,
}
#[test]
fn bindgen_test_layout_tagENUMTEXTMETRICW() {
  assert_eq!(
    ::core::mem::size_of::<tagENUMTEXTMETRICW>(),
    748usize,
    concat!("Size of: ", stringify!(tagENUMTEXTMETRICW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagENUMTEXTMETRICW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagENUMTEXTMETRICW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagENUMTEXTMETRICW>())).etmNewTextMetricEx as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMTEXTMETRICW),
      "::",
      stringify!(etmNewTextMetricEx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagENUMTEXTMETRICW>())).etmAxesList as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagENUMTEXTMETRICW),
      "::",
      stringify!(etmAxesList)
    )
  );
}
pub type ENUMTEXTMETRICW = tagENUMTEXTMETRICW;
pub type PENUMTEXTMETRICW = *mut tagENUMTEXTMETRICW;
pub type LPENUMTEXTMETRICW = *mut tagENUMTEXTMETRICW;
pub type ENUMTEXTMETRIC = ENUMTEXTMETRICA;
pub type PENUMTEXTMETRIC = PENUMTEXTMETRICA;
pub type LPENUMTEXTMETRIC = LPENUMTEXTMETRICA;
extern "C" {
  pub fn GetViewportExtEx(hdc: HDC, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetViewportOrgEx(hdc: HDC, lppoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn GetWindowExtEx(hdc: HDC, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn GetWindowOrgEx(hdc: HDC, lppoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn IntersectClipRect(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn InvertRgn(hdc: HDC, hrgn: HRGN) -> BOOL;
}
extern "C" {
  pub fn LineDDA(
    xStart: libc::c_int, yStart: libc::c_int, xEnd: libc::c_int, yEnd: libc::c_int,
    lpProc: LINEDDAPROC, data: LPARAM,
  ) -> BOOL;
}
extern "C" {
  pub fn LineTo(hdc: HDC, x: libc::c_int, y: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn MaskBlt(
    hdcDest: HDC, xDest: libc::c_int, yDest: libc::c_int, width: libc::c_int, height: libc::c_int,
    hdcSrc: HDC, xSrc: libc::c_int, ySrc: libc::c_int, hbmMask: HBITMAP, xMask: libc::c_int,
    yMask: libc::c_int, rop: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn PlgBlt(
    hdcDest: HDC, lpPoint: *const POINT, hdcSrc: HDC, xSrc: libc::c_int, ySrc: libc::c_int,
    width: libc::c_int, height: libc::c_int, hbmMask: HBITMAP, xMask: libc::c_int,
    yMask: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn OffsetClipRgn(hdc: HDC, x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn OffsetRgn(hrgn: HRGN, x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn PatBlt(
    hdc: HDC, x: libc::c_int, y: libc::c_int, w: libc::c_int, h: libc::c_int, rop: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn Pie(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
    xr1: libc::c_int, yr1: libc::c_int, xr2: libc::c_int, yr2: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn PlayMetaFile(hdc: HDC, hmf: HMETAFILE) -> BOOL;
}
extern "C" {
  pub fn PaintRgn(hdc: HDC, hrgn: HRGN) -> BOOL;
}
extern "C" {
  pub fn PolyPolygon(hdc: HDC, apt: *const POINT, asz: *const INT, csz: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn PtInRegion(hrgn: HRGN, x: libc::c_int, y: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn PtVisible(hdc: HDC, x: libc::c_int, y: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn RectInRegion(hrgn: HRGN, lprect: *const RECT) -> BOOL;
}
extern "C" {
  pub fn RectVisible(hdc: HDC, lprect: *const RECT) -> BOOL;
}
extern "C" {
  pub fn Rectangle(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn RestoreDC(hdc: HDC, nSavedDC: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn ResetDCA(hdc: HDC, lpdm: *const DEVMODEA) -> HDC;
}
extern "C" {
  pub fn ResetDCW(hdc: HDC, lpdm: *const DEVMODEW) -> HDC;
}
extern "C" {
  pub fn RealizePalette(hdc: HDC) -> UINT;
}
extern "C" {
  pub fn RemoveFontResourceA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn RemoveFontResourceW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn RoundRect(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
    width: libc::c_int, height: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn ResizePalette(hpal: HPALETTE, n: UINT) -> BOOL;
}
extern "C" {
  pub fn SaveDC(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn SelectClipRgn(hdc: HDC, hrgn: HRGN) -> libc::c_int;
}
extern "C" {
  pub fn ExtSelectClipRgn(hdc: HDC, hrgn: HRGN, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetMetaRgn(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn SelectObject(hdc: HDC, h: HGDIOBJ) -> HGDIOBJ;
}
extern "C" {
  pub fn SelectPalette(hdc: HDC, hPal: HPALETTE, bForceBkgd: BOOL) -> HPALETTE;
}
extern "C" {
  pub fn SetBkColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
  pub fn SetDCBrushColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
  pub fn SetDCPenColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
  pub fn SetBkMode(hdc: HDC, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetBitmapBits(hbm: HBITMAP, cb: DWORD, pvBits: *const libc::c_void) -> LONG;
}
extern "C" {
  pub fn SetBoundsRect(hdc: HDC, lprect: *const RECT, flags: UINT) -> UINT;
}
extern "C" {
  pub fn SetDIBits(
    hdc: HDC, hbm: HBITMAP, start: UINT, cLines: UINT, lpBits: *const libc::c_void,
    lpbmi: *const BITMAPINFO, ColorUse: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SetDIBitsToDevice(
    hdc: HDC, xDest: libc::c_int, yDest: libc::c_int, w: DWORD, h: DWORD, xSrc: libc::c_int,
    ySrc: libc::c_int, StartScan: UINT, cLines: UINT, lpvBits: *const libc::c_void,
    lpbmi: *const BITMAPINFO, ColorUse: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SetMapperFlags(hdc: HDC, flags: DWORD) -> DWORD;
}
extern "C" {
  pub fn SetGraphicsMode(hdc: HDC, iMode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetMapMode(hdc: HDC, iMode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetLayout(hdc: HDC, l: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetLayout(hdc: HDC) -> DWORD;
}
extern "C" {
  pub fn SetMetaFileBitsEx(cbBuffer: UINT, lpData: *const BYTE) -> HMETAFILE;
}
extern "C" {
  pub fn SetPaletteEntries(
    hpal: HPALETTE, iStart: UINT, cEntries: UINT, pPalEntries: *const PALETTEENTRY,
  ) -> UINT;
}
extern "C" {
  pub fn SetPixel(hdc: HDC, x: libc::c_int, y: libc::c_int, color: COLORREF) -> COLORREF;
}
extern "C" {
  pub fn SetPixelV(hdc: HDC, x: libc::c_int, y: libc::c_int, color: COLORREF) -> BOOL;
}
extern "C" {
  pub fn SetPixelFormat(hdc: HDC, format: libc::c_int, ppfd: *const PIXELFORMATDESCRIPTOR) -> BOOL;
}
extern "C" {
  pub fn SetPolyFillMode(hdc: HDC, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn StretchBlt(
    hdcDest: HDC, xDest: libc::c_int, yDest: libc::c_int, wDest: libc::c_int, hDest: libc::c_int,
    hdcSrc: HDC, xSrc: libc::c_int, ySrc: libc::c_int, wSrc: libc::c_int, hSrc: libc::c_int,
    rop: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetRectRgn(
    hrgn: HRGN, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn StretchDIBits(
    hdc: HDC, xDest: libc::c_int, yDest: libc::c_int, DestWidth: libc::c_int,
    DestHeight: libc::c_int, xSrc: libc::c_int, ySrc: libc::c_int, SrcWidth: libc::c_int,
    SrcHeight: libc::c_int, lpBits: *const libc::c_void, lpbmi: *const BITMAPINFO, iUsage: UINT,
    rop: DWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SetROP2(hdc: HDC, rop2: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetStretchBltMode(hdc: HDC, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetSystemPaletteUse(hdc: HDC, use_: UINT) -> UINT;
}
extern "C" {
  pub fn SetTextCharacterExtra(hdc: HDC, extra: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetTextColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
  pub fn SetTextAlign(hdc: HDC, align: UINT) -> UINT;
}
extern "C" {
  pub fn SetTextJustification(hdc: HDC, extra: libc::c_int, count: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn UpdateColors(hdc: HDC) -> BOOL;
}
pub type COLOR16 = USHORT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _TRIVERTEX {
  pub x: LONG,
  pub y: LONG,
  pub Red: COLOR16,
  pub Green: COLOR16,
  pub Blue: COLOR16,
  pub Alpha: COLOR16,
}
#[test]
fn bindgen_test_layout__TRIVERTEX() {
  assert_eq!(
    ::core::mem::size_of::<_TRIVERTEX>(),
    16usize,
    concat!("Size of: ", stringify!(_TRIVERTEX))
  );
  assert_eq!(
    ::core::mem::align_of::<_TRIVERTEX>(),
    4usize,
    concat!("Alignment of ", stringify!(_TRIVERTEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRIVERTEX>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRIVERTEX),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRIVERTEX>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRIVERTEX),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRIVERTEX>())).Red as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRIVERTEX),
      "::",
      stringify!(Red)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRIVERTEX>())).Green as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRIVERTEX),
      "::",
      stringify!(Green)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRIVERTEX>())).Blue as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRIVERTEX),
      "::",
      stringify!(Blue)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_TRIVERTEX>())).Alpha as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_TRIVERTEX),
      "::",
      stringify!(Alpha)
    )
  );
}
pub type TRIVERTEX = _TRIVERTEX;
pub type PTRIVERTEX = *mut _TRIVERTEX;
pub type LPTRIVERTEX = *mut _TRIVERTEX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GRADIENT_TRIANGLE {
  pub Vertex1: ULONG,
  pub Vertex2: ULONG,
  pub Vertex3: ULONG,
}
#[test]
fn bindgen_test_layout__GRADIENT_TRIANGLE() {
  assert_eq!(
    ::core::mem::size_of::<_GRADIENT_TRIANGLE>(),
    12usize,
    concat!("Size of: ", stringify!(_GRADIENT_TRIANGLE))
  );
  assert_eq!(
    ::core::mem::align_of::<_GRADIENT_TRIANGLE>(),
    4usize,
    concat!("Alignment of ", stringify!(_GRADIENT_TRIANGLE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GRADIENT_TRIANGLE>())).Vertex1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GRADIENT_TRIANGLE),
      "::",
      stringify!(Vertex1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GRADIENT_TRIANGLE>())).Vertex2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GRADIENT_TRIANGLE),
      "::",
      stringify!(Vertex2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GRADIENT_TRIANGLE>())).Vertex3 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GRADIENT_TRIANGLE),
      "::",
      stringify!(Vertex3)
    )
  );
}
pub type GRADIENT_TRIANGLE = _GRADIENT_TRIANGLE;
pub type PGRADIENT_TRIANGLE = *mut _GRADIENT_TRIANGLE;
pub type LPGRADIENT_TRIANGLE = *mut _GRADIENT_TRIANGLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GRADIENT_RECT {
  pub UpperLeft: ULONG,
  pub LowerRight: ULONG,
}
#[test]
fn bindgen_test_layout__GRADIENT_RECT() {
  assert_eq!(
    ::core::mem::size_of::<_GRADIENT_RECT>(),
    8usize,
    concat!("Size of: ", stringify!(_GRADIENT_RECT))
  );
  assert_eq!(
    ::core::mem::align_of::<_GRADIENT_RECT>(),
    4usize,
    concat!("Alignment of ", stringify!(_GRADIENT_RECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GRADIENT_RECT>())).UpperLeft as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GRADIENT_RECT),
      "::",
      stringify!(UpperLeft)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GRADIENT_RECT>())).LowerRight as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GRADIENT_RECT),
      "::",
      stringify!(LowerRight)
    )
  );
}
pub type GRADIENT_RECT = _GRADIENT_RECT;
pub type PGRADIENT_RECT = *mut _GRADIENT_RECT;
pub type LPGRADIENT_RECT = *mut _GRADIENT_RECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _BLENDFUNCTION {
  pub BlendOp: BYTE,
  pub BlendFlags: BYTE,
  pub SourceConstantAlpha: BYTE,
  pub AlphaFormat: BYTE,
}
#[test]
fn bindgen_test_layout__BLENDFUNCTION() {
  assert_eq!(
    ::core::mem::size_of::<_BLENDFUNCTION>(),
    4usize,
    concat!("Size of: ", stringify!(_BLENDFUNCTION))
  );
  assert_eq!(
    ::core::mem::align_of::<_BLENDFUNCTION>(),
    1usize,
    concat!("Alignment of ", stringify!(_BLENDFUNCTION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_BLENDFUNCTION>())).BlendOp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_BLENDFUNCTION),
      "::",
      stringify!(BlendOp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_BLENDFUNCTION>())).BlendFlags as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_BLENDFUNCTION),
      "::",
      stringify!(BlendFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_BLENDFUNCTION>())).SourceConstantAlpha as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_BLENDFUNCTION),
      "::",
      stringify!(SourceConstantAlpha)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_BLENDFUNCTION>())).AlphaFormat as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_BLENDFUNCTION),
      "::",
      stringify!(AlphaFormat)
    )
  );
}
pub type BLENDFUNCTION = _BLENDFUNCTION;
pub type PBLENDFUNCTION = *mut _BLENDFUNCTION;
extern "C" {
  pub fn AlphaBlend(
    hdcDest: HDC, xoriginDest: libc::c_int, yoriginDest: libc::c_int, wDest: libc::c_int,
    hDest: libc::c_int, hdcSrc: HDC, xoriginSrc: libc::c_int, yoriginSrc: libc::c_int,
    wSrc: libc::c_int, hSrc: libc::c_int, ftn: BLENDFUNCTION,
  ) -> BOOL;
}
extern "C" {
  pub fn TransparentBlt(
    hdcDest: HDC, xoriginDest: libc::c_int, yoriginDest: libc::c_int, wDest: libc::c_int,
    hDest: libc::c_int, hdcSrc: HDC, xoriginSrc: libc::c_int, yoriginSrc: libc::c_int,
    wSrc: libc::c_int, hSrc: libc::c_int, crTransparent: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GradientFill(
    hdc: HDC, pVertex: PTRIVERTEX, nVertex: ULONG, pMesh: PVOID, nMesh: ULONG, ulMode: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GdiAlphaBlend(
    hdcDest: HDC, xoriginDest: libc::c_int, yoriginDest: libc::c_int, wDest: libc::c_int,
    hDest: libc::c_int, hdcSrc: HDC, xoriginSrc: libc::c_int, yoriginSrc: libc::c_int,
    wSrc: libc::c_int, hSrc: libc::c_int, ftn: BLENDFUNCTION,
  ) -> BOOL;
}
extern "C" {
  pub fn GdiTransparentBlt(
    hdcDest: HDC, xoriginDest: libc::c_int, yoriginDest: libc::c_int, wDest: libc::c_int,
    hDest: libc::c_int, hdcSrc: HDC, xoriginSrc: libc::c_int, yoriginSrc: libc::c_int,
    wSrc: libc::c_int, hSrc: libc::c_int, crTransparent: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GdiGradientFill(
    hdc: HDC, pVertex: PTRIVERTEX, nVertex: ULONG, pMesh: PVOID, nCount: ULONG, ulMode: ULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn PlayMetaFileRecord(
    hdc: HDC, lpHandleTable: LPHANDLETABLE, lpMR: LPMETARECORD, noObjs: UINT,
  ) -> BOOL;
}
pub type MFENUMPROC = ::core::option::Option<
  unsafe extern "C" fn(
    hdc: HDC,
    lpht: *mut HANDLETABLE,
    lpMR: *mut METARECORD,
    nObj: libc::c_int,
    param: LPARAM,
  ) -> libc::c_int,
>;
extern "C" {
  pub fn EnumMetaFile(hdc: HDC, hmf: HMETAFILE, proc_: MFENUMPROC, param: LPARAM) -> BOOL;
}
pub type ENHMFENUMPROC = ::core::option::Option<
  unsafe extern "C" fn(
    hdc: HDC,
    lpht: *mut HANDLETABLE,
    lpmr: *const ENHMETARECORD,
    nHandles: libc::c_int,
    data: LPARAM,
  ) -> libc::c_int,
>;
extern "C" {
  pub fn CloseEnhMetaFile(hdc: HDC) -> HENHMETAFILE;
}
extern "C" {
  pub fn CopyEnhMetaFileA(hEnh: HENHMETAFILE, lpFileName: LPCSTR) -> HENHMETAFILE;
}
extern "C" {
  pub fn CopyEnhMetaFileW(hEnh: HENHMETAFILE, lpFileName: LPCWSTR) -> HENHMETAFILE;
}
extern "C" {
  pub fn CreateEnhMetaFileA(hdc: HDC, lpFilename: LPCSTR, lprc: *const RECT, lpDesc: LPCSTR)
    -> HDC;
}
extern "C" {
  pub fn CreateEnhMetaFileW(
    hdc: HDC, lpFilename: LPCWSTR, lprc: *const RECT, lpDesc: LPCWSTR,
  ) -> HDC;
}
extern "C" {
  pub fn DeleteEnhMetaFile(hmf: HENHMETAFILE) -> BOOL;
}
extern "C" {
  pub fn EnumEnhMetaFile(
    hdc: HDC, hmf: HENHMETAFILE, proc_: ENHMFENUMPROC, param: LPVOID, lpRect: *const RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetEnhMetaFileA(lpName: LPCSTR) -> HENHMETAFILE;
}
extern "C" {
  pub fn GetEnhMetaFileW(lpName: LPCWSTR) -> HENHMETAFILE;
}
extern "C" {
  pub fn GetEnhMetaFileBits(hEMF: HENHMETAFILE, nSize: UINT, lpData: LPBYTE) -> UINT;
}
extern "C" {
  pub fn GetEnhMetaFileDescriptionA(
    hemf: HENHMETAFILE, cchBuffer: UINT, lpDescription: LPSTR,
  ) -> UINT;
}
extern "C" {
  pub fn GetEnhMetaFileDescriptionW(
    hemf: HENHMETAFILE, cchBuffer: UINT, lpDescription: LPWSTR,
  ) -> UINT;
}
extern "C" {
  pub fn GetEnhMetaFileHeader(
    hemf: HENHMETAFILE, nSize: UINT, lpEnhMetaHeader: LPENHMETAHEADER,
  ) -> UINT;
}
extern "C" {
  pub fn GetEnhMetaFilePaletteEntries(
    hemf: HENHMETAFILE, nNumEntries: UINT, lpPaletteEntries: LPPALETTEENTRY,
  ) -> UINT;
}
extern "C" {
  pub fn GetEnhMetaFilePixelFormat(
    hemf: HENHMETAFILE, cbBuffer: UINT, ppfd: *mut PIXELFORMATDESCRIPTOR,
  ) -> UINT;
}
extern "C" {
  pub fn GetWinMetaFileBits(
    hemf: HENHMETAFILE, cbData16: UINT, pData16: LPBYTE, iMapMode: INT, hdcRef: HDC,
  ) -> UINT;
}
extern "C" {
  pub fn PlayEnhMetaFile(hdc: HDC, hmf: HENHMETAFILE, lprect: *const RECT) -> BOOL;
}
extern "C" {
  pub fn PlayEnhMetaFileRecord(
    hdc: HDC, pht: LPHANDLETABLE, pmr: *const ENHMETARECORD, cht: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SetEnhMetaFileBits(nSize: UINT, pb: *const BYTE) -> HENHMETAFILE;
}
extern "C" {
  pub fn SetWinMetaFileBits(
    nSize: UINT, lpMeta16Data: *const BYTE, hdcRef: HDC, lpMFP: *const METAFILEPICT,
  ) -> HENHMETAFILE;
}
extern "C" {
  pub fn GdiComment(hdc: HDC, nSize: UINT, lpData: *const BYTE) -> BOOL;
}
extern "C" {
  pub fn GetTextMetricsA(hdc: HDC, lptm: LPTEXTMETRICA) -> BOOL;
}
extern "C" {
  pub fn GetTextMetricsW(hdc: HDC, lptm: LPTEXTMETRICW) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagDIBSECTION {
  pub dsBm: BITMAP,
  pub dsBmih: BITMAPINFOHEADER,
  pub dsBitfields: [DWORD; 3usize],
  pub dshSection: HANDLE,
  pub dsOffset: DWORD,
}
#[test]
fn bindgen_test_layout_tagDIBSECTION() {
  assert_eq!(
    ::core::mem::size_of::<tagDIBSECTION>(),
    104usize,
    concat!("Size of: ", stringify!(tagDIBSECTION))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDIBSECTION>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDIBSECTION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDIBSECTION>())).dsBm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDIBSECTION),
      "::",
      stringify!(dsBm)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDIBSECTION>())).dsBmih as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDIBSECTION),
      "::",
      stringify!(dsBmih)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDIBSECTION>())).dsBitfields as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDIBSECTION),
      "::",
      stringify!(dsBitfields)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDIBSECTION>())).dshSection as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDIBSECTION),
      "::",
      stringify!(dshSection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDIBSECTION>())).dsOffset as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDIBSECTION),
      "::",
      stringify!(dsOffset)
    )
  );
}
impl Default for tagDIBSECTION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DIBSECTION = tagDIBSECTION;
pub type LPDIBSECTION = *mut tagDIBSECTION;
pub type PDIBSECTION = *mut tagDIBSECTION;
extern "C" {
  pub fn AngleArc(
    hdc: HDC, x: libc::c_int, y: libc::c_int, r: DWORD, StartAngle: FLOAT, SweepAngle: FLOAT,
  ) -> BOOL;
}
extern "C" {
  pub fn PolyPolyline(hdc: HDC, apt: *const POINT, asz: *const DWORD, csz: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetWorldTransform(hdc: HDC, lpxf: LPXFORM) -> BOOL;
}
extern "C" {
  pub fn SetWorldTransform(hdc: HDC, lpxf: *const XFORM) -> BOOL;
}
extern "C" {
  pub fn ModifyWorldTransform(hdc: HDC, lpxf: *const XFORM, mode: DWORD) -> BOOL;
}
extern "C" {
  pub fn CombineTransform(lpxfOut: LPXFORM, lpxf1: *const XFORM, lpxf2: *const XFORM) -> BOOL;
}
extern "C" {
  pub fn CreateDIBSection(
    hdc: HDC, pbmi: *const BITMAPINFO, usage: UINT, ppvBits: *mut *mut libc::c_void,
    hSection: HANDLE, offset: DWORD,
  ) -> HBITMAP;
}
extern "C" {
  pub fn GetDIBColorTable(hdc: HDC, iStart: UINT, cEntries: UINT, prgbq: *mut RGBQUAD) -> UINT;
}
extern "C" {
  pub fn SetDIBColorTable(hdc: HDC, iStart: UINT, cEntries: UINT, prgbq: *const RGBQUAD) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCOLORADJUSTMENT {
  pub caSize: WORD,
  pub caFlags: WORD,
  pub caIlluminantIndex: WORD,
  pub caRedGamma: WORD,
  pub caGreenGamma: WORD,
  pub caBlueGamma: WORD,
  pub caReferenceBlack: WORD,
  pub caReferenceWhite: WORD,
  pub caContrast: SHORT,
  pub caBrightness: SHORT,
  pub caColorfulness: SHORT,
  pub caRedGreenTint: SHORT,
}
#[test]
fn bindgen_test_layout_tagCOLORADJUSTMENT() {
  assert_eq!(
    ::core::mem::size_of::<tagCOLORADJUSTMENT>(),
    24usize,
    concat!("Size of: ", stringify!(tagCOLORADJUSTMENT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOLORADJUSTMENT>(),
    2usize,
    concat!("Alignment of ", stringify!(tagCOLORADJUSTMENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caFlags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caIlluminantIndex as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caIlluminantIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caRedGamma as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caRedGamma)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caGreenGamma as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caGreenGamma)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caBlueGamma as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caBlueGamma)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caReferenceBlack as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caReferenceBlack)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caReferenceWhite as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caReferenceWhite)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caContrast as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caContrast)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caBrightness as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caBrightness)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caColorfulness as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caColorfulness)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORADJUSTMENT>())).caRedGreenTint as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORADJUSTMENT),
      "::",
      stringify!(caRedGreenTint)
    )
  );
}
pub type COLORADJUSTMENT = tagCOLORADJUSTMENT;
pub type PCOLORADJUSTMENT = *mut tagCOLORADJUSTMENT;
pub type LPCOLORADJUSTMENT = *mut tagCOLORADJUSTMENT;
extern "C" {
  pub fn SetColorAdjustment(hdc: HDC, lpca: *const COLORADJUSTMENT) -> BOOL;
}
extern "C" {
  pub fn GetColorAdjustment(hdc: HDC, lpca: LPCOLORADJUSTMENT) -> BOOL;
}
extern "C" {
  pub fn CreateHalftonePalette(hdc: HDC) -> HPALETTE;
}
pub type ABORTPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: HDC, arg2: libc::c_int) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _DOCINFOA {
  pub cbSize: libc::c_int,
  pub lpszDocName: LPCSTR,
  pub lpszOutput: LPCSTR,
  pub lpszDatatype: LPCSTR,
  pub fwType: DWORD,
}
#[test]
fn bindgen_test_layout__DOCINFOA() {
  assert_eq!(
    ::core::mem::size_of::<_DOCINFOA>(),
    40usize,
    concat!("Size of: ", stringify!(_DOCINFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<_DOCINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_DOCINFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOA>())).lpszDocName as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOA),
      "::",
      stringify!(lpszDocName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOA>())).lpszOutput as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOA),
      "::",
      stringify!(lpszOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOA>())).lpszDatatype as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOA),
      "::",
      stringify!(lpszDatatype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOA>())).fwType as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOA),
      "::",
      stringify!(fwType)
    )
  );
}
impl Default for _DOCINFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DOCINFOA = _DOCINFOA;
pub type LPDOCINFOA = *mut _DOCINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _DOCINFOW {
  pub cbSize: libc::c_int,
  pub lpszDocName: LPCWSTR,
  pub lpszOutput: LPCWSTR,
  pub lpszDatatype: LPCWSTR,
  pub fwType: DWORD,
}
#[test]
fn bindgen_test_layout__DOCINFOW() {
  assert_eq!(
    ::core::mem::size_of::<_DOCINFOW>(),
    40usize,
    concat!("Size of: ", stringify!(_DOCINFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<_DOCINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_DOCINFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOW>())).lpszDocName as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOW),
      "::",
      stringify!(lpszDocName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOW>())).lpszOutput as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOW),
      "::",
      stringify!(lpszOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOW>())).lpszDatatype as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOW),
      "::",
      stringify!(lpszDatatype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DOCINFOW>())).fwType as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_DOCINFOW),
      "::",
      stringify!(fwType)
    )
  );
}
impl Default for _DOCINFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DOCINFOW = _DOCINFOW;
pub type LPDOCINFOW = *mut _DOCINFOW;
pub type DOCINFO = DOCINFOA;
pub type LPDOCINFO = LPDOCINFOA;
extern "C" {
  pub fn StartDocA(hdc: HDC, lpdi: *const DOCINFOA) -> libc::c_int;
}
extern "C" {
  pub fn StartDocW(hdc: HDC, lpdi: *const DOCINFOW) -> libc::c_int;
}
extern "C" {
  pub fn EndDoc(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn StartPage(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn EndPage(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn AbortDoc(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn SetAbortProc(hdc: HDC, proc_: ABORTPROC) -> libc::c_int;
}
extern "C" {
  pub fn AbortPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn ArcTo(
    hdc: HDC, left: libc::c_int, top: libc::c_int, right: libc::c_int, bottom: libc::c_int,
    xr1: libc::c_int, yr1: libc::c_int, xr2: libc::c_int, yr2: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn BeginPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn CloseFigure(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn EndPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn FillPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn FlattenPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn GetPath(hdc: HDC, apt: LPPOINT, aj: LPBYTE, cpt: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn PathToRegion(hdc: HDC) -> HRGN;
}
extern "C" {
  pub fn PolyDraw(hdc: HDC, apt: *const POINT, aj: *const BYTE, cpt: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn SelectClipPath(hdc: HDC, mode: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn SetArcDirection(hdc: HDC, dir: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetMiterLimit(hdc: HDC, limit: FLOAT, old: PFLOAT) -> BOOL;
}
extern "C" {
  pub fn StrokeAndFillPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn StrokePath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn WidenPath(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn ExtCreatePen(
    iPenStyle: DWORD, cWidth: DWORD, plbrush: *const LOGBRUSH, cStyle: DWORD, pstyle: *const DWORD,
  ) -> HPEN;
}
extern "C" {
  pub fn GetMiterLimit(hdc: HDC, plimit: PFLOAT) -> BOOL;
}
extern "C" {
  pub fn GetArcDirection(hdc: HDC) -> libc::c_int;
}
extern "C" {
  pub fn GetObjectA(h: HANDLE, c: libc::c_int, pv: LPVOID) -> libc::c_int;
}
extern "C" {
  pub fn GetObjectW(h: HANDLE, c: libc::c_int, pv: LPVOID) -> libc::c_int;
}
extern "C" {
  pub fn MoveToEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn TextOutA(
    hdc: HDC, x: libc::c_int, y: libc::c_int, lpString: LPCSTR, c: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn TextOutW(
    hdc: HDC, x: libc::c_int, y: libc::c_int, lpString: LPCWSTR, c: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn ExtTextOutA(
    hdc: HDC, x: libc::c_int, y: libc::c_int, options: UINT, lprect: *const RECT, lpString: LPCSTR,
    c: UINT, lpDx: *const INT,
  ) -> BOOL;
}
extern "C" {
  pub fn ExtTextOutW(
    hdc: HDC, x: libc::c_int, y: libc::c_int, options: UINT, lprect: *const RECT,
    lpString: LPCWSTR, c: UINT, lpDx: *const INT,
  ) -> BOOL;
}
extern "C" {
  pub fn PolyTextOutA(hdc: HDC, ppt: *const POLYTEXTA, nstrings: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn PolyTextOutW(hdc: HDC, ppt: *const POLYTEXTW, nstrings: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn CreatePolygonRgn(pptl: *const POINT, cPoint: libc::c_int, iMode: libc::c_int) -> HRGN;
}
extern "C" {
  pub fn DPtoLP(hdc: HDC, lppt: LPPOINT, c: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn LPtoDP(hdc: HDC, lppt: LPPOINT, c: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn Polygon(hdc: HDC, apt: *const POINT, cpt: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn Polyline(hdc: HDC, apt: *const POINT, cpt: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn PolyBezier(hdc: HDC, apt: *const POINT, cpt: DWORD) -> BOOL;
}
extern "C" {
  pub fn PolyBezierTo(hdc: HDC, apt: *const POINT, cpt: DWORD) -> BOOL;
}
extern "C" {
  pub fn PolylineTo(hdc: HDC, apt: *const POINT, cpt: DWORD) -> BOOL;
}
extern "C" {
  pub fn SetViewportExtEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lpsz: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn SetViewportOrgEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn SetWindowExtEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lpsz: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn SetWindowOrgEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn OffsetViewportOrgEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn OffsetWindowOrgEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn ScaleViewportExtEx(
    hdc: HDC, xn: libc::c_int, dx: libc::c_int, yn: libc::c_int, yd: libc::c_int, lpsz: LPSIZE,
  ) -> BOOL;
}
extern "C" {
  pub fn ScaleWindowExtEx(
    hdc: HDC, xn: libc::c_int, xd: libc::c_int, yn: libc::c_int, yd: libc::c_int, lpsz: LPSIZE,
  ) -> BOOL;
}
extern "C" {
  pub fn SetBitmapDimensionEx(hbm: HBITMAP, w: libc::c_int, h: libc::c_int, lpsz: LPSIZE) -> BOOL;
}
extern "C" {
  pub fn SetBrushOrgEx(hdc: HDC, x: libc::c_int, y: libc::c_int, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn GetTextFaceA(hdc: HDC, c: libc::c_int, lpName: LPSTR) -> libc::c_int;
}
extern "C" {
  pub fn GetTextFaceW(hdc: HDC, c: libc::c_int, lpName: LPWSTR) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagKERNINGPAIR {
  pub wFirst: WORD,
  pub wSecond: WORD,
  pub iKernAmount: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagKERNINGPAIR() {
  assert_eq!(
    ::core::mem::size_of::<tagKERNINGPAIR>(),
    8usize,
    concat!("Size of: ", stringify!(tagKERNINGPAIR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagKERNINGPAIR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagKERNINGPAIR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKERNINGPAIR>())).wFirst as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKERNINGPAIR),
      "::",
      stringify!(wFirst)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKERNINGPAIR>())).wSecond as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKERNINGPAIR),
      "::",
      stringify!(wSecond)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKERNINGPAIR>())).iKernAmount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKERNINGPAIR),
      "::",
      stringify!(iKernAmount)
    )
  );
}
pub type KERNINGPAIR = tagKERNINGPAIR;
pub type LPKERNINGPAIR = *mut tagKERNINGPAIR;
extern "C" {
  pub fn GetKerningPairsA(hdc: HDC, nPairs: DWORD, lpKernPair: LPKERNINGPAIR) -> DWORD;
}
extern "C" {
  pub fn GetKerningPairsW(hdc: HDC, nPairs: DWORD, lpKernPair: LPKERNINGPAIR) -> DWORD;
}
extern "C" {
  pub fn GetDCOrgEx(hdc: HDC, lppt: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn FixBrushOrgEx(hdc: HDC, x: libc::c_int, y: libc::c_int, ptl: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn UnrealizeObject(h: HGDIOBJ) -> BOOL;
}
extern "C" {
  pub fn GdiFlush() -> BOOL;
}
extern "C" {
  pub fn GdiSetBatchLimit(dw: DWORD) -> DWORD;
}
extern "C" {
  pub fn GdiGetBatchLimit() -> DWORD;
}
pub type ICMENUMPROCA =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: LPARAM) -> libc::c_int>;
pub type ICMENUMPROCW =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LPARAM) -> libc::c_int>;
extern "C" {
  pub fn SetICMMode(hdc: HDC, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn CheckColorsInGamut(
    hdc: HDC, lpRGBTriple: LPRGBTRIPLE, dlpBuffer: LPVOID, nCount: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetColorSpace(hdc: HDC) -> HCOLORSPACE;
}
extern "C" {
  pub fn GetLogColorSpaceA(
    hColorSpace: HCOLORSPACE, lpBuffer: LPLOGCOLORSPACEA, nSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetLogColorSpaceW(
    hColorSpace: HCOLORSPACE, lpBuffer: LPLOGCOLORSPACEW, nSize: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateColorSpaceA(lplcs: LPLOGCOLORSPACEA) -> HCOLORSPACE;
}
extern "C" {
  pub fn CreateColorSpaceW(lplcs: LPLOGCOLORSPACEW) -> HCOLORSPACE;
}
extern "C" {
  pub fn SetColorSpace(hdc: HDC, hcs: HCOLORSPACE) -> HCOLORSPACE;
}
extern "C" {
  pub fn DeleteColorSpace(hcs: HCOLORSPACE) -> BOOL;
}
extern "C" {
  pub fn GetICMProfileA(hdc: HDC, pBufSize: LPDWORD, pszFilename: LPSTR) -> BOOL;
}
extern "C" {
  pub fn GetICMProfileW(hdc: HDC, pBufSize: LPDWORD, pszFilename: LPWSTR) -> BOOL;
}
extern "C" {
  pub fn SetICMProfileA(hdc: HDC, lpFileName: LPSTR) -> BOOL;
}
extern "C" {
  pub fn SetICMProfileW(hdc: HDC, lpFileName: LPWSTR) -> BOOL;
}
extern "C" {
  pub fn GetDeviceGammaRamp(hdc: HDC, lpRamp: LPVOID) -> BOOL;
}
extern "C" {
  pub fn SetDeviceGammaRamp(hdc: HDC, lpRamp: LPVOID) -> BOOL;
}
extern "C" {
  pub fn ColorMatchToTarget(hdc: HDC, hdcTarget: HDC, action: DWORD) -> BOOL;
}
extern "C" {
  pub fn EnumICMProfilesA(hdc: HDC, proc_: ICMENUMPROCA, param: LPARAM) -> libc::c_int;
}
extern "C" {
  pub fn EnumICMProfilesW(hdc: HDC, proc_: ICMENUMPROCW, param: LPARAM) -> libc::c_int;
}
extern "C" {
  pub fn UpdateICMRegKeyA(
    reserved: DWORD, lpszCMID: LPSTR, lpszFileName: LPSTR, command: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn UpdateICMRegKeyW(
    reserved: DWORD, lpszCMID: LPWSTR, lpszFileName: LPWSTR, command: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn ColorCorrectPalette(hdc: HDC, hPal: HPALETTE, deFirst: DWORD, num: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMR {
  pub iType: DWORD,
  pub nSize: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMR() {
  assert_eq!(
    ::core::mem::size_of::<tagEMR>(),
    8usize,
    concat!("Size of: ", stringify!(tagEMR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMR>())).iType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMR),
      "::",
      stringify!(iType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMR>())).nSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMR),
      "::",
      stringify!(nSize)
    )
  );
}
pub type EMR = tagEMR;
pub type PEMR = *mut tagEMR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRTEXT {
  pub ptlReference: POINTL,
  pub nChars: DWORD,
  pub offString: DWORD,
  pub fOptions: DWORD,
  pub rcl: RECTL,
  pub offDx: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRTEXT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRTEXT>(),
    40usize,
    concat!("Size of: ", stringify!(tagEMRTEXT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRTEXT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRTEXT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTEXT>())).ptlReference as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTEXT),
      "::",
      stringify!(ptlReference)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTEXT>())).nChars as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTEXT),
      "::",
      stringify!(nChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTEXT>())).offString as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTEXT),
      "::",
      stringify!(offString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTEXT>())).fOptions as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTEXT),
      "::",
      stringify!(fOptions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTEXT>())).rcl as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTEXT),
      "::",
      stringify!(rcl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTEXT>())).offDx as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTEXT),
      "::",
      stringify!(offDx)
    )
  );
}
pub type EMRTEXT = tagEMRTEXT;
pub type PEMRTEXT = *mut tagEMRTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagABORTPATH {
  pub emr: EMR,
}
#[test]
fn bindgen_test_layout_tagABORTPATH() {
  assert_eq!(
    ::core::mem::size_of::<tagABORTPATH>(),
    8usize,
    concat!("Size of: ", stringify!(tagABORTPATH))
  );
  assert_eq!(
    ::core::mem::align_of::<tagABORTPATH>(),
    4usize,
    concat!("Alignment of ", stringify!(tagABORTPATH))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagABORTPATH>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagABORTPATH),
      "::",
      stringify!(emr)
    )
  );
}
pub type EMRABORTPATH = tagABORTPATH;
pub type PEMRABORTPATH = *mut tagABORTPATH;
pub type EMRBEGINPATH = tagABORTPATH;
pub type PEMRBEGINPATH = *mut tagABORTPATH;
pub type EMRENDPATH = tagABORTPATH;
pub type PEMRENDPATH = *mut tagABORTPATH;
pub type EMRCLOSEFIGURE = tagABORTPATH;
pub type PEMRCLOSEFIGURE = *mut tagABORTPATH;
pub type EMRFLATTENPATH = tagABORTPATH;
pub type PEMRFLATTENPATH = *mut tagABORTPATH;
pub type EMRWIDENPATH = tagABORTPATH;
pub type PEMRWIDENPATH = *mut tagABORTPATH;
pub type EMRSETMETARGN = tagABORTPATH;
pub type PEMRSETMETARGN = *mut tagABORTPATH;
pub type EMRSAVEDC = tagABORTPATH;
pub type PEMRSAVEDC = *mut tagABORTPATH;
pub type EMRREALIZEPALETTE = tagABORTPATH;
pub type PEMRREALIZEPALETTE = *mut tagABORTPATH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSELECTCLIPPATH {
  pub emr: EMR,
  pub iMode: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSELECTCLIPPATH() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSELECTCLIPPATH>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSELECTCLIPPATH))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSELECTCLIPPATH>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSELECTCLIPPATH))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSELECTCLIPPATH>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSELECTCLIPPATH),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSELECTCLIPPATH>())).iMode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSELECTCLIPPATH),
      "::",
      stringify!(iMode)
    )
  );
}
pub type EMRSELECTCLIPPATH = tagEMRSELECTCLIPPATH;
pub type PEMRSELECTCLIPPATH = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETBKMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETBKMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETMAPMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETMAPMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETLAYOUT = tagEMRSELECTCLIPPATH;
pub type PEMRSETLAYOUT = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETPOLYFILLMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETPOLYFILLMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETROP2 = tagEMRSELECTCLIPPATH;
pub type PEMRSETROP2 = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETSTRETCHBLTMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETSTRETCHBLTMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETICMMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETICMMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETTEXTALIGN = tagEMRSELECTCLIPPATH;
pub type PEMRSETTEXTALIGN = *mut tagEMRSELECTCLIPPATH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETMITERLIMIT {
  pub emr: EMR,
  pub eMiterLimit: FLOAT,
}
#[test]
fn bindgen_test_layout_tagEMRSETMITERLIMIT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETMITERLIMIT>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSETMITERLIMIT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETMITERLIMIT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETMITERLIMIT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETMITERLIMIT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETMITERLIMIT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETMITERLIMIT>())).eMiterLimit as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETMITERLIMIT),
      "::",
      stringify!(eMiterLimit)
    )
  );
}
pub type EMRSETMITERLIMIT = tagEMRSETMITERLIMIT;
pub type PEMRSETMITERLIMIT = *mut tagEMRSETMITERLIMIT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRRESTOREDC {
  pub emr: EMR,
  pub iRelative: LONG,
}
#[test]
fn bindgen_test_layout_tagEMRRESTOREDC() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRRESTOREDC>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRRESTOREDC))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRRESTOREDC>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRRESTOREDC))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRRESTOREDC>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRRESTOREDC),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRRESTOREDC>())).iRelative as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRRESTOREDC),
      "::",
      stringify!(iRelative)
    )
  );
}
pub type EMRRESTOREDC = tagEMRRESTOREDC;
pub type PEMRRESTOREDC = *mut tagEMRRESTOREDC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETARCDIRECTION {
  pub emr: EMR,
  pub iArcDirection: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSETARCDIRECTION() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETARCDIRECTION>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSETARCDIRECTION))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETARCDIRECTION>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETARCDIRECTION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETARCDIRECTION>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETARCDIRECTION),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRSETARCDIRECTION>())).iArcDirection as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETARCDIRECTION),
      "::",
      stringify!(iArcDirection)
    )
  );
}
pub type EMRSETARCDIRECTION = tagEMRSETARCDIRECTION;
pub type PEMRSETARCDIRECTION = *mut tagEMRSETARCDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETMAPPERFLAGS {
  pub emr: EMR,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSETMAPPERFLAGS() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETMAPPERFLAGS>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSETMAPPERFLAGS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETMAPPERFLAGS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETMAPPERFLAGS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETMAPPERFLAGS>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETMAPPERFLAGS),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETMAPPERFLAGS>())).dwFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETMAPPERFLAGS),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type EMRSETMAPPERFLAGS = tagEMRSETMAPPERFLAGS;
pub type PEMRSETMAPPERFLAGS = *mut tagEMRSETMAPPERFLAGS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETTEXTCOLOR {
  pub emr: EMR,
  pub crColor: COLORREF,
}
#[test]
fn bindgen_test_layout_tagEMRSETTEXTCOLOR() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETTEXTCOLOR>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSETTEXTCOLOR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETTEXTCOLOR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETTEXTCOLOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETTEXTCOLOR>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETTEXTCOLOR),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETTEXTCOLOR>())).crColor as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETTEXTCOLOR),
      "::",
      stringify!(crColor)
    )
  );
}
pub type EMRSETBKCOLOR = tagEMRSETTEXTCOLOR;
pub type PEMRSETBKCOLOR = *mut tagEMRSETTEXTCOLOR;
pub type EMRSETTEXTCOLOR = tagEMRSETTEXTCOLOR;
pub type PEMRSETTEXTCOLOR = *mut tagEMRSETTEXTCOLOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSELECTOBJECT {
  pub emr: EMR,
  pub ihObject: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSELECTOBJECT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSELECTOBJECT>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSELECTOBJECT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSELECTOBJECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSELECTOBJECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSELECTOBJECT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSELECTOBJECT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSELECTOBJECT>())).ihObject as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSELECTOBJECT),
      "::",
      stringify!(ihObject)
    )
  );
}
pub type EMRSELECTOBJECT = tagEMRSELECTOBJECT;
pub type PEMRSELECTOBJECT = *mut tagEMRSELECTOBJECT;
pub type EMRDELETEOBJECT = tagEMRSELECTOBJECT;
pub type PEMRDELETEOBJECT = *mut tagEMRSELECTOBJECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSELECTPALETTE {
  pub emr: EMR,
  pub ihPal: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSELECTPALETTE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSELECTPALETTE>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSELECTPALETTE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSELECTPALETTE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSELECTPALETTE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSELECTPALETTE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSELECTPALETTE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSELECTPALETTE>())).ihPal as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSELECTPALETTE),
      "::",
      stringify!(ihPal)
    )
  );
}
pub type EMRSELECTPALETTE = tagEMRSELECTPALETTE;
pub type PEMRSELECTPALETTE = *mut tagEMRSELECTPALETTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRRESIZEPALETTE {
  pub emr: EMR,
  pub ihPal: DWORD,
  pub cEntries: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRRESIZEPALETTE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRRESIZEPALETTE>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRRESIZEPALETTE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRRESIZEPALETTE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRRESIZEPALETTE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRRESIZEPALETTE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRRESIZEPALETTE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRRESIZEPALETTE>())).ihPal as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRRESIZEPALETTE),
      "::",
      stringify!(ihPal)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRRESIZEPALETTE>())).cEntries as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRRESIZEPALETTE),
      "::",
      stringify!(cEntries)
    )
  );
}
pub type EMRRESIZEPALETTE = tagEMRRESIZEPALETTE;
pub type PEMRRESIZEPALETTE = *mut tagEMRRESIZEPALETTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETPALETTEENTRIES {
  pub emr: EMR,
  pub ihPal: DWORD,
  pub iStart: DWORD,
  pub cEntries: DWORD,
  pub aPalEntries: [PALETTEENTRY; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRSETPALETTEENTRIES() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETPALETTEENTRIES>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRSETPALETTEENTRIES))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETPALETTEENTRIES>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETPALETTEENTRIES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPALETTEENTRIES>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPALETTEENTRIES),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPALETTEENTRIES>())).ihPal as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPALETTEENTRIES),
      "::",
      stringify!(ihPal)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPALETTEENTRIES>())).iStart as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPALETTEENTRIES),
      "::",
      stringify!(iStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPALETTEENTRIES>())).cEntries as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPALETTEENTRIES),
      "::",
      stringify!(cEntries)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRSETPALETTEENTRIES>())).aPalEntries as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPALETTEENTRIES),
      "::",
      stringify!(aPalEntries)
    )
  );
}
pub type EMRSETPALETTEENTRIES = tagEMRSETPALETTEENTRIES;
pub type PEMRSETPALETTEENTRIES = *mut tagEMRSETPALETTEENTRIES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETCOLORADJUSTMENT {
  pub emr: EMR,
  pub ColorAdjustment: COLORADJUSTMENT,
}
#[test]
fn bindgen_test_layout_tagEMRSETCOLORADJUSTMENT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETCOLORADJUSTMENT>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRSETCOLORADJUSTMENT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETCOLORADJUSTMENT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETCOLORADJUSTMENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETCOLORADJUSTMENT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETCOLORADJUSTMENT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRSETCOLORADJUSTMENT>())).ColorAdjustment as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETCOLORADJUSTMENT),
      "::",
      stringify!(ColorAdjustment)
    )
  );
}
pub type EMRSETCOLORADJUSTMENT = tagEMRSETCOLORADJUSTMENT;
pub type PEMRSETCOLORADJUSTMENT = *mut tagEMRSETCOLORADJUSTMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRGDICOMMENT {
  pub emr: EMR,
  pub cbData: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRGDICOMMENT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRGDICOMMENT>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRGDICOMMENT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRGDICOMMENT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRGDICOMMENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGDICOMMENT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGDICOMMENT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGDICOMMENT>())).cbData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGDICOMMENT),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGDICOMMENT>())).Data as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGDICOMMENT),
      "::",
      stringify!(Data)
    )
  );
}
pub type EMRGDICOMMENT = tagEMRGDICOMMENT;
pub type PEMRGDICOMMENT = *mut tagEMRGDICOMMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREOF {
  pub emr: EMR,
  pub nPalEntries: DWORD,
  pub offPalEntries: DWORD,
  pub nSizeLast: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMREOF() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREOF>(),
    20usize,
    concat!("Size of: ", stringify!(tagEMREOF))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREOF>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREOF))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREOF>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREOF),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREOF>())).nPalEntries as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREOF),
      "::",
      stringify!(nPalEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREOF>())).offPalEntries as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREOF),
      "::",
      stringify!(offPalEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREOF>())).nSizeLast as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREOF),
      "::",
      stringify!(nSizeLast)
    )
  );
}
pub type EMREOF = tagEMREOF;
pub type PEMREOF = *mut tagEMREOF;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRLINETO {
  pub emr: EMR,
  pub ptl: POINTL,
}
#[test]
fn bindgen_test_layout_tagEMRLINETO() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRLINETO>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRLINETO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRLINETO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRLINETO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRLINETO>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRLINETO),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRLINETO>())).ptl as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRLINETO),
      "::",
      stringify!(ptl)
    )
  );
}
pub type EMRLINETO = tagEMRLINETO;
pub type PEMRLINETO = *mut tagEMRLINETO;
pub type EMRMOVETOEX = tagEMRLINETO;
pub type PEMRMOVETOEX = *mut tagEMRLINETO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMROFFSETCLIPRGN {
  pub emr: EMR,
  pub ptlOffset: POINTL,
}
#[test]
fn bindgen_test_layout_tagEMROFFSETCLIPRGN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMROFFSETCLIPRGN>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMROFFSETCLIPRGN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMROFFSETCLIPRGN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMROFFSETCLIPRGN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMROFFSETCLIPRGN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMROFFSETCLIPRGN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMROFFSETCLIPRGN>())).ptlOffset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMROFFSETCLIPRGN),
      "::",
      stringify!(ptlOffset)
    )
  );
}
pub type EMROFFSETCLIPRGN = tagEMROFFSETCLIPRGN;
pub type PEMROFFSETCLIPRGN = *mut tagEMROFFSETCLIPRGN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRFILLPATH {
  pub emr: EMR,
  pub rclBounds: RECTL,
}
#[test]
fn bindgen_test_layout_tagEMRFILLPATH() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRFILLPATH>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRFILLPATH))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRFILLPATH>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRFILLPATH))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLPATH>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLPATH),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLPATH>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLPATH),
      "::",
      stringify!(rclBounds)
    )
  );
}
pub type EMRFILLPATH = tagEMRFILLPATH;
pub type PEMRFILLPATH = *mut tagEMRFILLPATH;
pub type EMRSTROKEANDFILLPATH = tagEMRFILLPATH;
pub type PEMRSTROKEANDFILLPATH = *mut tagEMRFILLPATH;
pub type EMRSTROKEPATH = tagEMRFILLPATH;
pub type PEMRSTROKEPATH = *mut tagEMRFILLPATH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREXCLUDECLIPRECT {
  pub emr: EMR,
  pub rclClip: RECTL,
}
#[test]
fn bindgen_test_layout_tagEMREXCLUDECLIPRECT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXCLUDECLIPRECT>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMREXCLUDECLIPRECT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXCLUDECLIPRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXCLUDECLIPRECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXCLUDECLIPRECT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXCLUDECLIPRECT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXCLUDECLIPRECT>())).rclClip as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXCLUDECLIPRECT),
      "::",
      stringify!(rclClip)
    )
  );
}
pub type EMREXCLUDECLIPRECT = tagEMREXCLUDECLIPRECT;
pub type PEMREXCLUDECLIPRECT = *mut tagEMREXCLUDECLIPRECT;
pub type EMRINTERSECTCLIPRECT = tagEMREXCLUDECLIPRECT;
pub type PEMRINTERSECTCLIPRECT = *mut tagEMREXCLUDECLIPRECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETVIEWPORTORGEX {
  pub emr: EMR,
  pub ptlOrigin: POINTL,
}
#[test]
fn bindgen_test_layout_tagEMRSETVIEWPORTORGEX() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETVIEWPORTORGEX>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRSETVIEWPORTORGEX))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETVIEWPORTORGEX>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETVIEWPORTORGEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETVIEWPORTORGEX>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETVIEWPORTORGEX),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETVIEWPORTORGEX>())).ptlOrigin as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETVIEWPORTORGEX),
      "::",
      stringify!(ptlOrigin)
    )
  );
}
pub type EMRSETVIEWPORTORGEX = tagEMRSETVIEWPORTORGEX;
pub type PEMRSETVIEWPORTORGEX = *mut tagEMRSETVIEWPORTORGEX;
pub type EMRSETWINDOWORGEX = tagEMRSETVIEWPORTORGEX;
pub type PEMRSETWINDOWORGEX = *mut tagEMRSETVIEWPORTORGEX;
pub type EMRSETBRUSHORGEX = tagEMRSETVIEWPORTORGEX;
pub type PEMRSETBRUSHORGEX = *mut tagEMRSETVIEWPORTORGEX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETVIEWPORTEXTEX {
  pub emr: EMR,
  pub szlExtent: SIZEL,
}
#[test]
fn bindgen_test_layout_tagEMRSETVIEWPORTEXTEX() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETVIEWPORTEXTEX>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRSETVIEWPORTEXTEX))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETVIEWPORTEXTEX>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETVIEWPORTEXTEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETVIEWPORTEXTEX>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETVIEWPORTEXTEX),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETVIEWPORTEXTEX>())).szlExtent as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETVIEWPORTEXTEX),
      "::",
      stringify!(szlExtent)
    )
  );
}
pub type EMRSETVIEWPORTEXTEX = tagEMRSETVIEWPORTEXTEX;
pub type PEMRSETVIEWPORTEXTEX = *mut tagEMRSETVIEWPORTEXTEX;
pub type EMRSETWINDOWEXTEX = tagEMRSETVIEWPORTEXTEX;
pub type PEMRSETWINDOWEXTEX = *mut tagEMRSETVIEWPORTEXTEX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSCALEVIEWPORTEXTEX {
  pub emr: EMR,
  pub xNum: LONG,
  pub xDenom: LONG,
  pub yNum: LONG,
  pub yDenom: LONG,
}
#[test]
fn bindgen_test_layout_tagEMRSCALEVIEWPORTEXTEX() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSCALEVIEWPORTEXTEX>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRSCALEVIEWPORTEXTEX))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSCALEVIEWPORTEXTEX>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSCALEVIEWPORTEXTEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSCALEVIEWPORTEXTEX>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSCALEVIEWPORTEXTEX),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSCALEVIEWPORTEXTEX>())).xNum as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSCALEVIEWPORTEXTEX),
      "::",
      stringify!(xNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSCALEVIEWPORTEXTEX>())).xDenom as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSCALEVIEWPORTEXTEX),
      "::",
      stringify!(xDenom)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSCALEVIEWPORTEXTEX>())).yNum as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSCALEVIEWPORTEXTEX),
      "::",
      stringify!(yNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSCALEVIEWPORTEXTEX>())).yDenom as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSCALEVIEWPORTEXTEX),
      "::",
      stringify!(yDenom)
    )
  );
}
pub type EMRSCALEVIEWPORTEXTEX = tagEMRSCALEVIEWPORTEXTEX;
pub type PEMRSCALEVIEWPORTEXTEX = *mut tagEMRSCALEVIEWPORTEXTEX;
pub type EMRSCALEWINDOWEXTEX = tagEMRSCALEVIEWPORTEXTEX;
pub type PEMRSCALEWINDOWEXTEX = *mut tagEMRSCALEVIEWPORTEXTEX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETWORLDTRANSFORM {
  pub emr: EMR,
  pub xform: XFORM,
}
#[test]
fn bindgen_test_layout_tagEMRSETWORLDTRANSFORM() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETWORLDTRANSFORM>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRSETWORLDTRANSFORM))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETWORLDTRANSFORM>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETWORLDTRANSFORM))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETWORLDTRANSFORM>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETWORLDTRANSFORM),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETWORLDTRANSFORM>())).xform as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETWORLDTRANSFORM),
      "::",
      stringify!(xform)
    )
  );
}
pub type EMRSETWORLDTRANSFORM = tagEMRSETWORLDTRANSFORM;
pub type PEMRSETWORLDTRANSFORM = *mut tagEMRSETWORLDTRANSFORM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRMODIFYWORLDTRANSFORM {
  pub emr: EMR,
  pub xform: XFORM,
  pub iMode: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRMODIFYWORLDTRANSFORM() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRMODIFYWORLDTRANSFORM>(),
    36usize,
    concat!("Size of: ", stringify!(tagEMRMODIFYWORLDTRANSFORM))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRMODIFYWORLDTRANSFORM>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRMODIFYWORLDTRANSFORM))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMODIFYWORLDTRANSFORM>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMODIFYWORLDTRANSFORM),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMODIFYWORLDTRANSFORM>())).xform as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMODIFYWORLDTRANSFORM),
      "::",
      stringify!(xform)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMODIFYWORLDTRANSFORM>())).iMode as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMODIFYWORLDTRANSFORM),
      "::",
      stringify!(iMode)
    )
  );
}
pub type EMRMODIFYWORLDTRANSFORM = tagEMRMODIFYWORLDTRANSFORM;
pub type PEMRMODIFYWORLDTRANSFORM = *mut tagEMRMODIFYWORLDTRANSFORM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETPIXELV {
  pub emr: EMR,
  pub ptlPixel: POINTL,
  pub crColor: COLORREF,
}
#[test]
fn bindgen_test_layout_tagEMRSETPIXELV() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETPIXELV>(),
    20usize,
    concat!("Size of: ", stringify!(tagEMRSETPIXELV))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETPIXELV>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETPIXELV))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPIXELV>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPIXELV),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPIXELV>())).ptlPixel as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPIXELV),
      "::",
      stringify!(ptlPixel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETPIXELV>())).crColor as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETPIXELV),
      "::",
      stringify!(crColor)
    )
  );
}
pub type EMRSETPIXELV = tagEMRSETPIXELV;
pub type PEMRSETPIXELV = *mut tagEMRSETPIXELV;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREXTFLOODFILL {
  pub emr: EMR,
  pub ptlStart: POINTL,
  pub crColor: COLORREF,
  pub iMode: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMREXTFLOODFILL() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXTFLOODFILL>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMREXTFLOODFILL))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXTFLOODFILL>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXTFLOODFILL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTFLOODFILL>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTFLOODFILL),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTFLOODFILL>())).ptlStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTFLOODFILL),
      "::",
      stringify!(ptlStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTFLOODFILL>())).crColor as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTFLOODFILL),
      "::",
      stringify!(crColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTFLOODFILL>())).iMode as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTFLOODFILL),
      "::",
      stringify!(iMode)
    )
  );
}
pub type EMREXTFLOODFILL = tagEMREXTFLOODFILL;
pub type PEMREXTFLOODFILL = *mut tagEMREXTFLOODFILL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRELLIPSE {
  pub emr: EMR,
  pub rclBox: RECTL,
}
#[test]
fn bindgen_test_layout_tagEMRELLIPSE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRELLIPSE>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRELLIPSE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRELLIPSE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRELLIPSE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRELLIPSE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRELLIPSE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRELLIPSE>())).rclBox as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRELLIPSE),
      "::",
      stringify!(rclBox)
    )
  );
}
pub type EMRELLIPSE = tagEMRELLIPSE;
pub type PEMRELLIPSE = *mut tagEMRELLIPSE;
pub type EMRRECTANGLE = tagEMRELLIPSE;
pub type PEMRRECTANGLE = *mut tagEMRELLIPSE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRROUNDRECT {
  pub emr: EMR,
  pub rclBox: RECTL,
  pub szlCorner: SIZEL,
}
#[test]
fn bindgen_test_layout_tagEMRROUNDRECT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRROUNDRECT>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRROUNDRECT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRROUNDRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRROUNDRECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRROUNDRECT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRROUNDRECT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRROUNDRECT>())).rclBox as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRROUNDRECT),
      "::",
      stringify!(rclBox)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRROUNDRECT>())).szlCorner as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRROUNDRECT),
      "::",
      stringify!(szlCorner)
    )
  );
}
pub type EMRROUNDRECT = tagEMRROUNDRECT;
pub type PEMRROUNDRECT = *mut tagEMRROUNDRECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRARC {
  pub emr: EMR,
  pub rclBox: RECTL,
  pub ptlStart: POINTL,
  pub ptlEnd: POINTL,
}
#[test]
fn bindgen_test_layout_tagEMRARC() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRARC>(),
    40usize,
    concat!("Size of: ", stringify!(tagEMRARC))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRARC>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRARC))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRARC>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRARC),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRARC>())).rclBox as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRARC),
      "::",
      stringify!(rclBox)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRARC>())).ptlStart as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRARC),
      "::",
      stringify!(ptlStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRARC>())).ptlEnd as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRARC),
      "::",
      stringify!(ptlEnd)
    )
  );
}
pub type EMRARC = tagEMRARC;
pub type PEMRARC = *mut tagEMRARC;
pub type EMRARCTO = tagEMRARC;
pub type PEMRARCTO = *mut tagEMRARC;
pub type EMRCHORD = tagEMRARC;
pub type PEMRCHORD = *mut tagEMRARC;
pub type EMRPIE = tagEMRARC;
pub type PEMRPIE = *mut tagEMRARC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRANGLEARC {
  pub emr: EMR,
  pub ptlCenter: POINTL,
  pub nRadius: DWORD,
  pub eStartAngle: FLOAT,
  pub eSweepAngle: FLOAT,
}
#[test]
fn bindgen_test_layout_tagEMRANGLEARC() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRANGLEARC>(),
    28usize,
    concat!("Size of: ", stringify!(tagEMRANGLEARC))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRANGLEARC>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRANGLEARC))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRANGLEARC>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRANGLEARC),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRANGLEARC>())).ptlCenter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRANGLEARC),
      "::",
      stringify!(ptlCenter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRANGLEARC>())).nRadius as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRANGLEARC),
      "::",
      stringify!(nRadius)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRANGLEARC>())).eStartAngle as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRANGLEARC),
      "::",
      stringify!(eStartAngle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRANGLEARC>())).eSweepAngle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRANGLEARC),
      "::",
      stringify!(eSweepAngle)
    )
  );
}
pub type EMRANGLEARC = tagEMRANGLEARC;
pub type PEMRANGLEARC = *mut tagEMRANGLEARC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYLINE {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cptl: DWORD,
  pub aptl: [POINTL; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYLINE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYLINE>(),
    36usize,
    concat!("Size of: ", stringify!(tagEMRPOLYLINE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYLINE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYLINE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE>())).cptl as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE),
      "::",
      stringify!(cptl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE>())).aptl as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE),
      "::",
      stringify!(aptl)
    )
  );
}
pub type EMRPOLYLINE = tagEMRPOLYLINE;
pub type PEMRPOLYLINE = *mut tagEMRPOLYLINE;
pub type EMRPOLYBEZIER = tagEMRPOLYLINE;
pub type PEMRPOLYBEZIER = *mut tagEMRPOLYLINE;
pub type EMRPOLYGON = tagEMRPOLYLINE;
pub type PEMRPOLYGON = *mut tagEMRPOLYLINE;
pub type EMRPOLYBEZIERTO = tagEMRPOLYLINE;
pub type PEMRPOLYBEZIERTO = *mut tagEMRPOLYLINE;
pub type EMRPOLYLINETO = tagEMRPOLYLINE;
pub type PEMRPOLYLINETO = *mut tagEMRPOLYLINE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYLINE16 {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cpts: DWORD,
  pub apts: [POINTS; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYLINE16() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYLINE16>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRPOLYLINE16))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYLINE16>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYLINE16))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE16>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE16),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE16>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE16),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE16>())).cpts as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE16),
      "::",
      stringify!(cpts)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYLINE16>())).apts as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYLINE16),
      "::",
      stringify!(apts)
    )
  );
}
pub type EMRPOLYLINE16 = tagEMRPOLYLINE16;
pub type PEMRPOLYLINE16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYBEZIER16 = tagEMRPOLYLINE16;
pub type PEMRPOLYBEZIER16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYGON16 = tagEMRPOLYLINE16;
pub type PEMRPOLYGON16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYBEZIERTO16 = tagEMRPOLYLINE16;
pub type PEMRPOLYBEZIERTO16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYLINETO16 = tagEMRPOLYLINE16;
pub type PEMRPOLYLINETO16 = *mut tagEMRPOLYLINE16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYDRAW {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cptl: DWORD,
  pub aptl: [POINTL; 1usize],
  pub abTypes: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYDRAW() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYDRAW>(),
    40usize,
    concat!("Size of: ", stringify!(tagEMRPOLYDRAW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYDRAW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYDRAW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW>())).cptl as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW),
      "::",
      stringify!(cptl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW>())).aptl as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW),
      "::",
      stringify!(aptl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW>())).abTypes as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW),
      "::",
      stringify!(abTypes)
    )
  );
}
pub type EMRPOLYDRAW = tagEMRPOLYDRAW;
pub type PEMRPOLYDRAW = *mut tagEMRPOLYDRAW;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYDRAW16 {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cpts: DWORD,
  pub apts: [POINTS; 1usize],
  pub abTypes: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYDRAW16() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYDRAW16>(),
    36usize,
    concat!("Size of: ", stringify!(tagEMRPOLYDRAW16))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYDRAW16>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYDRAW16))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW16>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW16),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW16>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW16),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW16>())).cpts as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW16),
      "::",
      stringify!(cpts)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW16>())).apts as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW16),
      "::",
      stringify!(apts)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYDRAW16>())).abTypes as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYDRAW16),
      "::",
      stringify!(abTypes)
    )
  );
}
pub type EMRPOLYDRAW16 = tagEMRPOLYDRAW16;
pub type PEMRPOLYDRAW16 = *mut tagEMRPOLYDRAW16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYPOLYLINE {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub nPolys: DWORD,
  pub cptl: DWORD,
  pub aPolyCounts: [DWORD; 1usize],
  pub aptl: [POINTL; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYPOLYLINE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYPOLYLINE>(),
    44usize,
    concat!("Size of: ", stringify!(tagEMRPOLYPOLYLINE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYPOLYLINE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYPOLYLINE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE>())).nPolys as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE),
      "::",
      stringify!(nPolys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE>())).cptl as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE),
      "::",
      stringify!(cptl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE>())).aPolyCounts as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE),
      "::",
      stringify!(aPolyCounts)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE>())).aptl as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE),
      "::",
      stringify!(aptl)
    )
  );
}
pub type EMRPOLYPOLYLINE = tagEMRPOLYPOLYLINE;
pub type PEMRPOLYPOLYLINE = *mut tagEMRPOLYPOLYLINE;
pub type EMRPOLYPOLYGON = tagEMRPOLYPOLYLINE;
pub type PEMRPOLYPOLYGON = *mut tagEMRPOLYPOLYLINE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYPOLYLINE16 {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub nPolys: DWORD,
  pub cpts: DWORD,
  pub aPolyCounts: [DWORD; 1usize],
  pub apts: [POINTS; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYPOLYLINE16() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYPOLYLINE16>(),
    40usize,
    concat!("Size of: ", stringify!(tagEMRPOLYPOLYLINE16))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYPOLYLINE16>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYPOLYLINE16))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE16>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE16),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE16>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE16),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE16>())).nPolys as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE16),
      "::",
      stringify!(nPolys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE16>())).cpts as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE16),
      "::",
      stringify!(cpts)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE16>())).aPolyCounts as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE16),
      "::",
      stringify!(aPolyCounts)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYPOLYLINE16>())).apts as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYPOLYLINE16),
      "::",
      stringify!(apts)
    )
  );
}
pub type EMRPOLYPOLYLINE16 = tagEMRPOLYPOLYLINE16;
pub type PEMRPOLYPOLYLINE16 = *mut tagEMRPOLYPOLYLINE16;
pub type EMRPOLYPOLYGON16 = tagEMRPOLYPOLYLINE16;
pub type PEMRPOLYPOLYGON16 = *mut tagEMRPOLYPOLYLINE16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRINVERTRGN {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cbRgnData: DWORD,
  pub RgnData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRINVERTRGN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRINVERTRGN>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRINVERTRGN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRINVERTRGN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRINVERTRGN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRINVERTRGN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRINVERTRGN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRINVERTRGN>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRINVERTRGN),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRINVERTRGN>())).cbRgnData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRINVERTRGN),
      "::",
      stringify!(cbRgnData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRINVERTRGN>())).RgnData as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRINVERTRGN),
      "::",
      stringify!(RgnData)
    )
  );
}
pub type EMRINVERTRGN = tagEMRINVERTRGN;
pub type PEMRINVERTRGN = *mut tagEMRINVERTRGN;
pub type EMRPAINTRGN = tagEMRINVERTRGN;
pub type PEMRPAINTRGN = *mut tagEMRINVERTRGN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRFILLRGN {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cbRgnData: DWORD,
  pub ihBrush: DWORD,
  pub RgnData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRFILLRGN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRFILLRGN>(),
    36usize,
    concat!("Size of: ", stringify!(tagEMRFILLRGN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRFILLRGN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRFILLRGN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLRGN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLRGN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLRGN>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLRGN),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLRGN>())).cbRgnData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLRGN),
      "::",
      stringify!(cbRgnData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLRGN>())).ihBrush as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLRGN),
      "::",
      stringify!(ihBrush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFILLRGN>())).RgnData as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFILLRGN),
      "::",
      stringify!(RgnData)
    )
  );
}
pub type EMRFILLRGN = tagEMRFILLRGN;
pub type PEMRFILLRGN = *mut tagEMRFILLRGN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRFRAMERGN {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cbRgnData: DWORD,
  pub ihBrush: DWORD,
  pub szlStroke: SIZEL,
  pub RgnData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRFRAMERGN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRFRAMERGN>(),
    44usize,
    concat!("Size of: ", stringify!(tagEMRFRAMERGN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRFRAMERGN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRFRAMERGN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFRAMERGN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFRAMERGN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFRAMERGN>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFRAMERGN),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFRAMERGN>())).cbRgnData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFRAMERGN),
      "::",
      stringify!(cbRgnData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFRAMERGN>())).ihBrush as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFRAMERGN),
      "::",
      stringify!(ihBrush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFRAMERGN>())).szlStroke as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFRAMERGN),
      "::",
      stringify!(szlStroke)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFRAMERGN>())).RgnData as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFRAMERGN),
      "::",
      stringify!(RgnData)
    )
  );
}
pub type EMRFRAMERGN = tagEMRFRAMERGN;
pub type PEMRFRAMERGN = *mut tagEMRFRAMERGN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREXTSELECTCLIPRGN {
  pub emr: EMR,
  pub cbRgnData: DWORD,
  pub iMode: DWORD,
  pub RgnData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMREXTSELECTCLIPRGN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXTSELECTCLIPRGN>(),
    20usize,
    concat!("Size of: ", stringify!(tagEMREXTSELECTCLIPRGN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXTSELECTCLIPRGN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXTSELECTCLIPRGN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTSELECTCLIPRGN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTSELECTCLIPRGN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTSELECTCLIPRGN>())).cbRgnData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTSELECTCLIPRGN),
      "::",
      stringify!(cbRgnData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTSELECTCLIPRGN>())).iMode as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTSELECTCLIPRGN),
      "::",
      stringify!(iMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTSELECTCLIPRGN>())).RgnData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTSELECTCLIPRGN),
      "::",
      stringify!(RgnData)
    )
  );
}
pub type EMREXTSELECTCLIPRGN = tagEMREXTSELECTCLIPRGN;
pub type PEMREXTSELECTCLIPRGN = *mut tagEMREXTSELECTCLIPRGN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREXTTEXTOUTA {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub iGraphicsMode: DWORD,
  pub exScale: FLOAT,
  pub eyScale: FLOAT,
  pub emrtext: EMRTEXT,
}
#[test]
fn bindgen_test_layout_tagEMREXTTEXTOUTA() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXTTEXTOUTA>(),
    76usize,
    concat!("Size of: ", stringify!(tagEMREXTTEXTOUTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXTTEXTOUTA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXTTEXTOUTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTTEXTOUTA>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTTEXTOUTA),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTTEXTOUTA>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTTEXTOUTA),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTTEXTOUTA>())).iGraphicsMode as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTTEXTOUTA),
      "::",
      stringify!(iGraphicsMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTTEXTOUTA>())).exScale as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTTEXTOUTA),
      "::",
      stringify!(exScale)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTTEXTOUTA>())).eyScale as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTTEXTOUTA),
      "::",
      stringify!(eyScale)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTTEXTOUTA>())).emrtext as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTTEXTOUTA),
      "::",
      stringify!(emrtext)
    )
  );
}
pub type EMREXTTEXTOUTA = tagEMREXTTEXTOUTA;
pub type PEMREXTTEXTOUTA = *mut tagEMREXTTEXTOUTA;
pub type EMREXTTEXTOUTW = tagEMREXTTEXTOUTA;
pub type PEMREXTTEXTOUTW = *mut tagEMREXTTEXTOUTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPOLYTEXTOUTA {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub iGraphicsMode: DWORD,
  pub exScale: FLOAT,
  pub eyScale: FLOAT,
  pub cStrings: LONG,
  pub aemrtext: [EMRTEXT; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRPOLYTEXTOUTA() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPOLYTEXTOUTA>(),
    80usize,
    concat!("Size of: ", stringify!(tagEMRPOLYTEXTOUTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPOLYTEXTOUTA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPOLYTEXTOUTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).iGraphicsMode as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(iGraphicsMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).exScale as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(exScale)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).eyScale as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(eyScale)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).cStrings as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(cStrings)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPOLYTEXTOUTA>())).aemrtext as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPOLYTEXTOUTA),
      "::",
      stringify!(aemrtext)
    )
  );
}
pub type EMRPOLYTEXTOUTA = tagEMRPOLYTEXTOUTA;
pub type PEMRPOLYTEXTOUTA = *mut tagEMRPOLYTEXTOUTA;
pub type EMRPOLYTEXTOUTW = tagEMRPOLYTEXTOUTA;
pub type PEMRPOLYTEXTOUTW = *mut tagEMRPOLYTEXTOUTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRBITBLT {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub cxDest: LONG,
  pub cyDest: LONG,
  pub dwRop: DWORD,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub xformSrc: XFORM,
  pub crBkColorSrc: COLORREF,
  pub iUsageSrc: DWORD,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRBITBLT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRBITBLT>(),
    100usize,
    concat!("Size of: ", stringify!(tagEMRBITBLT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRBITBLT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRBITBLT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).cxDest as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(cxDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).cyDest as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(cyDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).dwRop as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(dwRop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).xSrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).ySrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).xformSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(xformSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).crBkColorSrc as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(crBkColorSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).iUsageSrc as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).offBmiSrc as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).cbBmiSrc as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).offBitsSrc as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRBITBLT>())).cbBitsSrc as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRBITBLT),
      "::",
      stringify!(cbBitsSrc)
    )
  );
}
pub type EMRBITBLT = tagEMRBITBLT;
pub type PEMRBITBLT = *mut tagEMRBITBLT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSTRETCHBLT {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub cxDest: LONG,
  pub cyDest: LONG,
  pub dwRop: DWORD,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub xformSrc: XFORM,
  pub crBkColorSrc: COLORREF,
  pub iUsageSrc: DWORD,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub cxSrc: LONG,
  pub cySrc: LONG,
}
#[test]
fn bindgen_test_layout_tagEMRSTRETCHBLT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSTRETCHBLT>(),
    108usize,
    concat!("Size of: ", stringify!(tagEMRSTRETCHBLT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSTRETCHBLT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSTRETCHBLT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).cxDest as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(cxDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).cyDest as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(cyDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).dwRop as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(dwRop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).xSrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).ySrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).xformSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(xformSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).crBkColorSrc as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(crBkColorSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).iUsageSrc as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).offBmiSrc as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).cbBmiSrc as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).offBitsSrc as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).cbBitsSrc as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).cxSrc as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(cxSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHBLT>())).cySrc as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHBLT),
      "::",
      stringify!(cySrc)
    )
  );
}
pub type EMRSTRETCHBLT = tagEMRSTRETCHBLT;
pub type PEMRSTRETCHBLT = *mut tagEMRSTRETCHBLT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRMASKBLT {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub cxDest: LONG,
  pub cyDest: LONG,
  pub dwRop: DWORD,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub xformSrc: XFORM,
  pub crBkColorSrc: COLORREF,
  pub iUsageSrc: DWORD,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub xMask: LONG,
  pub yMask: LONG,
  pub iUsageMask: DWORD,
  pub offBmiMask: DWORD,
  pub cbBmiMask: DWORD,
  pub offBitsMask: DWORD,
  pub cbBitsMask: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRMASKBLT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRMASKBLT>(),
    128usize,
    concat!("Size of: ", stringify!(tagEMRMASKBLT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRMASKBLT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRMASKBLT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).cxDest as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(cxDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).cyDest as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(cyDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).dwRop as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(dwRop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).xSrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).ySrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).xformSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(xformSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).crBkColorSrc as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(crBkColorSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).iUsageSrc as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).offBmiSrc as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).cbBmiSrc as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).offBitsSrc as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).cbBitsSrc as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).xMask as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(xMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).yMask as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(yMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).iUsageMask as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(iUsageMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).offBmiMask as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(offBmiMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).cbBmiMask as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(cbBmiMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).offBitsMask as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(offBitsMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRMASKBLT>())).cbBitsMask as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRMASKBLT),
      "::",
      stringify!(cbBitsMask)
    )
  );
}
pub type EMRMASKBLT = tagEMRMASKBLT;
pub type PEMRMASKBLT = *mut tagEMRMASKBLT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPLGBLT {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub aptlDest: [POINTL; 3usize],
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub cxSrc: LONG,
  pub cySrc: LONG,
  pub xformSrc: XFORM,
  pub crBkColorSrc: COLORREF,
  pub iUsageSrc: DWORD,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub xMask: LONG,
  pub yMask: LONG,
  pub iUsageMask: DWORD,
  pub offBmiMask: DWORD,
  pub cbBmiMask: DWORD,
  pub offBitsMask: DWORD,
  pub cbBitsMask: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRPLGBLT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPLGBLT>(),
    140usize,
    concat!("Size of: ", stringify!(tagEMRPLGBLT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPLGBLT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPLGBLT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).aptlDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(aptlDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).xSrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).ySrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).cxSrc as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(cxSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).cySrc as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(cySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).xformSrc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(xformSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).crBkColorSrc as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(crBkColorSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).iUsageSrc as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).offBmiSrc as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).cbBmiSrc as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).offBitsSrc as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).cbBitsSrc as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).xMask as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(xMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).yMask as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(yMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).iUsageMask as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(iUsageMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).offBmiMask as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(offBmiMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).cbBmiMask as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(cbBmiMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).offBitsMask as *const _ as usize },
    132usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(offBitsMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPLGBLT>())).cbBitsMask as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPLGBLT),
      "::",
      stringify!(cbBitsMask)
    )
  );
}
pub type EMRPLGBLT = tagEMRPLGBLT;
pub type PEMRPLGBLT = *mut tagEMRPLGBLT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETDIBITSTODEVICE {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub cxSrc: LONG,
  pub cySrc: LONG,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub iUsageSrc: DWORD,
  pub iStartScan: DWORD,
  pub cScans: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSETDIBITSTODEVICE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETDIBITSTODEVICE>(),
    76usize,
    concat!("Size of: ", stringify!(tagEMRSETDIBITSTODEVICE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETDIBITSTODEVICE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETDIBITSTODEVICE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).xSrc as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).ySrc as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).cxSrc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(cxSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).cySrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(cySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).offBmiSrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).cbBmiSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).offBitsSrc as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).cbBitsSrc as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).iUsageSrc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).iStartScan as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(iStartScan)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETDIBITSTODEVICE>())).cScans as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETDIBITSTODEVICE),
      "::",
      stringify!(cScans)
    )
  );
}
pub type EMRSETDIBITSTODEVICE = tagEMRSETDIBITSTODEVICE;
pub type PEMRSETDIBITSTODEVICE = *mut tagEMRSETDIBITSTODEVICE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSTRETCHDIBITS {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub cxSrc: LONG,
  pub cySrc: LONG,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub iUsageSrc: DWORD,
  pub dwRop: DWORD,
  pub cxDest: LONG,
  pub cyDest: LONG,
}
#[test]
fn bindgen_test_layout_tagEMRSTRETCHDIBITS() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSTRETCHDIBITS>(),
    80usize,
    concat!("Size of: ", stringify!(tagEMRSTRETCHDIBITS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSTRETCHDIBITS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSTRETCHDIBITS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).xSrc as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).ySrc as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).cxSrc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(cxSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).cySrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(cySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).offBmiSrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).cbBmiSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).offBitsSrc as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).cbBitsSrc as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).iUsageSrc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).dwRop as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(dwRop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).cxDest as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(cxDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSTRETCHDIBITS>())).cyDest as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSTRETCHDIBITS),
      "::",
      stringify!(cyDest)
    )
  );
}
pub type EMRSTRETCHDIBITS = tagEMRSTRETCHDIBITS;
pub type PEMRSTRETCHDIBITS = *mut tagEMRSTRETCHDIBITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagEMREXTCREATEFONTINDIRECTW {
  pub emr: EMR,
  pub ihFont: DWORD,
  pub elfw: EXTLOGFONTW,
}
#[test]
fn bindgen_test_layout_tagEMREXTCREATEFONTINDIRECTW() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXTCREATEFONTINDIRECTW>(),
    332usize,
    concat!("Size of: ", stringify!(tagEMREXTCREATEFONTINDIRECTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXTCREATEFONTINDIRECTW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXTCREATEFONTINDIRECTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEFONTINDIRECTW>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEFONTINDIRECTW),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMREXTCREATEFONTINDIRECTW>())).ihFont as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEFONTINDIRECTW),
      "::",
      stringify!(ihFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEFONTINDIRECTW>())).elfw as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEFONTINDIRECTW),
      "::",
      stringify!(elfw)
    )
  );
}
impl Default for tagEMREXTCREATEFONTINDIRECTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagEMREXTCREATEFONTINDIRECTW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagEMREXTCREATEFONTINDIRECTW {{ emr: {:?}, ihFont: {:?}, elfw: {:?} }}",
      self.emr, self.ihFont, self.elfw
    )
  }
}
impl ::core::cmp::PartialEq for tagEMREXTCREATEFONTINDIRECTW {
  fn eq(&self, other: &tagEMREXTCREATEFONTINDIRECTW) -> bool {
    self.emr == other.emr && self.ihFont == other.ihFont && self.elfw == other.elfw
  }
}
pub type EMREXTCREATEFONTINDIRECTW = tagEMREXTCREATEFONTINDIRECTW;
pub type PEMREXTCREATEFONTINDIRECTW = *mut tagEMREXTCREATEFONTINDIRECTW;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRCREATEPALETTE {
  pub emr: EMR,
  pub ihPal: DWORD,
  pub lgpl: LOGPALETTE,
}
#[test]
fn bindgen_test_layout_tagEMRCREATEPALETTE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATEPALETTE>(),
    20usize,
    concat!("Size of: ", stringify!(tagEMRCREATEPALETTE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATEPALETTE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATEPALETTE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEPALETTE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEPALETTE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEPALETTE>())).ihPal as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEPALETTE),
      "::",
      stringify!(ihPal)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEPALETTE>())).lgpl as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEPALETTE),
      "::",
      stringify!(lgpl)
    )
  );
}
pub type EMRCREATEPALETTE = tagEMRCREATEPALETTE;
pub type PEMRCREATEPALETTE = *mut tagEMRCREATEPALETTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRCREATEPEN {
  pub emr: EMR,
  pub ihPen: DWORD,
  pub lopn: LOGPEN,
}
#[test]
fn bindgen_test_layout_tagEMRCREATEPEN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATEPEN>(),
    28usize,
    concat!("Size of: ", stringify!(tagEMRCREATEPEN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATEPEN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATEPEN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEPEN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEPEN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEPEN>())).ihPen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEPEN),
      "::",
      stringify!(ihPen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEPEN>())).lopn as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEPEN),
      "::",
      stringify!(lopn)
    )
  );
}
pub type EMRCREATEPEN = tagEMRCREATEPEN;
pub type PEMRCREATEPEN = *mut tagEMRCREATEPEN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREXTCREATEPEN {
  pub emr: EMR,
  pub ihPen: DWORD,
  pub offBmi: DWORD,
  pub cbBmi: DWORD,
  pub offBits: DWORD,
  pub cbBits: DWORD,
  pub elp: EXTLOGPEN32,
}
#[test]
fn bindgen_test_layout_tagEMREXTCREATEPEN() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXTCREATEPEN>(),
    56usize,
    concat!("Size of: ", stringify!(tagEMREXTCREATEPEN))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXTCREATEPEN>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXTCREATEPEN))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).ihPen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(ihPen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).offBmi as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(offBmi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).cbBmi as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(cbBmi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).offBits as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(offBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).cbBits as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(cbBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTCREATEPEN>())).elp as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTCREATEPEN),
      "::",
      stringify!(elp)
    )
  );
}
pub type EMREXTCREATEPEN = tagEMREXTCREATEPEN;
pub type PEMREXTCREATEPEN = *mut tagEMREXTCREATEPEN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRCREATEBRUSHINDIRECT {
  pub emr: EMR,
  pub ihBrush: DWORD,
  pub lb: LOGBRUSH32,
}
#[test]
fn bindgen_test_layout_tagEMRCREATEBRUSHINDIRECT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATEBRUSHINDIRECT>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRCREATEBRUSHINDIRECT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATEBRUSHINDIRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATEBRUSHINDIRECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEBRUSHINDIRECT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEBRUSHINDIRECT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEBRUSHINDIRECT>())).ihBrush as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEBRUSHINDIRECT),
      "::",
      stringify!(ihBrush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEBRUSHINDIRECT>())).lb as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEBRUSHINDIRECT),
      "::",
      stringify!(lb)
    )
  );
}
pub type EMRCREATEBRUSHINDIRECT = tagEMRCREATEBRUSHINDIRECT;
pub type PEMRCREATEBRUSHINDIRECT = *mut tagEMRCREATEBRUSHINDIRECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRCREATEMONOBRUSH {
  pub emr: EMR,
  pub ihBrush: DWORD,
  pub iUsage: DWORD,
  pub offBmi: DWORD,
  pub cbBmi: DWORD,
  pub offBits: DWORD,
  pub cbBits: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRCREATEMONOBRUSH() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATEMONOBRUSH>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRCREATEMONOBRUSH))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATEMONOBRUSH>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATEMONOBRUSH))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).ihBrush as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(ihBrush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).iUsage as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(iUsage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).offBmi as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(offBmi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).cbBmi as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(cbBmi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).offBits as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(offBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEMONOBRUSH>())).cbBits as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEMONOBRUSH),
      "::",
      stringify!(cbBits)
    )
  );
}
pub type EMRCREATEMONOBRUSH = tagEMRCREATEMONOBRUSH;
pub type PEMRCREATEMONOBRUSH = *mut tagEMRCREATEMONOBRUSH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRCREATEDIBPATTERNBRUSHPT {
  pub emr: EMR,
  pub ihBrush: DWORD,
  pub iUsage: DWORD,
  pub offBmi: DWORD,
  pub cbBmi: DWORD,
  pub offBits: DWORD,
  pub cbBits: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRCREATEDIBPATTERNBRUSHPT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATEDIBPATTERNBRUSHPT>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRCREATEDIBPATTERNBRUSHPT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATEDIBPATTERNBRUSHPT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATEDIBPATTERNBRUSHPT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).ihBrush as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(ihBrush)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).iUsage as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(iUsage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).offBmi as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(offBmi)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).cbBmi as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(cbBmi)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).offBits as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(offBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagEMRCREATEDIBPATTERNBRUSHPT>())).cbBits as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATEDIBPATTERNBRUSHPT),
      "::",
      stringify!(cbBits)
    )
  );
}
pub type EMRCREATEDIBPATTERNBRUSHPT = tagEMRCREATEDIBPATTERNBRUSHPT;
pub type PEMRCREATEDIBPATTERNBRUSHPT = *mut tagEMRCREATEDIBPATTERNBRUSHPT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRFORMAT {
  pub dSignature: DWORD,
  pub nVersion: DWORD,
  pub cbData: DWORD,
  pub offData: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRFORMAT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRFORMAT>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRFORMAT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRFORMAT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRFORMAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFORMAT>())).dSignature as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFORMAT),
      "::",
      stringify!(dSignature)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFORMAT>())).nVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFORMAT),
      "::",
      stringify!(nVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFORMAT>())).cbData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFORMAT),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRFORMAT>())).offData as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRFORMAT),
      "::",
      stringify!(offData)
    )
  );
}
pub type EMRFORMAT = tagEMRFORMAT;
pub type PEMRFORMAT = *mut tagEMRFORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRGLSRECORD {
  pub emr: EMR,
  pub cbData: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRGLSRECORD() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRGLSRECORD>(),
    16usize,
    concat!("Size of: ", stringify!(tagEMRGLSRECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRGLSRECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRGLSRECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSRECORD>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSRECORD),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSRECORD>())).cbData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSRECORD),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSRECORD>())).Data as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSRECORD),
      "::",
      stringify!(Data)
    )
  );
}
pub type EMRGLSRECORD = tagEMRGLSRECORD;
pub type PEMRGLSRECORD = *mut tagEMRGLSRECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRGLSBOUNDEDRECORD {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub cbData: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRGLSBOUNDEDRECORD() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRGLSBOUNDEDRECORD>(),
    32usize,
    concat!("Size of: ", stringify!(tagEMRGLSBOUNDEDRECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRGLSBOUNDEDRECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRGLSBOUNDEDRECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSBOUNDEDRECORD>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSBOUNDEDRECORD),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSBOUNDEDRECORD>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSBOUNDEDRECORD),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSBOUNDEDRECORD>())).cbData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSBOUNDEDRECORD),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGLSBOUNDEDRECORD>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGLSBOUNDEDRECORD),
      "::",
      stringify!(Data)
    )
  );
}
pub type EMRGLSBOUNDEDRECORD = tagEMRGLSBOUNDEDRECORD;
pub type PEMRGLSBOUNDEDRECORD = *mut tagEMRGLSBOUNDEDRECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRPIXELFORMAT {
  pub emr: EMR,
  pub pfd: PIXELFORMATDESCRIPTOR,
}
#[test]
fn bindgen_test_layout_tagEMRPIXELFORMAT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRPIXELFORMAT>(),
    48usize,
    concat!("Size of: ", stringify!(tagEMRPIXELFORMAT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRPIXELFORMAT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRPIXELFORMAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPIXELFORMAT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPIXELFORMAT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRPIXELFORMAT>())).pfd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRPIXELFORMAT),
      "::",
      stringify!(pfd)
    )
  );
}
pub type EMRPIXELFORMAT = tagEMRPIXELFORMAT;
pub type PEMRPIXELFORMAT = *mut tagEMRPIXELFORMAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagEMRCREATECOLORSPACE {
  pub emr: EMR,
  pub ihCS: DWORD,
  pub lcs: LOGCOLORSPACEA,
}
#[test]
fn bindgen_test_layout_tagEMRCREATECOLORSPACE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATECOLORSPACE>(),
    340usize,
    concat!("Size of: ", stringify!(tagEMRCREATECOLORSPACE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATECOLORSPACE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATECOLORSPACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACE>())).ihCS as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACE),
      "::",
      stringify!(ihCS)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACE>())).lcs as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACE),
      "::",
      stringify!(lcs)
    )
  );
}
impl Default for tagEMRCREATECOLORSPACE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagEMRCREATECOLORSPACE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagEMRCREATECOLORSPACE {{ emr: {:?}, ihCS: {:?}, lcs: {:?} }}",
      self.emr, self.ihCS, self.lcs
    )
  }
}
impl ::core::cmp::PartialEq for tagEMRCREATECOLORSPACE {
  fn eq(&self, other: &tagEMRCREATECOLORSPACE) -> bool {
    self.emr == other.emr && self.ihCS == other.ihCS && self.lcs == other.lcs
  }
}
pub type EMRCREATECOLORSPACE = tagEMRCREATECOLORSPACE;
pub type PEMRCREATECOLORSPACE = *mut tagEMRCREATECOLORSPACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETCOLORSPACE {
  pub emr: EMR,
  pub ihCS: DWORD,
}
#[test]
fn bindgen_test_layout_tagEMRSETCOLORSPACE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETCOLORSPACE>(),
    12usize,
    concat!("Size of: ", stringify!(tagEMRSETCOLORSPACE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETCOLORSPACE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETCOLORSPACE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETCOLORSPACE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETCOLORSPACE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETCOLORSPACE>())).ihCS as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETCOLORSPACE),
      "::",
      stringify!(ihCS)
    )
  );
}
pub type EMRSETCOLORSPACE = tagEMRSETCOLORSPACE;
pub type PEMRSETCOLORSPACE = *mut tagEMRSETCOLORSPACE;
pub type EMRSELECTCOLORSPACE = tagEMRSETCOLORSPACE;
pub type PEMRSELECTCOLORSPACE = *mut tagEMRSETCOLORSPACE;
pub type EMRDELETECOLORSPACE = tagEMRSETCOLORSPACE;
pub type PEMRDELETECOLORSPACE = *mut tagEMRSETCOLORSPACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMREXTESCAPE {
  pub emr: EMR,
  pub iEscape: INT,
  pub cbEscData: INT,
  pub EscData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMREXTESCAPE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMREXTESCAPE>(),
    20usize,
    concat!("Size of: ", stringify!(tagEMREXTESCAPE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMREXTESCAPE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMREXTESCAPE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTESCAPE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTESCAPE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTESCAPE>())).iEscape as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTESCAPE),
      "::",
      stringify!(iEscape)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTESCAPE>())).cbEscData as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTESCAPE),
      "::",
      stringify!(cbEscData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMREXTESCAPE>())).EscData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMREXTESCAPE),
      "::",
      stringify!(EscData)
    )
  );
}
pub type EMREXTESCAPE = tagEMREXTESCAPE;
pub type PEMREXTESCAPE = *mut tagEMREXTESCAPE;
pub type EMRDRAWESCAPE = tagEMREXTESCAPE;
pub type PEMRDRAWESCAPE = *mut tagEMREXTESCAPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRNAMEDESCAPE {
  pub emr: EMR,
  pub iEscape: INT,
  pub cbDriver: INT,
  pub cbEscData: INT,
  pub EscData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRNAMEDESCAPE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRNAMEDESCAPE>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRNAMEDESCAPE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRNAMEDESCAPE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRNAMEDESCAPE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRNAMEDESCAPE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRNAMEDESCAPE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRNAMEDESCAPE>())).iEscape as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRNAMEDESCAPE),
      "::",
      stringify!(iEscape)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRNAMEDESCAPE>())).cbDriver as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRNAMEDESCAPE),
      "::",
      stringify!(cbDriver)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRNAMEDESCAPE>())).cbEscData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRNAMEDESCAPE),
      "::",
      stringify!(cbEscData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRNAMEDESCAPE>())).EscData as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRNAMEDESCAPE),
      "::",
      stringify!(EscData)
    )
  );
}
pub type EMRNAMEDESCAPE = tagEMRNAMEDESCAPE;
pub type PEMRNAMEDESCAPE = *mut tagEMRNAMEDESCAPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRSETICMPROFILE {
  pub emr: EMR,
  pub dwFlags: DWORD,
  pub cbName: DWORD,
  pub cbData: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRSETICMPROFILE() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRSETICMPROFILE>(),
    24usize,
    concat!("Size of: ", stringify!(tagEMRSETICMPROFILE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRSETICMPROFILE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRSETICMPROFILE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETICMPROFILE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETICMPROFILE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETICMPROFILE>())).dwFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETICMPROFILE),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETICMPROFILE>())).cbName as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETICMPROFILE),
      "::",
      stringify!(cbName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETICMPROFILE>())).cbData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETICMPROFILE),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRSETICMPROFILE>())).Data as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRSETICMPROFILE),
      "::",
      stringify!(Data)
    )
  );
}
pub type EMRSETICMPROFILE = tagEMRSETICMPROFILE;
pub type PEMRSETICMPROFILE = *mut tagEMRSETICMPROFILE;
pub type EMRSETICMPROFILEA = tagEMRSETICMPROFILE;
pub type PEMRSETICMPROFILEA = *mut tagEMRSETICMPROFILE;
pub type EMRSETICMPROFILEW = tagEMRSETICMPROFILE;
pub type PEMRSETICMPROFILEW = *mut tagEMRSETICMPROFILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagEMRCREATECOLORSPACEW {
  pub emr: EMR,
  pub ihCS: DWORD,
  pub lcs: LOGCOLORSPACEW,
  pub dwFlags: DWORD,
  pub cbData: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRCREATECOLORSPACEW() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRCREATECOLORSPACEW>(),
    612usize,
    concat!("Size of: ", stringify!(tagEMRCREATECOLORSPACEW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRCREATECOLORSPACEW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRCREATECOLORSPACEW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACEW>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACEW),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACEW>())).ihCS as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACEW),
      "::",
      stringify!(ihCS)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACEW>())).lcs as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACEW),
      "::",
      stringify!(lcs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACEW>())).dwFlags as *const _ as usize },
    600usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACEW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACEW>())).cbData as *const _ as usize },
    604usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACEW),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRCREATECOLORSPACEW>())).Data as *const _ as usize },
    608usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRCREATECOLORSPACEW),
      "::",
      stringify!(Data)
    )
  );
}
impl Default for tagEMRCREATECOLORSPACEW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagEMRCREATECOLORSPACEW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagEMRCREATECOLORSPACEW {{ emr: {:?}, ihCS: {:?}, lcs: {:?}, dwFlags: {:?}, cbData: {:?}, Data: {:?} }}" , self . emr , self . ihCS , self . lcs , self . dwFlags , self . cbData , self . Data )
  }
}
impl ::core::cmp::PartialEq for tagEMRCREATECOLORSPACEW {
  fn eq(&self, other: &tagEMRCREATECOLORSPACEW) -> bool {
    self.emr == other.emr
      && self.ihCS == other.ihCS
      && self.lcs == other.lcs
      && self.dwFlags == other.dwFlags
      && self.cbData == other.cbData
      && self.Data == other.Data
  }
}
pub type EMRCREATECOLORSPACEW = tagEMRCREATECOLORSPACEW;
pub type PEMRCREATECOLORSPACEW = *mut tagEMRCREATECOLORSPACEW;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCOLORMATCHTOTARGET {
  pub emr: EMR,
  pub dwAction: DWORD,
  pub dwFlags: DWORD,
  pub cbName: DWORD,
  pub cbData: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagCOLORMATCHTOTARGET() {
  assert_eq!(
    ::core::mem::size_of::<tagCOLORMATCHTOTARGET>(),
    28usize,
    concat!("Size of: ", stringify!(tagCOLORMATCHTOTARGET))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOLORMATCHTOTARGET>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCOLORMATCHTOTARGET))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORMATCHTOTARGET>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORMATCHTOTARGET),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORMATCHTOTARGET>())).dwAction as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORMATCHTOTARGET),
      "::",
      stringify!(dwAction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORMATCHTOTARGET>())).dwFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORMATCHTOTARGET),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORMATCHTOTARGET>())).cbName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORMATCHTOTARGET),
      "::",
      stringify!(cbName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORMATCHTOTARGET>())).cbData as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORMATCHTOTARGET),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORMATCHTOTARGET>())).Data as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORMATCHTOTARGET),
      "::",
      stringify!(Data)
    )
  );
}
pub type EMRCOLORMATCHTOTARGET = tagCOLORMATCHTOTARGET;
pub type PEMRCOLORMATCHTOTARGET = *mut tagCOLORMATCHTOTARGET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCOLORCORRECTPALETTE {
  pub emr: EMR,
  pub ihPalette: DWORD,
  pub nFirstEntry: DWORD,
  pub nPalEntries: DWORD,
  pub nReserved: DWORD,
}
#[test]
fn bindgen_test_layout_tagCOLORCORRECTPALETTE() {
  assert_eq!(
    ::core::mem::size_of::<tagCOLORCORRECTPALETTE>(),
    24usize,
    concat!("Size of: ", stringify!(tagCOLORCORRECTPALETTE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOLORCORRECTPALETTE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCOLORCORRECTPALETTE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORCORRECTPALETTE>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORCORRECTPALETTE),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORCORRECTPALETTE>())).ihPalette as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORCORRECTPALETTE),
      "::",
      stringify!(ihPalette)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORCORRECTPALETTE>())).nFirstEntry as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORCORRECTPALETTE),
      "::",
      stringify!(nFirstEntry)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORCORRECTPALETTE>())).nPalEntries as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORCORRECTPALETTE),
      "::",
      stringify!(nPalEntries)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOLORCORRECTPALETTE>())).nReserved as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOLORCORRECTPALETTE),
      "::",
      stringify!(nReserved)
    )
  );
}
pub type EMRCOLORCORRECTPALETTE = tagCOLORCORRECTPALETTE;
pub type PEMRCOLORCORRECTPALETTE = *mut tagCOLORCORRECTPALETTE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRALPHABLEND {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub cxDest: LONG,
  pub cyDest: LONG,
  pub dwRop: DWORD,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub xformSrc: XFORM,
  pub crBkColorSrc: COLORREF,
  pub iUsageSrc: DWORD,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub cxSrc: LONG,
  pub cySrc: LONG,
}
#[test]
fn bindgen_test_layout_tagEMRALPHABLEND() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRALPHABLEND>(),
    108usize,
    concat!("Size of: ", stringify!(tagEMRALPHABLEND))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRALPHABLEND>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRALPHABLEND))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).cxDest as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(cxDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).cyDest as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(cyDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).dwRop as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(dwRop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).xSrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).ySrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).xformSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(xformSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).crBkColorSrc as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(crBkColorSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).iUsageSrc as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).offBmiSrc as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).cbBmiSrc as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).offBitsSrc as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).cbBitsSrc as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).cxSrc as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(cxSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRALPHABLEND>())).cySrc as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRALPHABLEND),
      "::",
      stringify!(cySrc)
    )
  );
}
pub type EMRALPHABLEND = tagEMRALPHABLEND;
pub type PEMRALPHABLEND = *mut tagEMRALPHABLEND;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRGRADIENTFILL {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub nVer: DWORD,
  pub nTri: DWORD,
  pub ulMode: ULONG,
  pub Ver: [TRIVERTEX; 1usize],
}
#[test]
fn bindgen_test_layout_tagEMRGRADIENTFILL() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRGRADIENTFILL>(),
    52usize,
    concat!("Size of: ", stringify!(tagEMRGRADIENTFILL))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRGRADIENTFILL>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRGRADIENTFILL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGRADIENTFILL>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGRADIENTFILL),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGRADIENTFILL>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGRADIENTFILL),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGRADIENTFILL>())).nVer as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGRADIENTFILL),
      "::",
      stringify!(nVer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGRADIENTFILL>())).nTri as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGRADIENTFILL),
      "::",
      stringify!(nTri)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGRADIENTFILL>())).ulMode as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGRADIENTFILL),
      "::",
      stringify!(ulMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRGRADIENTFILL>())).Ver as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRGRADIENTFILL),
      "::",
      stringify!(Ver)
    )
  );
}
pub type EMRGRADIENTFILL = tagEMRGRADIENTFILL;
pub type PEMRGRADIENTFILL = *mut tagEMRGRADIENTFILL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagEMRTRANSPARENTBLT {
  pub emr: EMR,
  pub rclBounds: RECTL,
  pub xDest: LONG,
  pub yDest: LONG,
  pub cxDest: LONG,
  pub cyDest: LONG,
  pub dwRop: DWORD,
  pub xSrc: LONG,
  pub ySrc: LONG,
  pub xformSrc: XFORM,
  pub crBkColorSrc: COLORREF,
  pub iUsageSrc: DWORD,
  pub offBmiSrc: DWORD,
  pub cbBmiSrc: DWORD,
  pub offBitsSrc: DWORD,
  pub cbBitsSrc: DWORD,
  pub cxSrc: LONG,
  pub cySrc: LONG,
}
#[test]
fn bindgen_test_layout_tagEMRTRANSPARENTBLT() {
  assert_eq!(
    ::core::mem::size_of::<tagEMRTRANSPARENTBLT>(),
    108usize,
    concat!("Size of: ", stringify!(tagEMRTRANSPARENTBLT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEMRTRANSPARENTBLT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagEMRTRANSPARENTBLT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).emr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(emr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).rclBounds as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(rclBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).xDest as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(xDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).yDest as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(yDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).cxDest as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(cxDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).cyDest as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(cyDest)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).dwRop as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(dwRop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).xSrc as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(xSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).ySrc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(ySrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).xformSrc as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(xformSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).crBkColorSrc as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(crBkColorSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).iUsageSrc as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(iUsageSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).offBmiSrc as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(offBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).cbBmiSrc as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(cbBmiSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).offBitsSrc as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(offBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).cbBitsSrc as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(cbBitsSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).cxSrc as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(cxSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEMRTRANSPARENTBLT>())).cySrc as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEMRTRANSPARENTBLT),
      "::",
      stringify!(cySrc)
    )
  );
}
pub type EMRTRANSPARENTBLT = tagEMRTRANSPARENTBLT;
pub type PEMRTRANSPARENTBLT = *mut tagEMRTRANSPARENTBLT;
extern "C" {
  pub fn wglCopyContext(arg1: HGLRC, arg2: HGLRC, arg3: UINT) -> BOOL;
}
extern "C" {
  pub fn wglCreateContext(arg1: HDC) -> HGLRC;
}
extern "C" {
  pub fn wglCreateLayerContext(arg1: HDC, arg2: libc::c_int) -> HGLRC;
}
extern "C" {
  pub fn wglDeleteContext(arg1: HGLRC) -> BOOL;
}
extern "C" {
  pub fn wglGetCurrentContext() -> HGLRC;
}
extern "C" {
  pub fn wglGetCurrentDC() -> HDC;
}
extern "C" {
  pub fn wglGetProcAddress(arg1: LPCSTR) -> PROC;
}
extern "C" {
  pub fn wglMakeCurrent(arg1: HDC, arg2: HGLRC) -> BOOL;
}
extern "C" {
  pub fn wglShareLists(arg1: HGLRC, arg2: HGLRC) -> BOOL;
}
extern "C" {
  pub fn wglUseFontBitmapsA(arg1: HDC, arg2: DWORD, arg3: DWORD, arg4: DWORD) -> BOOL;
}
extern "C" {
  pub fn wglUseFontBitmapsW(arg1: HDC, arg2: DWORD, arg3: DWORD, arg4: DWORD) -> BOOL;
}
extern "C" {
  pub fn SwapBuffers(arg1: HDC) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _POINTFLOAT {
  pub x: FLOAT,
  pub y: FLOAT,
}
#[test]
fn bindgen_test_layout__POINTFLOAT() {
  assert_eq!(
    ::core::mem::size_of::<_POINTFLOAT>(),
    8usize,
    concat!("Size of: ", stringify!(_POINTFLOAT))
  );
  assert_eq!(
    ::core::mem::align_of::<_POINTFLOAT>(),
    4usize,
    concat!("Alignment of ", stringify!(_POINTFLOAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POINTFLOAT>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_POINTFLOAT),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_POINTFLOAT>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_POINTFLOAT),
      "::",
      stringify!(y)
    )
  );
}
pub type POINTFLOAT = _POINTFLOAT;
pub type PPOINTFLOAT = *mut _POINTFLOAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _GLYPHMETRICSFLOAT {
  pub gmfBlackBoxX: FLOAT,
  pub gmfBlackBoxY: FLOAT,
  pub gmfptGlyphOrigin: POINTFLOAT,
  pub gmfCellIncX: FLOAT,
  pub gmfCellIncY: FLOAT,
}
#[test]
fn bindgen_test_layout__GLYPHMETRICSFLOAT() {
  assert_eq!(
    ::core::mem::size_of::<_GLYPHMETRICSFLOAT>(),
    24usize,
    concat!("Size of: ", stringify!(_GLYPHMETRICSFLOAT))
  );
  assert_eq!(
    ::core::mem::align_of::<_GLYPHMETRICSFLOAT>(),
    4usize,
    concat!("Alignment of ", stringify!(_GLYPHMETRICSFLOAT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICSFLOAT>())).gmfBlackBoxX as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICSFLOAT),
      "::",
      stringify!(gmfBlackBoxX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICSFLOAT>())).gmfBlackBoxY as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICSFLOAT),
      "::",
      stringify!(gmfBlackBoxY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_GLYPHMETRICSFLOAT>())).gmfptGlyphOrigin as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICSFLOAT),
      "::",
      stringify!(gmfptGlyphOrigin)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICSFLOAT>())).gmfCellIncX as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICSFLOAT),
      "::",
      stringify!(gmfCellIncX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_GLYPHMETRICSFLOAT>())).gmfCellIncY as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_GLYPHMETRICSFLOAT),
      "::",
      stringify!(gmfCellIncY)
    )
  );
}
pub type GLYPHMETRICSFLOAT = _GLYPHMETRICSFLOAT;
pub type PGLYPHMETRICSFLOAT = *mut _GLYPHMETRICSFLOAT;
pub type LPGLYPHMETRICSFLOAT = *mut _GLYPHMETRICSFLOAT;
extern "C" {
  pub fn wglUseFontOutlinesA(
    arg1: HDC, arg2: DWORD, arg3: DWORD, arg4: DWORD, arg5: FLOAT, arg6: FLOAT, arg7: libc::c_int,
    arg8: LPGLYPHMETRICSFLOAT,
  ) -> BOOL;
}
extern "C" {
  pub fn wglUseFontOutlinesW(
    arg1: HDC, arg2: DWORD, arg3: DWORD, arg4: DWORD, arg5: FLOAT, arg6: FLOAT, arg7: libc::c_int,
    arg8: LPGLYPHMETRICSFLOAT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLAYERPLANEDESCRIPTOR {
  pub nSize: WORD,
  pub nVersion: WORD,
  pub dwFlags: DWORD,
  pub iPixelType: BYTE,
  pub cColorBits: BYTE,
  pub cRedBits: BYTE,
  pub cRedShift: BYTE,
  pub cGreenBits: BYTE,
  pub cGreenShift: BYTE,
  pub cBlueBits: BYTE,
  pub cBlueShift: BYTE,
  pub cAlphaBits: BYTE,
  pub cAlphaShift: BYTE,
  pub cAccumBits: BYTE,
  pub cAccumRedBits: BYTE,
  pub cAccumGreenBits: BYTE,
  pub cAccumBlueBits: BYTE,
  pub cAccumAlphaBits: BYTE,
  pub cDepthBits: BYTE,
  pub cStencilBits: BYTE,
  pub cAuxBuffers: BYTE,
  pub iLayerPlane: BYTE,
  pub bReserved: BYTE,
  pub crTransparent: COLORREF,
}
#[test]
fn bindgen_test_layout_tagLAYERPLANEDESCRIPTOR() {
  assert_eq!(
    ::core::mem::size_of::<tagLAYERPLANEDESCRIPTOR>(),
    32usize,
    concat!("Size of: ", stringify!(tagLAYERPLANEDESCRIPTOR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLAYERPLANEDESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLAYERPLANEDESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).nSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(nSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).nVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(nVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).iPixelType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(iPixelType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cColorBits as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cRedBits as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cRedBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cRedShift as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cRedShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cGreenBits as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cGreenBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cGreenShift as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cGreenShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cBlueBits as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cBlueBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cBlueShift as *const _ as usize },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cBlueShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAlphaBits as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAlphaBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAlphaShift as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAlphaShift)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAccumBits as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAccumBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAccumRedBits as *const _ as usize
    },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAccumRedBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAccumGreenBits as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAccumGreenBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAccumBlueBits as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAccumBlueBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAccumAlphaBits as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAccumAlphaBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cDepthBits as *const _ as usize },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cDepthBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cStencilBits as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cStencilBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).cAuxBuffers as *const _ as usize
    },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(cAuxBuffers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).iLayerPlane as *const _ as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(iLayerPlane)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).bReserved as *const _ as usize },
    27usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagLAYERPLANEDESCRIPTOR>())).crTransparent as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLAYERPLANEDESCRIPTOR),
      "::",
      stringify!(crTransparent)
    )
  );
}
pub type LAYERPLANEDESCRIPTOR = tagLAYERPLANEDESCRIPTOR;
pub type PLAYERPLANEDESCRIPTOR = *mut tagLAYERPLANEDESCRIPTOR;
pub type LPLAYERPLANEDESCRIPTOR = *mut tagLAYERPLANEDESCRIPTOR;
extern "C" {
  pub fn wglDescribeLayerPlane(
    arg1: HDC, arg2: libc::c_int, arg3: libc::c_int, arg4: UINT, arg5: LPLAYERPLANEDESCRIPTOR,
  ) -> BOOL;
}
extern "C" {
  pub fn wglSetLayerPaletteEntries(
    arg1: HDC, arg2: libc::c_int, arg3: libc::c_int, arg4: libc::c_int, arg5: *const COLORREF,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wglGetLayerPaletteEntries(
    arg1: HDC, arg2: libc::c_int, arg3: libc::c_int, arg4: libc::c_int, arg5: *mut COLORREF,
  ) -> libc::c_int;
}
extern "C" {
  pub fn wglRealizeLayerPalette(arg1: HDC, arg2: libc::c_int, arg3: BOOL) -> BOOL;
}
extern "C" {
  pub fn wglSwapLayerBuffers(arg1: HDC, arg2: UINT) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _WGLSWAP {
  pub hdc: HDC,
  pub uiFlags: UINT,
}
#[test]
fn bindgen_test_layout__WGLSWAP() {
  assert_eq!(
    ::core::mem::size_of::<_WGLSWAP>(),
    16usize,
    concat!("Size of: ", stringify!(_WGLSWAP))
  );
  assert_eq!(
    ::core::mem::align_of::<_WGLSWAP>(),
    8usize,
    concat!("Alignment of ", stringify!(_WGLSWAP))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WGLSWAP>())).hdc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WGLSWAP),
      "::",
      stringify!(hdc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WGLSWAP>())).uiFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_WGLSWAP),
      "::",
      stringify!(uiFlags)
    )
  );
}
impl Default for _WGLSWAP {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WGLSWAP = _WGLSWAP;
pub type PWGLSWAP = *mut _WGLSWAP;
pub type LPWGLSWAP = *mut _WGLSWAP;
extern "C" {
  pub fn wglSwapMultipleBuffers(arg1: UINT, arg2: *const WGLSWAP) -> DWORD;
}
pub type HDWP = HANDLE;
pub type MENUTEMPLATEA = libc::c_void;
pub type MENUTEMPLATEW = libc::c_void;
pub type MENUTEMPLATE = MENUTEMPLATEA;
pub type LPMENUTEMPLATEA = PVOID;
pub type LPMENUTEMPLATEW = PVOID;
pub type LPMENUTEMPLATE = LPMENUTEMPLATEA;
pub type WNDPROC = ::core::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> LRESULT,
>;
pub type DLGPROC = ::core::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> INT_PTR,
>;
pub type TIMERPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: UINT_PTR, arg4: DWORD)>;
pub type GRAYSTRINGPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: HDC, arg2: LPARAM, arg3: libc::c_int) -> BOOL>;
pub type WNDENUMPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: LPARAM) -> BOOL>;
pub type HOOKPROC = ::core::option::Option<
  unsafe extern "C" fn(code: libc::c_int, wParam: WPARAM, lParam: LPARAM) -> LRESULT,
>;
pub type SENDASYNCPROC = ::core::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: ULONG_PTR, arg4: LRESULT),
>;
pub type PROPENUMPROCA =
  ::core::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: LPCSTR, arg3: HANDLE) -> BOOL>;
pub type PROPENUMPROCW =
  ::core::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: LPCWSTR, arg3: HANDLE) -> BOOL>;
pub type PROPENUMPROCEXA = ::core::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: LPSTR, arg3: HANDLE, arg4: ULONG_PTR) -> BOOL,
>;
pub type PROPENUMPROCEXW = ::core::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: LPWSTR, arg3: HANDLE, arg4: ULONG_PTR) -> BOOL,
>;
pub type EDITWORDBREAKPROCA = ::core::option::Option<
  unsafe extern "C" fn(
    lpch: LPSTR,
    ichCurrent: libc::c_int,
    cch: libc::c_int,
    code: libc::c_int,
  ) -> libc::c_int,
>;
pub type EDITWORDBREAKPROCW = ::core::option::Option<
  unsafe extern "C" fn(
    lpch: LPWSTR,
    ichCurrent: libc::c_int,
    cch: libc::c_int,
    code: libc::c_int,
  ) -> libc::c_int,
>;
pub type DRAWSTATEPROC = ::core::option::Option<
  unsafe extern "C" fn(
    hdc: HDC,
    lData: LPARAM,
    wData: WPARAM,
    cx: libc::c_int,
    cy: libc::c_int,
  ) -> BOOL,
>;
pub type PROPENUMPROC = PROPENUMPROCA;
pub type PROPENUMPROCEX = PROPENUMPROCEXA;
pub type EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
pub type NAMEENUMPROCA =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: LPARAM) -> BOOL>;
pub type NAMEENUMPROCW =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LPARAM) -> BOOL>;
pub type WINSTAENUMPROCA = NAMEENUMPROCA;
pub type DESKTOPENUMPROCA = NAMEENUMPROCA;
pub type WINSTAENUMPROCW = NAMEENUMPROCW;
pub type DESKTOPENUMPROCW = NAMEENUMPROCW;
pub type WINSTAENUMPROC = WINSTAENUMPROCA;
pub type DESKTOPENUMPROC = DESKTOPENUMPROCA;
extern "C" {
  pub fn wvsprintfA(arg1: LPSTR, arg2: LPCSTR, arglist: va_list) -> libc::c_int;
}
extern "C" {
  pub fn wvsprintfW(arg1: LPWSTR, arg2: LPCWSTR, arglist: va_list) -> libc::c_int;
}
extern "C" {
  pub fn wsprintfA(arg1: LPSTR, arg2: LPCSTR, ...) -> libc::c_int;
}
extern "C" {
  pub fn wsprintfW(arg1: LPWSTR, arg2: LPCWSTR, ...) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCBT_CREATEWNDA {
  pub lpcs: *mut tagCREATESTRUCTA,
  pub hwndInsertAfter: HWND,
}
#[test]
fn bindgen_test_layout_tagCBT_CREATEWNDA() {
  assert_eq!(
    ::core::mem::size_of::<tagCBT_CREATEWNDA>(),
    16usize,
    concat!("Size of: ", stringify!(tagCBT_CREATEWNDA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCBT_CREATEWNDA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCBT_CREATEWNDA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCBT_CREATEWNDA>())).lpcs as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCBT_CREATEWNDA),
      "::",
      stringify!(lpcs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCBT_CREATEWNDA>())).hwndInsertAfter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCBT_CREATEWNDA),
      "::",
      stringify!(hwndInsertAfter)
    )
  );
}
impl Default for tagCBT_CREATEWNDA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CBT_CREATEWNDA = tagCBT_CREATEWNDA;
pub type LPCBT_CREATEWNDA = *mut tagCBT_CREATEWNDA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCBT_CREATEWNDW {
  pub lpcs: *mut tagCREATESTRUCTW,
  pub hwndInsertAfter: HWND,
}
#[test]
fn bindgen_test_layout_tagCBT_CREATEWNDW() {
  assert_eq!(
    ::core::mem::size_of::<tagCBT_CREATEWNDW>(),
    16usize,
    concat!("Size of: ", stringify!(tagCBT_CREATEWNDW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCBT_CREATEWNDW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCBT_CREATEWNDW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCBT_CREATEWNDW>())).lpcs as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCBT_CREATEWNDW),
      "::",
      stringify!(lpcs)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCBT_CREATEWNDW>())).hwndInsertAfter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCBT_CREATEWNDW),
      "::",
      stringify!(hwndInsertAfter)
    )
  );
}
impl Default for tagCBT_CREATEWNDW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CBT_CREATEWNDW = tagCBT_CREATEWNDW;
pub type LPCBT_CREATEWNDW = *mut tagCBT_CREATEWNDW;
pub type CBT_CREATEWND = CBT_CREATEWNDA;
pub type LPCBT_CREATEWND = LPCBT_CREATEWNDA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCBTACTIVATESTRUCT {
  pub fMouse: BOOL,
  pub hWndActive: HWND,
}
#[test]
fn bindgen_test_layout_tagCBTACTIVATESTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCBTACTIVATESTRUCT>(),
    16usize,
    concat!("Size of: ", stringify!(tagCBTACTIVATESTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCBTACTIVATESTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCBTACTIVATESTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCBTACTIVATESTRUCT>())).fMouse as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCBTACTIVATESTRUCT),
      "::",
      stringify!(fMouse)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCBTACTIVATESTRUCT>())).hWndActive as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCBTACTIVATESTRUCT),
      "::",
      stringify!(hWndActive)
    )
  );
}
impl Default for tagCBTACTIVATESTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CBTACTIVATESTRUCT = tagCBTACTIVATESTRUCT;
pub type LPCBTACTIVATESTRUCT = *mut tagCBTACTIVATESTRUCT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagWTSSESSION_NOTIFICATION {
  pub cbSize: DWORD,
  pub dwSessionId: DWORD,
}
#[test]
fn bindgen_test_layout_tagWTSSESSION_NOTIFICATION() {
  assert_eq!(
    ::core::mem::size_of::<tagWTSSESSION_NOTIFICATION>(),
    8usize,
    concat!("Size of: ", stringify!(tagWTSSESSION_NOTIFICATION))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWTSSESSION_NOTIFICATION>(),
    4usize,
    concat!("Alignment of ", stringify!(tagWTSSESSION_NOTIFICATION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWTSSESSION_NOTIFICATION>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWTSSESSION_NOTIFICATION),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagWTSSESSION_NOTIFICATION>())).dwSessionId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWTSSESSION_NOTIFICATION),
      "::",
      stringify!(dwSessionId)
    )
  );
}
pub type WTSSESSION_NOTIFICATION = tagWTSSESSION_NOTIFICATION;
pub type PWTSSESSION_NOTIFICATION = *mut tagWTSSESSION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SHELLHOOKINFO {
  pub hwnd: HWND,
  pub rc: RECT,
}
#[test]
fn bindgen_test_layout_SHELLHOOKINFO() {
  assert_eq!(
    ::core::mem::size_of::<SHELLHOOKINFO>(),
    24usize,
    concat!("Size of: ", stringify!(SHELLHOOKINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<SHELLHOOKINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(SHELLHOOKINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHELLHOOKINFO>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHELLHOOKINFO),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHELLHOOKINFO>())).rc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHELLHOOKINFO),
      "::",
      stringify!(rc)
    )
  );
}
impl Default for SHELLHOOKINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type LPSHELLHOOKINFO = *mut SHELLHOOKINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagEVENTMSG {
  pub message: UINT,
  pub paramL: UINT,
  pub paramH: UINT,
  pub time: DWORD,
  pub hwnd: HWND,
}
#[test]
fn bindgen_test_layout_tagEVENTMSG() {
  assert_eq!(
    ::core::mem::size_of::<tagEVENTMSG>(),
    24usize,
    concat!("Size of: ", stringify!(tagEVENTMSG))
  );
  assert_eq!(
    ::core::mem::align_of::<tagEVENTMSG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagEVENTMSG))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEVENTMSG>())).message as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEVENTMSG),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEVENTMSG>())).paramL as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEVENTMSG),
      "::",
      stringify!(paramL)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEVENTMSG>())).paramH as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEVENTMSG),
      "::",
      stringify!(paramH)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEVENTMSG>())).time as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEVENTMSG),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagEVENTMSG>())).hwnd as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEVENTMSG),
      "::",
      stringify!(hwnd)
    )
  );
}
impl Default for tagEVENTMSG {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type EVENTMSG = tagEVENTMSG;
pub type PEVENTMSGMSG = *mut tagEVENTMSG;
pub type NPEVENTMSGMSG = *mut tagEVENTMSG;
pub type LPEVENTMSGMSG = *mut tagEVENTMSG;
pub type PEVENTMSG = *mut tagEVENTMSG;
pub type NPEVENTMSG = *mut tagEVENTMSG;
pub type LPEVENTMSG = *mut tagEVENTMSG;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCWPSTRUCT {
  pub lParam: LPARAM,
  pub wParam: WPARAM,
  pub message: UINT,
  pub hwnd: HWND,
}
#[test]
fn bindgen_test_layout_tagCWPSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCWPSTRUCT>(),
    32usize,
    concat!("Size of: ", stringify!(tagCWPSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCWPSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCWPSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPSTRUCT>())).lParam as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPSTRUCT),
      "::",
      stringify!(lParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPSTRUCT>())).wParam as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPSTRUCT),
      "::",
      stringify!(wParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPSTRUCT>())).message as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPSTRUCT),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPSTRUCT>())).hwnd as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPSTRUCT),
      "::",
      stringify!(hwnd)
    )
  );
}
impl Default for tagCWPSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CWPSTRUCT = tagCWPSTRUCT;
pub type PCWPSTRUCT = *mut tagCWPSTRUCT;
pub type NPCWPSTRUCT = *mut tagCWPSTRUCT;
pub type LPCWPSTRUCT = *mut tagCWPSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCWPRETSTRUCT {
  pub lResult: LRESULT,
  pub lParam: LPARAM,
  pub wParam: WPARAM,
  pub message: UINT,
  pub hwnd: HWND,
}
#[test]
fn bindgen_test_layout_tagCWPRETSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCWPRETSTRUCT>(),
    40usize,
    concat!("Size of: ", stringify!(tagCWPRETSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCWPRETSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCWPRETSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPRETSTRUCT>())).lResult as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPRETSTRUCT),
      "::",
      stringify!(lResult)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPRETSTRUCT>())).lParam as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPRETSTRUCT),
      "::",
      stringify!(lParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPRETSTRUCT>())).wParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPRETSTRUCT),
      "::",
      stringify!(wParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPRETSTRUCT>())).message as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPRETSTRUCT),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCWPRETSTRUCT>())).hwnd as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCWPRETSTRUCT),
      "::",
      stringify!(hwnd)
    )
  );
}
impl Default for tagCWPRETSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CWPRETSTRUCT = tagCWPRETSTRUCT;
pub type PCWPRETSTRUCT = *mut tagCWPRETSTRUCT;
pub type NPCWPRETSTRUCT = *mut tagCWPRETSTRUCT;
pub type LPCWPRETSTRUCT = *mut tagCWPRETSTRUCT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagKBDLLHOOKSTRUCT {
  pub vkCode: DWORD,
  pub scanCode: DWORD,
  pub flags: DWORD,
  pub time: DWORD,
  pub dwExtraInfo: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagKBDLLHOOKSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagKBDLLHOOKSTRUCT>(),
    24usize,
    concat!("Size of: ", stringify!(tagKBDLLHOOKSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagKBDLLHOOKSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagKBDLLHOOKSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKBDLLHOOKSTRUCT>())).vkCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKBDLLHOOKSTRUCT),
      "::",
      stringify!(vkCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKBDLLHOOKSTRUCT>())).scanCode as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKBDLLHOOKSTRUCT),
      "::",
      stringify!(scanCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKBDLLHOOKSTRUCT>())).flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKBDLLHOOKSTRUCT),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKBDLLHOOKSTRUCT>())).time as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKBDLLHOOKSTRUCT),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKBDLLHOOKSTRUCT>())).dwExtraInfo as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKBDLLHOOKSTRUCT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
}
pub type KBDLLHOOKSTRUCT = tagKBDLLHOOKSTRUCT;
pub type LPKBDLLHOOKSTRUCT = *mut tagKBDLLHOOKSTRUCT;
pub type PKBDLLHOOKSTRUCT = *mut tagKBDLLHOOKSTRUCT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMSLLHOOKSTRUCT {
  pub pt: POINT,
  pub mouseData: DWORD,
  pub flags: DWORD,
  pub time: DWORD,
  pub dwExtraInfo: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagMSLLHOOKSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagMSLLHOOKSTRUCT>(),
    32usize,
    concat!("Size of: ", stringify!(tagMSLLHOOKSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMSLLHOOKSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMSLLHOOKSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSLLHOOKSTRUCT>())).pt as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSLLHOOKSTRUCT),
      "::",
      stringify!(pt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSLLHOOKSTRUCT>())).mouseData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSLLHOOKSTRUCT),
      "::",
      stringify!(mouseData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSLLHOOKSTRUCT>())).flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSLLHOOKSTRUCT),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSLLHOOKSTRUCT>())).time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSLLHOOKSTRUCT),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSLLHOOKSTRUCT>())).dwExtraInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSLLHOOKSTRUCT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
}
pub type MSLLHOOKSTRUCT = tagMSLLHOOKSTRUCT;
pub type LPMSLLHOOKSTRUCT = *mut tagMSLLHOOKSTRUCT;
pub type PMSLLHOOKSTRUCT = *mut tagMSLLHOOKSTRUCT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagDEBUGHOOKINFO {
  pub idThread: DWORD,
  pub idThreadInstaller: DWORD,
  pub lParam: LPARAM,
  pub wParam: WPARAM,
  pub code: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagDEBUGHOOKINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagDEBUGHOOKINFO>(),
    32usize,
    concat!("Size of: ", stringify!(tagDEBUGHOOKINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDEBUGHOOKINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDEBUGHOOKINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDEBUGHOOKINFO>())).idThread as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEBUGHOOKINFO),
      "::",
      stringify!(idThread)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDEBUGHOOKINFO>())).idThreadInstaller as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEBUGHOOKINFO),
      "::",
      stringify!(idThreadInstaller)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDEBUGHOOKINFO>())).lParam as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEBUGHOOKINFO),
      "::",
      stringify!(lParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDEBUGHOOKINFO>())).wParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEBUGHOOKINFO),
      "::",
      stringify!(wParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDEBUGHOOKINFO>())).code as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEBUGHOOKINFO),
      "::",
      stringify!(code)
    )
  );
}
pub type DEBUGHOOKINFO = tagDEBUGHOOKINFO;
pub type PDEBUGHOOKINFO = *mut tagDEBUGHOOKINFO;
pub type NPDEBUGHOOKINFO = *mut tagDEBUGHOOKINFO;
pub type LPDEBUGHOOKINFO = *mut tagDEBUGHOOKINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMOUSEHOOKSTRUCT {
  pub pt: POINT,
  pub hwnd: HWND,
  pub wHitTestCode: UINT,
  pub dwExtraInfo: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagMOUSEHOOKSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagMOUSEHOOKSTRUCT>(),
    32usize,
    concat!("Size of: ", stringify!(tagMOUSEHOOKSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMOUSEHOOKSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMOUSEHOOKSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEHOOKSTRUCT>())).pt as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEHOOKSTRUCT),
      "::",
      stringify!(pt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEHOOKSTRUCT>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEHOOKSTRUCT),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEHOOKSTRUCT>())).wHitTestCode as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEHOOKSTRUCT),
      "::",
      stringify!(wHitTestCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEHOOKSTRUCT>())).dwExtraInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEHOOKSTRUCT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
}
impl Default for tagMOUSEHOOKSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MOUSEHOOKSTRUCT = tagMOUSEHOOKSTRUCT;
pub type LPMOUSEHOOKSTRUCT = *mut tagMOUSEHOOKSTRUCT;
pub type PMOUSEHOOKSTRUCT = *mut tagMOUSEHOOKSTRUCT;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMOUSEHOOKSTRUCTEX {
  pub __bindgen_padding_0: [u32; 8usize],
  pub mouseData: DWORD,
}
#[test]
fn bindgen_test_layout_tagMOUSEHOOKSTRUCTEX() {
  assert_eq!(
    ::core::mem::size_of::<tagMOUSEHOOKSTRUCTEX>(),
    40usize,
    concat!("Size of: ", stringify!(tagMOUSEHOOKSTRUCTEX))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMOUSEHOOKSTRUCTEX>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMOUSEHOOKSTRUCTEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEHOOKSTRUCTEX>())).mouseData as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEHOOKSTRUCTEX),
      "::",
      stringify!(mouseData)
    )
  );
}
pub type MOUSEHOOKSTRUCTEX = tagMOUSEHOOKSTRUCTEX;
pub type LPMOUSEHOOKSTRUCTEX = *mut tagMOUSEHOOKSTRUCTEX;
pub type PMOUSEHOOKSTRUCTEX = *mut tagMOUSEHOOKSTRUCTEX;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagHARDWAREHOOKSTRUCT {
  pub hwnd: HWND,
  pub message: UINT,
  pub wParam: WPARAM,
  pub lParam: LPARAM,
}
#[test]
fn bindgen_test_layout_tagHARDWAREHOOKSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagHARDWAREHOOKSTRUCT>(),
    32usize,
    concat!("Size of: ", stringify!(tagHARDWAREHOOKSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHARDWAREHOOKSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagHARDWAREHOOKSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREHOOKSTRUCT>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREHOOKSTRUCT),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREHOOKSTRUCT>())).message as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREHOOKSTRUCT),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREHOOKSTRUCT>())).wParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREHOOKSTRUCT),
      "::",
      stringify!(wParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREHOOKSTRUCT>())).lParam as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREHOOKSTRUCT),
      "::",
      stringify!(lParam)
    )
  );
}
impl Default for tagHARDWAREHOOKSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type HARDWAREHOOKSTRUCT = tagHARDWAREHOOKSTRUCT;
pub type LPHARDWAREHOOKSTRUCT = *mut tagHARDWAREHOOKSTRUCT;
pub type PHARDWAREHOOKSTRUCT = *mut tagHARDWAREHOOKSTRUCT;
extern "C" {
  pub fn LoadKeyboardLayoutA(pwszKLID: LPCSTR, Flags: UINT) -> HKL;
}
extern "C" {
  pub fn LoadKeyboardLayoutW(pwszKLID: LPCWSTR, Flags: UINT) -> HKL;
}
extern "C" {
  pub fn ActivateKeyboardLayout(hkl: HKL, Flags: UINT) -> HKL;
}
extern "C" {
  pub fn ToUnicodeEx(
    wVirtKey: UINT, wScanCode: UINT, lpKeyState: *const BYTE, pwszBuff: LPWSTR,
    cchBuff: libc::c_int, wFlags: UINT, dwhkl: HKL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn UnloadKeyboardLayout(hkl: HKL) -> BOOL;
}
extern "C" {
  pub fn GetKeyboardLayoutNameA(pwszKLID: LPSTR) -> BOOL;
}
extern "C" {
  pub fn GetKeyboardLayoutNameW(pwszKLID: LPWSTR) -> BOOL;
}
extern "C" {
  pub fn GetKeyboardLayoutList(nBuff: libc::c_int, lpList: *mut HKL) -> libc::c_int;
}
extern "C" {
  pub fn GetKeyboardLayout(idThread: DWORD) -> HKL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMOUSEMOVEPOINT {
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub time: DWORD,
  pub dwExtraInfo: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagMOUSEMOVEPOINT() {
  assert_eq!(
    ::core::mem::size_of::<tagMOUSEMOVEPOINT>(),
    24usize,
    concat!("Size of: ", stringify!(tagMOUSEMOVEPOINT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMOUSEMOVEPOINT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMOUSEMOVEPOINT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEMOVEPOINT>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEMOVEPOINT),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEMOVEPOINT>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEMOVEPOINT),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEMOVEPOINT>())).time as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEMOVEPOINT),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEMOVEPOINT>())).dwExtraInfo as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEMOVEPOINT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
}
pub type MOUSEMOVEPOINT = tagMOUSEMOVEPOINT;
pub type PMOUSEMOVEPOINT = *mut tagMOUSEMOVEPOINT;
pub type LPMOUSEMOVEPOINT = *mut tagMOUSEMOVEPOINT;
extern "C" {
  pub fn GetMouseMovePointsEx(
    cbSize: UINT, lppt: LPMOUSEMOVEPOINT, lpptBuf: LPMOUSEMOVEPOINT, nBufPoints: libc::c_int,
    resolution: DWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CreateDesktopA(
    lpszDesktop: LPCSTR, lpszDevice: LPCSTR, pDevmode: *mut DEVMODEA, dwFlags: DWORD,
    dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES,
  ) -> HDESK;
}
extern "C" {
  pub fn CreateDesktopW(
    lpszDesktop: LPCWSTR, lpszDevice: LPCWSTR, pDevmode: *mut DEVMODEW, dwFlags: DWORD,
    dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES,
  ) -> HDESK;
}
extern "C" {
  pub fn CreateDesktopExA(
    lpszDesktop: LPCSTR, lpszDevice: LPCSTR, pDevmode: *mut DEVMODEA, dwFlags: DWORD,
    dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES, ulHeapSize: ULONG, pvoid: PVOID,
  ) -> HDESK;
}
extern "C" {
  pub fn CreateDesktopExW(
    lpszDesktop: LPCWSTR, lpszDevice: LPCWSTR, pDevmode: *mut DEVMODEW, dwFlags: DWORD,
    dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES, ulHeapSize: ULONG, pvoid: PVOID,
  ) -> HDESK;
}
extern "C" {
  pub fn OpenDesktopA(
    lpszDesktop: LPCSTR, dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK,
  ) -> HDESK;
}
extern "C" {
  pub fn OpenDesktopW(
    lpszDesktop: LPCWSTR, dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK,
  ) -> HDESK;
}
extern "C" {
  pub fn OpenInputDesktop(dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) -> HDESK;
}
extern "C" {
  pub fn EnumDesktopsA(hwinsta: HWINSTA, lpEnumFunc: DESKTOPENUMPROCA, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn EnumDesktopsW(hwinsta: HWINSTA, lpEnumFunc: DESKTOPENUMPROCW, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn EnumDesktopWindows(hDesktop: HDESK, lpfn: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn SwitchDesktop(hDesktop: HDESK) -> BOOL;
}
extern "C" {
  pub fn SetThreadDesktop(hDesktop: HDESK) -> BOOL;
}
extern "C" {
  pub fn CloseDesktop(hDesktop: HDESK) -> BOOL;
}
extern "C" {
  pub fn GetThreadDesktop(dwThreadId: DWORD) -> HDESK;
}
extern "C" {
  pub fn CreateWindowStationA(
    lpwinsta: LPCSTR, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES,
  ) -> HWINSTA;
}
extern "C" {
  pub fn CreateWindowStationW(
    lpwinsta: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES,
  ) -> HWINSTA;
}
extern "C" {
  pub fn OpenWindowStationA(
    lpszWinSta: LPCSTR, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK,
  ) -> HWINSTA;
}
extern "C" {
  pub fn OpenWindowStationW(
    lpszWinSta: LPCWSTR, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK,
  ) -> HWINSTA;
}
extern "C" {
  pub fn EnumWindowStationsA(lpEnumFunc: WINSTAENUMPROCA, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn EnumWindowStationsW(lpEnumFunc: WINSTAENUMPROCW, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn CloseWindowStation(hWinSta: HWINSTA) -> BOOL;
}
extern "C" {
  pub fn SetProcessWindowStation(hWinSta: HWINSTA) -> BOOL;
}
extern "C" {
  pub fn GetProcessWindowStation() -> HWINSTA;
}
extern "C" {
  pub fn SetUserObjectSecurity(
    hObj: HANDLE, pSIRequested: PSECURITY_INFORMATION, pSID: PSECURITY_DESCRIPTOR,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUserObjectSecurity(
    hObj: HANDLE, pSIRequested: PSECURITY_INFORMATION, pSID: PSECURITY_DESCRIPTOR, nLength: DWORD,
    lpnLengthNeeded: LPDWORD,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagUSEROBJECTFLAGS {
  pub fInherit: BOOL,
  pub fReserved: BOOL,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagUSEROBJECTFLAGS() {
  assert_eq!(
    ::core::mem::size_of::<tagUSEROBJECTFLAGS>(),
    12usize,
    concat!("Size of: ", stringify!(tagUSEROBJECTFLAGS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagUSEROBJECTFLAGS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagUSEROBJECTFLAGS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSEROBJECTFLAGS>())).fInherit as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSEROBJECTFLAGS),
      "::",
      stringify!(fInherit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSEROBJECTFLAGS>())).fReserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSEROBJECTFLAGS),
      "::",
      stringify!(fReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSEROBJECTFLAGS>())).dwFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSEROBJECTFLAGS),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type USEROBJECTFLAGS = tagUSEROBJECTFLAGS;
pub type PUSEROBJECTFLAGS = *mut tagUSEROBJECTFLAGS;
extern "C" {
  pub fn GetUserObjectInformationA(
    hObj: HANDLE, nIndex: libc::c_int, pvInfo: PVOID, nLength: DWORD, lpnLengthNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUserObjectInformationW(
    hObj: HANDLE, nIndex: libc::c_int, pvInfo: PVOID, nLength: DWORD, lpnLengthNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetUserObjectInformationA(
    hObj: HANDLE, nIndex: libc::c_int, pvInfo: PVOID, nLength: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetUserObjectInformationW(
    hObj: HANDLE, nIndex: libc::c_int, pvInfo: PVOID, nLength: DWORD,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagWNDCLASSEXA {
  pub cbSize: UINT,
  pub style: UINT,
  pub lpfnWndProc: WNDPROC,
  pub cbClsExtra: libc::c_int,
  pub cbWndExtra: libc::c_int,
  pub hInstance: HINSTANCE,
  pub hIcon: HICON,
  pub hCursor: HCURSOR,
  pub hbrBackground: HBRUSH,
  pub lpszMenuName: LPCSTR,
  pub lpszClassName: LPCSTR,
  pub hIconSm: HICON,
}
#[test]
fn bindgen_test_layout_tagWNDCLASSEXA() {
  assert_eq!(
    ::core::mem::size_of::<tagWNDCLASSEXA>(),
    80usize,
    concat!("Size of: ", stringify!(tagWNDCLASSEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWNDCLASSEXA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagWNDCLASSEXA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).style as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).lpfnWndProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(lpfnWndProc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).cbClsExtra as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(cbClsExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).cbWndExtra as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(cbWndExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).hInstance as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).hIcon as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).hCursor as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(hCursor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).hbrBackground as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(hbrBackground)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).lpszMenuName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(lpszMenuName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).lpszClassName as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(lpszClassName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXA>())).hIconSm as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXA),
      "::",
      stringify!(hIconSm)
    )
  );
}
impl Default for tagWNDCLASSEXA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WNDCLASSEXA = tagWNDCLASSEXA;
pub type PWNDCLASSEXA = *mut tagWNDCLASSEXA;
pub type NPWNDCLASSEXA = *mut tagWNDCLASSEXA;
pub type LPWNDCLASSEXA = *mut tagWNDCLASSEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagWNDCLASSEXW {
  pub cbSize: UINT,
  pub style: UINT,
  pub lpfnWndProc: WNDPROC,
  pub cbClsExtra: libc::c_int,
  pub cbWndExtra: libc::c_int,
  pub hInstance: HINSTANCE,
  pub hIcon: HICON,
  pub hCursor: HCURSOR,
  pub hbrBackground: HBRUSH,
  pub lpszMenuName: LPCWSTR,
  pub lpszClassName: LPCWSTR,
  pub hIconSm: HICON,
}
#[test]
fn bindgen_test_layout_tagWNDCLASSEXW() {
  assert_eq!(
    ::core::mem::size_of::<tagWNDCLASSEXW>(),
    80usize,
    concat!("Size of: ", stringify!(tagWNDCLASSEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWNDCLASSEXW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagWNDCLASSEXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).style as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).lpfnWndProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(lpfnWndProc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).cbClsExtra as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(cbClsExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).cbWndExtra as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(cbWndExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).hInstance as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).hIcon as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).hCursor as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(hCursor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).hbrBackground as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(hbrBackground)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).lpszMenuName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(lpszMenuName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).lpszClassName as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(lpszClassName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSEXW>())).hIconSm as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSEXW),
      "::",
      stringify!(hIconSm)
    )
  );
}
impl Default for tagWNDCLASSEXW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WNDCLASSEXW = tagWNDCLASSEXW;
pub type PWNDCLASSEXW = *mut tagWNDCLASSEXW;
pub type NPWNDCLASSEXW = *mut tagWNDCLASSEXW;
pub type LPWNDCLASSEXW = *mut tagWNDCLASSEXW;
pub type WNDCLASSEX = WNDCLASSEXA;
pub type PWNDCLASSEX = PWNDCLASSEXA;
pub type NPWNDCLASSEX = NPWNDCLASSEXA;
pub type LPWNDCLASSEX = LPWNDCLASSEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagWNDCLASSA {
  pub style: UINT,
  pub lpfnWndProc: WNDPROC,
  pub cbClsExtra: libc::c_int,
  pub cbWndExtra: libc::c_int,
  pub hInstance: HINSTANCE,
  pub hIcon: HICON,
  pub hCursor: HCURSOR,
  pub hbrBackground: HBRUSH,
  pub lpszMenuName: LPCSTR,
  pub lpszClassName: LPCSTR,
}
#[test]
fn bindgen_test_layout_tagWNDCLASSA() {
  assert_eq!(
    ::core::mem::size_of::<tagWNDCLASSA>(),
    72usize,
    concat!("Size of: ", stringify!(tagWNDCLASSA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWNDCLASSA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagWNDCLASSA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).style as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).lpfnWndProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(lpfnWndProc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).cbClsExtra as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(cbClsExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).cbWndExtra as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(cbWndExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).hInstance as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).hIcon as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).hCursor as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(hCursor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).hbrBackground as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(hbrBackground)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).lpszMenuName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(lpszMenuName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSA>())).lpszClassName as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSA),
      "::",
      stringify!(lpszClassName)
    )
  );
}
impl Default for tagWNDCLASSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WNDCLASSA = tagWNDCLASSA;
pub type PWNDCLASSA = *mut tagWNDCLASSA;
pub type NPWNDCLASSA = *mut tagWNDCLASSA;
pub type LPWNDCLASSA = *mut tagWNDCLASSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagWNDCLASSW {
  pub style: UINT,
  pub lpfnWndProc: WNDPROC,
  pub cbClsExtra: libc::c_int,
  pub cbWndExtra: libc::c_int,
  pub hInstance: HINSTANCE,
  pub hIcon: HICON,
  pub hCursor: HCURSOR,
  pub hbrBackground: HBRUSH,
  pub lpszMenuName: LPCWSTR,
  pub lpszClassName: LPCWSTR,
}
#[test]
fn bindgen_test_layout_tagWNDCLASSW() {
  assert_eq!(
    ::core::mem::size_of::<tagWNDCLASSW>(),
    72usize,
    concat!("Size of: ", stringify!(tagWNDCLASSW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWNDCLASSW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagWNDCLASSW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).style as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).lpfnWndProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(lpfnWndProc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).cbClsExtra as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(cbClsExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).cbWndExtra as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(cbWndExtra)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).hInstance as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).hIcon as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).hCursor as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(hCursor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).hbrBackground as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(hbrBackground)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).lpszMenuName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(lpszMenuName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWNDCLASSW>())).lpszClassName as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWNDCLASSW),
      "::",
      stringify!(lpszClassName)
    )
  );
}
impl Default for tagWNDCLASSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WNDCLASSW = tagWNDCLASSW;
pub type PWNDCLASSW = *mut tagWNDCLASSW;
pub type NPWNDCLASSW = *mut tagWNDCLASSW;
pub type LPWNDCLASSW = *mut tagWNDCLASSW;
pub type WNDCLASS = WNDCLASSA;
pub type PWNDCLASS = PWNDCLASSA;
pub type NPWNDCLASS = NPWNDCLASSA;
pub type LPWNDCLASS = LPWNDCLASSA;
extern "C" {
  pub fn IsHungAppWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn DisableProcessWindowsGhosting();
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMSG {
  pub hwnd: HWND,
  pub message: UINT,
  pub wParam: WPARAM,
  pub lParam: LPARAM,
  pub time: DWORD,
  pub pt: POINT,
}
#[test]
fn bindgen_test_layout_tagMSG() {
  assert_eq!(
    ::core::mem::size_of::<tagMSG>(),
    48usize,
    concat!("Size of: ", stringify!(tagMSG))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMSG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMSG))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSG>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSG),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSG>())).message as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSG),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSG>())).wParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSG),
      "::",
      stringify!(wParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSG>())).lParam as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSG),
      "::",
      stringify!(lParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSG>())).time as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSG),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSG>())).pt as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSG),
      "::",
      stringify!(pt)
    )
  );
}
impl Default for tagMSG {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MSG = tagMSG;
pub type PMSG = *mut tagMSG;
pub type NPMSG = *mut tagMSG;
pub type LPMSG = *mut tagMSG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMINMAXINFO {
  pub ptReserved: POINT,
  pub ptMaxSize: POINT,
  pub ptMaxPosition: POINT,
  pub ptMinTrackSize: POINT,
  pub ptMaxTrackSize: POINT,
}
#[test]
fn bindgen_test_layout_tagMINMAXINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagMINMAXINFO>(),
    40usize,
    concat!("Size of: ", stringify!(tagMINMAXINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMINMAXINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMINMAXINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINMAXINFO>())).ptReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINMAXINFO),
      "::",
      stringify!(ptReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINMAXINFO>())).ptMaxSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINMAXINFO),
      "::",
      stringify!(ptMaxSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINMAXINFO>())).ptMaxPosition as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINMAXINFO),
      "::",
      stringify!(ptMaxPosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINMAXINFO>())).ptMinTrackSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINMAXINFO),
      "::",
      stringify!(ptMinTrackSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINMAXINFO>())).ptMaxTrackSize as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINMAXINFO),
      "::",
      stringify!(ptMaxTrackSize)
    )
  );
}
pub type MINMAXINFO = tagMINMAXINFO;
pub type PMINMAXINFO = *mut tagMINMAXINFO;
pub type LPMINMAXINFO = *mut tagMINMAXINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCOPYDATASTRUCT {
  pub dwData: ULONG_PTR,
  pub cbData: DWORD,
  pub lpData: PVOID,
}
#[test]
fn bindgen_test_layout_tagCOPYDATASTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCOPYDATASTRUCT>(),
    24usize,
    concat!("Size of: ", stringify!(tagCOPYDATASTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOPYDATASTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCOPYDATASTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOPYDATASTRUCT>())).dwData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOPYDATASTRUCT),
      "::",
      stringify!(dwData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOPYDATASTRUCT>())).cbData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOPYDATASTRUCT),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOPYDATASTRUCT>())).lpData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOPYDATASTRUCT),
      "::",
      stringify!(lpData)
    )
  );
}
impl Default for tagCOPYDATASTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type COPYDATASTRUCT = tagCOPYDATASTRUCT;
pub type PCOPYDATASTRUCT = *mut tagCOPYDATASTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMDINEXTMENU {
  pub hmenuIn: HMENU,
  pub hmenuNext: HMENU,
  pub hwndNext: HWND,
}
#[test]
fn bindgen_test_layout_tagMDINEXTMENU() {
  assert_eq!(
    ::core::mem::size_of::<tagMDINEXTMENU>(),
    24usize,
    concat!("Size of: ", stringify!(tagMDINEXTMENU))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMDINEXTMENU>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMDINEXTMENU))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDINEXTMENU>())).hmenuIn as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDINEXTMENU),
      "::",
      stringify!(hmenuIn)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDINEXTMENU>())).hmenuNext as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDINEXTMENU),
      "::",
      stringify!(hmenuNext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDINEXTMENU>())).hwndNext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDINEXTMENU),
      "::",
      stringify!(hwndNext)
    )
  );
}
impl Default for tagMDINEXTMENU {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MDINEXTMENU = tagMDINEXTMENU;
pub type PMDINEXTMENU = *mut tagMDINEXTMENU;
pub type LPMDINEXTMENU = *mut tagMDINEXTMENU;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct POWERBROADCAST_SETTING {
  pub PowerSetting: GUID,
  pub DataLength: DWORD,
  pub Data: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout_POWERBROADCAST_SETTING() {
  assert_eq!(
    ::core::mem::size_of::<POWERBROADCAST_SETTING>(),
    24usize,
    concat!("Size of: ", stringify!(POWERBROADCAST_SETTING))
  );
  assert_eq!(
    ::core::mem::align_of::<POWERBROADCAST_SETTING>(),
    4usize,
    concat!("Alignment of ", stringify!(POWERBROADCAST_SETTING))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<POWERBROADCAST_SETTING>())).PowerSetting as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(POWERBROADCAST_SETTING),
      "::",
      stringify!(PowerSetting)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<POWERBROADCAST_SETTING>())).DataLength as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(POWERBROADCAST_SETTING),
      "::",
      stringify!(DataLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<POWERBROADCAST_SETTING>())).Data as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(POWERBROADCAST_SETTING),
      "::",
      stringify!(Data)
    )
  );
}
pub type PPOWERBROADCAST_SETTING = *mut POWERBROADCAST_SETTING;
extern "C" {
  pub fn RegisterWindowMessageA(lpString: LPCSTR) -> UINT;
}
extern "C" {
  pub fn RegisterWindowMessageW(lpString: LPCWSTR) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagWINDOWPOS {
  pub hwnd: HWND,
  pub hwndInsertAfter: HWND,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub cx: libc::c_int,
  pub cy: libc::c_int,
  pub flags: UINT,
}
#[test]
fn bindgen_test_layout_tagWINDOWPOS() {
  assert_eq!(
    ::core::mem::size_of::<tagWINDOWPOS>(),
    40usize,
    concat!("Size of: ", stringify!(tagWINDOWPOS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWINDOWPOS>(),
    8usize,
    concat!("Alignment of ", stringify!(tagWINDOWPOS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).hwndInsertAfter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(hwndInsertAfter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).x as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).y as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).cx as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).cy as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPOS>())).flags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPOS),
      "::",
      stringify!(flags)
    )
  );
}
impl Default for tagWINDOWPOS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type WINDOWPOS = tagWINDOWPOS;
pub type LPWINDOWPOS = *mut tagWINDOWPOS;
pub type PWINDOWPOS = *mut tagWINDOWPOS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagNCCALCSIZE_PARAMS {
  pub rgrc: [RECT; 3usize],
  pub lppos: PWINDOWPOS,
}
#[test]
fn bindgen_test_layout_tagNCCALCSIZE_PARAMS() {
  assert_eq!(
    ::core::mem::size_of::<tagNCCALCSIZE_PARAMS>(),
    56usize,
    concat!("Size of: ", stringify!(tagNCCALCSIZE_PARAMS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNCCALCSIZE_PARAMS>(),
    8usize,
    concat!("Alignment of ", stringify!(tagNCCALCSIZE_PARAMS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNCCALCSIZE_PARAMS>())).rgrc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNCCALCSIZE_PARAMS),
      "::",
      stringify!(rgrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNCCALCSIZE_PARAMS>())).lppos as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNCCALCSIZE_PARAMS),
      "::",
      stringify!(lppos)
    )
  );
}
impl Default for tagNCCALCSIZE_PARAMS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NCCALCSIZE_PARAMS = tagNCCALCSIZE_PARAMS;
pub type LPNCCALCSIZE_PARAMS = *mut tagNCCALCSIZE_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagTRACKMOUSEEVENT {
  pub cbSize: DWORD,
  pub dwFlags: DWORD,
  pub hwndTrack: HWND,
  pub dwHoverTime: DWORD,
}
#[test]
fn bindgen_test_layout_tagTRACKMOUSEEVENT() {
  assert_eq!(
    ::core::mem::size_of::<tagTRACKMOUSEEVENT>(),
    24usize,
    concat!("Size of: ", stringify!(tagTRACKMOUSEEVENT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTRACKMOUSEEVENT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTRACKMOUSEEVENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTRACKMOUSEEVENT>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTRACKMOUSEEVENT),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTRACKMOUSEEVENT>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTRACKMOUSEEVENT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTRACKMOUSEEVENT>())).hwndTrack as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTRACKMOUSEEVENT),
      "::",
      stringify!(hwndTrack)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTRACKMOUSEEVENT>())).dwHoverTime as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTRACKMOUSEEVENT),
      "::",
      stringify!(dwHoverTime)
    )
  );
}
impl Default for tagTRACKMOUSEEVENT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TRACKMOUSEEVENT = tagTRACKMOUSEEVENT;
pub type LPTRACKMOUSEEVENT = *mut tagTRACKMOUSEEVENT;
extern "C" {
  pub fn TrackMouseEvent(lpEventTrack: LPTRACKMOUSEEVENT) -> BOOL;
}
extern "C" {
  pub fn DrawEdge(hdc: HDC, qrc: LPRECT, edge: UINT, grfFlags: UINT) -> BOOL;
}
extern "C" {
  pub fn DrawFrameControl(arg1: HDC, arg2: LPRECT, arg3: UINT, arg4: UINT) -> BOOL;
}
extern "C" {
  pub fn DrawCaption(hwnd: HWND, hdc: HDC, lprect: *const RECT, flags: UINT) -> BOOL;
}
extern "C" {
  pub fn DrawAnimatedRects(
    hwnd: HWND, idAni: libc::c_int, lprcFrom: *const RECT, lprcTo: *const RECT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagACCEL {
  pub fVirt: BYTE,
  pub key: WORD,
  pub cmd: WORD,
}
#[test]
fn bindgen_test_layout_tagACCEL() {
  assert_eq!(
    ::core::mem::size_of::<tagACCEL>(),
    6usize,
    concat!("Size of: ", stringify!(tagACCEL))
  );
  assert_eq!(
    ::core::mem::align_of::<tagACCEL>(),
    2usize,
    concat!("Alignment of ", stringify!(tagACCEL))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACCEL>())).fVirt as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACCEL),
      "::",
      stringify!(fVirt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACCEL>())).key as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACCEL),
      "::",
      stringify!(key)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACCEL>())).cmd as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACCEL),
      "::",
      stringify!(cmd)
    )
  );
}
pub type ACCEL = tagACCEL;
pub type LPACCEL = *mut tagACCEL;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPAINTSTRUCT {
  pub hdc: HDC,
  pub fErase: BOOL,
  pub rcPaint: RECT,
  pub fRestore: BOOL,
  pub fIncUpdate: BOOL,
  pub rgbReserved: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_tagPAINTSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagPAINTSTRUCT>(),
    72usize,
    concat!("Size of: ", stringify!(tagPAINTSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPAINTSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPAINTSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPAINTSTRUCT>())).hdc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPAINTSTRUCT),
      "::",
      stringify!(hdc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPAINTSTRUCT>())).fErase as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPAINTSTRUCT),
      "::",
      stringify!(fErase)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPAINTSTRUCT>())).rcPaint as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPAINTSTRUCT),
      "::",
      stringify!(rcPaint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPAINTSTRUCT>())).fRestore as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPAINTSTRUCT),
      "::",
      stringify!(fRestore)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPAINTSTRUCT>())).fIncUpdate as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPAINTSTRUCT),
      "::",
      stringify!(fIncUpdate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPAINTSTRUCT>())).rgbReserved as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPAINTSTRUCT),
      "::",
      stringify!(rgbReserved)
    )
  );
}
impl Default for tagPAINTSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PAINTSTRUCT = tagPAINTSTRUCT;
pub type PPAINTSTRUCT = *mut tagPAINTSTRUCT;
pub type NPPAINTSTRUCT = *mut tagPAINTSTRUCT;
pub type LPPAINTSTRUCT = *mut tagPAINTSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCREATESTRUCTA {
  pub lpCreateParams: LPVOID,
  pub hInstance: HINSTANCE,
  pub hMenu: HMENU,
  pub hwndParent: HWND,
  pub cy: libc::c_int,
  pub cx: libc::c_int,
  pub y: libc::c_int,
  pub x: libc::c_int,
  pub style: LONG,
  pub lpszName: LPCSTR,
  pub lpszClass: LPCSTR,
  pub dwExStyle: DWORD,
}
#[test]
fn bindgen_test_layout_tagCREATESTRUCTA() {
  assert_eq!(
    ::core::mem::size_of::<tagCREATESTRUCTA>(),
    80usize,
    concat!("Size of: ", stringify!(tagCREATESTRUCTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCREATESTRUCTA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCREATESTRUCTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).lpCreateParams as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(lpCreateParams)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).hInstance as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).hMenu as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(hMenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).hwndParent as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(hwndParent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).cy as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).cx as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).y as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).x as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).style as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).lpszName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(lpszName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).lpszClass as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(lpszClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTA>())).dwExStyle as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTA),
      "::",
      stringify!(dwExStyle)
    )
  );
}
impl Default for tagCREATESTRUCTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CREATESTRUCTA = tagCREATESTRUCTA;
pub type LPCREATESTRUCTA = *mut tagCREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCREATESTRUCTW {
  pub lpCreateParams: LPVOID,
  pub hInstance: HINSTANCE,
  pub hMenu: HMENU,
  pub hwndParent: HWND,
  pub cy: libc::c_int,
  pub cx: libc::c_int,
  pub y: libc::c_int,
  pub x: libc::c_int,
  pub style: LONG,
  pub lpszName: LPCWSTR,
  pub lpszClass: LPCWSTR,
  pub dwExStyle: DWORD,
}
#[test]
fn bindgen_test_layout_tagCREATESTRUCTW() {
  assert_eq!(
    ::core::mem::size_of::<tagCREATESTRUCTW>(),
    80usize,
    concat!("Size of: ", stringify!(tagCREATESTRUCTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCREATESTRUCTW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCREATESTRUCTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).lpCreateParams as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(lpCreateParams)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).hInstance as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).hMenu as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(hMenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).hwndParent as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(hwndParent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).cy as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).cx as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).y as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).x as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).style as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).lpszName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(lpszName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).lpszClass as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(lpszClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCREATESTRUCTW>())).dwExStyle as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCREATESTRUCTW),
      "::",
      stringify!(dwExStyle)
    )
  );
}
impl Default for tagCREATESTRUCTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CREATESTRUCTW = tagCREATESTRUCTW;
pub type LPCREATESTRUCTW = *mut tagCREATESTRUCTW;
pub type CREATESTRUCT = CREATESTRUCTA;
pub type LPCREATESTRUCT = LPCREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagWINDOWPLACEMENT {
  pub length: UINT,
  pub flags: UINT,
  pub showCmd: UINT,
  pub ptMinPosition: POINT,
  pub ptMaxPosition: POINT,
  pub rcNormalPosition: RECT,
}
#[test]
fn bindgen_test_layout_tagWINDOWPLACEMENT() {
  assert_eq!(
    ::core::mem::size_of::<tagWINDOWPLACEMENT>(),
    44usize,
    concat!("Size of: ", stringify!(tagWINDOWPLACEMENT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWINDOWPLACEMENT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagWINDOWPLACEMENT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPLACEMENT>())).length as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPLACEMENT),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPLACEMENT>())).flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPLACEMENT),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPLACEMENT>())).showCmd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPLACEMENT),
      "::",
      stringify!(showCmd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPLACEMENT>())).ptMinPosition as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPLACEMENT),
      "::",
      stringify!(ptMinPosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWPLACEMENT>())).ptMaxPosition as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPLACEMENT),
      "::",
      stringify!(ptMaxPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagWINDOWPLACEMENT>())).rcNormalPosition as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWPLACEMENT),
      "::",
      stringify!(rcNormalPosition)
    )
  );
}
pub type WINDOWPLACEMENT = tagWINDOWPLACEMENT;
pub type PWINDOWPLACEMENT = *mut WINDOWPLACEMENT;
pub type LPWINDOWPLACEMENT = *mut WINDOWPLACEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagNMHDR {
  pub hwndFrom: HWND,
  pub idFrom: UINT_PTR,
  pub code: UINT,
}
#[test]
fn bindgen_test_layout_tagNMHDR() {
  assert_eq!(
    ::core::mem::size_of::<tagNMHDR>(),
    24usize,
    concat!("Size of: ", stringify!(tagNMHDR))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNMHDR>(),
    8usize,
    concat!("Alignment of ", stringify!(tagNMHDR))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNMHDR>())).hwndFrom as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNMHDR),
      "::",
      stringify!(hwndFrom)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNMHDR>())).idFrom as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNMHDR),
      "::",
      stringify!(idFrom)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNMHDR>())).code as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNMHDR),
      "::",
      stringify!(code)
    )
  );
}
impl Default for tagNMHDR {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NMHDR = tagNMHDR;
pub type LPNMHDR = *mut NMHDR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSTYLESTRUCT {
  pub styleOld: DWORD,
  pub styleNew: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTYLESTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagSTYLESTRUCT>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTYLESTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSTYLESTRUCT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLESTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTYLESTRUCT>())).styleOld as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLESTRUCT),
      "::",
      stringify!(styleOld)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTYLESTRUCT>())).styleNew as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLESTRUCT),
      "::",
      stringify!(styleNew)
    )
  );
}
pub type STYLESTRUCT = tagSTYLESTRUCT;
pub type LPSTYLESTRUCT = *mut tagSTYLESTRUCT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMEASUREITEMSTRUCT {
  pub CtlType: UINT,
  pub CtlID: UINT,
  pub itemID: UINT,
  pub itemWidth: UINT,
  pub itemHeight: UINT,
  pub itemData: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagMEASUREITEMSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagMEASUREITEMSTRUCT>(),
    32usize,
    concat!("Size of: ", stringify!(tagMEASUREITEMSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMEASUREITEMSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMEASUREITEMSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMEASUREITEMSTRUCT>())).CtlType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMEASUREITEMSTRUCT),
      "::",
      stringify!(CtlType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMEASUREITEMSTRUCT>())).CtlID as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMEASUREITEMSTRUCT),
      "::",
      stringify!(CtlID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMEASUREITEMSTRUCT>())).itemID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMEASUREITEMSTRUCT),
      "::",
      stringify!(itemID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMEASUREITEMSTRUCT>())).itemWidth as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMEASUREITEMSTRUCT),
      "::",
      stringify!(itemWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMEASUREITEMSTRUCT>())).itemHeight as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMEASUREITEMSTRUCT),
      "::",
      stringify!(itemHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMEASUREITEMSTRUCT>())).itemData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMEASUREITEMSTRUCT),
      "::",
      stringify!(itemData)
    )
  );
}
pub type MEASUREITEMSTRUCT = tagMEASUREITEMSTRUCT;
pub type PMEASUREITEMSTRUCT = *mut tagMEASUREITEMSTRUCT;
pub type LPMEASUREITEMSTRUCT = *mut tagMEASUREITEMSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagDRAWITEMSTRUCT {
  pub CtlType: UINT,
  pub CtlID: UINT,
  pub itemID: UINT,
  pub itemAction: UINT,
  pub itemState: UINT,
  pub hwndItem: HWND,
  pub hDC: HDC,
  pub rcItem: RECT,
  pub itemData: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagDRAWITEMSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagDRAWITEMSTRUCT>(),
    64usize,
    concat!("Size of: ", stringify!(tagDRAWITEMSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDRAWITEMSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDRAWITEMSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).CtlType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(CtlType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).CtlID as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(CtlID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).itemID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(itemID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).itemAction as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(itemAction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).itemState as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(itemState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).hwndItem as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(hwndItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).hDC as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(hDC)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).rcItem as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(rcItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWITEMSTRUCT>())).itemData as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWITEMSTRUCT),
      "::",
      stringify!(itemData)
    )
  );
}
impl Default for tagDRAWITEMSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DRAWITEMSTRUCT = tagDRAWITEMSTRUCT;
pub type PDRAWITEMSTRUCT = *mut tagDRAWITEMSTRUCT;
pub type LPDRAWITEMSTRUCT = *mut tagDRAWITEMSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagDELETEITEMSTRUCT {
  pub CtlType: UINT,
  pub CtlID: UINT,
  pub itemID: UINT,
  pub hwndItem: HWND,
  pub itemData: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagDELETEITEMSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagDELETEITEMSTRUCT>(),
    32usize,
    concat!("Size of: ", stringify!(tagDELETEITEMSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDELETEITEMSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDELETEITEMSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDELETEITEMSTRUCT>())).CtlType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDELETEITEMSTRUCT),
      "::",
      stringify!(CtlType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDELETEITEMSTRUCT>())).CtlID as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDELETEITEMSTRUCT),
      "::",
      stringify!(CtlID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDELETEITEMSTRUCT>())).itemID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDELETEITEMSTRUCT),
      "::",
      stringify!(itemID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDELETEITEMSTRUCT>())).hwndItem as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDELETEITEMSTRUCT),
      "::",
      stringify!(hwndItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDELETEITEMSTRUCT>())).itemData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDELETEITEMSTRUCT),
      "::",
      stringify!(itemData)
    )
  );
}
impl Default for tagDELETEITEMSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DELETEITEMSTRUCT = tagDELETEITEMSTRUCT;
pub type PDELETEITEMSTRUCT = *mut tagDELETEITEMSTRUCT;
pub type LPDELETEITEMSTRUCT = *mut tagDELETEITEMSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCOMPAREITEMSTRUCT {
  pub CtlType: UINT,
  pub CtlID: UINT,
  pub hwndItem: HWND,
  pub itemID1: UINT,
  pub itemData1: ULONG_PTR,
  pub itemID2: UINT,
  pub itemData2: ULONG_PTR,
  pub dwLocaleId: DWORD,
}
#[test]
fn bindgen_test_layout_tagCOMPAREITEMSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCOMPAREITEMSTRUCT>(),
    56usize,
    concat!("Size of: ", stringify!(tagCOMPAREITEMSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOMPAREITEMSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCOMPAREITEMSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).CtlType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(CtlType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).CtlID as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(CtlID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).hwndItem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(hwndItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).itemID1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(itemID1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).itemData1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(itemData1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).itemID2 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(itemID2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).itemData2 as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(itemData2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPAREITEMSTRUCT>())).dwLocaleId as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPAREITEMSTRUCT),
      "::",
      stringify!(dwLocaleId)
    )
  );
}
impl Default for tagCOMPAREITEMSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type COMPAREITEMSTRUCT = tagCOMPAREITEMSTRUCT;
pub type PCOMPAREITEMSTRUCT = *mut tagCOMPAREITEMSTRUCT;
pub type LPCOMPAREITEMSTRUCT = *mut tagCOMPAREITEMSTRUCT;
extern "C" {
  pub fn GetMessageA(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT) -> BOOL;
}
extern "C" {
  pub fn GetMessageW(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT) -> BOOL;
}
extern "C" {
  pub fn TranslateMessage(lpMsg: *const MSG) -> BOOL;
}
extern "C" {
  pub fn DispatchMessageA(lpMsg: *const MSG) -> LRESULT;
}
extern "C" {
  pub fn DispatchMessageW(lpMsg: *const MSG) -> LRESULT;
}
extern "C" {
  pub fn SetMessageQueue(cMessagesMax: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn PeekMessageA(
    lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT, wRemoveMsg: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn PeekMessageW(
    lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT, wRemoveMsg: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn RegisterHotKey(hWnd: HWND, id: libc::c_int, fsModifiers: UINT, vk: UINT) -> BOOL;
}
extern "C" {
  pub fn UnregisterHotKey(hWnd: HWND, id: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn ExitWindowsEx(uFlags: UINT, dwReason: DWORD) -> BOOL;
}
extern "C" {
  pub fn SwapMouseButton(fSwap: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetMessagePos() -> DWORD;
}
extern "C" {
  pub fn GetMessageTime() -> LONG;
}
extern "C" {
  pub fn GetMessageExtraInfo() -> LPARAM;
}
extern "C" {
  pub fn GetUnpredictedMessagePos() -> DWORD;
}
extern "C" {
  pub fn IsWow64Message() -> BOOL;
}
extern "C" {
  pub fn SetMessageExtraInfo(lParam: LPARAM) -> LPARAM;
}
extern "C" {
  pub fn SendMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn SendMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn SendMessageTimeoutA(
    hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, fuFlags: UINT, uTimeout: UINT,
    lpdwResult: PDWORD_PTR,
  ) -> LRESULT;
}
extern "C" {
  pub fn SendMessageTimeoutW(
    hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, fuFlags: UINT, uTimeout: UINT,
    lpdwResult: PDWORD_PTR,
  ) -> LRESULT;
}
extern "C" {
  pub fn SendNotifyMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn SendNotifyMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn SendMessageCallbackA(
    hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, lpResultCallBack: SENDASYNCPROC,
    dwData: ULONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn SendMessageCallbackW(
    hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, lpResultCallBack: SENDASYNCPROC,
    dwData: ULONG_PTR,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct BSMINFO {
  pub cbSize: UINT,
  pub hdesk: HDESK,
  pub hwnd: HWND,
  pub luid: LUID,
}
#[test]
fn bindgen_test_layout_BSMINFO() {
  assert_eq!(
    ::core::mem::size_of::<BSMINFO>(),
    32usize,
    concat!("Size of: ", stringify!(BSMINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<BSMINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(BSMINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BSMINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(BSMINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BSMINFO>())).hdesk as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(BSMINFO),
      "::",
      stringify!(hdesk)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BSMINFO>())).hwnd as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(BSMINFO),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<BSMINFO>())).luid as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(BSMINFO),
      "::",
      stringify!(luid)
    )
  );
}
impl Default for BSMINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PBSMINFO = *mut BSMINFO;
extern "C" {
  pub fn BroadcastSystemMessageExA(
    flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM, pbsmInfo: PBSMINFO,
  ) -> libc::c_long;
}
extern "C" {
  pub fn BroadcastSystemMessageExW(
    flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM, pbsmInfo: PBSMINFO,
  ) -> libc::c_long;
}
extern "C" {
  pub fn BroadcastSystemMessageA(
    flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> libc::c_long;
}
extern "C" {
  pub fn BroadcastSystemMessageW(
    flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> libc::c_long;
}
pub type HDEVNOTIFY = PVOID;
pub type PHDEVNOTIFY = *mut HDEVNOTIFY;
extern "C" {
  pub fn RegisterDeviceNotificationA(
    hRecipient: HANDLE, NotificationFilter: LPVOID, Flags: DWORD,
  ) -> HDEVNOTIFY;
}
extern "C" {
  pub fn RegisterDeviceNotificationW(
    hRecipient: HANDLE, NotificationFilter: LPVOID, Flags: DWORD,
  ) -> HDEVNOTIFY;
}
extern "C" {
  pub fn UnregisterDeviceNotification(Handle: HDEVNOTIFY) -> BOOL;
}
pub type HPOWERNOTIFY = PVOID;
pub type PHPOWERNOTIFY = *mut HPOWERNOTIFY;
extern "C" {
  pub fn RegisterPowerSettingNotification(
    hRecipient: HANDLE, PowerSettingGuid: LPCGUID, Flags: DWORD,
  ) -> HPOWERNOTIFY;
}
extern "C" {
  pub fn UnregisterPowerSettingNotification(Handle: HPOWERNOTIFY) -> BOOL;
}
extern "C" {
  pub fn RegisterSuspendResumeNotification(hRecipient: HANDLE, Flags: DWORD) -> HPOWERNOTIFY;
}
extern "C" {
  pub fn UnregisterSuspendResumeNotification(Handle: HPOWERNOTIFY) -> BOOL;
}
extern "C" {
  pub fn PostMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn PostMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn PostThreadMessageA(idThread: DWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn PostThreadMessageW(idThread: DWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn AttachThreadInput(idAttach: DWORD, idAttachTo: DWORD, fAttach: BOOL) -> BOOL;
}
extern "C" {
  pub fn ReplyMessage(lResult: LRESULT) -> BOOL;
}
extern "C" {
  pub fn WaitMessage() -> BOOL;
}
extern "C" {
  pub fn WaitForInputIdle(hProcess: HANDLE, dwMilliseconds: DWORD) -> DWORD;
}
extern "C" {
  pub fn DefWindowProcA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn DefWindowProcW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn PostQuitMessage(nExitCode: libc::c_int);
}
extern "C" {
  pub fn CallWindowProcA(
    lpPrevWndFunc: WNDPROC, hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> LRESULT;
}
extern "C" {
  pub fn CallWindowProcW(
    lpPrevWndFunc: WNDPROC, hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> LRESULT;
}
extern "C" {
  pub fn InSendMessage() -> BOOL;
}
extern "C" {
  pub fn InSendMessageEx(lpReserved: LPVOID) -> DWORD;
}
extern "C" {
  pub fn GetDoubleClickTime() -> UINT;
}
extern "C" {
  pub fn SetDoubleClickTime(arg1: UINT) -> BOOL;
}
extern "C" {
  pub fn RegisterClassA(lpWndClass: *const WNDCLASSA) -> ATOM;
}
extern "C" {
  pub fn RegisterClassW(lpWndClass: *const WNDCLASSW) -> ATOM;
}
extern "C" {
  pub fn UnregisterClassA(lpClassName: LPCSTR, hInstance: HINSTANCE) -> BOOL;
}
extern "C" {
  pub fn UnregisterClassW(lpClassName: LPCWSTR, hInstance: HINSTANCE) -> BOOL;
}
extern "C" {
  pub fn GetClassInfoA(hInstance: HINSTANCE, lpClassName: LPCSTR, lpWndClass: LPWNDCLASSA) -> BOOL;
}
extern "C" {
  pub fn GetClassInfoW(hInstance: HINSTANCE, lpClassName: LPCWSTR, lpWndClass: LPWNDCLASSW)
    -> BOOL;
}
extern "C" {
  pub fn RegisterClassExA(arg1: *const WNDCLASSEXA) -> ATOM;
}
extern "C" {
  pub fn RegisterClassExW(arg1: *const WNDCLASSEXW) -> ATOM;
}
extern "C" {
  pub fn GetClassInfoExA(hInstance: HINSTANCE, lpszClass: LPCSTR, lpwcx: LPWNDCLASSEXA) -> BOOL;
}
extern "C" {
  pub fn GetClassInfoExW(hInstance: HINSTANCE, lpszClass: LPCWSTR, lpwcx: LPWNDCLASSEXW) -> BOOL;
}
pub type PREGISTERCLASSNAMEW =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPCWSTR) -> BOOLEAN>;
extern "C" {
  pub fn CreateWindowExA(
    dwExStyle: DWORD, lpClassName: LPCSTR, lpWindowName: LPCSTR, dwStyle: DWORD, X: libc::c_int,
    Y: libc::c_int, nWidth: libc::c_int, nHeight: libc::c_int, hWndParent: HWND, hMenu: HMENU,
    hInstance: HINSTANCE, lpParam: LPVOID,
  ) -> HWND;
}
extern "C" {
  pub fn CreateWindowExW(
    dwExStyle: DWORD, lpClassName: LPCWSTR, lpWindowName: LPCWSTR, dwStyle: DWORD, X: libc::c_int,
    Y: libc::c_int, nWidth: libc::c_int, nHeight: libc::c_int, hWndParent: HWND, hMenu: HMENU,
    hInstance: HINSTANCE, lpParam: LPVOID,
  ) -> HWND;
}
extern "C" {
  pub fn IsWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn IsMenu(hMenu: HMENU) -> BOOL;
}
extern "C" {
  pub fn IsChild(hWndParent: HWND, hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn DestroyWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn ShowWindow(hWnd: HWND, nCmdShow: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn AnimateWindow(hWnd: HWND, dwTime: DWORD, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn UpdateLayeredWindow(
    hWnd: HWND, hdcDst: HDC, pptDst: *mut POINT, psize: *mut SIZE, hdcSrc: HDC, pptSrc: *mut POINT,
    crKey: COLORREF, pblend: *mut BLENDFUNCTION, dwFlags: DWORD,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagUPDATELAYEREDWINDOWINFO {
  pub cbSize: DWORD,
  pub hdcDst: HDC,
  pub pptDst: *const POINT,
  pub psize: *const SIZE,
  pub hdcSrc: HDC,
  pub pptSrc: *const POINT,
  pub crKey: COLORREF,
  pub pblend: *const BLENDFUNCTION,
  pub dwFlags: DWORD,
  pub prcDirty: *const RECT,
}
#[test]
fn bindgen_test_layout_tagUPDATELAYEREDWINDOWINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagUPDATELAYEREDWINDOWINFO>(),
    80usize,
    concat!("Size of: ", stringify!(tagUPDATELAYEREDWINDOWINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagUPDATELAYEREDWINDOWINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagUPDATELAYEREDWINDOWINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).hdcDst as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(hdcDst)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).pptDst as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(pptDst)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).psize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(psize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).hdcSrc as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(hdcSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).pptSrc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(pptSrc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).crKey as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(crKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).pblend as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(pblend)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).dwFlags as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagUPDATELAYEREDWINDOWINFO>())).prcDirty as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUPDATELAYEREDWINDOWINFO),
      "::",
      stringify!(prcDirty)
    )
  );
}
impl Default for tagUPDATELAYEREDWINDOWINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UPDATELAYEREDWINDOWINFO = tagUPDATELAYEREDWINDOWINFO;
pub type PUPDATELAYEREDWINDOWINFO = *mut tagUPDATELAYEREDWINDOWINFO;
extern "C" {
  pub fn UpdateLayeredWindowIndirect(hWnd: HWND, pULWInfo: *const UPDATELAYEREDWINDOWINFO) -> BOOL;
}
extern "C" {
  pub fn GetLayeredWindowAttributes(
    hwnd: HWND, pcrKey: *mut COLORREF, pbAlpha: *mut BYTE, pdwFlags: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn PrintWindow(hwnd: HWND, hdcBlt: HDC, nFlags: UINT) -> BOOL;
}
extern "C" {
  pub fn SetLayeredWindowAttributes(
    hwnd: HWND, crKey: COLORREF, bAlpha: BYTE, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ShowWindowAsync(hWnd: HWND, nCmdShow: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn FlashWindow(hWnd: HWND, bInvert: BOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct FLASHWINFO {
  pub cbSize: UINT,
  pub hwnd: HWND,
  pub dwFlags: DWORD,
  pub uCount: UINT,
  pub dwTimeout: DWORD,
}
#[test]
fn bindgen_test_layout_FLASHWINFO() {
  assert_eq!(
    ::core::mem::size_of::<FLASHWINFO>(),
    32usize,
    concat!("Size of: ", stringify!(FLASHWINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<FLASHWINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(FLASHWINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FLASHWINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLASHWINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FLASHWINFO>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLASHWINFO),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FLASHWINFO>())).dwFlags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLASHWINFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FLASHWINFO>())).uCount as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(FLASHWINFO),
      "::",
      stringify!(uCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<FLASHWINFO>())).dwTimeout as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLASHWINFO),
      "::",
      stringify!(dwTimeout)
    )
  );
}
impl Default for FLASHWINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PFLASHWINFO = *mut FLASHWINFO;
extern "C" {
  pub fn FlashWindowEx(pfwi: PFLASHWINFO) -> BOOL;
}
extern "C" {
  pub fn ShowOwnedPopups(hWnd: HWND, fShow: BOOL) -> BOOL;
}
extern "C" {
  pub fn OpenIcon(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn CloseWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn MoveWindow(
    hWnd: HWND, X: libc::c_int, Y: libc::c_int, nWidth: libc::c_int, nHeight: libc::c_int,
    bRepaint: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetWindowPos(
    hWnd: HWND, hWndInsertAfter: HWND, X: libc::c_int, Y: libc::c_int, cx: libc::c_int,
    cy: libc::c_int, uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetWindowPlacement(hWnd: HWND, lpwndpl: *mut WINDOWPLACEMENT) -> BOOL;
}
extern "C" {
  pub fn SetWindowPlacement(hWnd: HWND, lpwndpl: *const WINDOWPLACEMENT) -> BOOL;
}
extern "C" {
  pub fn GetWindowDisplayAffinity(hWnd: HWND, pdwAffinity: *mut DWORD) -> BOOL;
}
extern "C" {
  pub fn SetWindowDisplayAffinity(hWnd: HWND, dwAffinity: DWORD) -> BOOL;
}
extern "C" {
  pub fn BeginDeferWindowPos(nNumWindows: libc::c_int) -> HDWP;
}
extern "C" {
  pub fn DeferWindowPos(
    hWinPosInfo: HDWP, hWnd: HWND, hWndInsertAfter: HWND, x: libc::c_int, y: libc::c_int,
    cx: libc::c_int, cy: libc::c_int, uFlags: UINT,
  ) -> HDWP;
}
extern "C" {
  pub fn EndDeferWindowPos(hWinPosInfo: HDWP) -> BOOL;
}
extern "C" {
  pub fn IsWindowVisible(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn IsIconic(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn AnyPopup() -> BOOL;
}
extern "C" {
  pub fn BringWindowToTop(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn IsZoomed(hWnd: HWND) -> BOOL;
}
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DLGTEMPLATE {
  pub style: DWORD,
  pub dwExtendedStyle: DWORD,
  pub cdit: WORD,
  pub x: libc::c_short,
  pub y: libc::c_short,
  pub cx: libc::c_short,
  pub cy: libc::c_short,
}
#[test]
fn bindgen_test_layout_DLGTEMPLATE() {
  assert_eq!(
    ::core::mem::size_of::<DLGTEMPLATE>(),
    18usize,
    concat!("Size of: ", stringify!(DLGTEMPLATE))
  );
  assert_eq!(
    ::core::mem::align_of::<DLGTEMPLATE>(),
    2usize,
    concat!("Alignment of ", stringify!(DLGTEMPLATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).style as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).dwExtendedStyle as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(dwExtendedStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).cdit as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(cdit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).x as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).y as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).cx as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGTEMPLATE>())).cy as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGTEMPLATE),
      "::",
      stringify!(cy)
    )
  );
}
pub type LPDLGTEMPLATEA = *mut DLGTEMPLATE;
pub type LPDLGTEMPLATEW = *mut DLGTEMPLATE;
pub type LPDLGTEMPLATE = LPDLGTEMPLATEA;
pub type LPCDLGTEMPLATEA = *const DLGTEMPLATE;
pub type LPCDLGTEMPLATEW = *const DLGTEMPLATE;
pub type LPCDLGTEMPLATE = LPCDLGTEMPLATEA;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct DLGITEMTEMPLATE {
  pub style: DWORD,
  pub dwExtendedStyle: DWORD,
  pub x: libc::c_short,
  pub y: libc::c_short,
  pub cx: libc::c_short,
  pub cy: libc::c_short,
  pub id: WORD,
}
#[test]
fn bindgen_test_layout_DLGITEMTEMPLATE() {
  assert_eq!(
    ::core::mem::size_of::<DLGITEMTEMPLATE>(),
    18usize,
    concat!("Size of: ", stringify!(DLGITEMTEMPLATE))
  );
  assert_eq!(
    ::core::mem::align_of::<DLGITEMTEMPLATE>(),
    2usize,
    concat!("Alignment of ", stringify!(DLGITEMTEMPLATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).style as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).dwExtendedStyle as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(dwExtendedStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).x as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).y as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).cx as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).cy as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<DLGITEMTEMPLATE>())).id as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(DLGITEMTEMPLATE),
      "::",
      stringify!(id)
    )
  );
}
pub type PDLGITEMTEMPLATEA = *mut DLGITEMTEMPLATE;
pub type PDLGITEMTEMPLATEW = *mut DLGITEMTEMPLATE;
pub type PDLGITEMTEMPLATE = PDLGITEMTEMPLATEA;
pub type LPDLGITEMTEMPLATEA = *mut DLGITEMTEMPLATE;
pub type LPDLGITEMTEMPLATEW = *mut DLGITEMTEMPLATE;
pub type LPDLGITEMTEMPLATE = LPDLGITEMTEMPLATEA;
extern "C" {
  pub fn CreateDialogParamA(
    hInstance: HINSTANCE, lpTemplateName: LPCSTR, hWndParent: HWND, lpDialogFunc: DLGPROC,
    dwInitParam: LPARAM,
  ) -> HWND;
}
extern "C" {
  pub fn CreateDialogParamW(
    hInstance: HINSTANCE, lpTemplateName: LPCWSTR, hWndParent: HWND, lpDialogFunc: DLGPROC,
    dwInitParam: LPARAM,
  ) -> HWND;
}
extern "C" {
  pub fn CreateDialogIndirectParamA(
    hInstance: HINSTANCE, lpTemplate: LPCDLGTEMPLATEA, hWndParent: HWND, lpDialogFunc: DLGPROC,
    dwInitParam: LPARAM,
  ) -> HWND;
}
extern "C" {
  pub fn CreateDialogIndirectParamW(
    hInstance: HINSTANCE, lpTemplate: LPCDLGTEMPLATEW, hWndParent: HWND, lpDialogFunc: DLGPROC,
    dwInitParam: LPARAM,
  ) -> HWND;
}
extern "C" {
  pub fn DialogBoxParamA(
    hInstance: HINSTANCE, lpTemplateName: LPCSTR, hWndParent: HWND, lpDialogFunc: DLGPROC,
    dwInitParam: LPARAM,
  ) -> INT_PTR;
}
extern "C" {
  pub fn DialogBoxParamW(
    hInstance: HINSTANCE, lpTemplateName: LPCWSTR, hWndParent: HWND, lpDialogFunc: DLGPROC,
    dwInitParam: LPARAM,
  ) -> INT_PTR;
}
extern "C" {
  pub fn DialogBoxIndirectParamA(
    hInstance: HINSTANCE, hDialogTemplate: LPCDLGTEMPLATEA, hWndParent: HWND,
    lpDialogFunc: DLGPROC, dwInitParam: LPARAM,
  ) -> INT_PTR;
}
extern "C" {
  pub fn DialogBoxIndirectParamW(
    hInstance: HINSTANCE, hDialogTemplate: LPCDLGTEMPLATEW, hWndParent: HWND,
    lpDialogFunc: DLGPROC, dwInitParam: LPARAM,
  ) -> INT_PTR;
}
extern "C" {
  pub fn EndDialog(hDlg: HWND, nResult: INT_PTR) -> BOOL;
}
extern "C" {
  pub fn GetDlgItem(hDlg: HWND, nIDDlgItem: libc::c_int) -> HWND;
}
extern "C" {
  pub fn SetDlgItemInt(hDlg: HWND, nIDDlgItem: libc::c_int, uValue: UINT, bSigned: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetDlgItemInt(
    hDlg: HWND, nIDDlgItem: libc::c_int, lpTranslated: *mut BOOL, bSigned: BOOL,
  ) -> UINT;
}
extern "C" {
  pub fn SetDlgItemTextA(hDlg: HWND, nIDDlgItem: libc::c_int, lpString: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetDlgItemTextW(hDlg: HWND, nIDDlgItem: libc::c_int, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetDlgItemTextA(
    hDlg: HWND, nIDDlgItem: libc::c_int, lpString: LPSTR, cchMax: libc::c_int,
  ) -> UINT;
}
extern "C" {
  pub fn GetDlgItemTextW(
    hDlg: HWND, nIDDlgItem: libc::c_int, lpString: LPWSTR, cchMax: libc::c_int,
  ) -> UINT;
}
extern "C" {
  pub fn CheckDlgButton(hDlg: HWND, nIDButton: libc::c_int, uCheck: UINT) -> BOOL;
}
extern "C" {
  pub fn CheckRadioButton(
    hDlg: HWND, nIDFirstButton: libc::c_int, nIDLastButton: libc::c_int,
    nIDCheckButton: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn IsDlgButtonChecked(hDlg: HWND, nIDButton: libc::c_int) -> UINT;
}
extern "C" {
  pub fn SendDlgItemMessageA(
    hDlg: HWND, nIDDlgItem: libc::c_int, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> LRESULT;
}
extern "C" {
  pub fn SendDlgItemMessageW(
    hDlg: HWND, nIDDlgItem: libc::c_int, Msg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> LRESULT;
}
extern "C" {
  pub fn GetNextDlgGroupItem(hDlg: HWND, hCtl: HWND, bPrevious: BOOL) -> HWND;
}
extern "C" {
  pub fn GetNextDlgTabItem(hDlg: HWND, hCtl: HWND, bPrevious: BOOL) -> HWND;
}
extern "C" {
  pub fn GetDlgCtrlID(hWnd: HWND) -> libc::c_int;
}
extern "C" {
  pub fn GetDialogBaseUnits() -> libc::c_long;
}
extern "C" {
  pub fn DefDlgProcA(hDlg: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn DefDlgProcW(hDlg: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
pub mod DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
  pub type Type = i32;
  pub const DCDC_DEFAULT: Type = 0;
  pub const DCDC_DISABLE_FONT_UPDATE: Type = 1;
  pub const DCDC_DISABLE_RELAYOUT: Type = 2;
}
extern "C" {
  pub fn SetDialogControlDpiChangeBehavior(
    hWnd: HWND, mask: DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS::Type,
    values: DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS::Type,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDialogControlDpiChangeBehavior(hWnd: HWND)
    -> DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS::Type;
}
pub mod DIALOG_DPI_CHANGE_BEHAVIORS {
  pub type Type = i32;
  pub const DDC_DEFAULT: Type = 0;
  pub const DDC_DISABLE_ALL: Type = 1;
  pub const DDC_DISABLE_RESIZE: Type = 2;
  pub const DDC_DISABLE_CONTROL_RELAYOUT: Type = 4;
}
extern "C" {
  pub fn SetDialogDpiChangeBehavior(
    hDlg: HWND, mask: DIALOG_DPI_CHANGE_BEHAVIORS::Type, values: DIALOG_DPI_CHANGE_BEHAVIORS::Type,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDialogDpiChangeBehavior(hDlg: HWND) -> DIALOG_DPI_CHANGE_BEHAVIORS::Type;
}
extern "C" {
  pub fn CallMsgFilterA(lpMsg: LPMSG, nCode: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn CallMsgFilterW(lpMsg: LPMSG, nCode: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn OpenClipboard(hWndNewOwner: HWND) -> BOOL;
}
extern "C" {
  pub fn CloseClipboard() -> BOOL;
}
extern "C" {
  pub fn GetClipboardSequenceNumber() -> DWORD;
}
extern "C" {
  pub fn GetClipboardOwner() -> HWND;
}
extern "C" {
  pub fn SetClipboardViewer(hWndNewViewer: HWND) -> HWND;
}
extern "C" {
  pub fn GetClipboardViewer() -> HWND;
}
extern "C" {
  pub fn ChangeClipboardChain(hWndRemove: HWND, hWndNewNext: HWND) -> BOOL;
}
extern "C" {
  pub fn SetClipboardData(uFormat: UINT, hMem: HANDLE) -> HANDLE;
}
extern "C" {
  pub fn GetClipboardData(uFormat: UINT) -> HANDLE;
}
extern "C" {
  pub fn RegisterClipboardFormatA(lpszFormat: LPCSTR) -> UINT;
}
extern "C" {
  pub fn RegisterClipboardFormatW(lpszFormat: LPCWSTR) -> UINT;
}
extern "C" {
  pub fn CountClipboardFormats() -> libc::c_int;
}
extern "C" {
  pub fn EnumClipboardFormats(format: UINT) -> UINT;
}
extern "C" {
  pub fn GetClipboardFormatNameA(
    format: UINT, lpszFormatName: LPSTR, cchMaxCount: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetClipboardFormatNameW(
    format: UINT, lpszFormatName: LPWSTR, cchMaxCount: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EmptyClipboard() -> BOOL;
}
extern "C" {
  pub fn IsClipboardFormatAvailable(format: UINT) -> BOOL;
}
extern "C" {
  pub fn GetPriorityClipboardFormat(
    paFormatPriorityList: *mut UINT, cFormats: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetOpenClipboardWindow() -> HWND;
}
extern "C" {
  pub fn AddClipboardFormatListener(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn RemoveClipboardFormatListener(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn GetUpdatedClipboardFormats(
    lpuiFormats: PUINT, cFormats: UINT, pcFormatsOut: PUINT,
  ) -> BOOL;
}
extern "C" {
  pub fn CharToOemA(pSrc: LPCSTR, pDst: LPSTR) -> BOOL;
}
extern "C" {
  pub fn CharToOemW(pSrc: LPCWSTR, pDst: LPSTR) -> BOOL;
}
extern "C" {
  pub fn OemToCharA(pSrc: LPCSTR, pDst: LPSTR) -> BOOL;
}
extern "C" {
  pub fn OemToCharW(pSrc: LPCSTR, pDst: LPWSTR) -> BOOL;
}
extern "C" {
  pub fn CharToOemBuffA(lpszSrc: LPCSTR, lpszDst: LPSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
  pub fn CharToOemBuffW(lpszSrc: LPCWSTR, lpszDst: LPSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
  pub fn OemToCharBuffA(lpszSrc: LPCSTR, lpszDst: LPSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
  pub fn OemToCharBuffW(lpszSrc: LPCSTR, lpszDst: LPWSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
  pub fn CharUpperA(lpsz: LPSTR) -> LPSTR;
}
extern "C" {
  pub fn CharUpperW(lpsz: LPWSTR) -> LPWSTR;
}
extern "C" {
  pub fn CharUpperBuffA(lpsz: LPSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
  pub fn CharUpperBuffW(lpsz: LPWSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
  pub fn CharLowerA(lpsz: LPSTR) -> LPSTR;
}
extern "C" {
  pub fn CharLowerW(lpsz: LPWSTR) -> LPWSTR;
}
extern "C" {
  pub fn CharLowerBuffA(lpsz: LPSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
  pub fn CharLowerBuffW(lpsz: LPWSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
  pub fn CharNextA(lpsz: LPCSTR) -> LPSTR;
}
extern "C" {
  pub fn CharNextW(lpsz: LPCWSTR) -> LPWSTR;
}
extern "C" {
  pub fn CharPrevA(lpszStart: LPCSTR, lpszCurrent: LPCSTR) -> LPSTR;
}
extern "C" {
  pub fn CharPrevW(lpszStart: LPCWSTR, lpszCurrent: LPCWSTR) -> LPWSTR;
}
extern "C" {
  pub fn CharNextExA(CodePage: WORD, lpCurrentChar: LPCSTR, dwFlags: DWORD) -> LPSTR;
}
extern "C" {
  pub fn CharPrevExA(
    CodePage: WORD, lpStart: LPCSTR, lpCurrentChar: LPCSTR, dwFlags: DWORD,
  ) -> LPSTR;
}
extern "C" {
  pub fn IsCharAlphaA(ch: CHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharAlphaW(ch: WCHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharAlphaNumericA(ch: CHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharAlphaNumericW(ch: WCHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharUpperA(ch: CHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharUpperW(ch: WCHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharLowerA(ch: CHAR) -> BOOL;
}
extern "C" {
  pub fn IsCharLowerW(ch: WCHAR) -> BOOL;
}
extern "C" {
  pub fn SetFocus(hWnd: HWND) -> HWND;
}
extern "C" {
  pub fn GetActiveWindow() -> HWND;
}
extern "C" {
  pub fn GetFocus() -> HWND;
}
extern "C" {
  pub fn GetKBCodePage() -> UINT;
}
extern "C" {
  pub fn GetKeyState(nVirtKey: libc::c_int) -> SHORT;
}
extern "C" {
  pub fn GetAsyncKeyState(vKey: libc::c_int) -> SHORT;
}
extern "C" {
  pub fn GetKeyboardState(lpKeyState: PBYTE) -> BOOL;
}
extern "C" {
  pub fn SetKeyboardState(lpKeyState: LPBYTE) -> BOOL;
}
extern "C" {
  pub fn GetKeyNameTextA(lParam: LONG, lpString: LPSTR, cchSize: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetKeyNameTextW(lParam: LONG, lpString: LPWSTR, cchSize: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetKeyboardType(nTypeFlag: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn ToAscii(
    uVirtKey: UINT, uScanCode: UINT, lpKeyState: *const BYTE, lpChar: LPWORD, uFlags: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn ToAsciiEx(
    uVirtKey: UINT, uScanCode: UINT, lpKeyState: *const BYTE, lpChar: LPWORD, uFlags: UINT,
    dwhkl: HKL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn ToUnicode(
    wVirtKey: UINT, wScanCode: UINT, lpKeyState: *const BYTE, pwszBuff: LPWSTR,
    cchBuff: libc::c_int, wFlags: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn OemKeyScan(wOemChar: WORD) -> DWORD;
}
extern "C" {
  pub fn VkKeyScanA(ch: CHAR) -> SHORT;
}
extern "C" {
  pub fn VkKeyScanW(ch: WCHAR) -> SHORT;
}
extern "C" {
  pub fn VkKeyScanExA(ch: CHAR, dwhkl: HKL) -> SHORT;
}
extern "C" {
  pub fn VkKeyScanExW(ch: WCHAR, dwhkl: HKL) -> SHORT;
}
extern "C" {
  pub fn keybd_event(bVk: BYTE, bScan: BYTE, dwFlags: DWORD, dwExtraInfo: ULONG_PTR);
}
extern "C" {
  pub fn mouse_event(dwFlags: DWORD, dx: DWORD, dy: DWORD, dwData: DWORD, dwExtraInfo: ULONG_PTR);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMOUSEINPUT {
  pub dx: LONG,
  pub dy: LONG,
  pub mouseData: DWORD,
  pub dwFlags: DWORD,
  pub time: DWORD,
  pub dwExtraInfo: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagMOUSEINPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagMOUSEINPUT>(),
    32usize,
    concat!("Size of: ", stringify!(tagMOUSEINPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMOUSEINPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMOUSEINPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEINPUT>())).dx as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEINPUT),
      "::",
      stringify!(dx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEINPUT>())).dy as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEINPUT),
      "::",
      stringify!(dy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEINPUT>())).mouseData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEINPUT),
      "::",
      stringify!(mouseData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEINPUT>())).dwFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEINPUT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEINPUT>())).time as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEINPUT),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEINPUT>())).dwExtraInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEINPUT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
}
pub type MOUSEINPUT = tagMOUSEINPUT;
pub type PMOUSEINPUT = *mut tagMOUSEINPUT;
pub type LPMOUSEINPUT = *mut tagMOUSEINPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagKEYBDINPUT {
  pub wVk: WORD,
  pub wScan: WORD,
  pub dwFlags: DWORD,
  pub time: DWORD,
  pub dwExtraInfo: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagKEYBDINPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagKEYBDINPUT>(),
    24usize,
    concat!("Size of: ", stringify!(tagKEYBDINPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagKEYBDINPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagKEYBDINPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKEYBDINPUT>())).wVk as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKEYBDINPUT),
      "::",
      stringify!(wVk)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKEYBDINPUT>())).wScan as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKEYBDINPUT),
      "::",
      stringify!(wScan)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKEYBDINPUT>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKEYBDINPUT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKEYBDINPUT>())).time as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKEYBDINPUT),
      "::",
      stringify!(time)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagKEYBDINPUT>())).dwExtraInfo as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagKEYBDINPUT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
}
pub type KEYBDINPUT = tagKEYBDINPUT;
pub type PKEYBDINPUT = *mut tagKEYBDINPUT;
pub type LPKEYBDINPUT = *mut tagKEYBDINPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagHARDWAREINPUT {
  pub uMsg: DWORD,
  pub wParamL: WORD,
  pub wParamH: WORD,
}
#[test]
fn bindgen_test_layout_tagHARDWAREINPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagHARDWAREINPUT>(),
    8usize,
    concat!("Size of: ", stringify!(tagHARDWAREINPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHARDWAREINPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagHARDWAREINPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREINPUT>())).uMsg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREINPUT),
      "::",
      stringify!(uMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREINPUT>())).wParamL as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREINPUT),
      "::",
      stringify!(wParamL)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHARDWAREINPUT>())).wParamH as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHARDWAREINPUT),
      "::",
      stringify!(wParamH)
    )
  );
}
pub type HARDWAREINPUT = tagHARDWAREINPUT;
pub type PHARDWAREINPUT = *mut tagHARDWAREINPUT;
pub type LPHARDWAREINPUT = *mut tagHARDWAREINPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagINPUT {
  pub type_: DWORD,
  pub __bindgen_anon_1: tagINPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagINPUT__bindgen_ty_1 {
  pub mi: MOUSEINPUT,
  pub ki: KEYBDINPUT,
  pub hi: HARDWAREINPUT,
  _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_tagINPUT__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT__bindgen_ty_1>(),
    32usize,
    concat!("Size of: ", stringify!(tagINPUT__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagINPUT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT__bindgen_ty_1>())).mi as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT__bindgen_ty_1),
      "::",
      stringify!(mi)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT__bindgen_ty_1>())).ki as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT__bindgen_ty_1),
      "::",
      stringify!(ki)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT__bindgen_ty_1>())).hi as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT__bindgen_ty_1),
      "::",
      stringify!(hi)
    )
  );
}
impl Default for tagINPUT__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagINPUT__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "tagINPUT__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_tagINPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT>(),
    40usize,
    concat!("Size of: ", stringify!(tagINPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagINPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT),
      "::",
      stringify!(type_)
    )
  );
}
impl Default for tagINPUT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagINPUT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagINPUT {{ type: {:?}, __bindgen_anon_1: {:?} }}",
      self.type_, self.__bindgen_anon_1
    )
  }
}
pub type INPUT = tagINPUT;
pub type PINPUT = *mut tagINPUT;
pub type LPINPUT = *mut tagINPUT;
extern "C" {
  pub fn SendInput(cInputs: UINT, pInputs: LPINPUT, cbSize: libc::c_int) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HTOUCHINPUT__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HTOUCHINPUT__() {
  assert_eq!(
    ::core::mem::size_of::<HTOUCHINPUT__>(),
    4usize,
    concat!("Size of: ", stringify!(HTOUCHINPUT__))
  );
  assert_eq!(
    ::core::mem::align_of::<HTOUCHINPUT__>(),
    4usize,
    concat!("Alignment of ", stringify!(HTOUCHINPUT__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HTOUCHINPUT__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HTOUCHINPUT__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HTOUCHINPUT = *mut HTOUCHINPUT__;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagTOUCHINPUT {
  pub x: LONG,
  pub y: LONG,
  pub hSource: HANDLE,
  pub dwID: DWORD,
  pub dwFlags: DWORD,
  pub dwMask: DWORD,
  pub dwTime: DWORD,
  pub dwExtraInfo: ULONG_PTR,
  pub cxContact: DWORD,
  pub cyContact: DWORD,
}
#[test]
fn bindgen_test_layout_tagTOUCHINPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagTOUCHINPUT>(),
    48usize,
    concat!("Size of: ", stringify!(tagTOUCHINPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTOUCHINPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTOUCHINPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).y as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).hSource as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(hSource)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).dwID as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(dwID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).dwFlags as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).dwMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(dwMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).dwTime as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(dwTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).dwExtraInfo as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(dwExtraInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).cxContact as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(cxContact)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCHINPUT>())).cyContact as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCHINPUT),
      "::",
      stringify!(cyContact)
    )
  );
}
impl Default for tagTOUCHINPUT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type TOUCHINPUT = tagTOUCHINPUT;
pub type PTOUCHINPUT = *mut tagTOUCHINPUT;
pub type PCTOUCHINPUT = *const TOUCHINPUT;
extern "C" {
  pub fn GetTouchInputInfo(
    hTouchInput: HTOUCHINPUT, cInputs: UINT, pInputs: PTOUCHINPUT, cbSize: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn CloseTouchInputHandle(hTouchInput: HTOUCHINPUT) -> BOOL;
}
extern "C" {
  pub fn RegisterTouchWindow(hwnd: HWND, ulFlags: ULONG) -> BOOL;
}
extern "C" {
  pub fn UnregisterTouchWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn IsTouchWindow(hwnd: HWND, pulFlags: PULONG) -> BOOL;
}
pub mod tagPOINTER_INPUT_TYPE {
  pub type Type = i32;
  pub const PT_POINTER: Type = 1;
  pub const PT_TOUCH: Type = 2;
  pub const PT_PEN: Type = 3;
  pub const PT_MOUSE: Type = 4;
  pub const PT_TOUCHPAD: Type = 5;
}
pub type POINTER_INPUT_TYPE = DWORD;
pub type POINTER_FLAGS = UINT32;
pub mod tagPOINTER_BUTTON_CHANGE_TYPE {
  pub type Type = i32;
  pub const POINTER_CHANGE_NONE: Type = 0;
  pub const POINTER_CHANGE_FIRSTBUTTON_DOWN: Type = 1;
  pub const POINTER_CHANGE_FIRSTBUTTON_UP: Type = 2;
  pub const POINTER_CHANGE_SECONDBUTTON_DOWN: Type = 3;
  pub const POINTER_CHANGE_SECONDBUTTON_UP: Type = 4;
  pub const POINTER_CHANGE_THIRDBUTTON_DOWN: Type = 5;
  pub const POINTER_CHANGE_THIRDBUTTON_UP: Type = 6;
  pub const POINTER_CHANGE_FOURTHBUTTON_DOWN: Type = 7;
  pub const POINTER_CHANGE_FOURTHBUTTON_UP: Type = 8;
  pub const POINTER_CHANGE_FIFTHBUTTON_DOWN: Type = 9;
  pub const POINTER_CHANGE_FIFTHBUTTON_UP: Type = 10;
}
pub use self::tagPOINTER_BUTTON_CHANGE_TYPE::Type as POINTER_BUTTON_CHANGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPOINTER_INFO {
  pub pointerType: POINTER_INPUT_TYPE,
  pub pointerId: UINT32,
  pub frameId: UINT32,
  pub pointerFlags: POINTER_FLAGS,
  pub sourceDevice: HANDLE,
  pub hwndTarget: HWND,
  pub ptPixelLocation: POINT,
  pub ptHimetricLocation: POINT,
  pub ptPixelLocationRaw: POINT,
  pub ptHimetricLocationRaw: POINT,
  pub dwTime: DWORD,
  pub historyCount: UINT32,
  pub InputData: INT32,
  pub dwKeyStates: DWORD,
  pub PerformanceCount: UINT64,
  pub ButtonChangeType: POINTER_BUTTON_CHANGE_TYPE,
}
#[test]
fn bindgen_test_layout_tagPOINTER_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_INFO>(),
    96usize,
    concat!("Size of: ", stringify!(tagPOINTER_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOINTER_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).pointerType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(pointerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).pointerId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(pointerId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).frameId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(frameId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).pointerFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(pointerFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).sourceDevice as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(sourceDevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).hwndTarget as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(hwndTarget)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).ptPixelLocation as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(ptPixelLocation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).ptHimetricLocation as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(ptHimetricLocation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).ptPixelLocationRaw as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(ptPixelLocationRaw)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_INFO>())).ptHimetricLocationRaw as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(ptHimetricLocationRaw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).dwTime as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(dwTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).historyCount as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(historyCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).InputData as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(InputData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).dwKeyStates as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(dwKeyStates)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).PerformanceCount as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(PerformanceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_INFO>())).ButtonChangeType as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_INFO),
      "::",
      stringify!(ButtonChangeType)
    )
  );
}
impl Default for tagPOINTER_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POINTER_INFO = tagPOINTER_INFO;
pub type TOUCH_FLAGS = UINT32;
pub type TOUCH_MASK = UINT32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPOINTER_TOUCH_INFO {
  pub pointerInfo: POINTER_INFO,
  pub touchFlags: TOUCH_FLAGS,
  pub touchMask: TOUCH_MASK,
  pub rcContact: RECT,
  pub rcContactRaw: RECT,
  pub orientation: UINT32,
  pub pressure: UINT32,
}
#[test]
fn bindgen_test_layout_tagPOINTER_TOUCH_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_TOUCH_INFO>(),
    144usize,
    concat!("Size of: ", stringify!(tagPOINTER_TOUCH_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_TOUCH_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOINTER_TOUCH_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).pointerInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(pointerInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).touchFlags as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(touchFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).touchMask as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(touchMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).rcContact as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(rcContact)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).rcContactRaw as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(rcContactRaw)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).orientation as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(orientation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TOUCH_INFO>())).pressure as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TOUCH_INFO),
      "::",
      stringify!(pressure)
    )
  );
}
impl Default for tagPOINTER_TOUCH_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POINTER_TOUCH_INFO = tagPOINTER_TOUCH_INFO;
pub type PEN_FLAGS = UINT32;
pub type PEN_MASK = UINT32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPOINTER_PEN_INFO {
  pub pointerInfo: POINTER_INFO,
  pub penFlags: PEN_FLAGS,
  pub penMask: PEN_MASK,
  pub pressure: UINT32,
  pub rotation: UINT32,
  pub tiltX: INT32,
  pub tiltY: INT32,
}
#[test]
fn bindgen_test_layout_tagPOINTER_PEN_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_PEN_INFO>(),
    120usize,
    concat!("Size of: ", stringify!(tagPOINTER_PEN_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_PEN_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOINTER_PEN_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).pointerInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(pointerInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).penFlags as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(penFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).penMask as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(penMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).pressure as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(pressure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).rotation as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(rotation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).tiltX as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(tiltX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_PEN_INFO>())).tiltY as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_PEN_INFO),
      "::",
      stringify!(tiltY)
    )
  );
}
impl Default for tagPOINTER_PEN_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POINTER_PEN_INFO = tagPOINTER_PEN_INFO;
extern "C" {
  pub fn InitializeTouchInjection(maxCount: UINT32, dwMode: DWORD) -> BOOL;
}
extern "C" {
  pub fn InjectTouchInput(count: UINT32, contacts: *const POINTER_TOUCH_INFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagUSAGE_PROPERTIES {
  pub level: USHORT,
  pub page: USHORT,
  pub usage: USHORT,
  pub logicalMinimum: INT32,
  pub logicalMaximum: INT32,
  pub unit: USHORT,
  pub exponent: USHORT,
  pub count: BYTE,
  pub physicalMinimum: INT32,
  pub physicalMaximum: INT32,
}
#[test]
fn bindgen_test_layout_tagUSAGE_PROPERTIES() {
  assert_eq!(
    ::core::mem::size_of::<tagUSAGE_PROPERTIES>(),
    32usize,
    concat!("Size of: ", stringify!(tagUSAGE_PROPERTIES))
  );
  assert_eq!(
    ::core::mem::align_of::<tagUSAGE_PROPERTIES>(),
    4usize,
    concat!("Alignment of ", stringify!(tagUSAGE_PROPERTIES))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(level)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).page as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(page)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).usage as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(usage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).logicalMinimum as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(logicalMinimum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).logicalMaximum as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(logicalMaximum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).unit as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(unit)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).exponent as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(exponent)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).count as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(count)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).physicalMinimum as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(physicalMinimum)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagUSAGE_PROPERTIES>())).physicalMaximum as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagUSAGE_PROPERTIES),
      "::",
      stringify!(physicalMaximum)
    )
  );
}
pub type USAGE_PROPERTIES = tagUSAGE_PROPERTIES;
pub type PUSAGE_PROPERTIES = *mut tagUSAGE_PROPERTIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPOINTER_TYPE_INFO {
  pub type_: POINTER_INPUT_TYPE,
  pub __bindgen_anon_1: tagPOINTER_TYPE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPOINTER_TYPE_INFO__bindgen_ty_1 {
  pub touchInfo: POINTER_TOUCH_INFO,
  pub penInfo: POINTER_PEN_INFO,
  _bindgen_union_align: [u64; 18usize],
}
#[test]
fn bindgen_test_layout_tagPOINTER_TYPE_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_TYPE_INFO__bindgen_ty_1>(),
    144usize,
    concat!("Size of: ", stringify!(tagPOINTER_TYPE_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_TYPE_INFO__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagPOINTER_TYPE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_TYPE_INFO__bindgen_ty_1>())).touchInfo as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TYPE_INFO__bindgen_ty_1),
      "::",
      stringify!(touchInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_TYPE_INFO__bindgen_ty_1>())).penInfo as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TYPE_INFO__bindgen_ty_1),
      "::",
      stringify!(penInfo)
    )
  );
}
impl Default for tagPOINTER_TYPE_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagPOINTER_TYPE_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "tagPOINTER_TYPE_INFO__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_tagPOINTER_TYPE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_TYPE_INFO>(),
    152usize,
    concat!("Size of: ", stringify!(tagPOINTER_TYPE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_TYPE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOINTER_TYPE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_TYPE_INFO>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_TYPE_INFO),
      "::",
      stringify!(type_)
    )
  );
}
impl Default for tagPOINTER_TYPE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagPOINTER_TYPE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagPOINTER_TYPE_INFO {{ type: {:?}, __bindgen_anon_1: {:?} }}",
      self.type_, self.__bindgen_anon_1
    )
  }
}
pub type POINTER_TYPE_INFO = tagPOINTER_TYPE_INFO;
pub type PPOINTER_TYPE_INFO = *mut tagPOINTER_TYPE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagINPUT_INJECTION_VALUE {
  pub page: USHORT,
  pub usage: USHORT,
  pub value: INT32,
  pub index: USHORT,
}
#[test]
fn bindgen_test_layout_tagINPUT_INJECTION_VALUE() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT_INJECTION_VALUE>(),
    12usize,
    concat!("Size of: ", stringify!(tagINPUT_INJECTION_VALUE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT_INJECTION_VALUE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagINPUT_INJECTION_VALUE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_INJECTION_VALUE>())).page as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_INJECTION_VALUE),
      "::",
      stringify!(page)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_INJECTION_VALUE>())).usage as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_INJECTION_VALUE),
      "::",
      stringify!(usage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_INJECTION_VALUE>())).value as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_INJECTION_VALUE),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_INJECTION_VALUE>())).index as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_INJECTION_VALUE),
      "::",
      stringify!(index)
    )
  );
}
pub type INPUT_INJECTION_VALUE = tagINPUT_INJECTION_VALUE;
pub type PINPUT_INJECTION_VALUE = *mut tagINPUT_INJECTION_VALUE;
extern "C" {
  pub fn GetPointerType(pointerId: UINT32, pointerType: *mut POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
  pub fn GetPointerCursorId(pointerId: UINT32, cursorId: *mut UINT32) -> BOOL;
}
extern "C" {
  pub fn GetPointerInfo(pointerId: UINT32, pointerInfo: *mut POINTER_INFO) -> BOOL;
}
extern "C" {
  pub fn GetPointerInfoHistory(
    pointerId: UINT32, entriesCount: *mut UINT32, pointerInfo: *mut POINTER_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerFrameInfo(
    pointerId: UINT32, pointerCount: *mut UINT32, pointerInfo: *mut POINTER_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerFrameInfoHistory(
    pointerId: UINT32, entriesCount: *mut UINT32, pointerCount: *mut UINT32,
    pointerInfo: *mut POINTER_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerTouchInfo(pointerId: UINT32, touchInfo: *mut POINTER_TOUCH_INFO) -> BOOL;
}
extern "C" {
  pub fn GetPointerTouchInfoHistory(
    pointerId: UINT32, entriesCount: *mut UINT32, touchInfo: *mut POINTER_TOUCH_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerFrameTouchInfo(
    pointerId: UINT32, pointerCount: *mut UINT32, touchInfo: *mut POINTER_TOUCH_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerFrameTouchInfoHistory(
    pointerId: UINT32, entriesCount: *mut UINT32, pointerCount: *mut UINT32,
    touchInfo: *mut POINTER_TOUCH_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerPenInfo(pointerId: UINT32, penInfo: *mut POINTER_PEN_INFO) -> BOOL;
}
extern "C" {
  pub fn GetPointerPenInfoHistory(
    pointerId: UINT32, entriesCount: *mut UINT32, penInfo: *mut POINTER_PEN_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerFramePenInfo(
    pointerId: UINT32, pointerCount: *mut UINT32, penInfo: *mut POINTER_PEN_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerFramePenInfoHistory(
    pointerId: UINT32, entriesCount: *mut UINT32, pointerCount: *mut UINT32,
    penInfo: *mut POINTER_PEN_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn SkipPointerFrameMessages(pointerId: UINT32) -> BOOL;
}
extern "C" {
  pub fn RegisterPointerInputTarget(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
  pub fn UnregisterPointerInputTarget(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
  pub fn RegisterPointerInputTargetEx(
    hwnd: HWND, pointerType: POINTER_INPUT_TYPE, fObserve: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn UnregisterPointerInputTargetEx(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
  pub fn EnableMouseInPointer(fEnable: BOOL) -> BOOL;
}
extern "C" {
  pub fn IsMouseInPointerEnabled() -> BOOL;
}
extern "C" {
  pub fn EnableMouseInPointerForThread() -> BOOL;
}
extern "C" {
  pub fn RegisterTouchHitTestingWindow(hwnd: HWND, value: ULONG) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
  pub score: UINT16,
  pub adjustedPoint: POINT,
}
#[test]
fn bindgen_test_layout_tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION() {
  assert_eq!(
    ::core::mem::size_of::<tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION>())).score as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION),
      "::",
      stringify!(score)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION>())).adjustedPoint
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION),
      "::",
      stringify!(adjustedPoint)
    )
  );
}
pub type TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
pub type PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = *mut tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTOUCH_HIT_TESTING_INPUT {
  pub pointerId: UINT32,
  pub point: POINT,
  pub boundingBox: RECT,
  pub nonOccludedBoundingBox: RECT,
  pub orientation: UINT32,
}
#[test]
fn bindgen_test_layout_tagTOUCH_HIT_TESTING_INPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagTOUCH_HIT_TESTING_INPUT>(),
    48usize,
    concat!("Size of: ", stringify!(tagTOUCH_HIT_TESTING_INPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTOUCH_HIT_TESTING_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTOUCH_HIT_TESTING_INPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_INPUT>())).pointerId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_INPUT),
      "::",
      stringify!(pointerId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_INPUT>())).point as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_INPUT),
      "::",
      stringify!(point)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_INPUT>())).boundingBox as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_INPUT),
      "::",
      stringify!(boundingBox)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_INPUT>())).nonOccludedBoundingBox as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_INPUT),
      "::",
      stringify!(nonOccludedBoundingBox)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTOUCH_HIT_TESTING_INPUT>())).orientation as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOUCH_HIT_TESTING_INPUT),
      "::",
      stringify!(orientation)
    )
  );
}
pub type TOUCH_HIT_TESTING_INPUT = tagTOUCH_HIT_TESTING_INPUT;
pub type PTOUCH_HIT_TESTING_INPUT = *mut tagTOUCH_HIT_TESTING_INPUT;
extern "C" {
  pub fn EvaluateProximityToRect(
    controlBoundingBox: *const RECT, pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *mut TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
  ) -> BOOL;
}
extern "C" {
  pub fn EvaluateProximityToPolygon(
    numVertices: UINT32, controlPolygon: *const POINT,
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *mut TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
  ) -> BOOL;
}
extern "C" {
  pub fn PackTouchHitTestingProximityEvaluation(
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
  ) -> LRESULT;
}
pub mod tagFEEDBACK_TYPE {
  pub type Type = i32;
  pub const FEEDBACK_TOUCH_CONTACTVISUALIZATION: Type = 1;
  pub const FEEDBACK_PEN_BARRELVISUALIZATION: Type = 2;
  pub const FEEDBACK_PEN_TAP: Type = 3;
  pub const FEEDBACK_PEN_DOUBLETAP: Type = 4;
  pub const FEEDBACK_PEN_PRESSANDHOLD: Type = 5;
  pub const FEEDBACK_PEN_RIGHTTAP: Type = 6;
  pub const FEEDBACK_TOUCH_TAP: Type = 7;
  pub const FEEDBACK_TOUCH_DOUBLETAP: Type = 8;
  pub const FEEDBACK_TOUCH_PRESSANDHOLD: Type = 9;
  pub const FEEDBACK_TOUCH_RIGHTTAP: Type = 10;
  pub const FEEDBACK_GESTURE_PRESSANDTAP: Type = 11;
  pub const FEEDBACK_MAX: Type = -1;
}
pub use self::tagFEEDBACK_TYPE::Type as FEEDBACK_TYPE;
extern "C" {
  pub fn GetWindowFeedbackSetting(
    hwnd: HWND, feedback: FEEDBACK_TYPE, dwFlags: DWORD, pSize: *mut UINT32,
    config: *mut libc::c_void,
  ) -> BOOL;
}
extern "C" {
  pub fn SetWindowFeedbackSetting(
    hwnd: HWND, feedback: FEEDBACK_TYPE, dwFlags: DWORD, size: UINT32,
    configuration: *const libc::c_void,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagINPUT_TRANSFORM {
  pub __bindgen_anon_1: tagINPUT_TRANSFORM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagINPUT_TRANSFORM__bindgen_ty_1 {
  pub __bindgen_anon_1: tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1,
  pub m: [[f32; 4usize]; 4usize],
  _bindgen_union_align: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1 {
  pub _11: f32,
  pub _12: f32,
  pub _13: f32,
  pub _14: f32,
  pub _21: f32,
  pub _22: f32,
  pub _23: f32,
  pub _24: f32,
  pub _31: f32,
  pub _32: f32,
  pub _33: f32,
  pub _34: f32,
  pub _41: f32,
  pub _42: f32,
  pub _43: f32,
  pub _44: f32,
}
#[test]
fn bindgen_test_layout_tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>(),
    64usize,
    concat!(
      "Size of: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._11 as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_11)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._12 as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_12)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._13 as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_13)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._14 as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_14)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._21 as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_21)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._22 as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_22)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._23 as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_23)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._24 as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_24)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._31 as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_31)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._32 as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_32)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._33 as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_33)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._34 as *const _
        as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_34)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._41 as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_41)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._42 as *const _
        as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_42)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._43 as *const _
        as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_43)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1>()))._44 as *const _
        as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(_44)
    )
  );
}
#[test]
fn bindgen_test_layout_tagINPUT_TRANSFORM__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT_TRANSFORM__bindgen_ty_1>(),
    64usize,
    concat!("Size of: ", stringify!(tagINPUT_TRANSFORM__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT_TRANSFORM__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_TRANSFORM__bindgen_ty_1>())).m as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_TRANSFORM__bindgen_ty_1),
      "::",
      stringify!(m)
    )
  );
}
impl Default for tagINPUT_TRANSFORM__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagINPUT_TRANSFORM__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "tagINPUT_TRANSFORM__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_tagINPUT_TRANSFORM() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT_TRANSFORM>(),
    64usize,
    concat!("Size of: ", stringify!(tagINPUT_TRANSFORM))
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT_TRANSFORM>(),
    4usize,
    concat!("Alignment of ", stringify!(tagINPUT_TRANSFORM))
  );
}
impl Default for tagINPUT_TRANSFORM {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagINPUT_TRANSFORM {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagINPUT_TRANSFORM {{ __bindgen_anon_1: {:?} }}",
      self.__bindgen_anon_1
    )
  }
}
pub type INPUT_TRANSFORM = tagINPUT_TRANSFORM;
extern "C" {
  pub fn GetPointerInputTransform(
    pointerId: UINT32, historyCount: UINT32, inputTransform: *mut INPUT_TRANSFORM,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagLASTINPUTINFO {
  pub cbSize: UINT,
  pub dwTime: DWORD,
}
#[test]
fn bindgen_test_layout_tagLASTINPUTINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagLASTINPUTINFO>(),
    8usize,
    concat!("Size of: ", stringify!(tagLASTINPUTINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLASTINPUTINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagLASTINPUTINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLASTINPUTINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLASTINPUTINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLASTINPUTINFO>())).dwTime as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLASTINPUTINFO),
      "::",
      stringify!(dwTime)
    )
  );
}
pub type LASTINPUTINFO = tagLASTINPUTINFO;
pub type PLASTINPUTINFO = *mut tagLASTINPUTINFO;
extern "C" {
  pub fn GetLastInputInfo(plii: PLASTINPUTINFO) -> BOOL;
}
extern "C" {
  pub fn MapVirtualKeyA(uCode: UINT, uMapType: UINT) -> UINT;
}
extern "C" {
  pub fn MapVirtualKeyW(uCode: UINT, uMapType: UINT) -> UINT;
}
extern "C" {
  pub fn MapVirtualKeyExA(uCode: UINT, uMapType: UINT, dwhkl: HKL) -> UINT;
}
extern "C" {
  pub fn MapVirtualKeyExW(uCode: UINT, uMapType: UINT, dwhkl: HKL) -> UINT;
}
extern "C" {
  pub fn GetInputState() -> BOOL;
}
extern "C" {
  pub fn GetQueueStatus(flags: UINT) -> DWORD;
}
extern "C" {
  pub fn GetCapture() -> HWND;
}
extern "C" {
  pub fn SetCapture(hWnd: HWND) -> HWND;
}
extern "C" {
  pub fn ReleaseCapture() -> BOOL;
}
extern "C" {
  pub fn MsgWaitForMultipleObjects(
    nCount: DWORD, pHandles: *const HANDLE, fWaitAll: BOOL, dwMilliseconds: DWORD,
    dwWakeMask: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn MsgWaitForMultipleObjectsEx(
    nCount: DWORD, pHandles: *const HANDLE, dwMilliseconds: DWORD, dwWakeMask: DWORD,
    dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SetTimer(
    hWnd: HWND, nIDEvent: UINT_PTR, uElapse: UINT, lpTimerFunc: TIMERPROC,
  ) -> UINT_PTR;
}
extern "C" {
  pub fn SetCoalescableTimer(
    hWnd: HWND, nIDEvent: UINT_PTR, uElapse: UINT, lpTimerFunc: TIMERPROC, uToleranceDelay: ULONG,
  ) -> UINT_PTR;
}
extern "C" {
  pub fn KillTimer(hWnd: HWND, uIDEvent: UINT_PTR) -> BOOL;
}
extern "C" {
  pub fn IsWindowUnicode(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn EnableWindow(hWnd: HWND, bEnable: BOOL) -> BOOL;
}
extern "C" {
  pub fn IsWindowEnabled(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn LoadAcceleratorsA(hInstance: HINSTANCE, lpTableName: LPCSTR) -> HACCEL;
}
extern "C" {
  pub fn LoadAcceleratorsW(hInstance: HINSTANCE, lpTableName: LPCWSTR) -> HACCEL;
}
extern "C" {
  pub fn CreateAcceleratorTableA(paccel: LPACCEL, cAccel: libc::c_int) -> HACCEL;
}
extern "C" {
  pub fn CreateAcceleratorTableW(paccel: LPACCEL, cAccel: libc::c_int) -> HACCEL;
}
extern "C" {
  pub fn DestroyAcceleratorTable(hAccel: HACCEL) -> BOOL;
}
extern "C" {
  pub fn CopyAcceleratorTableA(
    hAccelSrc: HACCEL, lpAccelDst: LPACCEL, cAccelEntries: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CopyAcceleratorTableW(
    hAccelSrc: HACCEL, lpAccelDst: LPACCEL, cAccelEntries: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn TranslateAcceleratorA(hWnd: HWND, hAccTable: HACCEL, lpMsg: LPMSG) -> libc::c_int;
}
extern "C" {
  pub fn TranslateAcceleratorW(hWnd: HWND, hAccTable: HACCEL, lpMsg: LPMSG) -> libc::c_int;
}
extern "C" {
  pub fn GetSystemMetrics(nIndex: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetSystemMetricsForDpi(nIndex: libc::c_int, dpi: UINT) -> libc::c_int;
}
extern "C" {
  pub fn LoadMenuA(hInstance: HINSTANCE, lpMenuName: LPCSTR) -> HMENU;
}
extern "C" {
  pub fn LoadMenuW(hInstance: HINSTANCE, lpMenuName: LPCWSTR) -> HMENU;
}
extern "C" {
  pub fn LoadMenuIndirectA(lpMenuTemplate: *const MENUTEMPLATEA) -> HMENU;
}
extern "C" {
  pub fn LoadMenuIndirectW(lpMenuTemplate: *const MENUTEMPLATEW) -> HMENU;
}
extern "C" {
  pub fn GetMenu(hWnd: HWND) -> HMENU;
}
extern "C" {
  pub fn SetMenu(hWnd: HWND, hMenu: HMENU) -> BOOL;
}
extern "C" {
  pub fn ChangeMenuA(
    hMenu: HMENU, cmd: UINT, lpszNewItem: LPCSTR, cmdInsert: UINT, flags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn ChangeMenuW(
    hMenu: HMENU, cmd: UINT, lpszNewItem: LPCWSTR, cmdInsert: UINT, flags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn HiliteMenuItem(hWnd: HWND, hMenu: HMENU, uIDHiliteItem: UINT, uHilite: UINT) -> BOOL;
}
extern "C" {
  pub fn GetMenuStringA(
    hMenu: HMENU, uIDItem: UINT, lpString: LPSTR, cchMax: libc::c_int, flags: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetMenuStringW(
    hMenu: HMENU, uIDItem: UINT, lpString: LPWSTR, cchMax: libc::c_int, flags: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetMenuState(hMenu: HMENU, uId: UINT, uFlags: UINT) -> UINT;
}
extern "C" {
  pub fn DrawMenuBar(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn GetSystemMenu(hWnd: HWND, bRevert: BOOL) -> HMENU;
}
extern "C" {
  pub fn CreateMenu() -> HMENU;
}
extern "C" {
  pub fn CreatePopupMenu() -> HMENU;
}
extern "C" {
  pub fn DestroyMenu(hMenu: HMENU) -> BOOL;
}
extern "C" {
  pub fn CheckMenuItem(hMenu: HMENU, uIDCheckItem: UINT, uCheck: UINT) -> DWORD;
}
extern "C" {
  pub fn EnableMenuItem(hMenu: HMENU, uIDEnableItem: UINT, uEnable: UINT) -> BOOL;
}
extern "C" {
  pub fn GetSubMenu(hMenu: HMENU, nPos: libc::c_int) -> HMENU;
}
extern "C" {
  pub fn GetMenuItemID(hMenu: HMENU, nPos: libc::c_int) -> UINT;
}
extern "C" {
  pub fn GetMenuItemCount(hMenu: HMENU) -> libc::c_int;
}
extern "C" {
  pub fn InsertMenuA(
    hMenu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn InsertMenuW(
    hMenu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn AppendMenuA(hMenu: HMENU, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn AppendMenuW(hMenu: HMENU, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn ModifyMenuA(
    hMnu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ModifyMenuW(
    hMnu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn RemoveMenu(hMenu: HMENU, uPosition: UINT, uFlags: UINT) -> BOOL;
}
extern "C" {
  pub fn DeleteMenu(hMenu: HMENU, uPosition: UINT, uFlags: UINT) -> BOOL;
}
extern "C" {
  pub fn SetMenuItemBitmaps(
    hMenu: HMENU, uPosition: UINT, uFlags: UINT, hBitmapUnchecked: HBITMAP, hBitmapChecked: HBITMAP,
  ) -> BOOL;
}
extern "C" {
  pub fn GetMenuCheckMarkDimensions() -> LONG;
}
extern "C" {
  pub fn TrackPopupMenu(
    hMenu: HMENU, uFlags: UINT, x: libc::c_int, y: libc::c_int, nReserved: libc::c_int, hWnd: HWND,
    prcRect: *const RECT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTPMPARAMS {
  pub cbSize: UINT,
  pub rcExclude: RECT,
}
#[test]
fn bindgen_test_layout_tagTPMPARAMS() {
  assert_eq!(
    ::core::mem::size_of::<tagTPMPARAMS>(),
    20usize,
    concat!("Size of: ", stringify!(tagTPMPARAMS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTPMPARAMS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTPMPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTPMPARAMS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTPMPARAMS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTPMPARAMS>())).rcExclude as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTPMPARAMS),
      "::",
      stringify!(rcExclude)
    )
  );
}
pub type TPMPARAMS = tagTPMPARAMS;
pub type LPTPMPARAMS = *mut TPMPARAMS;
extern "C" {
  pub fn TrackPopupMenuEx(
    hMenu: HMENU, uFlags: UINT, x: libc::c_int, y: libc::c_int, hwnd: HWND, lptpm: LPTPMPARAMS,
  ) -> BOOL;
}
extern "C" {
  pub fn CalculatePopupWindowPosition(
    anchorPoint: *const POINT, windowSize: *const SIZE, flags: UINT, excludeRect: *mut RECT,
    popupWindowPosition: *mut RECT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMENUINFO {
  pub cbSize: DWORD,
  pub fMask: DWORD,
  pub dwStyle: DWORD,
  pub cyMax: UINT,
  pub hbrBack: HBRUSH,
  pub dwContextHelpID: DWORD,
  pub dwMenuData: ULONG_PTR,
}
#[test]
fn bindgen_test_layout_tagMENUINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagMENUINFO>(),
    40usize,
    concat!("Size of: ", stringify!(tagMENUINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMENUINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMENUINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).dwStyle as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).cyMax as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(cyMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).hbrBack as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(hbrBack)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).dwContextHelpID as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(dwContextHelpID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUINFO>())).dwMenuData as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUINFO),
      "::",
      stringify!(dwMenuData)
    )
  );
}
impl Default for tagMENUINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MENUINFO = tagMENUINFO;
pub type LPMENUINFO = *mut tagMENUINFO;
pub type LPCMENUINFO = *const MENUINFO;
extern "C" {
  pub fn GetMenuInfo(arg1: HMENU, arg2: LPMENUINFO) -> BOOL;
}
extern "C" {
  pub fn SetMenuInfo(arg1: HMENU, arg2: LPCMENUINFO) -> BOOL;
}
extern "C" {
  pub fn EndMenu() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMENUGETOBJECTINFO {
  pub dwFlags: DWORD,
  pub uPos: UINT,
  pub hmenu: HMENU,
  pub riid: PVOID,
  pub pvObj: PVOID,
}
#[test]
fn bindgen_test_layout_tagMENUGETOBJECTINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagMENUGETOBJECTINFO>(),
    32usize,
    concat!("Size of: ", stringify!(tagMENUGETOBJECTINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMENUGETOBJECTINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMENUGETOBJECTINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUGETOBJECTINFO>())).dwFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUGETOBJECTINFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUGETOBJECTINFO>())).uPos as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUGETOBJECTINFO),
      "::",
      stringify!(uPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUGETOBJECTINFO>())).hmenu as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUGETOBJECTINFO),
      "::",
      stringify!(hmenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUGETOBJECTINFO>())).riid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUGETOBJECTINFO),
      "::",
      stringify!(riid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUGETOBJECTINFO>())).pvObj as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUGETOBJECTINFO),
      "::",
      stringify!(pvObj)
    )
  );
}
impl Default for tagMENUGETOBJECTINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MENUGETOBJECTINFO = tagMENUGETOBJECTINFO;
pub type PMENUGETOBJECTINFO = *mut tagMENUGETOBJECTINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMENUITEMINFOA {
  pub cbSize: UINT,
  pub fMask: UINT,
  pub fType: UINT,
  pub fState: UINT,
  pub wID: UINT,
  pub hSubMenu: HMENU,
  pub hbmpChecked: HBITMAP,
  pub hbmpUnchecked: HBITMAP,
  pub dwItemData: ULONG_PTR,
  pub dwTypeData: LPSTR,
  pub cch: UINT,
  pub hbmpItem: HBITMAP,
}
#[test]
fn bindgen_test_layout_tagMENUITEMINFOA() {
  assert_eq!(
    ::core::mem::size_of::<tagMENUITEMINFOA>(),
    80usize,
    concat!("Size of: ", stringify!(tagMENUITEMINFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMENUITEMINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMENUITEMINFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).fType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(fType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).fState as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(fState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).wID as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(wID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).hSubMenu as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(hSubMenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).hbmpChecked as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(hbmpChecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).hbmpUnchecked as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(hbmpUnchecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).dwItemData as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(dwItemData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).dwTypeData as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(dwTypeData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).cch as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(cch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOA>())).hbmpItem as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOA),
      "::",
      stringify!(hbmpItem)
    )
  );
}
impl Default for tagMENUITEMINFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MENUITEMINFOA = tagMENUITEMINFOA;
pub type LPMENUITEMINFOA = *mut tagMENUITEMINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMENUITEMINFOW {
  pub cbSize: UINT,
  pub fMask: UINT,
  pub fType: UINT,
  pub fState: UINT,
  pub wID: UINT,
  pub hSubMenu: HMENU,
  pub hbmpChecked: HBITMAP,
  pub hbmpUnchecked: HBITMAP,
  pub dwItemData: ULONG_PTR,
  pub dwTypeData: LPWSTR,
  pub cch: UINT,
  pub hbmpItem: HBITMAP,
}
#[test]
fn bindgen_test_layout_tagMENUITEMINFOW() {
  assert_eq!(
    ::core::mem::size_of::<tagMENUITEMINFOW>(),
    80usize,
    concat!("Size of: ", stringify!(tagMENUITEMINFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMENUITEMINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMENUITEMINFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).fType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(fType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).fState as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(fState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).wID as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(wID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).hSubMenu as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(hSubMenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).hbmpChecked as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(hbmpChecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).hbmpUnchecked as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(hbmpUnchecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).dwItemData as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(dwItemData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).dwTypeData as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(dwTypeData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).cch as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(cch)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUITEMINFOW>())).hbmpItem as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUITEMINFOW),
      "::",
      stringify!(hbmpItem)
    )
  );
}
impl Default for tagMENUITEMINFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MENUITEMINFOW = tagMENUITEMINFOW;
pub type LPMENUITEMINFOW = *mut tagMENUITEMINFOW;
pub type MENUITEMINFO = MENUITEMINFOA;
pub type LPMENUITEMINFO = LPMENUITEMINFOA;
pub type LPCMENUITEMINFOA = *const MENUITEMINFOA;
pub type LPCMENUITEMINFOW = *const MENUITEMINFOW;
pub type LPCMENUITEMINFO = LPCMENUITEMINFOA;
extern "C" {
  pub fn InsertMenuItemA(
    hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmi: LPCMENUITEMINFOA,
  ) -> BOOL;
}
extern "C" {
  pub fn InsertMenuItemW(
    hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmi: LPCMENUITEMINFOW,
  ) -> BOOL;
}
extern "C" {
  pub fn GetMenuItemInfoA(
    hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmii: LPMENUITEMINFOA,
  ) -> BOOL;
}
extern "C" {
  pub fn GetMenuItemInfoW(
    hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmii: LPMENUITEMINFOW,
  ) -> BOOL;
}
extern "C" {
  pub fn SetMenuItemInfoA(
    hmenu: HMENU, item: UINT, fByPositon: BOOL, lpmii: LPCMENUITEMINFOA,
  ) -> BOOL;
}
extern "C" {
  pub fn SetMenuItemInfoW(
    hmenu: HMENU, item: UINT, fByPositon: BOOL, lpmii: LPCMENUITEMINFOW,
  ) -> BOOL;
}
extern "C" {
  pub fn GetMenuDefaultItem(hMenu: HMENU, fByPos: UINT, gmdiFlags: UINT) -> UINT;
}
extern "C" {
  pub fn SetMenuDefaultItem(hMenu: HMENU, uItem: UINT, fByPos: UINT) -> BOOL;
}
extern "C" {
  pub fn GetMenuItemRect(hWnd: HWND, hMenu: HMENU, uItem: UINT, lprcItem: LPRECT) -> BOOL;
}
extern "C" {
  pub fn MenuItemFromPoint(hWnd: HWND, hMenu: HMENU, ptScreen: POINT) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagDROPSTRUCT {
  pub hwndSource: HWND,
  pub hwndSink: HWND,
  pub wFmt: DWORD,
  pub dwData: ULONG_PTR,
  pub ptDrop: POINT,
  pub dwControlData: DWORD,
}
#[test]
fn bindgen_test_layout_tagDROPSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagDROPSTRUCT>(),
    48usize,
    concat!("Size of: ", stringify!(tagDROPSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDROPSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDROPSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDROPSTRUCT>())).hwndSource as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDROPSTRUCT),
      "::",
      stringify!(hwndSource)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDROPSTRUCT>())).hwndSink as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDROPSTRUCT),
      "::",
      stringify!(hwndSink)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDROPSTRUCT>())).wFmt as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDROPSTRUCT),
      "::",
      stringify!(wFmt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDROPSTRUCT>())).dwData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDROPSTRUCT),
      "::",
      stringify!(dwData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDROPSTRUCT>())).ptDrop as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDROPSTRUCT),
      "::",
      stringify!(ptDrop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDROPSTRUCT>())).dwControlData as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDROPSTRUCT),
      "::",
      stringify!(dwControlData)
    )
  );
}
impl Default for tagDROPSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DROPSTRUCT = tagDROPSTRUCT;
pub type PDROPSTRUCT = *mut tagDROPSTRUCT;
pub type LPDROPSTRUCT = *mut tagDROPSTRUCT;
extern "C" {
  pub fn DragObject(
    hwndParent: HWND, hwndFrom: HWND, fmt: UINT, data: ULONG_PTR, hcur: HCURSOR,
  ) -> DWORD;
}
extern "C" {
  pub fn DragDetect(hwnd: HWND, pt: POINT) -> BOOL;
}
extern "C" {
  pub fn DrawIcon(hDC: HDC, X: libc::c_int, Y: libc::c_int, hIcon: HICON) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagDRAWTEXTPARAMS {
  pub cbSize: UINT,
  pub iTabLength: libc::c_int,
  pub iLeftMargin: libc::c_int,
  pub iRightMargin: libc::c_int,
  pub uiLengthDrawn: UINT,
}
#[test]
fn bindgen_test_layout_tagDRAWTEXTPARAMS() {
  assert_eq!(
    ::core::mem::size_of::<tagDRAWTEXTPARAMS>(),
    20usize,
    concat!("Size of: ", stringify!(tagDRAWTEXTPARAMS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagDRAWTEXTPARAMS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagDRAWTEXTPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWTEXTPARAMS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWTEXTPARAMS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWTEXTPARAMS>())).iTabLength as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWTEXTPARAMS),
      "::",
      stringify!(iTabLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWTEXTPARAMS>())).iLeftMargin as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWTEXTPARAMS),
      "::",
      stringify!(iLeftMargin)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWTEXTPARAMS>())).iRightMargin as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWTEXTPARAMS),
      "::",
      stringify!(iRightMargin)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagDRAWTEXTPARAMS>())).uiLengthDrawn as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDRAWTEXTPARAMS),
      "::",
      stringify!(uiLengthDrawn)
    )
  );
}
pub type DRAWTEXTPARAMS = tagDRAWTEXTPARAMS;
pub type LPDRAWTEXTPARAMS = *mut tagDRAWTEXTPARAMS;
extern "C" {
  pub fn DrawTextA(
    hdc: HDC, lpchText: LPCSTR, cchText: libc::c_int, lprc: LPRECT, format: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DrawTextW(
    hdc: HDC, lpchText: LPCWSTR, cchText: libc::c_int, lprc: LPRECT, format: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DrawTextExA(
    hdc: HDC, lpchText: LPSTR, cchText: libc::c_int, lprc: LPRECT, format: UINT,
    lpdtp: LPDRAWTEXTPARAMS,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DrawTextExW(
    hdc: HDC, lpchText: LPWSTR, cchText: libc::c_int, lprc: LPRECT, format: UINT,
    lpdtp: LPDRAWTEXTPARAMS,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GrayStringA(
    hDC: HDC, hBrush: HBRUSH, lpOutputFunc: GRAYSTRINGPROC, lpData: LPARAM, nCount: libc::c_int,
    X: libc::c_int, Y: libc::c_int, nWidth: libc::c_int, nHeight: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn GrayStringW(
    hDC: HDC, hBrush: HBRUSH, lpOutputFunc: GRAYSTRINGPROC, lpData: LPARAM, nCount: libc::c_int,
    X: libc::c_int, Y: libc::c_int, nWidth: libc::c_int, nHeight: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn DrawStateA(
    hdc: HDC, hbrFore: HBRUSH, qfnCallBack: DRAWSTATEPROC, lData: LPARAM, wData: WPARAM,
    x: libc::c_int, y: libc::c_int, cx: libc::c_int, cy: libc::c_int, uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn DrawStateW(
    hdc: HDC, hbrFore: HBRUSH, qfnCallBack: DRAWSTATEPROC, lData: LPARAM, wData: WPARAM,
    x: libc::c_int, y: libc::c_int, cx: libc::c_int, cy: libc::c_int, uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn TabbedTextOutA(
    hdc: HDC, x: libc::c_int, y: libc::c_int, lpString: LPCSTR, chCount: libc::c_int,
    nTabPositions: libc::c_int, lpnTabStopPositions: *const INT, nTabOrigin: libc::c_int,
  ) -> LONG;
}
extern "C" {
  pub fn TabbedTextOutW(
    hdc: HDC, x: libc::c_int, y: libc::c_int, lpString: LPCWSTR, chCount: libc::c_int,
    nTabPositions: libc::c_int, lpnTabStopPositions: *const INT, nTabOrigin: libc::c_int,
  ) -> LONG;
}
extern "C" {
  pub fn GetTabbedTextExtentA(
    hdc: HDC, lpString: LPCSTR, chCount: libc::c_int, nTabPositions: libc::c_int,
    lpnTabStopPositions: *const INT,
  ) -> DWORD;
}
extern "C" {
  pub fn GetTabbedTextExtentW(
    hdc: HDC, lpString: LPCWSTR, chCount: libc::c_int, nTabPositions: libc::c_int,
    lpnTabStopPositions: *const INT,
  ) -> DWORD;
}
extern "C" {
  pub fn UpdateWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn SetActiveWindow(hWnd: HWND) -> HWND;
}
extern "C" {
  pub fn GetForegroundWindow() -> HWND;
}
extern "C" {
  pub fn PaintDesktop(hdc: HDC) -> BOOL;
}
extern "C" {
  pub fn SwitchToThisWindow(hwnd: HWND, fUnknown: BOOL);
}
extern "C" {
  pub fn SetForegroundWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn AllowSetForegroundWindow(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
  pub fn LockSetForegroundWindow(uLockCode: UINT) -> BOOL;
}
extern "C" {
  pub fn WindowFromDC(hDC: HDC) -> HWND;
}
extern "C" {
  pub fn GetDC(hWnd: HWND) -> HDC;
}
extern "C" {
  pub fn GetDCEx(hWnd: HWND, hrgnClip: HRGN, flags: DWORD) -> HDC;
}
extern "C" {
  pub fn GetWindowDC(hWnd: HWND) -> HDC;
}
extern "C" {
  pub fn ReleaseDC(hWnd: HWND, hDC: HDC) -> libc::c_int;
}
extern "C" {
  pub fn BeginPaint(hWnd: HWND, lpPaint: LPPAINTSTRUCT) -> HDC;
}
extern "C" {
  pub fn EndPaint(hWnd: HWND, lpPaint: *const PAINTSTRUCT) -> BOOL;
}
extern "C" {
  pub fn GetUpdateRect(hWnd: HWND, lpRect: LPRECT, bErase: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetUpdateRgn(hWnd: HWND, hRgn: HRGN, bErase: BOOL) -> libc::c_int;
}
extern "C" {
  pub fn SetWindowRgn(hWnd: HWND, hRgn: HRGN, bRedraw: BOOL) -> libc::c_int;
}
extern "C" {
  pub fn GetWindowRgn(hWnd: HWND, hRgn: HRGN) -> libc::c_int;
}
extern "C" {
  pub fn GetWindowRgnBox(hWnd: HWND, lprc: LPRECT) -> libc::c_int;
}
extern "C" {
  pub fn ExcludeUpdateRgn(hDC: HDC, hWnd: HWND) -> libc::c_int;
}
extern "C" {
  pub fn InvalidateRect(hWnd: HWND, lpRect: *const RECT, bErase: BOOL) -> BOOL;
}
extern "C" {
  pub fn ValidateRect(hWnd: HWND, lpRect: *const RECT) -> BOOL;
}
extern "C" {
  pub fn InvalidateRgn(hWnd: HWND, hRgn: HRGN, bErase: BOOL) -> BOOL;
}
extern "C" {
  pub fn ValidateRgn(hWnd: HWND, hRgn: HRGN) -> BOOL;
}
extern "C" {
  pub fn RedrawWindow(hWnd: HWND, lprcUpdate: *const RECT, hrgnUpdate: HRGN, flags: UINT) -> BOOL;
}
extern "C" {
  pub fn LockWindowUpdate(hWndLock: HWND) -> BOOL;
}
extern "C" {
  pub fn ScrollWindow(
    hWnd: HWND, XAmount: libc::c_int, YAmount: libc::c_int, lpRect: *const RECT,
    lpClipRect: *const RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn ScrollDC(
    hDC: HDC, dx: libc::c_int, dy: libc::c_int, lprcScroll: *const RECT, lprcClip: *const RECT,
    hrgnUpdate: HRGN, lprcUpdate: LPRECT,
  ) -> BOOL;
}
extern "C" {
  pub fn ScrollWindowEx(
    hWnd: HWND, dx: libc::c_int, dy: libc::c_int, prcScroll: *const RECT, prcClip: *const RECT,
    hrgnUpdate: HRGN, prcUpdate: LPRECT, flags: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SetScrollPos(
    hWnd: HWND, nBar: libc::c_int, nPos: libc::c_int, bRedraw: BOOL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetScrollPos(hWnd: HWND, nBar: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetScrollRange(
    hWnd: HWND, nBar: libc::c_int, nMinPos: libc::c_int, nMaxPos: libc::c_int, bRedraw: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn GetScrollRange(hWnd: HWND, nBar: libc::c_int, lpMinPos: LPINT, lpMaxPos: LPINT) -> BOOL;
}
extern "C" {
  pub fn ShowScrollBar(hWnd: HWND, wBar: libc::c_int, bShow: BOOL) -> BOOL;
}
extern "C" {
  pub fn EnableScrollBar(hWnd: HWND, wSBflags: UINT, wArrows: UINT) -> BOOL;
}
extern "C" {
  pub fn SetPropA(hWnd: HWND, lpString: LPCSTR, hData: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetPropW(hWnd: HWND, lpString: LPCWSTR, hData: HANDLE) -> BOOL;
}
extern "C" {
  pub fn GetPropA(hWnd: HWND, lpString: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn GetPropW(hWnd: HWND, lpString: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn RemovePropA(hWnd: HWND, lpString: LPCSTR) -> HANDLE;
}
extern "C" {
  pub fn RemovePropW(hWnd: HWND, lpString: LPCWSTR) -> HANDLE;
}
extern "C" {
  pub fn EnumPropsExA(hWnd: HWND, lpEnumFunc: PROPENUMPROCEXA, lParam: LPARAM) -> libc::c_int;
}
extern "C" {
  pub fn EnumPropsExW(hWnd: HWND, lpEnumFunc: PROPENUMPROCEXW, lParam: LPARAM) -> libc::c_int;
}
extern "C" {
  pub fn EnumPropsA(hWnd: HWND, lpEnumFunc: PROPENUMPROCA) -> libc::c_int;
}
extern "C" {
  pub fn EnumPropsW(hWnd: HWND, lpEnumFunc: PROPENUMPROCW) -> libc::c_int;
}
extern "C" {
  pub fn SetWindowTextA(hWnd: HWND, lpString: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetWindowTextW(hWnd: HWND, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetWindowTextA(hWnd: HWND, lpString: LPSTR, nMaxCount: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetWindowTextW(hWnd: HWND, lpString: LPWSTR, nMaxCount: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetWindowTextLengthA(hWnd: HWND) -> libc::c_int;
}
extern "C" {
  pub fn GetWindowTextLengthW(hWnd: HWND) -> libc::c_int;
}
extern "C" {
  pub fn GetClientRect(hWnd: HWND, lpRect: LPRECT) -> BOOL;
}
extern "C" {
  pub fn GetWindowRect(hWnd: HWND, lpRect: LPRECT) -> BOOL;
}
extern "C" {
  pub fn AdjustWindowRect(lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL) -> BOOL;
}
extern "C" {
  pub fn AdjustWindowRectEx(lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL, dwExStyle: DWORD) -> BOOL;
}
extern "C" {
  pub fn AdjustWindowRectExForDpi(
    lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL, dwExStyle: DWORD, dpi: UINT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagHELPINFO {
  pub cbSize: UINT,
  pub iContextType: libc::c_int,
  pub iCtrlId: libc::c_int,
  pub hItemHandle: HANDLE,
  pub dwContextId: DWORD_PTR,
  pub MousePos: POINT,
}
#[test]
fn bindgen_test_layout_tagHELPINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagHELPINFO>(),
    40usize,
    concat!("Size of: ", stringify!(tagHELPINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHELPINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagHELPINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPINFO>())).iContextType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPINFO),
      "::",
      stringify!(iContextType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPINFO>())).iCtrlId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPINFO),
      "::",
      stringify!(iCtrlId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPINFO>())).hItemHandle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPINFO),
      "::",
      stringify!(hItemHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPINFO>())).dwContextId as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPINFO),
      "::",
      stringify!(dwContextId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPINFO>())).MousePos as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPINFO),
      "::",
      stringify!(MousePos)
    )
  );
}
impl Default for tagHELPINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type HELPINFO = tagHELPINFO;
pub type LPHELPINFO = *mut tagHELPINFO;
extern "C" {
  pub fn SetWindowContextHelpId(arg1: HWND, arg2: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetWindowContextHelpId(arg1: HWND) -> DWORD;
}
extern "C" {
  pub fn SetMenuContextHelpId(arg1: HMENU, arg2: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetMenuContextHelpId(arg1: HMENU) -> DWORD;
}
extern "C" {
  pub fn MessageBoxA(hWnd: HWND, lpText: LPCSTR, lpCaption: LPCSTR, uType: UINT) -> libc::c_int;
}
extern "C" {
  pub fn MessageBoxW(hWnd: HWND, lpText: LPCWSTR, lpCaption: LPCWSTR, uType: UINT) -> libc::c_int;
}
extern "C" {
  pub fn MessageBoxExA(
    hWnd: HWND, lpText: LPCSTR, lpCaption: LPCSTR, uType: UINT, wLanguageId: WORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn MessageBoxExW(
    hWnd: HWND, lpText: LPCWSTR, lpCaption: LPCWSTR, uType: UINT, wLanguageId: WORD,
  ) -> libc::c_int;
}
pub type MSGBOXCALLBACK = ::core::option::Option<unsafe extern "C" fn(lpHelpInfo: LPHELPINFO)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMSGBOXPARAMSA {
  pub cbSize: UINT,
  pub hwndOwner: HWND,
  pub hInstance: HINSTANCE,
  pub lpszText: LPCSTR,
  pub lpszCaption: LPCSTR,
  pub dwStyle: DWORD,
  pub lpszIcon: LPCSTR,
  pub dwContextHelpId: DWORD_PTR,
  pub lpfnMsgBoxCallback: MSGBOXCALLBACK,
  pub dwLanguageId: DWORD,
}
#[test]
fn bindgen_test_layout_tagMSGBOXPARAMSA() {
  assert_eq!(
    ::core::mem::size_of::<tagMSGBOXPARAMSA>(),
    80usize,
    concat!("Size of: ", stringify!(tagMSGBOXPARAMSA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMSGBOXPARAMSA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMSGBOXPARAMSA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).hwndOwner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).hInstance as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).lpszText as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(lpszText)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).lpszCaption as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(lpszCaption)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).dwStyle as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).lpszIcon as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(lpszIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).dwContextHelpId as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(dwContextHelpId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).lpfnMsgBoxCallback as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(lpfnMsgBoxCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSA>())).dwLanguageId as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSA),
      "::",
      stringify!(dwLanguageId)
    )
  );
}
impl Default for tagMSGBOXPARAMSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MSGBOXPARAMSA = tagMSGBOXPARAMSA;
pub type PMSGBOXPARAMSA = *mut tagMSGBOXPARAMSA;
pub type LPMSGBOXPARAMSA = *mut tagMSGBOXPARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMSGBOXPARAMSW {
  pub cbSize: UINT,
  pub hwndOwner: HWND,
  pub hInstance: HINSTANCE,
  pub lpszText: LPCWSTR,
  pub lpszCaption: LPCWSTR,
  pub dwStyle: DWORD,
  pub lpszIcon: LPCWSTR,
  pub dwContextHelpId: DWORD_PTR,
  pub lpfnMsgBoxCallback: MSGBOXCALLBACK,
  pub dwLanguageId: DWORD,
}
#[test]
fn bindgen_test_layout_tagMSGBOXPARAMSW() {
  assert_eq!(
    ::core::mem::size_of::<tagMSGBOXPARAMSW>(),
    80usize,
    concat!("Size of: ", stringify!(tagMSGBOXPARAMSW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMSGBOXPARAMSW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMSGBOXPARAMSW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).hwndOwner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).hInstance as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(hInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).lpszText as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(lpszText)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).lpszCaption as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(lpszCaption)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).dwStyle as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).lpszIcon as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(lpszIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).dwContextHelpId as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(dwContextHelpId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).lpfnMsgBoxCallback as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(lpfnMsgBoxCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMSGBOXPARAMSW>())).dwLanguageId as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMSGBOXPARAMSW),
      "::",
      stringify!(dwLanguageId)
    )
  );
}
impl Default for tagMSGBOXPARAMSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MSGBOXPARAMSW = tagMSGBOXPARAMSW;
pub type PMSGBOXPARAMSW = *mut tagMSGBOXPARAMSW;
pub type LPMSGBOXPARAMSW = *mut tagMSGBOXPARAMSW;
pub type MSGBOXPARAMS = MSGBOXPARAMSA;
pub type PMSGBOXPARAMS = PMSGBOXPARAMSA;
pub type LPMSGBOXPARAMS = LPMSGBOXPARAMSA;
extern "C" {
  pub fn MessageBoxIndirectA(lpmbp: *const MSGBOXPARAMSA) -> libc::c_int;
}
extern "C" {
  pub fn MessageBoxIndirectW(lpmbp: *const MSGBOXPARAMSW) -> libc::c_int;
}
extern "C" {
  pub fn MessageBeep(uType: UINT) -> BOOL;
}
extern "C" {
  pub fn ShowCursor(bShow: BOOL) -> libc::c_int;
}
extern "C" {
  pub fn SetCursorPos(X: libc::c_int, Y: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn SetPhysicalCursorPos(X: libc::c_int, Y: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn SetCursor(hCursor: HCURSOR) -> HCURSOR;
}
extern "C" {
  pub fn GetCursorPos(lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn GetPhysicalCursorPos(lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn GetClipCursor(lpRect: LPRECT) -> BOOL;
}
extern "C" {
  pub fn GetCursor() -> HCURSOR;
}
extern "C" {
  pub fn CreateCaret(
    hWnd: HWND, hBitmap: HBITMAP, nWidth: libc::c_int, nHeight: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCaretBlinkTime() -> UINT;
}
extern "C" {
  pub fn SetCaretBlinkTime(uMSeconds: UINT) -> BOOL;
}
extern "C" {
  pub fn DestroyCaret() -> BOOL;
}
extern "C" {
  pub fn HideCaret(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn ShowCaret(hWnd: HWND) -> BOOL;
}
extern "C" {
  pub fn SetCaretPos(X: libc::c_int, Y: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn GetCaretPos(lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn ClientToScreen(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn ScreenToClient(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn LogicalToPhysicalPoint(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn PhysicalToLogicalPoint(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn LogicalToPhysicalPointForPerMonitorDPI(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn PhysicalToLogicalPointForPerMonitorDPI(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn MapWindowPoints(
    hWndFrom: HWND, hWndTo: HWND, lpPoints: LPPOINT, cPoints: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn WindowFromPoint(Point: POINT) -> HWND;
}
extern "C" {
  pub fn WindowFromPhysicalPoint(Point: POINT) -> HWND;
}
extern "C" {
  pub fn ChildWindowFromPoint(hWndParent: HWND, Point: POINT) -> HWND;
}
extern "C" {
  pub fn ClipCursor(lpRect: *const RECT) -> BOOL;
}
extern "C" {
  pub fn ChildWindowFromPointEx(hwnd: HWND, pt: POINT, flags: UINT) -> HWND;
}
extern "C" {
  pub fn GetSysColor(nIndex: libc::c_int) -> DWORD;
}
extern "C" {
  pub fn GetSysColorBrush(nIndex: libc::c_int) -> HBRUSH;
}
extern "C" {
  pub fn SetSysColors(
    cElements: libc::c_int, lpaElements: *const INT, lpaRgbValues: *const COLORREF,
  ) -> BOOL;
}
extern "C" {
  pub fn DrawFocusRect(hDC: HDC, lprc: *const RECT) -> BOOL;
}
extern "C" {
  pub fn FillRect(hDC: HDC, lprc: *const RECT, hbr: HBRUSH) -> libc::c_int;
}
extern "C" {
  pub fn FrameRect(hDC: HDC, lprc: *const RECT, hbr: HBRUSH) -> libc::c_int;
}
extern "C" {
  pub fn InvertRect(hDC: HDC, lprc: *const RECT) -> BOOL;
}
extern "C" {
  pub fn SetRect(
    lprc: LPRECT, xLeft: libc::c_int, yTop: libc::c_int, xRight: libc::c_int, yBottom: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn SetRectEmpty(lprc: LPRECT) -> BOOL;
}
extern "C" {
  pub fn CopyRect(lprcDst: LPRECT, lprcSrc: *const RECT) -> BOOL;
}
extern "C" {
  pub fn InflateRect(lprc: LPRECT, dx: libc::c_int, dy: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn IntersectRect(lprcDst: LPRECT, lprcSrc1: *const RECT, lprcSrc2: *const RECT) -> BOOL;
}
extern "C" {
  pub fn UnionRect(lprcDst: LPRECT, lprcSrc1: *const RECT, lprcSrc2: *const RECT) -> BOOL;
}
extern "C" {
  pub fn SubtractRect(lprcDst: LPRECT, lprcSrc1: *const RECT, lprcSrc2: *const RECT) -> BOOL;
}
extern "C" {
  pub fn OffsetRect(lprc: LPRECT, dx: libc::c_int, dy: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn IsRectEmpty(lprc: *const RECT) -> BOOL;
}
extern "C" {
  pub fn EqualRect(lprc1: *const RECT, lprc2: *const RECT) -> BOOL;
}
extern "C" {
  pub fn PtInRect(lprc: *const RECT, pt: POINT) -> BOOL;
}
extern "C" {
  pub fn GetWindowWord(hWnd: HWND, nIndex: libc::c_int) -> WORD;
}
extern "C" {
  pub fn SetWindowWord(hWnd: HWND, nIndex: libc::c_int, wNewWord: WORD) -> WORD;
}
extern "C" {
  pub fn GetWindowLongA(hWnd: HWND, nIndex: libc::c_int) -> LONG;
}
extern "C" {
  pub fn GetWindowLongW(hWnd: HWND, nIndex: libc::c_int) -> LONG;
}
extern "C" {
  pub fn SetWindowLongA(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG) -> LONG;
}
extern "C" {
  pub fn SetWindowLongW(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG) -> LONG;
}
extern "C" {
  pub fn GetWindowLongPtrA(hWnd: HWND, nIndex: libc::c_int) -> LONG_PTR;
}
extern "C" {
  pub fn GetWindowLongPtrW(hWnd: HWND, nIndex: libc::c_int) -> LONG_PTR;
}
extern "C" {
  pub fn SetWindowLongPtrA(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG_PTR) -> LONG_PTR;
}
extern "C" {
  pub fn SetWindowLongPtrW(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG_PTR) -> LONG_PTR;
}
extern "C" {
  pub fn GetClassWord(hWnd: HWND, nIndex: libc::c_int) -> WORD;
}
extern "C" {
  pub fn SetClassWord(hWnd: HWND, nIndex: libc::c_int, wNewWord: WORD) -> WORD;
}
extern "C" {
  pub fn GetClassLongA(hWnd: HWND, nIndex: libc::c_int) -> DWORD;
}
extern "C" {
  pub fn GetClassLongW(hWnd: HWND, nIndex: libc::c_int) -> DWORD;
}
extern "C" {
  pub fn SetClassLongA(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG) -> DWORD;
}
extern "C" {
  pub fn SetClassLongW(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG) -> DWORD;
}
extern "C" {
  pub fn GetClassLongPtrA(hWnd: HWND, nIndex: libc::c_int) -> ULONG_PTR;
}
extern "C" {
  pub fn GetClassLongPtrW(hWnd: HWND, nIndex: libc::c_int) -> ULONG_PTR;
}
extern "C" {
  pub fn SetClassLongPtrA(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG_PTR) -> ULONG_PTR;
}
extern "C" {
  pub fn SetClassLongPtrW(hWnd: HWND, nIndex: libc::c_int, dwNewLong: LONG_PTR) -> ULONG_PTR;
}
extern "C" {
  pub fn GetProcessDefaultLayout(pdwDefaultLayout: *mut DWORD) -> BOOL;
}
extern "C" {
  pub fn SetProcessDefaultLayout(dwDefaultLayout: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetDesktopWindow() -> HWND;
}
extern "C" {
  pub fn GetParent(hWnd: HWND) -> HWND;
}
extern "C" {
  pub fn SetParent(hWndChild: HWND, hWndNewParent: HWND) -> HWND;
}
extern "C" {
  pub fn EnumChildWindows(hWndParent: HWND, lpEnumFunc: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn FindWindowA(lpClassName: LPCSTR, lpWindowName: LPCSTR) -> HWND;
}
extern "C" {
  pub fn FindWindowW(lpClassName: LPCWSTR, lpWindowName: LPCWSTR) -> HWND;
}
extern "C" {
  pub fn FindWindowExA(
    hWndParent: HWND, hWndChildAfter: HWND, lpszClass: LPCSTR, lpszWindow: LPCSTR,
  ) -> HWND;
}
extern "C" {
  pub fn FindWindowExW(
    hWndParent: HWND, hWndChildAfter: HWND, lpszClass: LPCWSTR, lpszWindow: LPCWSTR,
  ) -> HWND;
}
extern "C" {
  pub fn GetShellWindow() -> HWND;
}
extern "C" {
  pub fn RegisterShellHookWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn DeregisterShellHookWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn EnumWindows(lpEnumFunc: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn EnumThreadWindows(dwThreadId: DWORD, lpfn: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn GetClassNameA(hWnd: HWND, lpClassName: LPSTR, nMaxCount: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetClassNameW(hWnd: HWND, lpClassName: LPWSTR, nMaxCount: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetTopWindow(hWnd: HWND) -> HWND;
}
extern "C" {
  pub fn GetWindowThreadProcessId(hWnd: HWND, lpdwProcessId: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn IsGUIThread(bConvert: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetLastActivePopup(hWnd: HWND) -> HWND;
}
extern "C" {
  pub fn GetWindow(hWnd: HWND, uCmd: UINT) -> HWND;
}
extern "C" {
  pub fn SetWindowsHookA(nFilterType: libc::c_int, pfnFilterProc: HOOKPROC) -> HHOOK;
}
extern "C" {
  pub fn SetWindowsHookW(nFilterType: libc::c_int, pfnFilterProc: HOOKPROC) -> HHOOK;
}
extern "C" {
  pub fn UnhookWindowsHook(nCode: libc::c_int, pfnFilterProc: HOOKPROC) -> BOOL;
}
extern "C" {
  pub fn SetWindowsHookExA(
    idHook: libc::c_int, lpfn: HOOKPROC, hmod: HINSTANCE, dwThreadId: DWORD,
  ) -> HHOOK;
}
extern "C" {
  pub fn SetWindowsHookExW(
    idHook: libc::c_int, lpfn: HOOKPROC, hmod: HINSTANCE, dwThreadId: DWORD,
  ) -> HHOOK;
}
extern "C" {
  pub fn UnhookWindowsHookEx(hhk: HHOOK) -> BOOL;
}
extern "C" {
  pub fn CallNextHookEx(hhk: HHOOK, nCode: libc::c_int, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn CheckMenuRadioItem(
    hmenu: HMENU, first: UINT, last: UINT, check: UINT, flags: UINT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct MENUITEMTEMPLATEHEADER {
  pub versionNumber: WORD,
  pub offset: WORD,
}
#[test]
fn bindgen_test_layout_MENUITEMTEMPLATEHEADER() {
  assert_eq!(
    ::core::mem::size_of::<MENUITEMTEMPLATEHEADER>(),
    4usize,
    concat!("Size of: ", stringify!(MENUITEMTEMPLATEHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<MENUITEMTEMPLATEHEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(MENUITEMTEMPLATEHEADER))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<MENUITEMTEMPLATEHEADER>())).versionNumber as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(MENUITEMTEMPLATEHEADER),
      "::",
      stringify!(versionNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<MENUITEMTEMPLATEHEADER>())).offset as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(MENUITEMTEMPLATEHEADER),
      "::",
      stringify!(offset)
    )
  );
}
pub type PMENUITEMTEMPLATEHEADER = *mut MENUITEMTEMPLATEHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct MENUITEMTEMPLATE {
  pub mtOption: WORD,
  pub mtID: WORD,
  pub mtString: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout_MENUITEMTEMPLATE() {
  assert_eq!(
    ::core::mem::size_of::<MENUITEMTEMPLATE>(),
    6usize,
    concat!("Size of: ", stringify!(MENUITEMTEMPLATE))
  );
  assert_eq!(
    ::core::mem::align_of::<MENUITEMTEMPLATE>(),
    2usize,
    concat!("Alignment of ", stringify!(MENUITEMTEMPLATE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<MENUITEMTEMPLATE>())).mtOption as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(MENUITEMTEMPLATE),
      "::",
      stringify!(mtOption)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<MENUITEMTEMPLATE>())).mtID as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(MENUITEMTEMPLATE),
      "::",
      stringify!(mtID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<MENUITEMTEMPLATE>())).mtString as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(MENUITEMTEMPLATE),
      "::",
      stringify!(mtString)
    )
  );
}
pub type PMENUITEMTEMPLATE = *mut MENUITEMTEMPLATE;
extern "C" {
  pub fn LoadBitmapA(hInstance: HINSTANCE, lpBitmapName: LPCSTR) -> HBITMAP;
}
extern "C" {
  pub fn LoadBitmapW(hInstance: HINSTANCE, lpBitmapName: LPCWSTR) -> HBITMAP;
}
extern "C" {
  pub fn LoadCursorA(hInstance: HINSTANCE, lpCursorName: LPCSTR) -> HCURSOR;
}
extern "C" {
  pub fn LoadCursorW(hInstance: HINSTANCE, lpCursorName: LPCWSTR) -> HCURSOR;
}
extern "C" {
  pub fn LoadCursorFromFileA(lpFileName: LPCSTR) -> HCURSOR;
}
extern "C" {
  pub fn LoadCursorFromFileW(lpFileName: LPCWSTR) -> HCURSOR;
}
extern "C" {
  pub fn CreateCursor(
    hInst: HINSTANCE, xHotSpot: libc::c_int, yHotSpot: libc::c_int, nWidth: libc::c_int,
    nHeight: libc::c_int, pvANDPlane: *const libc::c_void, pvXORPlane: *const libc::c_void,
  ) -> HCURSOR;
}
extern "C" {
  pub fn DestroyCursor(hCursor: HCURSOR) -> BOOL;
}
extern "C" {
  pub fn SetSystemCursor(hcur: HCURSOR, id: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ICONINFO {
  pub fIcon: BOOL,
  pub xHotspot: DWORD,
  pub yHotspot: DWORD,
  pub hbmMask: HBITMAP,
  pub hbmColor: HBITMAP,
}
#[test]
fn bindgen_test_layout__ICONINFO() {
  assert_eq!(
    ::core::mem::size_of::<_ICONINFO>(),
    32usize,
    concat!("Size of: ", stringify!(_ICONINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_ICONINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_ICONINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFO>())).fIcon as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFO),
      "::",
      stringify!(fIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFO>())).xHotspot as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFO),
      "::",
      stringify!(xHotspot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFO>())).yHotspot as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFO),
      "::",
      stringify!(yHotspot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFO>())).hbmMask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFO),
      "::",
      stringify!(hbmMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFO>())).hbmColor as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFO),
      "::",
      stringify!(hbmColor)
    )
  );
}
impl Default for _ICONINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ICONINFO = _ICONINFO;
pub type PICONINFO = *mut ICONINFO;
extern "C" {
  pub fn LoadIconA(hInstance: HINSTANCE, lpIconName: LPCSTR) -> HICON;
}
extern "C" {
  pub fn LoadIconW(hInstance: HINSTANCE, lpIconName: LPCWSTR) -> HICON;
}
extern "C" {
  pub fn PrivateExtractIconsA(
    szFileName: LPCSTR, nIconIndex: libc::c_int, cxIcon: libc::c_int, cyIcon: libc::c_int,
    phicon: *mut HICON, piconid: *mut UINT, nIcons: UINT, flags: UINT,
  ) -> UINT;
}
extern "C" {
  pub fn PrivateExtractIconsW(
    szFileName: LPCWSTR, nIconIndex: libc::c_int, cxIcon: libc::c_int, cyIcon: libc::c_int,
    phicon: *mut HICON, piconid: *mut UINT, nIcons: UINT, flags: UINT,
  ) -> UINT;
}
extern "C" {
  pub fn CreateIcon(
    hInstance: HINSTANCE, nWidth: libc::c_int, nHeight: libc::c_int, cPlanes: BYTE,
    cBitsPixel: BYTE, lpbANDbits: *const BYTE, lpbXORbits: *const BYTE,
  ) -> HICON;
}
extern "C" {
  pub fn DestroyIcon(hIcon: HICON) -> BOOL;
}
extern "C" {
  pub fn LookupIconIdFromDirectory(presbits: PBYTE, fIcon: BOOL) -> libc::c_int;
}
extern "C" {
  pub fn LookupIconIdFromDirectoryEx(
    presbits: PBYTE, fIcon: BOOL, cxDesired: libc::c_int, cyDesired: libc::c_int, Flags: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CreateIconFromResource(
    presbits: PBYTE, dwResSize: DWORD, fIcon: BOOL, dwVer: DWORD,
  ) -> HICON;
}
extern "C" {
  pub fn CreateIconFromResourceEx(
    presbits: PBYTE, dwResSize: DWORD, fIcon: BOOL, dwVer: DWORD, cxDesired: libc::c_int,
    cyDesired: libc::c_int, Flags: UINT,
  ) -> HICON;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCURSORSHAPE {
  pub xHotSpot: libc::c_int,
  pub yHotSpot: libc::c_int,
  pub cx: libc::c_int,
  pub cy: libc::c_int,
  pub cbWidth: libc::c_int,
  pub Planes: BYTE,
  pub BitsPixel: BYTE,
}
#[test]
fn bindgen_test_layout_tagCURSORSHAPE() {
  assert_eq!(
    ::core::mem::size_of::<tagCURSORSHAPE>(),
    24usize,
    concat!("Size of: ", stringify!(tagCURSORSHAPE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCURSORSHAPE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCURSORSHAPE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).xHotSpot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(xHotSpot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).yHotSpot as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(yHotSpot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).cx as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).cy as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).cbWidth as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(cbWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).Planes as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(Planes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORSHAPE>())).BitsPixel as *const _ as usize },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORSHAPE),
      "::",
      stringify!(BitsPixel)
    )
  );
}
pub type CURSORSHAPE = tagCURSORSHAPE;
pub type LPCURSORSHAPE = *mut tagCURSORSHAPE;
extern "C" {
  pub fn LoadImageA(
    hInst: HINSTANCE, name: LPCSTR, type_: UINT, cx: libc::c_int, cy: libc::c_int, fuLoad: UINT,
  ) -> HANDLE;
}
extern "C" {
  pub fn LoadImageW(
    hInst: HINSTANCE, name: LPCWSTR, type_: UINT, cx: libc::c_int, cy: libc::c_int, fuLoad: UINT,
  ) -> HANDLE;
}
extern "C" {
  pub fn CopyImage(h: HANDLE, type_: UINT, cx: libc::c_int, cy: libc::c_int, flags: UINT)
    -> HANDLE;
}
extern "C" {
  pub fn DrawIconEx(
    hdc: HDC, xLeft: libc::c_int, yTop: libc::c_int, hIcon: HICON, cxWidth: libc::c_int,
    cyWidth: libc::c_int, istepIfAniCur: UINT, hbrFlickerFreeDraw: HBRUSH, diFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateIconIndirect(piconinfo: PICONINFO) -> HICON;
}
extern "C" {
  pub fn CopyIcon(hIcon: HICON) -> HICON;
}
extern "C" {
  pub fn GetIconInfo(hIcon: HICON, piconinfo: PICONINFO) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ICONINFOEXA {
  pub cbSize: DWORD,
  pub fIcon: BOOL,
  pub xHotspot: DWORD,
  pub yHotspot: DWORD,
  pub hbmMask: HBITMAP,
  pub hbmColor: HBITMAP,
  pub wResID: WORD,
  pub szModName: [CHAR; 260usize],
  pub szResName: [CHAR; 260usize],
}
#[test]
fn bindgen_test_layout__ICONINFOEXA() {
  assert_eq!(
    ::core::mem::size_of::<_ICONINFOEXA>(),
    560usize,
    concat!("Size of: ", stringify!(_ICONINFOEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<_ICONINFOEXA>(),
    8usize,
    concat!("Alignment of ", stringify!(_ICONINFOEXA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).fIcon as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(fIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).xHotspot as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(xHotspot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).yHotspot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(yHotspot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).hbmMask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(hbmMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).hbmColor as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(hbmColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).wResID as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(wResID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).szModName as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(szModName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXA>())).szResName as *const _ as usize },
    294usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXA),
      "::",
      stringify!(szResName)
    )
  );
}
impl Default for _ICONINFOEXA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ICONINFOEXA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_ICONINFOEXA {{ cbSize: {:?}, fIcon: {:?}, xHotspot: {:?}, yHotspot: {:?}, hbmMask: {:?}, hbmColor: {:?}, wResID: {:?}, szModName: [...], szResName: [...] }}" , self . cbSize , self . fIcon , self . xHotspot , self . yHotspot , self . hbmMask , self . hbmColor , self . wResID )
  }
}
impl ::core::cmp::PartialEq for _ICONINFOEXA {
  fn eq(&self, other: &_ICONINFOEXA) -> bool {
    self.cbSize == other.cbSize
      && self.fIcon == other.fIcon
      && self.xHotspot == other.xHotspot
      && self.yHotspot == other.yHotspot
      && self.hbmMask == other.hbmMask
      && self.hbmColor == other.hbmColor
      && self.wResID == other.wResID
      && &self.szModName[..] == &other.szModName[..]
      && &self.szResName[..] == &other.szResName[..]
  }
}
pub type ICONINFOEXA = _ICONINFOEXA;
pub type PICONINFOEXA = *mut _ICONINFOEXA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ICONINFOEXW {
  pub cbSize: DWORD,
  pub fIcon: BOOL,
  pub xHotspot: DWORD,
  pub yHotspot: DWORD,
  pub hbmMask: HBITMAP,
  pub hbmColor: HBITMAP,
  pub wResID: WORD,
  pub szModName: [WCHAR; 260usize],
  pub szResName: [WCHAR; 260usize],
}
#[test]
fn bindgen_test_layout__ICONINFOEXW() {
  assert_eq!(
    ::core::mem::size_of::<_ICONINFOEXW>(),
    1080usize,
    concat!("Size of: ", stringify!(_ICONINFOEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<_ICONINFOEXW>(),
    8usize,
    concat!("Alignment of ", stringify!(_ICONINFOEXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).fIcon as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(fIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).xHotspot as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(xHotspot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).yHotspot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(yHotspot)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).hbmMask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(hbmMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).hbmColor as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(hbmColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).wResID as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(wResID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).szModName as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(szModName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_ICONINFOEXW>())).szResName as *const _ as usize },
    554usize,
    concat!(
      "Offset of field: ",
      stringify!(_ICONINFOEXW),
      "::",
      stringify!(szResName)
    )
  );
}
impl Default for _ICONINFOEXW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _ICONINFOEXW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_ICONINFOEXW {{ cbSize: {:?}, fIcon: {:?}, xHotspot: {:?}, yHotspot: {:?}, hbmMask: {:?}, hbmColor: {:?}, wResID: {:?}, szModName: [...], szResName: [...] }}" , self . cbSize , self . fIcon , self . xHotspot , self . yHotspot , self . hbmMask , self . hbmColor , self . wResID )
  }
}
impl ::core::cmp::PartialEq for _ICONINFOEXW {
  fn eq(&self, other: &_ICONINFOEXW) -> bool {
    self.cbSize == other.cbSize
      && self.fIcon == other.fIcon
      && self.xHotspot == other.xHotspot
      && self.yHotspot == other.yHotspot
      && self.hbmMask == other.hbmMask
      && self.hbmColor == other.hbmColor
      && self.wResID == other.wResID
      && &self.szModName[..] == &other.szModName[..]
      && &self.szResName[..] == &other.szResName[..]
  }
}
pub type ICONINFOEXW = _ICONINFOEXW;
pub type PICONINFOEXW = *mut _ICONINFOEXW;
pub type ICONINFOEX = ICONINFOEXA;
pub type PICONINFOEX = PICONINFOEXA;
extern "C" {
  pub fn GetIconInfoExA(hicon: HICON, piconinfo: PICONINFOEXA) -> BOOL;
}
extern "C" {
  pub fn GetIconInfoExW(hicon: HICON, piconinfo: PICONINFOEXW) -> BOOL;
}
pub mod EDIT_CONTROL_FEATURE {
  pub type Type = i32;
  pub const EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT: Type = 0;
  pub const EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS: Type = 1;
}
extern "C" {
  pub fn IsDialogMessageA(hDlg: HWND, lpMsg: LPMSG) -> BOOL;
}
extern "C" {
  pub fn IsDialogMessageW(hDlg: HWND, lpMsg: LPMSG) -> BOOL;
}
extern "C" {
  pub fn MapDialogRect(hDlg: HWND, lpRect: LPRECT) -> BOOL;
}
extern "C" {
  pub fn DlgDirListA(
    hDlg: HWND, lpPathSpec: LPSTR, nIDListBox: libc::c_int, nIDStaticPath: libc::c_int,
    uFileType: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DlgDirListW(
    hDlg: HWND, lpPathSpec: LPWSTR, nIDListBox: libc::c_int, nIDStaticPath: libc::c_int,
    uFileType: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DlgDirSelectExA(
    hwndDlg: HWND, lpString: LPSTR, chCount: libc::c_int, idListBox: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn DlgDirSelectExW(
    hwndDlg: HWND, lpString: LPWSTR, chCount: libc::c_int, idListBox: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn DlgDirListComboBoxA(
    hDlg: HWND, lpPathSpec: LPSTR, nIDComboBox: libc::c_int, nIDStaticPath: libc::c_int,
    uFiletype: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DlgDirListComboBoxW(
    hDlg: HWND, lpPathSpec: LPWSTR, nIDComboBox: libc::c_int, nIDStaticPath: libc::c_int,
    uFiletype: UINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn DlgDirSelectComboBoxExA(
    hwndDlg: HWND, lpString: LPSTR, cchOut: libc::c_int, idComboBox: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn DlgDirSelectComboBoxExW(
    hwndDlg: HWND, lpString: LPWSTR, cchOut: libc::c_int, idComboBox: libc::c_int,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSCROLLINFO {
  pub cbSize: UINT,
  pub fMask: UINT,
  pub nMin: libc::c_int,
  pub nMax: libc::c_int,
  pub nPage: UINT,
  pub nPos: libc::c_int,
  pub nTrackPos: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagSCROLLINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagSCROLLINFO>(),
    28usize,
    concat!("Size of: ", stringify!(tagSCROLLINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSCROLLINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSCROLLINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).nMin as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nMin)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).nMax as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).nPage as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nPage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).nPos as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLINFO>())).nTrackPos as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nTrackPos)
    )
  );
}
pub type SCROLLINFO = tagSCROLLINFO;
pub type LPSCROLLINFO = *mut tagSCROLLINFO;
pub type LPCSCROLLINFO = *const SCROLLINFO;
extern "C" {
  pub fn SetScrollInfo(
    hwnd: HWND, nBar: libc::c_int, lpsi: LPCSCROLLINFO, redraw: BOOL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetScrollInfo(hwnd: HWND, nBar: libc::c_int, lpsi: LPSCROLLINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMDICREATESTRUCTA {
  pub szClass: LPCSTR,
  pub szTitle: LPCSTR,
  pub hOwner: HANDLE,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub cx: libc::c_int,
  pub cy: libc::c_int,
  pub style: DWORD,
  pub lParam: LPARAM,
}
#[test]
fn bindgen_test_layout_tagMDICREATESTRUCTA() {
  assert_eq!(
    ::core::mem::size_of::<tagMDICREATESTRUCTA>(),
    56usize,
    concat!("Size of: ", stringify!(tagMDICREATESTRUCTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMDICREATESTRUCTA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMDICREATESTRUCTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).szClass as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(szClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).szTitle as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(szTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).hOwner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(hOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).cx as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).cy as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).style as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTA>())).lParam as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTA),
      "::",
      stringify!(lParam)
    )
  );
}
impl Default for tagMDICREATESTRUCTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MDICREATESTRUCTA = tagMDICREATESTRUCTA;
pub type LPMDICREATESTRUCTA = *mut tagMDICREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMDICREATESTRUCTW {
  pub szClass: LPCWSTR,
  pub szTitle: LPCWSTR,
  pub hOwner: HANDLE,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub cx: libc::c_int,
  pub cy: libc::c_int,
  pub style: DWORD,
  pub lParam: LPARAM,
}
#[test]
fn bindgen_test_layout_tagMDICREATESTRUCTW() {
  assert_eq!(
    ::core::mem::size_of::<tagMDICREATESTRUCTW>(),
    56usize,
    concat!("Size of: ", stringify!(tagMDICREATESTRUCTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMDICREATESTRUCTW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMDICREATESTRUCTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).szClass as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(szClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).szTitle as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(szTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).hOwner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(hOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).x as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).y as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).cx as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).cy as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(cy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).style as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(style)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMDICREATESTRUCTW>())).lParam as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMDICREATESTRUCTW),
      "::",
      stringify!(lParam)
    )
  );
}
impl Default for tagMDICREATESTRUCTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type MDICREATESTRUCTW = tagMDICREATESTRUCTW;
pub type LPMDICREATESTRUCTW = *mut tagMDICREATESTRUCTW;
pub type MDICREATESTRUCT = MDICREATESTRUCTA;
pub type LPMDICREATESTRUCT = LPMDICREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCLIENTCREATESTRUCT {
  pub hWindowMenu: HANDLE,
  pub idFirstChild: UINT,
}
#[test]
fn bindgen_test_layout_tagCLIENTCREATESTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCLIENTCREATESTRUCT>(),
    16usize,
    concat!("Size of: ", stringify!(tagCLIENTCREATESTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCLIENTCREATESTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCLIENTCREATESTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCLIENTCREATESTRUCT>())).hWindowMenu as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCLIENTCREATESTRUCT),
      "::",
      stringify!(hWindowMenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCLIENTCREATESTRUCT>())).idFirstChild as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCLIENTCREATESTRUCT),
      "::",
      stringify!(idFirstChild)
    )
  );
}
impl Default for tagCLIENTCREATESTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CLIENTCREATESTRUCT = tagCLIENTCREATESTRUCT;
pub type LPCLIENTCREATESTRUCT = *mut tagCLIENTCREATESTRUCT;
extern "C" {
  pub fn DefFrameProcA(
    hWnd: HWND, hWndMDIClient: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> LRESULT;
}
extern "C" {
  pub fn DefFrameProcW(
    hWnd: HWND, hWndMDIClient: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM,
  ) -> LRESULT;
}
extern "C" {
  pub fn DefMDIChildProcA(hWnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn DefMDIChildProcW(hWnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
  pub fn TranslateMDISysAccel(hWndClient: HWND, lpMsg: LPMSG) -> BOOL;
}
extern "C" {
  pub fn ArrangeIconicWindows(hWnd: HWND) -> UINT;
}
extern "C" {
  pub fn CreateMDIWindowA(
    lpClassName: LPCSTR, lpWindowName: LPCSTR, dwStyle: DWORD, X: libc::c_int, Y: libc::c_int,
    nWidth: libc::c_int, nHeight: libc::c_int, hWndParent: HWND, hInstance: HINSTANCE,
    lParam: LPARAM,
  ) -> HWND;
}
extern "C" {
  pub fn CreateMDIWindowW(
    lpClassName: LPCWSTR, lpWindowName: LPCWSTR, dwStyle: DWORD, X: libc::c_int, Y: libc::c_int,
    nWidth: libc::c_int, nHeight: libc::c_int, hWndParent: HWND, hInstance: HINSTANCE,
    lParam: LPARAM,
  ) -> HWND;
}
extern "C" {
  pub fn TileWindows(
    hwndParent: HWND, wHow: UINT, lpRect: *const RECT, cKids: UINT, lpKids: *const HWND,
  ) -> WORD;
}
extern "C" {
  pub fn CascadeWindows(
    hwndParent: HWND, wHow: UINT, lpRect: *const RECT, cKids: UINT, lpKids: *const HWND,
  ) -> WORD;
}
pub type HELPPOLY = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMULTIKEYHELPA {
  pub mkSize: DWORD,
  pub mkKeylist: CHAR,
  pub szKeyphrase: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout_tagMULTIKEYHELPA() {
  assert_eq!(
    ::core::mem::size_of::<tagMULTIKEYHELPA>(),
    8usize,
    concat!("Size of: ", stringify!(tagMULTIKEYHELPA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMULTIKEYHELPA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMULTIKEYHELPA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMULTIKEYHELPA>())).mkSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMULTIKEYHELPA),
      "::",
      stringify!(mkSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMULTIKEYHELPA>())).mkKeylist as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMULTIKEYHELPA),
      "::",
      stringify!(mkKeylist)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMULTIKEYHELPA>())).szKeyphrase as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMULTIKEYHELPA),
      "::",
      stringify!(szKeyphrase)
    )
  );
}
pub type MULTIKEYHELPA = tagMULTIKEYHELPA;
pub type PMULTIKEYHELPA = *mut tagMULTIKEYHELPA;
pub type LPMULTIKEYHELPA = *mut tagMULTIKEYHELPA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMULTIKEYHELPW {
  pub mkSize: DWORD,
  pub mkKeylist: WCHAR,
  pub szKeyphrase: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout_tagMULTIKEYHELPW() {
  assert_eq!(
    ::core::mem::size_of::<tagMULTIKEYHELPW>(),
    8usize,
    concat!("Size of: ", stringify!(tagMULTIKEYHELPW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMULTIKEYHELPW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMULTIKEYHELPW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMULTIKEYHELPW>())).mkSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMULTIKEYHELPW),
      "::",
      stringify!(mkSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMULTIKEYHELPW>())).mkKeylist as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMULTIKEYHELPW),
      "::",
      stringify!(mkKeylist)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMULTIKEYHELPW>())).szKeyphrase as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMULTIKEYHELPW),
      "::",
      stringify!(szKeyphrase)
    )
  );
}
pub type MULTIKEYHELPW = tagMULTIKEYHELPW;
pub type PMULTIKEYHELPW = *mut tagMULTIKEYHELPW;
pub type LPMULTIKEYHELPW = *mut tagMULTIKEYHELPW;
pub type MULTIKEYHELP = MULTIKEYHELPA;
pub type PMULTIKEYHELP = PMULTIKEYHELPA;
pub type LPMULTIKEYHELP = LPMULTIKEYHELPA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagHELPWININFOA {
  pub wStructSize: libc::c_int,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub dx: libc::c_int,
  pub dy: libc::c_int,
  pub wMax: libc::c_int,
  pub rgchMember: [CHAR; 2usize],
}
#[test]
fn bindgen_test_layout_tagHELPWININFOA() {
  assert_eq!(
    ::core::mem::size_of::<tagHELPWININFOA>(),
    28usize,
    concat!("Size of: ", stringify!(tagHELPWININFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHELPWININFOA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagHELPWININFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).wStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(wStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).x as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).y as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).dx as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(dx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).dy as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(dy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).wMax as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(wMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOA>())).rgchMember as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOA),
      "::",
      stringify!(rgchMember)
    )
  );
}
pub type HELPWININFOA = tagHELPWININFOA;
pub type PHELPWININFOA = *mut tagHELPWININFOA;
pub type LPHELPWININFOA = *mut tagHELPWININFOA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagHELPWININFOW {
  pub wStructSize: libc::c_int,
  pub x: libc::c_int,
  pub y: libc::c_int,
  pub dx: libc::c_int,
  pub dy: libc::c_int,
  pub wMax: libc::c_int,
  pub rgchMember: [WCHAR; 2usize],
}
#[test]
fn bindgen_test_layout_tagHELPWININFOW() {
  assert_eq!(
    ::core::mem::size_of::<tagHELPWININFOW>(),
    28usize,
    concat!("Size of: ", stringify!(tagHELPWININFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHELPWININFOW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagHELPWININFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).wStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(wStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).x as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(x)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).y as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(y)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).dx as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(dx)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).dy as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(dy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).wMax as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(wMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHELPWININFOW>())).rgchMember as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHELPWININFOW),
      "::",
      stringify!(rgchMember)
    )
  );
}
pub type HELPWININFOW = tagHELPWININFOW;
pub type PHELPWININFOW = *mut tagHELPWININFOW;
pub type LPHELPWININFOW = *mut tagHELPWININFOW;
pub type HELPWININFO = HELPWININFOA;
pub type PHELPWININFO = PHELPWININFOA;
pub type LPHELPWININFO = LPHELPWININFOA;
extern "C" {
  pub fn WinHelpA(hWndMain: HWND, lpszHelp: LPCSTR, uCommand: UINT, dwData: ULONG_PTR) -> BOOL;
}
extern "C" {
  pub fn WinHelpW(hWndMain: HWND, lpszHelp: LPCWSTR, uCommand: UINT, dwData: ULONG_PTR) -> BOOL;
}
extern "C" {
  pub fn GetGuiResources(hProcess: HANDLE, uiFlags: DWORD) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTouchPredictionParameters {
  pub cbSize: UINT,
  pub dwLatency: UINT,
  pub dwSampleTime: UINT,
  pub bUseHWTimeStamp: UINT,
}
#[test]
fn bindgen_test_layout_tagTouchPredictionParameters() {
  assert_eq!(
    ::core::mem::size_of::<tagTouchPredictionParameters>(),
    16usize,
    concat!("Size of: ", stringify!(tagTouchPredictionParameters))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTouchPredictionParameters>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTouchPredictionParameters))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTouchPredictionParameters>())).cbSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTouchPredictionParameters),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTouchPredictionParameters>())).dwLatency as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTouchPredictionParameters),
      "::",
      stringify!(dwLatency)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTouchPredictionParameters>())).dwSampleTime as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTouchPredictionParameters),
      "::",
      stringify!(dwSampleTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagTouchPredictionParameters>())).bUseHWTimeStamp as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTouchPredictionParameters),
      "::",
      stringify!(bUseHWTimeStamp)
    )
  );
}
pub type TOUCHPREDICTIONPARAMETERS = tagTouchPredictionParameters;
pub type PTOUCHPREDICTIONPARAMETERS = *mut tagTouchPredictionParameters;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagNONCLIENTMETRICSA {
  pub cbSize: UINT,
  pub iBorderWidth: libc::c_int,
  pub iScrollWidth: libc::c_int,
  pub iScrollHeight: libc::c_int,
  pub iCaptionWidth: libc::c_int,
  pub iCaptionHeight: libc::c_int,
  pub lfCaptionFont: LOGFONTA,
  pub iSmCaptionWidth: libc::c_int,
  pub iSmCaptionHeight: libc::c_int,
  pub lfSmCaptionFont: LOGFONTA,
  pub iMenuWidth: libc::c_int,
  pub iMenuHeight: libc::c_int,
  pub lfMenuFont: LOGFONTA,
  pub lfStatusFont: LOGFONTA,
  pub lfMessageFont: LOGFONTA,
  pub iPaddedBorderWidth: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagNONCLIENTMETRICSA() {
  assert_eq!(
    ::core::mem::size_of::<tagNONCLIENTMETRICSA>(),
    344usize,
    concat!("Size of: ", stringify!(tagNONCLIENTMETRICSA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNONCLIENTMETRICSA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagNONCLIENTMETRICSA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iBorderWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iBorderWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iScrollWidth as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iScrollWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iScrollHeight as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iScrollHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iCaptionWidth as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iCaptionWidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iCaptionHeight as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iCaptionHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).lfCaptionFont as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(lfCaptionFont)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iSmCaptionWidth as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iSmCaptionWidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iSmCaptionHeight as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iSmCaptionHeight)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).lfSmCaptionFont as *const _ as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(lfSmCaptionFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iMenuWidth as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iMenuWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iMenuHeight as *const _ as usize },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iMenuHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).lfMenuFont as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(lfMenuFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).lfStatusFont as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(lfStatusFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).lfMessageFont as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(lfMessageFont)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSA>())).iPaddedBorderWidth as *const _ as usize
    },
    340usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSA),
      "::",
      stringify!(iPaddedBorderWidth)
    )
  );
}
pub type NONCLIENTMETRICSA = tagNONCLIENTMETRICSA;
pub type PNONCLIENTMETRICSA = *mut tagNONCLIENTMETRICSA;
pub type LPNONCLIENTMETRICSA = *mut tagNONCLIENTMETRICSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagNONCLIENTMETRICSW {
  pub cbSize: UINT,
  pub iBorderWidth: libc::c_int,
  pub iScrollWidth: libc::c_int,
  pub iScrollHeight: libc::c_int,
  pub iCaptionWidth: libc::c_int,
  pub iCaptionHeight: libc::c_int,
  pub lfCaptionFont: LOGFONTW,
  pub iSmCaptionWidth: libc::c_int,
  pub iSmCaptionHeight: libc::c_int,
  pub lfSmCaptionFont: LOGFONTW,
  pub iMenuWidth: libc::c_int,
  pub iMenuHeight: libc::c_int,
  pub lfMenuFont: LOGFONTW,
  pub lfStatusFont: LOGFONTW,
  pub lfMessageFont: LOGFONTW,
  pub iPaddedBorderWidth: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagNONCLIENTMETRICSW() {
  assert_eq!(
    ::core::mem::size_of::<tagNONCLIENTMETRICSW>(),
    504usize,
    concat!("Size of: ", stringify!(tagNONCLIENTMETRICSW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagNONCLIENTMETRICSW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagNONCLIENTMETRICSW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iBorderWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iBorderWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iScrollWidth as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iScrollWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iScrollHeight as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iScrollHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iCaptionWidth as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iCaptionWidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iCaptionHeight as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iCaptionHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).lfCaptionFont as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(lfCaptionFont)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iSmCaptionWidth as *const _ as usize
    },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iSmCaptionWidth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iSmCaptionHeight as *const _ as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iSmCaptionHeight)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).lfSmCaptionFont as *const _ as usize
    },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(lfSmCaptionFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iMenuWidth as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iMenuWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iMenuHeight as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iMenuHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).lfMenuFont as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(lfMenuFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).lfStatusFont as *const _ as usize },
    316usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(lfStatusFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).lfMessageFont as *const _ as usize },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(lfMessageFont)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagNONCLIENTMETRICSW>())).iPaddedBorderWidth as *const _ as usize
    },
    500usize,
    concat!(
      "Offset of field: ",
      stringify!(tagNONCLIENTMETRICSW),
      "::",
      stringify!(iPaddedBorderWidth)
    )
  );
}
pub type NONCLIENTMETRICSW = tagNONCLIENTMETRICSW;
pub type PNONCLIENTMETRICSW = *mut tagNONCLIENTMETRICSW;
pub type LPNONCLIENTMETRICSW = *mut tagNONCLIENTMETRICSW;
pub type NONCLIENTMETRICS = NONCLIENTMETRICSA;
pub type PNONCLIENTMETRICS = PNONCLIENTMETRICSA;
pub type LPNONCLIENTMETRICS = LPNONCLIENTMETRICSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMINIMIZEDMETRICS {
  pub cbSize: UINT,
  pub iWidth: libc::c_int,
  pub iHorzGap: libc::c_int,
  pub iVertGap: libc::c_int,
  pub iArrange: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagMINIMIZEDMETRICS() {
  assert_eq!(
    ::core::mem::size_of::<tagMINIMIZEDMETRICS>(),
    20usize,
    concat!("Size of: ", stringify!(tagMINIMIZEDMETRICS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMINIMIZEDMETRICS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMINIMIZEDMETRICS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINIMIZEDMETRICS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINIMIZEDMETRICS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINIMIZEDMETRICS>())).iWidth as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINIMIZEDMETRICS),
      "::",
      stringify!(iWidth)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINIMIZEDMETRICS>())).iHorzGap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINIMIZEDMETRICS),
      "::",
      stringify!(iHorzGap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINIMIZEDMETRICS>())).iVertGap as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINIMIZEDMETRICS),
      "::",
      stringify!(iVertGap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMINIMIZEDMETRICS>())).iArrange as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMINIMIZEDMETRICS),
      "::",
      stringify!(iArrange)
    )
  );
}
pub type MINIMIZEDMETRICS = tagMINIMIZEDMETRICS;
pub type PMINIMIZEDMETRICS = *mut tagMINIMIZEDMETRICS;
pub type LPMINIMIZEDMETRICS = *mut tagMINIMIZEDMETRICS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagICONMETRICSA {
  pub cbSize: UINT,
  pub iHorzSpacing: libc::c_int,
  pub iVertSpacing: libc::c_int,
  pub iTitleWrap: libc::c_int,
  pub lfFont: LOGFONTA,
}
#[test]
fn bindgen_test_layout_tagICONMETRICSA() {
  assert_eq!(
    ::core::mem::size_of::<tagICONMETRICSA>(),
    76usize,
    concat!("Size of: ", stringify!(tagICONMETRICSA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagICONMETRICSA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagICONMETRICSA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSA>())).iHorzSpacing as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSA),
      "::",
      stringify!(iHorzSpacing)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSA>())).iVertSpacing as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSA),
      "::",
      stringify!(iVertSpacing)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSA>())).iTitleWrap as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSA),
      "::",
      stringify!(iTitleWrap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSA>())).lfFont as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSA),
      "::",
      stringify!(lfFont)
    )
  );
}
pub type ICONMETRICSA = tagICONMETRICSA;
pub type PICONMETRICSA = *mut tagICONMETRICSA;
pub type LPICONMETRICSA = *mut tagICONMETRICSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagICONMETRICSW {
  pub cbSize: UINT,
  pub iHorzSpacing: libc::c_int,
  pub iVertSpacing: libc::c_int,
  pub iTitleWrap: libc::c_int,
  pub lfFont: LOGFONTW,
}
#[test]
fn bindgen_test_layout_tagICONMETRICSW() {
  assert_eq!(
    ::core::mem::size_of::<tagICONMETRICSW>(),
    108usize,
    concat!("Size of: ", stringify!(tagICONMETRICSW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagICONMETRICSW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagICONMETRICSW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSW>())).iHorzSpacing as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSW),
      "::",
      stringify!(iHorzSpacing)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSW>())).iVertSpacing as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSW),
      "::",
      stringify!(iVertSpacing)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSW>())).iTitleWrap as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSW),
      "::",
      stringify!(iTitleWrap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagICONMETRICSW>())).lfFont as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagICONMETRICSW),
      "::",
      stringify!(lfFont)
    )
  );
}
pub type ICONMETRICSW = tagICONMETRICSW;
pub type PICONMETRICSW = *mut tagICONMETRICSW;
pub type LPICONMETRICSW = *mut tagICONMETRICSW;
pub type ICONMETRICS = ICONMETRICSA;
pub type PICONMETRICS = PICONMETRICSA;
pub type LPICONMETRICS = LPICONMETRICSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagANIMATIONINFO {
  pub cbSize: UINT,
  pub iMinAnimate: libc::c_int,
}
#[test]
fn bindgen_test_layout_tagANIMATIONINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagANIMATIONINFO>(),
    8usize,
    concat!("Size of: ", stringify!(tagANIMATIONINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagANIMATIONINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagANIMATIONINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagANIMATIONINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagANIMATIONINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagANIMATIONINFO>())).iMinAnimate as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagANIMATIONINFO),
      "::",
      stringify!(iMinAnimate)
    )
  );
}
pub type ANIMATIONINFO = tagANIMATIONINFO;
pub type LPANIMATIONINFO = *mut tagANIMATIONINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagSERIALKEYSA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszActivePort: LPSTR,
  pub lpszPort: LPSTR,
  pub iBaudRate: UINT,
  pub iPortState: UINT,
  pub iActive: UINT,
}
#[test]
fn bindgen_test_layout_tagSERIALKEYSA() {
  assert_eq!(
    ::core::mem::size_of::<tagSERIALKEYSA>(),
    40usize,
    concat!("Size of: ", stringify!(tagSERIALKEYSA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSERIALKEYSA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSERIALKEYSA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).lpszActivePort as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(lpszActivePort)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).lpszPort as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(lpszPort)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).iBaudRate as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iBaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).iPortState as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iPortState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSA>())).iActive as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iActive)
    )
  );
}
impl Default for tagSERIALKEYSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERIALKEYSA = tagSERIALKEYSA;
pub type LPSERIALKEYSA = *mut tagSERIALKEYSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagSERIALKEYSW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszActivePort: LPWSTR,
  pub lpszPort: LPWSTR,
  pub iBaudRate: UINT,
  pub iPortState: UINT,
  pub iActive: UINT,
}
#[test]
fn bindgen_test_layout_tagSERIALKEYSW() {
  assert_eq!(
    ::core::mem::size_of::<tagSERIALKEYSW>(),
    40usize,
    concat!("Size of: ", stringify!(tagSERIALKEYSW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSERIALKEYSW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSERIALKEYSW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).lpszActivePort as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(lpszActivePort)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).lpszPort as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(lpszPort)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).iBaudRate as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iBaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).iPortState as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iPortState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSERIALKEYSW>())).iActive as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iActive)
    )
  );
}
impl Default for tagSERIALKEYSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERIALKEYSW = tagSERIALKEYSW;
pub type LPSERIALKEYSW = *mut tagSERIALKEYSW;
pub type SERIALKEYS = SERIALKEYSA;
pub type LPSERIALKEYS = LPSERIALKEYSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagHIGHCONTRASTA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszDefaultScheme: LPSTR,
}
#[test]
fn bindgen_test_layout_tagHIGHCONTRASTA() {
  assert_eq!(
    ::core::mem::size_of::<tagHIGHCONTRASTA>(),
    16usize,
    concat!("Size of: ", stringify!(tagHIGHCONTRASTA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHIGHCONTRASTA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagHIGHCONTRASTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHIGHCONTRASTA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHIGHCONTRASTA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHIGHCONTRASTA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHIGHCONTRASTA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHIGHCONTRASTA>())).lpszDefaultScheme as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHIGHCONTRASTA),
      "::",
      stringify!(lpszDefaultScheme)
    )
  );
}
impl Default for tagHIGHCONTRASTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type HIGHCONTRASTA = tagHIGHCONTRASTA;
pub type LPHIGHCONTRASTA = *mut tagHIGHCONTRASTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagHIGHCONTRASTW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszDefaultScheme: LPWSTR,
}
#[test]
fn bindgen_test_layout_tagHIGHCONTRASTW() {
  assert_eq!(
    ::core::mem::size_of::<tagHIGHCONTRASTW>(),
    16usize,
    concat!("Size of: ", stringify!(tagHIGHCONTRASTW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagHIGHCONTRASTW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagHIGHCONTRASTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHIGHCONTRASTW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHIGHCONTRASTW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHIGHCONTRASTW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHIGHCONTRASTW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagHIGHCONTRASTW>())).lpszDefaultScheme as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagHIGHCONTRASTW),
      "::",
      stringify!(lpszDefaultScheme)
    )
  );
}
impl Default for tagHIGHCONTRASTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type HIGHCONTRASTW = tagHIGHCONTRASTW;
pub type LPHIGHCONTRASTW = *mut tagHIGHCONTRASTW;
pub type HIGHCONTRAST = HIGHCONTRASTA;
pub type LPHIGHCONTRAST = LPHIGHCONTRASTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VIDEOPARAMETERS {
  pub Guid: GUID,
  pub dwOffset: ULONG,
  pub dwCommand: ULONG,
  pub dwFlags: ULONG,
  pub dwMode: ULONG,
  pub dwTVStandard: ULONG,
  pub dwAvailableModes: ULONG,
  pub dwAvailableTVStandard: ULONG,
  pub dwFlickerFilter: ULONG,
  pub dwOverScanX: ULONG,
  pub dwOverScanY: ULONG,
  pub dwMaxUnscaledX: ULONG,
  pub dwMaxUnscaledY: ULONG,
  pub dwPositionX: ULONG,
  pub dwPositionY: ULONG,
  pub dwBrightness: ULONG,
  pub dwContrast: ULONG,
  pub dwCPType: ULONG,
  pub dwCPCommand: ULONG,
  pub dwCPStandard: ULONG,
  pub dwCPKey: ULONG,
  pub bCP_APSTriggerBits: ULONG,
  pub bOEMCopyProtection: [UCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__VIDEOPARAMETERS() {
  assert_eq!(
    ::core::mem::size_of::<_VIDEOPARAMETERS>(),
    356usize,
    concat!("Size of: ", stringify!(_VIDEOPARAMETERS))
  );
  assert_eq!(
    ::core::mem::align_of::<_VIDEOPARAMETERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_VIDEOPARAMETERS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).Guid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(Guid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwOffset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwCommand as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwMode as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwTVStandard as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwTVStandard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwAvailableModes as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwAvailableModes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwAvailableTVStandard as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwAvailableTVStandard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwFlickerFilter as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwFlickerFilter)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwOverScanX as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwOverScanX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwOverScanY as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwOverScanY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwMaxUnscaledX as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwMaxUnscaledX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwMaxUnscaledY as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwMaxUnscaledY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwPositionX as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwPositionX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwPositionY as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwPositionY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwBrightness as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwBrightness)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwContrast as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwContrast)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwCPType as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwCPType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwCPCommand as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwCPCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwCPStandard as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwCPStandard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).dwCPKey as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(dwCPKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).bCP_APSTriggerBits as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(bCP_APSTriggerBits)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_VIDEOPARAMETERS>())).bOEMCopyProtection as *const _ as usize
    },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIDEOPARAMETERS),
      "::",
      stringify!(bOEMCopyProtection)
    )
  );
}
impl Default for _VIDEOPARAMETERS {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _VIDEOPARAMETERS {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_VIDEOPARAMETERS {{ Guid: {:?}, dwOffset: {:?}, dwCommand: {:?}, dwFlags: {:?}, dwMode: {:?}, dwTVStandard: {:?}, dwAvailableModes: {:?}, dwAvailableTVStandard: {:?}, dwFlickerFilter: {:?}, dwOverScanX: {:?}, dwOverScanY: {:?}, dwMaxUnscaledX: {:?}, dwMaxUnscaledY: {:?}, dwPositionX: {:?}, dwPositionY: {:?}, dwBrightness: {:?}, dwContrast: {:?}, dwCPType: {:?}, dwCPCommand: {:?}, dwCPStandard: {:?}, dwCPKey: {:?}, bCP_APSTriggerBits: {:?}, bOEMCopyProtection: [...] }}" , self . Guid , self . dwOffset , self . dwCommand , self . dwFlags , self . dwMode , self . dwTVStandard , self . dwAvailableModes , self . dwAvailableTVStandard , self . dwFlickerFilter , self . dwOverScanX , self . dwOverScanY , self . dwMaxUnscaledX , self . dwMaxUnscaledY , self . dwPositionX , self . dwPositionY , self . dwBrightness , self . dwContrast , self . dwCPType , self . dwCPCommand , self . dwCPStandard , self . dwCPKey , self . bCP_APSTriggerBits )
  }
}
impl ::core::cmp::PartialEq for _VIDEOPARAMETERS {
  fn eq(&self, other: &_VIDEOPARAMETERS) -> bool {
    self.Guid == other.Guid
      && self.dwOffset == other.dwOffset
      && self.dwCommand == other.dwCommand
      && self.dwFlags == other.dwFlags
      && self.dwMode == other.dwMode
      && self.dwTVStandard == other.dwTVStandard
      && self.dwAvailableModes == other.dwAvailableModes
      && self.dwAvailableTVStandard == other.dwAvailableTVStandard
      && self.dwFlickerFilter == other.dwFlickerFilter
      && self.dwOverScanX == other.dwOverScanX
      && self.dwOverScanY == other.dwOverScanY
      && self.dwMaxUnscaledX == other.dwMaxUnscaledX
      && self.dwMaxUnscaledY == other.dwMaxUnscaledY
      && self.dwPositionX == other.dwPositionX
      && self.dwPositionY == other.dwPositionY
      && self.dwBrightness == other.dwBrightness
      && self.dwContrast == other.dwContrast
      && self.dwCPType == other.dwCPType
      && self.dwCPCommand == other.dwCPCommand
      && self.dwCPStandard == other.dwCPStandard
      && self.dwCPKey == other.dwCPKey
      && self.bCP_APSTriggerBits == other.bCP_APSTriggerBits
      && &self.bOEMCopyProtection[..] == &other.bOEMCopyProtection[..]
  }
}
pub type VIDEOPARAMETERS = _VIDEOPARAMETERS;
pub type PVIDEOPARAMETERS = *mut _VIDEOPARAMETERS;
pub type LPVIDEOPARAMETERS = *mut _VIDEOPARAMETERS;
extern "C" {
  pub fn ChangeDisplaySettingsA(lpDevMode: *mut DEVMODEA, dwFlags: DWORD) -> LONG;
}
extern "C" {
  pub fn ChangeDisplaySettingsW(lpDevMode: *mut DEVMODEW, dwFlags: DWORD) -> LONG;
}
extern "C" {
  pub fn ChangeDisplaySettingsExA(
    lpszDeviceName: LPCSTR, lpDevMode: *mut DEVMODEA, hwnd: HWND, dwflags: DWORD, lParam: LPVOID,
  ) -> LONG;
}
extern "C" {
  pub fn ChangeDisplaySettingsExW(
    lpszDeviceName: LPCWSTR, lpDevMode: *mut DEVMODEW, hwnd: HWND, dwflags: DWORD, lParam: LPVOID,
  ) -> LONG;
}
extern "C" {
  pub fn EnumDisplaySettingsA(
    lpszDeviceName: LPCSTR, iModeNum: DWORD, lpDevMode: *mut DEVMODEA,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDisplaySettingsW(
    lpszDeviceName: LPCWSTR, iModeNum: DWORD, lpDevMode: *mut DEVMODEW,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDisplaySettingsExA(
    lpszDeviceName: LPCSTR, iModeNum: DWORD, lpDevMode: *mut DEVMODEA, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDisplaySettingsExW(
    lpszDeviceName: LPCWSTR, iModeNum: DWORD, lpDevMode: *mut DEVMODEW, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDisplayDevicesA(
    lpDevice: LPCSTR, iDevNum: DWORD, lpDisplayDevice: PDISPLAY_DEVICEA, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDisplayDevicesW(
    lpDevice: LPCWSTR, iDevNum: DWORD, lpDisplayDevice: PDISPLAY_DEVICEW, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetDisplayConfigBufferSizes(
    flags: UINT32, numPathArrayElements: *mut UINT32, numModeInfoArrayElements: *mut UINT32,
  ) -> LONG;
}
extern "C" {
  pub fn SetDisplayConfig(
    numPathArrayElements: UINT32, pathArray: *mut DISPLAYCONFIG_PATH_INFO,
    numModeInfoArrayElements: UINT32, modeInfoArray: *mut DISPLAYCONFIG_MODE_INFO, flags: UINT32,
  ) -> LONG;
}
extern "C" {
  pub fn QueryDisplayConfig(
    flags: UINT32, numPathArrayElements: *mut UINT32, pathArray: *mut DISPLAYCONFIG_PATH_INFO,
    numModeInfoArrayElements: *mut UINT32, modeInfoArray: *mut DISPLAYCONFIG_MODE_INFO,
    currentTopologyId: *mut DISPLAYCONFIG_TOPOLOGY_ID::Type,
  ) -> LONG;
}
extern "C" {
  pub fn DisplayConfigGetDeviceInfo(requestPacket: *mut DISPLAYCONFIG_DEVICE_INFO_HEADER) -> LONG;
}
extern "C" {
  pub fn DisplayConfigSetDeviceInfo(setPacket: *mut DISPLAYCONFIG_DEVICE_INFO_HEADER) -> LONG;
}
extern "C" {
  pub fn SystemParametersInfoA(
    uiAction: UINT, uiParam: UINT, pvParam: PVOID, fWinIni: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SystemParametersInfoW(
    uiAction: UINT, uiParam: UINT, pvParam: PVOID, fWinIni: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SystemParametersInfoForDpi(
    uiAction: UINT, uiParam: UINT, pvParam: PVOID, fWinIni: UINT, dpi: UINT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagFILTERKEYS {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iWaitMSec: DWORD,
  pub iDelayMSec: DWORD,
  pub iRepeatMSec: DWORD,
  pub iBounceMSec: DWORD,
}
#[test]
fn bindgen_test_layout_tagFILTERKEYS() {
  assert_eq!(
    ::core::mem::size_of::<tagFILTERKEYS>(),
    24usize,
    concat!("Size of: ", stringify!(tagFILTERKEYS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagFILTERKEYS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagFILTERKEYS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFILTERKEYS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFILTERKEYS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFILTERKEYS>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFILTERKEYS),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFILTERKEYS>())).iWaitMSec as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFILTERKEYS),
      "::",
      stringify!(iWaitMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFILTERKEYS>())).iDelayMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFILTERKEYS),
      "::",
      stringify!(iDelayMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFILTERKEYS>())).iRepeatMSec as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFILTERKEYS),
      "::",
      stringify!(iRepeatMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagFILTERKEYS>())).iBounceMSec as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFILTERKEYS),
      "::",
      stringify!(iBounceMSec)
    )
  );
}
pub type FILTERKEYS = tagFILTERKEYS;
pub type LPFILTERKEYS = *mut tagFILTERKEYS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSTICKYKEYS {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTICKYKEYS() {
  assert_eq!(
    ::core::mem::size_of::<tagSTICKYKEYS>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTICKYKEYS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSTICKYKEYS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTICKYKEYS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTICKYKEYS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTICKYKEYS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTICKYKEYS>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTICKYKEYS),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type STICKYKEYS = tagSTICKYKEYS;
pub type LPSTICKYKEYS = *mut tagSTICKYKEYS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMOUSEKEYS {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iMaxSpeed: DWORD,
  pub iTimeToMaxSpeed: DWORD,
  pub iCtrlSpeed: DWORD,
  pub dwReserved1: DWORD,
  pub dwReserved2: DWORD,
}
#[test]
fn bindgen_test_layout_tagMOUSEKEYS() {
  assert_eq!(
    ::core::mem::size_of::<tagMOUSEKEYS>(),
    28usize,
    concat!("Size of: ", stringify!(tagMOUSEKEYS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMOUSEKEYS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMOUSEKEYS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).iMaxSpeed as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(iMaxSpeed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).iTimeToMaxSpeed as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(iTimeToMaxSpeed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).iCtrlSpeed as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(iCtrlSpeed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).dwReserved1 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(dwReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMOUSEKEYS>())).dwReserved2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMOUSEKEYS),
      "::",
      stringify!(dwReserved2)
    )
  );
}
pub type MOUSEKEYS = tagMOUSEKEYS;
pub type LPMOUSEKEYS = *mut tagMOUSEKEYS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagACCESSTIMEOUT {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iTimeOutMSec: DWORD,
}
#[test]
fn bindgen_test_layout_tagACCESSTIMEOUT() {
  assert_eq!(
    ::core::mem::size_of::<tagACCESSTIMEOUT>(),
    12usize,
    concat!("Size of: ", stringify!(tagACCESSTIMEOUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagACCESSTIMEOUT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagACCESSTIMEOUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACCESSTIMEOUT>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACCESSTIMEOUT),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACCESSTIMEOUT>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACCESSTIMEOUT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagACCESSTIMEOUT>())).iTimeOutMSec as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagACCESSTIMEOUT),
      "::",
      stringify!(iTimeOutMSec)
    )
  );
}
pub type ACCESSTIMEOUT = tagACCESSTIMEOUT;
pub type LPACCESSTIMEOUT = *mut tagACCESSTIMEOUT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagSOUNDSENTRYA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iFSTextEffect: DWORD,
  pub iFSTextEffectMSec: DWORD,
  pub iFSTextEffectColorBits: DWORD,
  pub iFSGrafEffect: DWORD,
  pub iFSGrafEffectMSec: DWORD,
  pub iFSGrafEffectColor: DWORD,
  pub iWindowsEffect: DWORD,
  pub iWindowsEffectMSec: DWORD,
  pub lpszWindowsEffectDLL: LPSTR,
  pub iWindowsEffectOrdinal: DWORD,
}
#[test]
fn bindgen_test_layout_tagSOUNDSENTRYA() {
  assert_eq!(
    ::core::mem::size_of::<tagSOUNDSENTRYA>(),
    56usize,
    concat!("Size of: ", stringify!(tagSOUNDSENTRYA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSOUNDSENTRYA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOUNDSENTRYA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffect as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffectMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffectColorBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffectColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffect as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffectMSec as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffectMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffectColor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffectColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffect as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffectMSec as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).lpszWindowsEffectDLL as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(lpszWindowsEffectDLL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffectOrdinal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffectOrdinal)
    )
  );
}
impl Default for tagSOUNDSENTRYA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SOUNDSENTRYA = tagSOUNDSENTRYA;
pub type LPSOUNDSENTRYA = *mut tagSOUNDSENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagSOUNDSENTRYW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iFSTextEffect: DWORD,
  pub iFSTextEffectMSec: DWORD,
  pub iFSTextEffectColorBits: DWORD,
  pub iFSGrafEffect: DWORD,
  pub iFSGrafEffectMSec: DWORD,
  pub iFSGrafEffectColor: DWORD,
  pub iWindowsEffect: DWORD,
  pub iWindowsEffectMSec: DWORD,
  pub lpszWindowsEffectDLL: LPWSTR,
  pub iWindowsEffectOrdinal: DWORD,
}
#[test]
fn bindgen_test_layout_tagSOUNDSENTRYW() {
  assert_eq!(
    ::core::mem::size_of::<tagSOUNDSENTRYW>(),
    56usize,
    concat!("Size of: ", stringify!(tagSOUNDSENTRYW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSOUNDSENTRYW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOUNDSENTRYW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffect as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffectMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffectColorBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffectColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffect as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffectMSec as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffectMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffectColor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffectColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffect as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffectMSec as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).lpszWindowsEffectDLL as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(lpszWindowsEffectDLL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffectOrdinal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffectOrdinal)
    )
  );
}
impl Default for tagSOUNDSENTRYW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SOUNDSENTRYW = tagSOUNDSENTRYW;
pub type LPSOUNDSENTRYW = *mut tagSOUNDSENTRYW;
pub type SOUNDSENTRY = SOUNDSENTRYA;
pub type LPSOUNDSENTRY = LPSOUNDSENTRYA;
extern "C" {
  pub fn SoundSentry() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTOGGLEKEYS {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagTOGGLEKEYS() {
  assert_eq!(
    ::core::mem::size_of::<tagTOGGLEKEYS>(),
    8usize,
    concat!("Size of: ", stringify!(tagTOGGLEKEYS))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTOGGLEKEYS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTOGGLEKEYS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOGGLEKEYS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOGGLEKEYS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTOGGLEKEYS>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTOGGLEKEYS),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type TOGGLEKEYS = tagTOGGLEKEYS;
pub type LPTOGGLEKEYS = *mut tagTOGGLEKEYS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagAUDIODESCRIPTION {
  pub cbSize: UINT,
  pub Enabled: BOOL,
  pub Locale: LCID,
}
#[test]
fn bindgen_test_layout_tagAUDIODESCRIPTION() {
  assert_eq!(
    ::core::mem::size_of::<tagAUDIODESCRIPTION>(),
    12usize,
    concat!("Size of: ", stringify!(tagAUDIODESCRIPTION))
  );
  assert_eq!(
    ::core::mem::align_of::<tagAUDIODESCRIPTION>(),
    4usize,
    concat!("Alignment of ", stringify!(tagAUDIODESCRIPTION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAUDIODESCRIPTION>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAUDIODESCRIPTION),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAUDIODESCRIPTION>())).Enabled as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAUDIODESCRIPTION),
      "::",
      stringify!(Enabled)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagAUDIODESCRIPTION>())).Locale as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagAUDIODESCRIPTION),
      "::",
      stringify!(Locale)
    )
  );
}
pub type AUDIODESCRIPTION = tagAUDIODESCRIPTION;
pub type LPAUDIODESCRIPTION = *mut tagAUDIODESCRIPTION;
extern "C" {
  pub fn SetDebugErrorLevel(dwLevel: DWORD);
}
extern "C" {
  pub fn SetLastErrorEx(dwErrCode: DWORD, dwType: DWORD);
}
extern "C" {
  pub fn InternalGetWindowText(
    hWnd: HWND, pString: LPWSTR, cchMaxCount: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CancelShutdown() -> BOOL;
}
extern "C" {
  pub fn MonitorFromPoint(pt: POINT, dwFlags: DWORD) -> HMONITOR;
}
extern "C" {
  pub fn MonitorFromRect(lprc: LPCRECT, dwFlags: DWORD) -> HMONITOR;
}
extern "C" {
  pub fn MonitorFromWindow(hwnd: HWND, dwFlags: DWORD) -> HMONITOR;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMONITORINFO {
  pub cbSize: DWORD,
  pub rcMonitor: RECT,
  pub rcWork: RECT,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagMONITORINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagMONITORINFO>(),
    40usize,
    concat!("Size of: ", stringify!(tagMONITORINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMONITORINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMONITORINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMONITORINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMONITORINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMONITORINFO>())).rcMonitor as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMONITORINFO),
      "::",
      stringify!(rcMonitor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMONITORINFO>())).rcWork as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMONITORINFO),
      "::",
      stringify!(rcWork)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMONITORINFO>())).dwFlags as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMONITORINFO),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type MONITORINFO = tagMONITORINFO;
pub type LPMONITORINFO = *mut tagMONITORINFO;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMONITORINFOEXA {
  pub _bindgen_opaque_blob: [u32; 18usize],
}
#[test]
fn bindgen_test_layout_tagMONITORINFOEXA() {
  assert_eq!(
    ::core::mem::size_of::<tagMONITORINFOEXA>(),
    72usize,
    concat!("Size of: ", stringify!(tagMONITORINFOEXA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMONITORINFOEXA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMONITORINFOEXA))
  );
}
pub type MONITORINFOEXA = tagMONITORINFOEXA;
pub type LPMONITORINFOEXA = *mut tagMONITORINFOEXA;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagMONITORINFOEXW {
  pub __bindgen_padding_0: [u16; 20usize],
  pub szDevice: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagMONITORINFOEXW() {
  assert_eq!(
    ::core::mem::size_of::<tagMONITORINFOEXW>(),
    104usize,
    concat!("Size of: ", stringify!(tagMONITORINFOEXW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMONITORINFOEXW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagMONITORINFOEXW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMONITORINFOEXW>())).szDevice as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMONITORINFOEXW),
      "::",
      stringify!(szDevice)
    )
  );
}
pub type MONITORINFOEXW = tagMONITORINFOEXW;
pub type LPMONITORINFOEXW = *mut tagMONITORINFOEXW;
pub type MONITORINFOEX = MONITORINFOEXA;
pub type LPMONITORINFOEX = LPMONITORINFOEXA;
extern "C" {
  pub fn GetMonitorInfoA(hMonitor: HMONITOR, lpmi: LPMONITORINFO) -> BOOL;
}
extern "C" {
  pub fn GetMonitorInfoW(hMonitor: HMONITOR, lpmi: LPMONITORINFO) -> BOOL;
}
pub type MONITORENUMPROC = ::core::option::Option<
  unsafe extern "C" fn(arg1: HMONITOR, arg2: HDC, arg3: LPRECT, arg4: LPARAM) -> BOOL,
>;
extern "C" {
  pub fn EnumDisplayMonitors(
    hdc: HDC, lprcClip: LPCRECT, lpfnEnum: MONITORENUMPROC, dwData: LPARAM,
  ) -> BOOL;
}
extern "C" {
  pub fn NotifyWinEvent(event: DWORD, hwnd: HWND, idObject: LONG, idChild: LONG);
}
pub type WINEVENTPROC = ::core::option::Option<
  unsafe extern "C" fn(
    hWinEventHook: HWINEVENTHOOK,
    event: DWORD,
    hwnd: HWND,
    idObject: LONG,
    idChild: LONG,
    idEventThread: DWORD,
    dwmsEventTime: DWORD,
  ),
>;
extern "C" {
  pub fn SetWinEventHook(
    eventMin: DWORD, eventMax: DWORD, hmodWinEventProc: HMODULE, pfnWinEventProc: WINEVENTPROC,
    idProcess: DWORD, idThread: DWORD, dwFlags: DWORD,
  ) -> HWINEVENTHOOK;
}
extern "C" {
  pub fn IsWinEventHookInstalled(event: DWORD) -> BOOL;
}
extern "C" {
  pub fn UnhookWinEvent(hWinEventHook: HWINEVENTHOOK) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagGUITHREADINFO {
  pub cbSize: DWORD,
  pub flags: DWORD,
  pub hwndActive: HWND,
  pub hwndFocus: HWND,
  pub hwndCapture: HWND,
  pub hwndMenuOwner: HWND,
  pub hwndMoveSize: HWND,
  pub hwndCaret: HWND,
  pub rcCaret: RECT,
}
#[test]
fn bindgen_test_layout_tagGUITHREADINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagGUITHREADINFO>(),
    72usize,
    concat!("Size of: ", stringify!(tagGUITHREADINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGUITHREADINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagGUITHREADINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).hwndActive as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(hwndActive)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).hwndFocus as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(hwndFocus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).hwndCapture as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(hwndCapture)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).hwndMenuOwner as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(hwndMenuOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).hwndMoveSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(hwndMoveSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).hwndCaret as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(hwndCaret)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGUITHREADINFO>())).rcCaret as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGUITHREADINFO),
      "::",
      stringify!(rcCaret)
    )
  );
}
impl Default for tagGUITHREADINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type GUITHREADINFO = tagGUITHREADINFO;
pub type PGUITHREADINFO = *mut tagGUITHREADINFO;
pub type LPGUITHREADINFO = *mut tagGUITHREADINFO;
extern "C" {
  pub fn GetGUIThreadInfo(idThread: DWORD, pgui: PGUITHREADINFO) -> BOOL;
}
extern "C" {
  pub fn BlockInput(fBlockIt: BOOL) -> BOOL;
}
extern "C" {
  pub fn SetProcessDPIAware() -> BOOL;
}
extern "C" {
  pub fn IsProcessDPIAware() -> BOOL;
}
extern "C" {
  pub fn SetThreadDpiAwarenessContext(dpiContext: DPI_AWARENESS_CONTEXT) -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
  pub fn GetThreadDpiAwarenessContext() -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
  pub fn GetWindowDpiAwarenessContext(hwnd: HWND) -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
  pub fn GetAwarenessFromDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> DPI_AWARENESS::Type;
}
extern "C" {
  pub fn AreDpiAwarenessContextsEqual(
    dpiContextA: DPI_AWARENESS_CONTEXT, dpiContextB: DPI_AWARENESS_CONTEXT,
  ) -> BOOL;
}
extern "C" {
  pub fn IsValidDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn GetDpiForWindow(hwnd: HWND) -> UINT;
}
extern "C" {
  pub fn GetDpiForSystem() -> UINT;
}
extern "C" {
  pub fn EnableNonClientDpiScaling(hwnd: HWND) -> BOOL;
}
extern "C" {
  pub fn InheritWindowMonitor(hwnd: HWND, hwndInherit: HWND) -> BOOL;
}
extern "C" {
  pub fn SetProcessDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> BOOL;
}
extern "C" {
  pub fn GetWindowModuleFileNameA(hwnd: HWND, pszFileName: LPSTR, cchFileNameMax: UINT) -> UINT;
}
extern "C" {
  pub fn GetWindowModuleFileNameW(hwnd: HWND, pszFileName: LPWSTR, cchFileNameMax: UINT) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCURSORINFO {
  pub cbSize: DWORD,
  pub flags: DWORD,
  pub hCursor: HCURSOR,
  pub ptScreenPos: POINT,
}
#[test]
fn bindgen_test_layout_tagCURSORINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagCURSORINFO>(),
    24usize,
    concat!("Size of: ", stringify!(tagCURSORINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCURSORINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCURSORINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORINFO>())).flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORINFO),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORINFO>())).hCursor as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORINFO),
      "::",
      stringify!(hCursor)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCURSORINFO>())).ptScreenPos as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCURSORINFO),
      "::",
      stringify!(ptScreenPos)
    )
  );
}
impl Default for tagCURSORINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CURSORINFO = tagCURSORINFO;
pub type PCURSORINFO = *mut tagCURSORINFO;
pub type LPCURSORINFO = *mut tagCURSORINFO;
extern "C" {
  pub fn GetCursorInfo(pci: PCURSORINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagWINDOWINFO {
  pub cbSize: DWORD,
  pub rcWindow: RECT,
  pub rcClient: RECT,
  pub dwStyle: DWORD,
  pub dwExStyle: DWORD,
  pub dwWindowStatus: DWORD,
  pub cxWindowBorders: UINT,
  pub cyWindowBorders: UINT,
  pub atomWindowType: ATOM,
  pub wCreatorVersion: WORD,
}
#[test]
fn bindgen_test_layout_tagWINDOWINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagWINDOWINFO>(),
    60usize,
    concat!("Size of: ", stringify!(tagWINDOWINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagWINDOWINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagWINDOWINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).rcWindow as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(rcWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).rcClient as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(rcClient)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).dwStyle as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).dwExStyle as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(dwExStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).dwWindowStatus as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(dwWindowStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).cxWindowBorders as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(cxWindowBorders)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).cyWindowBorders as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(cyWindowBorders)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).atomWindowType as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(atomWindowType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagWINDOWINFO>())).wCreatorVersion as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(tagWINDOWINFO),
      "::",
      stringify!(wCreatorVersion)
    )
  );
}
pub type WINDOWINFO = tagWINDOWINFO;
pub type PWINDOWINFO = *mut tagWINDOWINFO;
pub type LPWINDOWINFO = *mut tagWINDOWINFO;
extern "C" {
  pub fn GetWindowInfo(hwnd: HWND, pwi: PWINDOWINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTITLEBARINFO {
  pub cbSize: DWORD,
  pub rcTitleBar: RECT,
  pub rgstate: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_tagTITLEBARINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagTITLEBARINFO>(),
    44usize,
    concat!("Size of: ", stringify!(tagTITLEBARINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTITLEBARINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTITLEBARINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFO>())).rcTitleBar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFO),
      "::",
      stringify!(rcTitleBar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFO>())).rgstate as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFO),
      "::",
      stringify!(rgstate)
    )
  );
}
pub type TITLEBARINFO = tagTITLEBARINFO;
pub type PTITLEBARINFO = *mut tagTITLEBARINFO;
pub type LPTITLEBARINFO = *mut tagTITLEBARINFO;
extern "C" {
  pub fn GetTitleBarInfo(hwnd: HWND, pti: PTITLEBARINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagTITLEBARINFOEX {
  pub cbSize: DWORD,
  pub rcTitleBar: RECT,
  pub rgstate: [DWORD; 6usize],
  pub rgrect: [RECT; 6usize],
}
#[test]
fn bindgen_test_layout_tagTITLEBARINFOEX() {
  assert_eq!(
    ::core::mem::size_of::<tagTITLEBARINFOEX>(),
    140usize,
    concat!("Size of: ", stringify!(tagTITLEBARINFOEX))
  );
  assert_eq!(
    ::core::mem::align_of::<tagTITLEBARINFOEX>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTITLEBARINFOEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFOEX>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFOEX),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFOEX>())).rcTitleBar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFOEX),
      "::",
      stringify!(rcTitleBar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFOEX>())).rgstate as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFOEX),
      "::",
      stringify!(rgstate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagTITLEBARINFOEX>())).rgrect as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTITLEBARINFOEX),
      "::",
      stringify!(rgrect)
    )
  );
}
pub type TITLEBARINFOEX = tagTITLEBARINFOEX;
pub type PTITLEBARINFOEX = *mut tagTITLEBARINFOEX;
pub type LPTITLEBARINFOEX = *mut tagTITLEBARINFOEX;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagMENUBARINFO {
  pub cbSize: DWORD,
  pub rcBar: RECT,
  pub hMenu: HMENU,
  pub hwndMenu: HWND,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_tagMENUBARINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagMENUBARINFO>(),
    48usize,
    concat!("Size of: ", stringify!(tagMENUBARINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagMENUBARINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagMENUBARINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUBARINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUBARINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUBARINFO>())).rcBar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUBARINFO),
      "::",
      stringify!(rcBar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUBARINFO>())).hMenu as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUBARINFO),
      "::",
      stringify!(hMenu)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagMENUBARINFO>())).hwndMenu as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagMENUBARINFO),
      "::",
      stringify!(hwndMenu)
    )
  );
}
impl Default for tagMENUBARINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl tagMENUBARINFO {
  #[inline]
  pub fn fBarFocused(&self) -> BOOL {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fBarFocused(&mut self, val: BOOL) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fFocused(&self) -> BOOL {
    unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fFocused(&mut self, val: BOOL) {
    unsafe {
      let val: u32 = ::core::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    fBarFocused: BOOL, fFocused: BOOL,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let fBarFocused: u32 = unsafe { ::core::mem::transmute(fBarFocused) };
      fBarFocused as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let fFocused: u32 = unsafe { ::core::mem::transmute(fFocused) };
      fFocused as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type MENUBARINFO = tagMENUBARINFO;
pub type PMENUBARINFO = *mut tagMENUBARINFO;
pub type LPMENUBARINFO = *mut tagMENUBARINFO;
extern "C" {
  pub fn GetMenuBarInfo(hwnd: HWND, idObject: LONG, idItem: LONG, pmbi: PMENUBARINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSCROLLBARINFO {
  pub cbSize: DWORD,
  pub rcScrollBar: RECT,
  pub dxyLineButton: libc::c_int,
  pub xyThumbTop: libc::c_int,
  pub xyThumbBottom: libc::c_int,
  pub reserved: libc::c_int,
  pub rgstate: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_tagSCROLLBARINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagSCROLLBARINFO>(),
    60usize,
    concat!("Size of: ", stringify!(tagSCROLLBARINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSCROLLBARINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSCROLLBARINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).rcScrollBar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(rcScrollBar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).dxyLineButton as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(dxyLineButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).xyThumbTop as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(xyThumbTop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).xyThumbBottom as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(xyThumbBottom)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).reserved as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSCROLLBARINFO>())).rgstate as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(rgstate)
    )
  );
}
pub type SCROLLBARINFO = tagSCROLLBARINFO;
pub type PSCROLLBARINFO = *mut tagSCROLLBARINFO;
pub type LPSCROLLBARINFO = *mut tagSCROLLBARINFO;
extern "C" {
  pub fn GetScrollBarInfo(hwnd: HWND, idObject: LONG, psbi: PSCROLLBARINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagCOMBOBOXINFO {
  pub cbSize: DWORD,
  pub rcItem: RECT,
  pub rcButton: RECT,
  pub stateButton: DWORD,
  pub hwndCombo: HWND,
  pub hwndItem: HWND,
  pub hwndList: HWND,
}
#[test]
fn bindgen_test_layout_tagCOMBOBOXINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagCOMBOBOXINFO>(),
    64usize,
    concat!("Size of: ", stringify!(tagCOMBOBOXINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOMBOBOXINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCOMBOBOXINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).rcItem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(rcItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).rcButton as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(rcButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).stateButton as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(stateButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).hwndCombo as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(hwndCombo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).hwndItem as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(hwndItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMBOBOXINFO>())).hwndList as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMBOBOXINFO),
      "::",
      stringify!(hwndList)
    )
  );
}
impl Default for tagCOMBOBOXINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type COMBOBOXINFO = tagCOMBOBOXINFO;
pub type PCOMBOBOXINFO = *mut tagCOMBOBOXINFO;
pub type LPCOMBOBOXINFO = *mut tagCOMBOBOXINFO;
extern "C" {
  pub fn GetComboBoxInfo(hwndCombo: HWND, pcbi: PCOMBOBOXINFO) -> BOOL;
}
extern "C" {
  pub fn GetAncestor(hwnd: HWND, gaFlags: UINT) -> HWND;
}
extern "C" {
  pub fn RealChildWindowFromPoint(hwndParent: HWND, ptParentClientCoords: POINT) -> HWND;
}
extern "C" {
  pub fn RealGetWindowClassA(hwnd: HWND, ptszClassName: LPSTR, cchClassNameMax: UINT) -> UINT;
}
extern "C" {
  pub fn RealGetWindowClassW(hwnd: HWND, ptszClassName: LPWSTR, cchClassNameMax: UINT) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagALTTABINFO {
  pub cbSize: DWORD,
  pub cItems: libc::c_int,
  pub cColumns: libc::c_int,
  pub cRows: libc::c_int,
  pub iColFocus: libc::c_int,
  pub iRowFocus: libc::c_int,
  pub cxItem: libc::c_int,
  pub cyItem: libc::c_int,
  pub ptStart: POINT,
}
#[test]
fn bindgen_test_layout_tagALTTABINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagALTTABINFO>(),
    40usize,
    concat!("Size of: ", stringify!(tagALTTABINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagALTTABINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagALTTABINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).cItems as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(cItems)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).cColumns as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(cColumns)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).cRows as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(cRows)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).iColFocus as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(iColFocus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).iRowFocus as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(iRowFocus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).cxItem as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(cxItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).cyItem as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(cyItem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagALTTABINFO>())).ptStart as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagALTTABINFO),
      "::",
      stringify!(ptStart)
    )
  );
}
pub type ALTTABINFO = tagALTTABINFO;
pub type PALTTABINFO = *mut tagALTTABINFO;
pub type LPALTTABINFO = *mut tagALTTABINFO;
extern "C" {
  pub fn GetAltTabInfoA(
    hwnd: HWND, iItem: libc::c_int, pati: PALTTABINFO, pszItemText: LPSTR, cchItemText: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetAltTabInfoW(
    hwnd: HWND, iItem: libc::c_int, pati: PALTTABINFO, pszItemText: LPWSTR, cchItemText: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetListBoxInfo(hwnd: HWND) -> DWORD;
}
extern "C" {
  pub fn LockWorkStation() -> BOOL;
}
extern "C" {
  pub fn UserHandleGrantAccess(hUserHandle: HANDLE, hJob: HANDLE, bGrant: BOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HRAWINPUT__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HRAWINPUT__() {
  assert_eq!(
    ::core::mem::size_of::<HRAWINPUT__>(),
    4usize,
    concat!("Size of: ", stringify!(HRAWINPUT__))
  );
  assert_eq!(
    ::core::mem::align_of::<HRAWINPUT__>(),
    4usize,
    concat!("Alignment of ", stringify!(HRAWINPUT__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HRAWINPUT__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HRAWINPUT__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HRAWINPUT = *mut HRAWINPUT__;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagRAWINPUTHEADER {
  pub dwType: DWORD,
  pub dwSize: DWORD,
  pub hDevice: HANDLE,
  pub wParam: WPARAM,
}
#[test]
fn bindgen_test_layout_tagRAWINPUTHEADER() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWINPUTHEADER>(),
    24usize,
    concat!("Size of: ", stringify!(tagRAWINPUTHEADER))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWINPUTHEADER>(),
    8usize,
    concat!("Alignment of ", stringify!(tagRAWINPUTHEADER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTHEADER>())).dwType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTHEADER),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTHEADER>())).dwSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTHEADER),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTHEADER>())).hDevice as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTHEADER),
      "::",
      stringify!(hDevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTHEADER>())).wParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTHEADER),
      "::",
      stringify!(wParam)
    )
  );
}
impl Default for tagRAWINPUTHEADER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RAWINPUTHEADER = tagRAWINPUTHEADER;
pub type PRAWINPUTHEADER = *mut tagRAWINPUTHEADER;
pub type LPRAWINPUTHEADER = *mut tagRAWINPUTHEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRAWMOUSE {
  pub usFlags: USHORT,
  pub __bindgen_anon_1: tagRAWMOUSE__bindgen_ty_1,
  pub ulRawButtons: ULONG,
  pub lLastX: LONG,
  pub lLastY: LONG,
  pub ulExtraInformation: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRAWMOUSE__bindgen_ty_1 {
  pub ulButtons: ULONG,
  pub __bindgen_anon_1: tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1 {
  pub usButtonFlags: USHORT,
  pub usButtonData: USHORT,
}
#[test]
fn bindgen_test_layout_tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1>())).usButtonFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(usButtonFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1>())).usButtonData as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(usButtonData)
    )
  );
}
#[test]
fn bindgen_test_layout_tagRAWMOUSE__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWMOUSE__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(tagRAWMOUSE__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWMOUSE__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRAWMOUSE__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRAWMOUSE__bindgen_ty_1>())).ulButtons as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE__bindgen_ty_1),
      "::",
      stringify!(ulButtons)
    )
  );
}
impl Default for tagRAWMOUSE__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagRAWMOUSE__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "tagRAWMOUSE__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_tagRAWMOUSE() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWMOUSE>(),
    24usize,
    concat!("Size of: ", stringify!(tagRAWMOUSE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWMOUSE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRAWMOUSE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWMOUSE>())).usFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE),
      "::",
      stringify!(usFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWMOUSE>())).ulRawButtons as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE),
      "::",
      stringify!(ulRawButtons)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWMOUSE>())).lLastX as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE),
      "::",
      stringify!(lLastX)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWMOUSE>())).lLastY as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE),
      "::",
      stringify!(lLastY)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWMOUSE>())).ulExtraInformation as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWMOUSE),
      "::",
      stringify!(ulExtraInformation)
    )
  );
}
impl Default for tagRAWMOUSE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagRAWMOUSE {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagRAWMOUSE {{ usFlags: {:?}, __bindgen_anon_1: {:?}, ulRawButtons: {:?}, lLastX: {:?}, lLastY: {:?}, ulExtraInformation: {:?} }}" , self . usFlags , self . __bindgen_anon_1 , self . ulRawButtons , self . lLastX , self . lLastY , self . ulExtraInformation )
  }
}
pub type RAWMOUSE = tagRAWMOUSE;
pub type PRAWMOUSE = *mut tagRAWMOUSE;
pub type LPRAWMOUSE = *mut tagRAWMOUSE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRAWKEYBOARD {
  pub MakeCode: USHORT,
  pub Flags: USHORT,
  pub Reserved: USHORT,
  pub VKey: USHORT,
  pub Message: UINT,
  pub ExtraInformation: ULONG,
}
#[test]
fn bindgen_test_layout_tagRAWKEYBOARD() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWKEYBOARD>(),
    16usize,
    concat!("Size of: ", stringify!(tagRAWKEYBOARD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWKEYBOARD>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRAWKEYBOARD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWKEYBOARD>())).MakeCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWKEYBOARD),
      "::",
      stringify!(MakeCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWKEYBOARD>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWKEYBOARD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWKEYBOARD>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWKEYBOARD),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWKEYBOARD>())).VKey as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWKEYBOARD),
      "::",
      stringify!(VKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWKEYBOARD>())).Message as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWKEYBOARD),
      "::",
      stringify!(Message)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWKEYBOARD>())).ExtraInformation as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWKEYBOARD),
      "::",
      stringify!(ExtraInformation)
    )
  );
}
pub type RAWKEYBOARD = tagRAWKEYBOARD;
pub type PRAWKEYBOARD = *mut tagRAWKEYBOARD;
pub type LPRAWKEYBOARD = *mut tagRAWKEYBOARD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRAWHID {
  pub dwSizeHid: DWORD,
  pub dwCount: DWORD,
  pub bRawData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagRAWHID() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWHID>(),
    12usize,
    concat!("Size of: ", stringify!(tagRAWHID))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWHID>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRAWHID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWHID>())).dwSizeHid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWHID),
      "::",
      stringify!(dwSizeHid)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWHID>())).dwCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWHID),
      "::",
      stringify!(dwCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWHID>())).bRawData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWHID),
      "::",
      stringify!(bRawData)
    )
  );
}
pub type RAWHID = tagRAWHID;
pub type PRAWHID = *mut tagRAWHID;
pub type LPRAWHID = *mut tagRAWHID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRAWINPUT {
  pub header: RAWINPUTHEADER,
  pub data: tagRAWINPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRAWINPUT__bindgen_ty_1 {
  pub mouse: RAWMOUSE,
  pub keyboard: RAWKEYBOARD,
  pub hid: RAWHID,
  _bindgen_union_align: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_tagRAWINPUT__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWINPUT__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(tagRAWINPUT__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWINPUT__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRAWINPUT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUT__bindgen_ty_1>())).mouse as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUT__bindgen_ty_1),
      "::",
      stringify!(mouse)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUT__bindgen_ty_1>())).keyboard as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUT__bindgen_ty_1),
      "::",
      stringify!(keyboard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUT__bindgen_ty_1>())).hid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUT__bindgen_ty_1),
      "::",
      stringify!(hid)
    )
  );
}
impl Default for tagRAWINPUT__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagRAWINPUT__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "tagRAWINPUT__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_tagRAWINPUT() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWINPUT>(),
    48usize,
    concat!("Size of: ", stringify!(tagRAWINPUT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWINPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagRAWINPUT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUT>())).header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUT),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUT>())).data as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUT),
      "::",
      stringify!(data)
    )
  );
}
impl Default for tagRAWINPUT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagRAWINPUT {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagRAWINPUT {{ header: {:?}, data: {:?} }}",
      self.header, self.data
    )
  }
}
pub type RAWINPUT = tagRAWINPUT;
pub type PRAWINPUT = *mut tagRAWINPUT;
pub type LPRAWINPUT = *mut tagRAWINPUT;
extern "C" {
  pub fn GetRawInputData(
    hRawInput: HRAWINPUT, uiCommand: UINT, pData: LPVOID, pcbSize: PUINT, cbSizeHeader: UINT,
  ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRID_DEVICE_INFO_MOUSE {
  pub dwId: DWORD,
  pub dwNumberOfButtons: DWORD,
  pub dwSampleRate: DWORD,
  pub fHasHorizontalWheel: BOOL,
}
#[test]
fn bindgen_test_layout_tagRID_DEVICE_INFO_MOUSE() {
  assert_eq!(
    ::core::mem::size_of::<tagRID_DEVICE_INFO_MOUSE>(),
    16usize,
    concat!("Size of: ", stringify!(tagRID_DEVICE_INFO_MOUSE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRID_DEVICE_INFO_MOUSE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRID_DEVICE_INFO_MOUSE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO_MOUSE>())).dwId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_MOUSE),
      "::",
      stringify!(dwId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_MOUSE>())).dwNumberOfButtons as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_MOUSE),
      "::",
      stringify!(dwNumberOfButtons)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_MOUSE>())).dwSampleRate as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_MOUSE),
      "::",
      stringify!(dwSampleRate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_MOUSE>())).fHasHorizontalWheel as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_MOUSE),
      "::",
      stringify!(fHasHorizontalWheel)
    )
  );
}
pub type RID_DEVICE_INFO_MOUSE = tagRID_DEVICE_INFO_MOUSE;
pub type PRID_DEVICE_INFO_MOUSE = *mut tagRID_DEVICE_INFO_MOUSE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRID_DEVICE_INFO_KEYBOARD {
  pub dwType: DWORD,
  pub dwSubType: DWORD,
  pub dwKeyboardMode: DWORD,
  pub dwNumberOfFunctionKeys: DWORD,
  pub dwNumberOfIndicators: DWORD,
  pub dwNumberOfKeysTotal: DWORD,
}
#[test]
fn bindgen_test_layout_tagRID_DEVICE_INFO_KEYBOARD() {
  assert_eq!(
    ::core::mem::size_of::<tagRID_DEVICE_INFO_KEYBOARD>(),
    24usize,
    concat!("Size of: ", stringify!(tagRID_DEVICE_INFO_KEYBOARD))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRID_DEVICE_INFO_KEYBOARD>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRID_DEVICE_INFO_KEYBOARD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO_KEYBOARD>())).dwType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_KEYBOARD),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_KEYBOARD>())).dwSubType as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_KEYBOARD),
      "::",
      stringify!(dwSubType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_KEYBOARD>())).dwKeyboardMode as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_KEYBOARD),
      "::",
      stringify!(dwKeyboardMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_KEYBOARD>())).dwNumberOfFunctionKeys as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_KEYBOARD),
      "::",
      stringify!(dwNumberOfFunctionKeys)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_KEYBOARD>())).dwNumberOfIndicators as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_KEYBOARD),
      "::",
      stringify!(dwNumberOfIndicators)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_KEYBOARD>())).dwNumberOfKeysTotal as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_KEYBOARD),
      "::",
      stringify!(dwNumberOfKeysTotal)
    )
  );
}
pub type RID_DEVICE_INFO_KEYBOARD = tagRID_DEVICE_INFO_KEYBOARD;
pub type PRID_DEVICE_INFO_KEYBOARD = *mut tagRID_DEVICE_INFO_KEYBOARD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRID_DEVICE_INFO_HID {
  pub dwVendorId: DWORD,
  pub dwProductId: DWORD,
  pub dwVersionNumber: DWORD,
  pub usUsagePage: USHORT,
  pub usUsage: USHORT,
}
#[test]
fn bindgen_test_layout_tagRID_DEVICE_INFO_HID() {
  assert_eq!(
    ::core::mem::size_of::<tagRID_DEVICE_INFO_HID>(),
    16usize,
    concat!("Size of: ", stringify!(tagRID_DEVICE_INFO_HID))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRID_DEVICE_INFO_HID>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRID_DEVICE_INFO_HID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO_HID>())).dwVendorId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_HID),
      "::",
      stringify!(dwVendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO_HID>())).dwProductId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_HID),
      "::",
      stringify!(dwProductId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO_HID>())).dwVersionNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_HID),
      "::",
      stringify!(dwVersionNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO_HID>())).usUsagePage as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_HID),
      "::",
      stringify!(usUsagePage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO_HID>())).usUsage as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO_HID),
      "::",
      stringify!(usUsage)
    )
  );
}
pub type RID_DEVICE_INFO_HID = tagRID_DEVICE_INFO_HID;
pub type PRID_DEVICE_INFO_HID = *mut tagRID_DEVICE_INFO_HID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRID_DEVICE_INFO {
  pub cbSize: DWORD,
  pub dwType: DWORD,
  pub __bindgen_anon_1: tagRID_DEVICE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRID_DEVICE_INFO__bindgen_ty_1 {
  pub mouse: RID_DEVICE_INFO_MOUSE,
  pub keyboard: RID_DEVICE_INFO_KEYBOARD,
  pub hid: RID_DEVICE_INFO_HID,
  _bindgen_union_align: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_tagRID_DEVICE_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<tagRID_DEVICE_INFO__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(tagRID_DEVICE_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRID_DEVICE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(tagRID_DEVICE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO__bindgen_ty_1>())).mouse as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO__bindgen_ty_1),
      "::",
      stringify!(mouse)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO__bindgen_ty_1>())).keyboard as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO__bindgen_ty_1),
      "::",
      stringify!(keyboard)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRID_DEVICE_INFO__bindgen_ty_1>())).hid as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO__bindgen_ty_1),
      "::",
      stringify!(hid)
    )
  );
}
impl Default for tagRID_DEVICE_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagRID_DEVICE_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "tagRID_DEVICE_INFO__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_tagRID_DEVICE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagRID_DEVICE_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(tagRID_DEVICE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRID_DEVICE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRID_DEVICE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRID_DEVICE_INFO>())).dwType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRID_DEVICE_INFO),
      "::",
      stringify!(dwType)
    )
  );
}
impl Default for tagRID_DEVICE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagRID_DEVICE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "tagRID_DEVICE_INFO {{ cbSize: {:?}, dwType: {:?}, __bindgen_anon_1: {:?} }}",
      self.cbSize, self.dwType, self.__bindgen_anon_1
    )
  }
}
pub type RID_DEVICE_INFO = tagRID_DEVICE_INFO;
pub type PRID_DEVICE_INFO = *mut tagRID_DEVICE_INFO;
pub type LPRID_DEVICE_INFO = *mut tagRID_DEVICE_INFO;
extern "C" {
  pub fn GetRawInputDeviceInfoA(
    hDevice: HANDLE, uiCommand: UINT, pData: LPVOID, pcbSize: PUINT,
  ) -> UINT;
}
extern "C" {
  pub fn GetRawInputDeviceInfoW(
    hDevice: HANDLE, uiCommand: UINT, pData: LPVOID, pcbSize: PUINT,
  ) -> UINT;
}
extern "C" {
  pub fn GetRawInputBuffer(pData: PRAWINPUT, pcbSize: PUINT, cbSizeHeader: UINT) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagRAWINPUTDEVICE {
  pub usUsagePage: USHORT,
  pub usUsage: USHORT,
  pub dwFlags: DWORD,
  pub hwndTarget: HWND,
}
#[test]
fn bindgen_test_layout_tagRAWINPUTDEVICE() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWINPUTDEVICE>(),
    16usize,
    concat!("Size of: ", stringify!(tagRAWINPUTDEVICE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWINPUTDEVICE>(),
    8usize,
    concat!("Alignment of ", stringify!(tagRAWINPUTDEVICE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTDEVICE>())).usUsagePage as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTDEVICE),
      "::",
      stringify!(usUsagePage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTDEVICE>())).usUsage as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTDEVICE),
      "::",
      stringify!(usUsage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTDEVICE>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTDEVICE),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTDEVICE>())).hwndTarget as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTDEVICE),
      "::",
      stringify!(hwndTarget)
    )
  );
}
impl Default for tagRAWINPUTDEVICE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RAWINPUTDEVICE = tagRAWINPUTDEVICE;
pub type PRAWINPUTDEVICE = *mut tagRAWINPUTDEVICE;
pub type LPRAWINPUTDEVICE = *mut tagRAWINPUTDEVICE;
pub type PCRAWINPUTDEVICE = *const RAWINPUTDEVICE;
extern "C" {
  pub fn RegisterRawInputDevices(
    pRawInputDevices: PCRAWINPUTDEVICE, uiNumDevices: UINT, cbSize: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetRegisteredRawInputDevices(
    pRawInputDevices: PRAWINPUTDEVICE, puiNumDevices: PUINT, cbSize: UINT,
  ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagRAWINPUTDEVICELIST {
  pub hDevice: HANDLE,
  pub dwType: DWORD,
}
#[test]
fn bindgen_test_layout_tagRAWINPUTDEVICELIST() {
  assert_eq!(
    ::core::mem::size_of::<tagRAWINPUTDEVICELIST>(),
    16usize,
    concat!("Size of: ", stringify!(tagRAWINPUTDEVICELIST))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRAWINPUTDEVICELIST>(),
    8usize,
    concat!("Alignment of ", stringify!(tagRAWINPUTDEVICELIST))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTDEVICELIST>())).hDevice as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTDEVICELIST),
      "::",
      stringify!(hDevice)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRAWINPUTDEVICELIST>())).dwType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRAWINPUTDEVICELIST),
      "::",
      stringify!(dwType)
    )
  );
}
impl Default for tagRAWINPUTDEVICELIST {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type RAWINPUTDEVICELIST = tagRAWINPUTDEVICELIST;
pub type PRAWINPUTDEVICELIST = *mut tagRAWINPUTDEVICELIST;
extern "C" {
  pub fn GetRawInputDeviceList(
    pRawInputDeviceList: PRAWINPUTDEVICELIST, puiNumDevices: PUINT, cbSize: UINT,
  ) -> UINT;
}
extern "C" {
  pub fn DefRawInputProc(paRawInput: *mut PRAWINPUT, nInput: INT, cbSizeHeader: UINT) -> LRESULT;
}
pub mod tagPOINTER_DEVICE_TYPE {
  pub type Type = i32;
  pub const POINTER_DEVICE_TYPE_INTEGRATED_PEN: Type = 1;
  pub const POINTER_DEVICE_TYPE_EXTERNAL_PEN: Type = 2;
  pub const POINTER_DEVICE_TYPE_TOUCH: Type = 3;
  pub const POINTER_DEVICE_TYPE_TOUCH_PAD: Type = 4;
  pub const POINTER_DEVICE_TYPE_MAX: Type = -1;
}
pub use self::tagPOINTER_DEVICE_TYPE::Type as POINTER_DEVICE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPOINTER_DEVICE_INFO {
  pub displayOrientation: DWORD,
  pub device: HANDLE,
  pub pointerDeviceType: POINTER_DEVICE_TYPE,
  pub monitor: HMONITOR,
  pub startingCursorId: ULONG,
  pub maxActiveContacts: USHORT,
  pub productString: [WCHAR; 520usize],
}
#[test]
fn bindgen_test_layout_tagPOINTER_DEVICE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_DEVICE_INFO>(),
    1080usize,
    concat!("Size of: ", stringify!(tagPOINTER_DEVICE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_DEVICE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPOINTER_DEVICE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).displayOrientation as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(displayOrientation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).device as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(device)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).pointerDeviceType as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(pointerDeviceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).monitor as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(monitor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).startingCursorId as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(startingCursorId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).maxActiveContacts as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(maxActiveContacts)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_INFO>())).productString as *const _ as usize
    },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_INFO),
      "::",
      stringify!(productString)
    )
  );
}
impl Default for tagPOINTER_DEVICE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagPOINTER_DEVICE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagPOINTER_DEVICE_INFO {{ displayOrientation: {:?}, device: {:?}, pointerDeviceType: {:?}, monitor: {:?}, startingCursorId: {:?}, maxActiveContacts: {:?}, productString: [...] }}" , self . displayOrientation , self . device , self . pointerDeviceType , self . monitor , self . startingCursorId , self . maxActiveContacts )
  }
}
impl ::core::cmp::PartialEq for tagPOINTER_DEVICE_INFO {
  fn eq(&self, other: &tagPOINTER_DEVICE_INFO) -> bool {
    self.displayOrientation == other.displayOrientation
      && self.device == other.device
      && self.pointerDeviceType == other.pointerDeviceType
      && self.monitor == other.monitor
      && self.startingCursorId == other.startingCursorId
      && self.maxActiveContacts == other.maxActiveContacts
      && &self.productString[..] == &other.productString[..]
  }
}
pub type POINTER_DEVICE_INFO = tagPOINTER_DEVICE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagPOINTER_DEVICE_PROPERTY {
  pub logicalMin: INT32,
  pub logicalMax: INT32,
  pub physicalMin: INT32,
  pub physicalMax: INT32,
  pub unit: UINT32,
  pub unitExponent: UINT32,
  pub usagePageId: USHORT,
  pub usageId: USHORT,
}
#[test]
fn bindgen_test_layout_tagPOINTER_DEVICE_PROPERTY() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_DEVICE_PROPERTY>(),
    28usize,
    concat!("Size of: ", stringify!(tagPOINTER_DEVICE_PROPERTY))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_DEVICE_PROPERTY>(),
    4usize,
    concat!("Alignment of ", stringify!(tagPOINTER_DEVICE_PROPERTY))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).logicalMin as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(logicalMin)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).logicalMax as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(logicalMax)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).physicalMin as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(physicalMin)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).physicalMax as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(physicalMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).unit as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(unit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).unitExponent as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(unitExponent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).usagePageId as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(usagePageId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagPOINTER_DEVICE_PROPERTY>())).usageId as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_PROPERTY),
      "::",
      stringify!(usageId)
    )
  );
}
pub type POINTER_DEVICE_PROPERTY = tagPOINTER_DEVICE_PROPERTY;
pub mod tagPOINTER_DEVICE_CURSOR_TYPE {
  pub type Type = i32;
  pub const POINTER_DEVICE_CURSOR_TYPE_UNKNOWN: Type = 0;
  pub const POINTER_DEVICE_CURSOR_TYPE_TIP: Type = 1;
  pub const POINTER_DEVICE_CURSOR_TYPE_ERASER: Type = 2;
  pub const POINTER_DEVICE_CURSOR_TYPE_MAX: Type = -1;
}
pub use self::tagPOINTER_DEVICE_CURSOR_TYPE::Type as POINTER_DEVICE_CURSOR_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagPOINTER_DEVICE_CURSOR_INFO {
  pub cursorId: UINT32,
  pub cursor: POINTER_DEVICE_CURSOR_TYPE,
}
#[test]
fn bindgen_test_layout_tagPOINTER_DEVICE_CURSOR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<tagPOINTER_DEVICE_CURSOR_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(tagPOINTER_DEVICE_CURSOR_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagPOINTER_DEVICE_CURSOR_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagPOINTER_DEVICE_CURSOR_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_CURSOR_INFO>())).cursorId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_CURSOR_INFO),
      "::",
      stringify!(cursorId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagPOINTER_DEVICE_CURSOR_INFO>())).cursor as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPOINTER_DEVICE_CURSOR_INFO),
      "::",
      stringify!(cursor)
    )
  );
}
impl Default for tagPOINTER_DEVICE_CURSOR_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type POINTER_DEVICE_CURSOR_INFO = tagPOINTER_DEVICE_CURSOR_INFO;
extern "C" {
  pub fn GetPointerDevices(
    deviceCount: *mut UINT32, pointerDevices: *mut POINTER_DEVICE_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerDevice(device: HANDLE, pointerDevice: *mut POINTER_DEVICE_INFO) -> BOOL;
}
extern "C" {
  pub fn GetPointerDeviceProperties(
    device: HANDLE, propertyCount: *mut UINT32, pointerProperties: *mut POINTER_DEVICE_PROPERTY,
  ) -> BOOL;
}
extern "C" {
  pub fn RegisterPointerDeviceNotifications(window: HWND, notifyRange: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetPointerDeviceRects(
    device: HANDLE, pointerDeviceRect: *mut RECT, displayRect: *mut RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetPointerDeviceCursors(
    device: HANDLE, cursorCount: *mut UINT32, deviceCursors: *mut POINTER_DEVICE_CURSOR_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetRawPointerDeviceData(
    pointerId: UINT32, historyCount: UINT32, propertiesCount: UINT32,
    pProperties: *mut POINTER_DEVICE_PROPERTY, pValues: *mut LONG,
  ) -> BOOL;
}
extern "C" {
  pub fn ChangeWindowMessageFilter(message: UINT, dwFlag: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCHANGEFILTERSTRUCT {
  pub cbSize: DWORD,
  pub ExtStatus: DWORD,
}
#[test]
fn bindgen_test_layout_tagCHANGEFILTERSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagCHANGEFILTERSTRUCT>(),
    8usize,
    concat!("Size of: ", stringify!(tagCHANGEFILTERSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCHANGEFILTERSTRUCT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCHANGEFILTERSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCHANGEFILTERSTRUCT>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCHANGEFILTERSTRUCT),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCHANGEFILTERSTRUCT>())).ExtStatus as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCHANGEFILTERSTRUCT),
      "::",
      stringify!(ExtStatus)
    )
  );
}
pub type CHANGEFILTERSTRUCT = tagCHANGEFILTERSTRUCT;
pub type PCHANGEFILTERSTRUCT = *mut tagCHANGEFILTERSTRUCT;
extern "C" {
  pub fn ChangeWindowMessageFilterEx(
    hwnd: HWND, message: UINT, action: DWORD, pChangeFilterStruct: PCHANGEFILTERSTRUCT,
  ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HGESTUREINFO__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HGESTUREINFO__() {
  assert_eq!(
    ::core::mem::size_of::<HGESTUREINFO__>(),
    4usize,
    concat!("Size of: ", stringify!(HGESTUREINFO__))
  );
  assert_eq!(
    ::core::mem::align_of::<HGESTUREINFO__>(),
    4usize,
    concat!("Alignment of ", stringify!(HGESTUREINFO__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HGESTUREINFO__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HGESTUREINFO__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HGESTUREINFO = *mut HGESTUREINFO__;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagGESTUREINFO {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub dwID: DWORD,
  pub hwndTarget: HWND,
  pub ptsLocation: POINTS,
  pub dwInstanceID: DWORD,
  pub dwSequenceID: DWORD,
  pub ullArguments: ULONGLONG,
  pub cbExtraArgs: UINT,
}
#[test]
fn bindgen_test_layout_tagGESTUREINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagGESTUREINFO>(),
    56usize,
    concat!("Size of: ", stringify!(tagGESTUREINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGESTUREINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagGESTUREINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).dwID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(dwID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).hwndTarget as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(hwndTarget)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).ptsLocation as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(ptsLocation)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).dwInstanceID as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(dwInstanceID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).dwSequenceID as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(dwSequenceID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).ullArguments as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(ullArguments)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTUREINFO>())).cbExtraArgs as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTUREINFO),
      "::",
      stringify!(cbExtraArgs)
    )
  );
}
impl Default for tagGESTUREINFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type GESTUREINFO = tagGESTUREINFO;
pub type PGESTUREINFO = *mut tagGESTUREINFO;
pub type PCGESTUREINFO = *const GESTUREINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagGESTURENOTIFYSTRUCT {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub hwndTarget: HWND,
  pub ptsLocation: POINTS,
  pub dwInstanceID: DWORD,
}
#[test]
fn bindgen_test_layout_tagGESTURENOTIFYSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<tagGESTURENOTIFYSTRUCT>(),
    24usize,
    concat!("Size of: ", stringify!(tagGESTURENOTIFYSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGESTURENOTIFYSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagGESTURENOTIFYSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURENOTIFYSTRUCT>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURENOTIFYSTRUCT),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURENOTIFYSTRUCT>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURENOTIFYSTRUCT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURENOTIFYSTRUCT>())).hwndTarget as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURENOTIFYSTRUCT),
      "::",
      stringify!(hwndTarget)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURENOTIFYSTRUCT>())).ptsLocation as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURENOTIFYSTRUCT),
      "::",
      stringify!(ptsLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagGESTURENOTIFYSTRUCT>())).dwInstanceID as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURENOTIFYSTRUCT),
      "::",
      stringify!(dwInstanceID)
    )
  );
}
impl Default for tagGESTURENOTIFYSTRUCT {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type GESTURENOTIFYSTRUCT = tagGESTURENOTIFYSTRUCT;
pub type PGESTURENOTIFYSTRUCT = *mut tagGESTURENOTIFYSTRUCT;
extern "C" {
  pub fn GetGestureInfo(hGestureInfo: HGESTUREINFO, pGestureInfo: PGESTUREINFO) -> BOOL;
}
extern "C" {
  pub fn GetGestureExtraArgs(
    hGestureInfo: HGESTUREINFO, cbExtraArgs: UINT, pExtraArgs: PBYTE,
  ) -> BOOL;
}
extern "C" {
  pub fn CloseGestureInfoHandle(hGestureInfo: HGESTUREINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagGESTURECONFIG {
  pub dwID: DWORD,
  pub dwWant: DWORD,
  pub dwBlock: DWORD,
}
#[test]
fn bindgen_test_layout_tagGESTURECONFIG() {
  assert_eq!(
    ::core::mem::size_of::<tagGESTURECONFIG>(),
    12usize,
    concat!("Size of: ", stringify!(tagGESTURECONFIG))
  );
  assert_eq!(
    ::core::mem::align_of::<tagGESTURECONFIG>(),
    4usize,
    concat!("Alignment of ", stringify!(tagGESTURECONFIG))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURECONFIG>())).dwID as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURECONFIG),
      "::",
      stringify!(dwID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURECONFIG>())).dwWant as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURECONFIG),
      "::",
      stringify!(dwWant)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagGESTURECONFIG>())).dwBlock as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagGESTURECONFIG),
      "::",
      stringify!(dwBlock)
    )
  );
}
pub type GESTURECONFIG = tagGESTURECONFIG;
pub type PGESTURECONFIG = *mut tagGESTURECONFIG;
extern "C" {
  pub fn SetGestureConfig(
    hwnd: HWND, dwReserved: DWORD, cIDs: UINT, pGestureConfig: PGESTURECONFIG, cbSize: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn GetGestureConfig(
    hwnd: HWND, dwReserved: DWORD, dwFlags: DWORD, pcIDs: PUINT, pGestureConfig: PGESTURECONFIG,
    cbSize: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn ShutdownBlockReasonCreate(hWnd: HWND, pwszReason: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn ShutdownBlockReasonQuery(hWnd: HWND, pwszBuff: LPWSTR, pcchBuff: *mut DWORD) -> BOOL;
}
extern "C" {
  pub fn ShutdownBlockReasonDestroy(hWnd: HWND) -> BOOL;
}
pub mod tagINPUT_MESSAGE_DEVICE_TYPE {
  pub type Type = i32;
  pub const IMDT_UNAVAILABLE: Type = 0;
  pub const IMDT_KEYBOARD: Type = 1;
  pub const IMDT_MOUSE: Type = 2;
  pub const IMDT_TOUCH: Type = 4;
  pub const IMDT_PEN: Type = 8;
  pub const IMDT_TOUCHPAD: Type = 16;
}
pub use self::tagINPUT_MESSAGE_DEVICE_TYPE::Type as INPUT_MESSAGE_DEVICE_TYPE;
pub mod tagINPUT_MESSAGE_ORIGIN_ID {
  pub type Type = i32;
  pub const IMO_UNAVAILABLE: Type = 0;
  pub const IMO_HARDWARE: Type = 1;
  pub const IMO_INJECTED: Type = 2;
  pub const IMO_SYSTEM: Type = 4;
}
pub use self::tagINPUT_MESSAGE_ORIGIN_ID::Type as INPUT_MESSAGE_ORIGIN_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagINPUT_MESSAGE_SOURCE {
  pub deviceType: INPUT_MESSAGE_DEVICE_TYPE,
  pub originId: INPUT_MESSAGE_ORIGIN_ID,
}
#[test]
fn bindgen_test_layout_tagINPUT_MESSAGE_SOURCE() {
  assert_eq!(
    ::core::mem::size_of::<tagINPUT_MESSAGE_SOURCE>(),
    8usize,
    concat!("Size of: ", stringify!(tagINPUT_MESSAGE_SOURCE))
  );
  assert_eq!(
    ::core::mem::align_of::<tagINPUT_MESSAGE_SOURCE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagINPUT_MESSAGE_SOURCE))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_MESSAGE_SOURCE>())).deviceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_MESSAGE_SOURCE),
      "::",
      stringify!(deviceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagINPUT_MESSAGE_SOURCE>())).originId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagINPUT_MESSAGE_SOURCE),
      "::",
      stringify!(originId)
    )
  );
}
impl Default for tagINPUT_MESSAGE_SOURCE {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type INPUT_MESSAGE_SOURCE = tagINPUT_MESSAGE_SOURCE;
extern "C" {
  pub fn GetCurrentInputMessageSource(inputMessageSource: *mut INPUT_MESSAGE_SOURCE) -> BOOL;
}
extern "C" {
  pub fn GetCIMSSM(inputMessageSource: *mut INPUT_MESSAGE_SOURCE) -> BOOL;
}
pub mod tagAR_STATE {
  pub type Type = i32;
  pub const AR_ENABLED: Type = 0;
  pub const AR_DISABLED: Type = 1;
  pub const AR_SUPPRESSED: Type = 2;
  pub const AR_REMOTESESSION: Type = 4;
  pub const AR_MULTIMON: Type = 8;
  pub const AR_NOSENSOR: Type = 16;
  pub const AR_NOT_SUPPORTED: Type = 32;
  pub const AR_DOCKED: Type = 64;
  pub const AR_LAPTOP: Type = 128;
}
pub use self::tagAR_STATE::Type as AR_STATE;
pub type PAR_STATE = *mut tagAR_STATE::Type;
pub mod ORIENTATION_PREFERENCE {
  pub type Type = i32;
  pub const ORIENTATION_PREFERENCE_NONE: Type = 0;
  pub const ORIENTATION_PREFERENCE_LANDSCAPE: Type = 1;
  pub const ORIENTATION_PREFERENCE_PORTRAIT: Type = 2;
  pub const ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED: Type = 4;
  pub const ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED: Type = 8;
}
extern "C" {
  pub fn GetAutoRotationState(pState: PAR_STATE) -> BOOL;
}
extern "C" {
  pub fn GetDisplayAutoRotationPreferences(pOrientation: *mut ORIENTATION_PREFERENCE::Type)
    -> BOOL;
}
extern "C" {
  pub fn GetDisplayAutoRotationPreferencesByProcessId(
    dwProcessId: DWORD, pOrientation: *mut ORIENTATION_PREFERENCE::Type, fRotateScreen: *mut BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SetDisplayAutoRotationPreferences(orientation: ORIENTATION_PREFERENCE::Type) -> BOOL;
}
extern "C" {
  pub fn IsImmersiveProcess(hProcess: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetProcessRestrictionExemption(fEnableExemption: BOOL) -> BOOL;
}
extern "C" {
  pub fn GetDateFormatA(
    Locale: LCID, dwFlags: DWORD, lpDate: *const SYSTEMTIME, lpFormat: LPCSTR, lpDateStr: LPSTR,
    cchDate: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetDateFormatW(
    Locale: LCID, dwFlags: DWORD, lpDate: *const SYSTEMTIME, lpFormat: LPCWSTR, lpDateStr: LPWSTR,
    cchDate: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetTimeFormatA(
    Locale: LCID, dwFlags: DWORD, lpTime: *const SYSTEMTIME, lpFormat: LPCSTR, lpTimeStr: LPSTR,
    cchTime: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetTimeFormatW(
    Locale: LCID, dwFlags: DWORD, lpTime: *const SYSTEMTIME, lpFormat: LPCWSTR, lpTimeStr: LPWSTR,
    cchTime: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetTimeFormatEx(
    lpLocaleName: LPCWSTR, dwFlags: DWORD, lpTime: *const SYSTEMTIME, lpFormat: LPCWSTR,
    lpTimeStr: LPWSTR, cchTime: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetDateFormatEx(
    lpLocaleName: LPCWSTR, dwFlags: DWORD, lpDate: *const SYSTEMTIME, lpFormat: LPCWSTR,
    lpDateStr: LPWSTR, cchDate: libc::c_int, lpCalendar: LPCWSTR,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetDurationFormatEx(
    lpLocaleName: LPCWSTR, dwFlags: DWORD, lpDuration: *const SYSTEMTIME, ullDuration: ULONGLONG,
    lpFormat: LPCWSTR, lpDurationStr: LPWSTR, cchDuration: libc::c_int,
  ) -> libc::c_int;
}
pub type LGRPID = DWORD;
pub type LCTYPE = DWORD;
pub type CALTYPE = DWORD;
pub type CALID = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _cpinfo {
  pub MaxCharSize: UINT,
  pub DefaultChar: [BYTE; 2usize],
  pub LeadByte: [BYTE; 12usize],
}
#[test]
fn bindgen_test_layout__cpinfo() {
  assert_eq!(
    ::core::mem::size_of::<_cpinfo>(),
    20usize,
    concat!("Size of: ", stringify!(_cpinfo))
  );
  assert_eq!(
    ::core::mem::align_of::<_cpinfo>(),
    4usize,
    concat!("Alignment of ", stringify!(_cpinfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfo>())).MaxCharSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfo),
      "::",
      stringify!(MaxCharSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfo>())).DefaultChar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfo),
      "::",
      stringify!(DefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfo>())).LeadByte as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfo),
      "::",
      stringify!(LeadByte)
    )
  );
}
pub type CPINFO = _cpinfo;
pub type LPCPINFO = *mut _cpinfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _cpinfoexA {
  pub MaxCharSize: UINT,
  pub DefaultChar: [BYTE; 2usize],
  pub LeadByte: [BYTE; 12usize],
  pub UnicodeDefaultChar: WCHAR,
  pub CodePage: UINT,
  pub CodePageName: [CHAR; 260usize],
}
#[test]
fn bindgen_test_layout__cpinfoexA() {
  assert_eq!(
    ::core::mem::size_of::<_cpinfoexA>(),
    284usize,
    concat!("Size of: ", stringify!(_cpinfoexA))
  );
  assert_eq!(
    ::core::mem::align_of::<_cpinfoexA>(),
    4usize,
    concat!("Alignment of ", stringify!(_cpinfoexA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexA>())).MaxCharSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexA),
      "::",
      stringify!(MaxCharSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexA>())).DefaultChar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexA),
      "::",
      stringify!(DefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexA>())).LeadByte as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexA),
      "::",
      stringify!(LeadByte)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexA>())).UnicodeDefaultChar as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexA),
      "::",
      stringify!(UnicodeDefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexA>())).CodePage as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexA),
      "::",
      stringify!(CodePage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexA>())).CodePageName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexA),
      "::",
      stringify!(CodePageName)
    )
  );
}
impl Default for _cpinfoexA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _cpinfoexA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_cpinfoexA {{ MaxCharSize: {:?}, DefaultChar: {:?}, LeadByte: {:?}, UnicodeDefaultChar: {:?}, CodePage: {:?}, CodePageName: [...] }}" , self . MaxCharSize , self . DefaultChar , self . LeadByte , self . UnicodeDefaultChar , self . CodePage )
  }
}
impl ::core::cmp::PartialEq for _cpinfoexA {
  fn eq(&self, other: &_cpinfoexA) -> bool {
    self.MaxCharSize == other.MaxCharSize
      && self.DefaultChar == other.DefaultChar
      && self.LeadByte == other.LeadByte
      && self.UnicodeDefaultChar == other.UnicodeDefaultChar
      && self.CodePage == other.CodePage
      && &self.CodePageName[..] == &other.CodePageName[..]
  }
}
pub type CPINFOEXA = _cpinfoexA;
pub type LPCPINFOEXA = *mut _cpinfoexA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _cpinfoexW {
  pub MaxCharSize: UINT,
  pub DefaultChar: [BYTE; 2usize],
  pub LeadByte: [BYTE; 12usize],
  pub UnicodeDefaultChar: WCHAR,
  pub CodePage: UINT,
  pub CodePageName: [WCHAR; 260usize],
}
#[test]
fn bindgen_test_layout__cpinfoexW() {
  assert_eq!(
    ::core::mem::size_of::<_cpinfoexW>(),
    544usize,
    concat!("Size of: ", stringify!(_cpinfoexW))
  );
  assert_eq!(
    ::core::mem::align_of::<_cpinfoexW>(),
    4usize,
    concat!("Alignment of ", stringify!(_cpinfoexW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexW>())).MaxCharSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexW),
      "::",
      stringify!(MaxCharSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexW>())).DefaultChar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexW),
      "::",
      stringify!(DefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexW>())).LeadByte as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexW),
      "::",
      stringify!(LeadByte)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexW>())).UnicodeDefaultChar as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexW),
      "::",
      stringify!(UnicodeDefaultChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexW>())).CodePage as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexW),
      "::",
      stringify!(CodePage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_cpinfoexW>())).CodePageName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_cpinfoexW),
      "::",
      stringify!(CodePageName)
    )
  );
}
impl Default for _cpinfoexW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _cpinfoexW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_cpinfoexW {{ MaxCharSize: {:?}, DefaultChar: {:?}, LeadByte: {:?}, UnicodeDefaultChar: {:?}, CodePage: {:?}, CodePageName: [...] }}" , self . MaxCharSize , self . DefaultChar , self . LeadByte , self . UnicodeDefaultChar , self . CodePage )
  }
}
impl ::core::cmp::PartialEq for _cpinfoexW {
  fn eq(&self, other: &_cpinfoexW) -> bool {
    self.MaxCharSize == other.MaxCharSize
      && self.DefaultChar == other.DefaultChar
      && self.LeadByte == other.LeadByte
      && self.UnicodeDefaultChar == other.UnicodeDefaultChar
      && self.CodePage == other.CodePage
      && &self.CodePageName[..] == &other.CodePageName[..]
  }
}
pub type CPINFOEXW = _cpinfoexW;
pub type LPCPINFOEXW = *mut _cpinfoexW;
pub type CPINFOEX = CPINFOEXA;
pub type LPCPINFOEX = LPCPINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _numberfmtA {
  pub NumDigits: UINT,
  pub LeadingZero: UINT,
  pub Grouping: UINT,
  pub lpDecimalSep: LPSTR,
  pub lpThousandSep: LPSTR,
  pub NegativeOrder: UINT,
}
#[test]
fn bindgen_test_layout__numberfmtA() {
  assert_eq!(
    ::core::mem::size_of::<_numberfmtA>(),
    40usize,
    concat!("Size of: ", stringify!(_numberfmtA))
  );
  assert_eq!(
    ::core::mem::align_of::<_numberfmtA>(),
    8usize,
    concat!("Alignment of ", stringify!(_numberfmtA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtA>())).NumDigits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtA),
      "::",
      stringify!(NumDigits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtA>())).LeadingZero as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtA),
      "::",
      stringify!(LeadingZero)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtA>())).Grouping as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtA),
      "::",
      stringify!(Grouping)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtA>())).lpDecimalSep as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtA),
      "::",
      stringify!(lpDecimalSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtA>())).lpThousandSep as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtA),
      "::",
      stringify!(lpThousandSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtA>())).NegativeOrder as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtA),
      "::",
      stringify!(NegativeOrder)
    )
  );
}
impl Default for _numberfmtA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NUMBERFMTA = _numberfmtA;
pub type LPNUMBERFMTA = *mut _numberfmtA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _numberfmtW {
  pub NumDigits: UINT,
  pub LeadingZero: UINT,
  pub Grouping: UINT,
  pub lpDecimalSep: LPWSTR,
  pub lpThousandSep: LPWSTR,
  pub NegativeOrder: UINT,
}
#[test]
fn bindgen_test_layout__numberfmtW() {
  assert_eq!(
    ::core::mem::size_of::<_numberfmtW>(),
    40usize,
    concat!("Size of: ", stringify!(_numberfmtW))
  );
  assert_eq!(
    ::core::mem::align_of::<_numberfmtW>(),
    8usize,
    concat!("Alignment of ", stringify!(_numberfmtW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtW>())).NumDigits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtW),
      "::",
      stringify!(NumDigits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtW>())).LeadingZero as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtW),
      "::",
      stringify!(LeadingZero)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtW>())).Grouping as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtW),
      "::",
      stringify!(Grouping)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtW>())).lpDecimalSep as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtW),
      "::",
      stringify!(lpDecimalSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtW>())).lpThousandSep as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtW),
      "::",
      stringify!(lpThousandSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_numberfmtW>())).NegativeOrder as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_numberfmtW),
      "::",
      stringify!(NegativeOrder)
    )
  );
}
impl Default for _numberfmtW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NUMBERFMTW = _numberfmtW;
pub type LPNUMBERFMTW = *mut _numberfmtW;
pub type NUMBERFMT = NUMBERFMTA;
pub type LPNUMBERFMT = LPNUMBERFMTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _currencyfmtA {
  pub NumDigits: UINT,
  pub LeadingZero: UINT,
  pub Grouping: UINT,
  pub lpDecimalSep: LPSTR,
  pub lpThousandSep: LPSTR,
  pub NegativeOrder: UINT,
  pub PositiveOrder: UINT,
  pub lpCurrencySymbol: LPSTR,
}
#[test]
fn bindgen_test_layout__currencyfmtA() {
  assert_eq!(
    ::core::mem::size_of::<_currencyfmtA>(),
    48usize,
    concat!("Size of: ", stringify!(_currencyfmtA))
  );
  assert_eq!(
    ::core::mem::align_of::<_currencyfmtA>(),
    8usize,
    concat!("Alignment of ", stringify!(_currencyfmtA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).NumDigits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(NumDigits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).LeadingZero as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(LeadingZero)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).Grouping as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(Grouping)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).lpDecimalSep as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(lpDecimalSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).lpThousandSep as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(lpThousandSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).NegativeOrder as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(NegativeOrder)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).PositiveOrder as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(PositiveOrder)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtA>())).lpCurrencySymbol as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtA),
      "::",
      stringify!(lpCurrencySymbol)
    )
  );
}
impl Default for _currencyfmtA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CURRENCYFMTA = _currencyfmtA;
pub type LPCURRENCYFMTA = *mut _currencyfmtA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _currencyfmtW {
  pub NumDigits: UINT,
  pub LeadingZero: UINT,
  pub Grouping: UINT,
  pub lpDecimalSep: LPWSTR,
  pub lpThousandSep: LPWSTR,
  pub NegativeOrder: UINT,
  pub PositiveOrder: UINT,
  pub lpCurrencySymbol: LPWSTR,
}
#[test]
fn bindgen_test_layout__currencyfmtW() {
  assert_eq!(
    ::core::mem::size_of::<_currencyfmtW>(),
    48usize,
    concat!("Size of: ", stringify!(_currencyfmtW))
  );
  assert_eq!(
    ::core::mem::align_of::<_currencyfmtW>(),
    8usize,
    concat!("Alignment of ", stringify!(_currencyfmtW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).NumDigits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(NumDigits)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).LeadingZero as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(LeadingZero)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).Grouping as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(Grouping)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).lpDecimalSep as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(lpDecimalSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).lpThousandSep as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(lpThousandSep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).NegativeOrder as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(NegativeOrder)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).PositiveOrder as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(PositiveOrder)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_currencyfmtW>())).lpCurrencySymbol as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_currencyfmtW),
      "::",
      stringify!(lpCurrencySymbol)
    )
  );
}
impl Default for _currencyfmtW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CURRENCYFMTW = _currencyfmtW;
pub type LPCURRENCYFMTW = *mut _currencyfmtW;
pub type CURRENCYFMT = CURRENCYFMTA;
pub type LPCURRENCYFMT = LPCURRENCYFMTA;
pub mod SYSNLS_FUNCTION {
  pub type Type = i32;
  pub const COMPARE_STRING: Type = 1;
}
pub type NLS_FUNCTION = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _nlsversioninfo {
  pub dwNLSVersionInfoSize: DWORD,
  pub dwNLSVersion: DWORD,
  pub dwDefinedVersion: DWORD,
  pub dwEffectiveId: DWORD,
  pub guidCustomVersion: GUID,
}
#[test]
fn bindgen_test_layout__nlsversioninfo() {
  assert_eq!(
    ::core::mem::size_of::<_nlsversioninfo>(),
    32usize,
    concat!("Size of: ", stringify!(_nlsversioninfo))
  );
  assert_eq!(
    ::core::mem::align_of::<_nlsversioninfo>(),
    4usize,
    concat!("Alignment of ", stringify!(_nlsversioninfo))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_nlsversioninfo>())).dwNLSVersionInfoSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfo),
      "::",
      stringify!(dwNLSVersionInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfo>())).dwNLSVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfo),
      "::",
      stringify!(dwNLSVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfo>())).dwDefinedVersion as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfo),
      "::",
      stringify!(dwDefinedVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfo>())).dwEffectiveId as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfo),
      "::",
      stringify!(dwEffectiveId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfo>())).guidCustomVersion as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfo),
      "::",
      stringify!(guidCustomVersion)
    )
  );
}
pub type NLSVERSIONINFO = _nlsversioninfo;
pub type LPNLSVERSIONINFO = *mut _nlsversioninfo;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _nlsversioninfoex {
  pub dwNLSVersionInfoSize: DWORD,
  pub dwNLSVersion: DWORD,
  pub dwDefinedVersion: DWORD,
  pub dwEffectiveId: DWORD,
  pub guidCustomVersion: GUID,
}
#[test]
fn bindgen_test_layout__nlsversioninfoex() {
  assert_eq!(
    ::core::mem::size_of::<_nlsversioninfoex>(),
    32usize,
    concat!("Size of: ", stringify!(_nlsversioninfoex))
  );
  assert_eq!(
    ::core::mem::align_of::<_nlsversioninfoex>(),
    4usize,
    concat!("Alignment of ", stringify!(_nlsversioninfoex))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_nlsversioninfoex>())).dwNLSVersionInfoSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfoex),
      "::",
      stringify!(dwNLSVersionInfoSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfoex>())).dwNLSVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfoex),
      "::",
      stringify!(dwNLSVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfoex>())).dwDefinedVersion as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfoex),
      "::",
      stringify!(dwDefinedVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_nlsversioninfoex>())).dwEffectiveId as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfoex),
      "::",
      stringify!(dwEffectiveId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_nlsversioninfoex>())).guidCustomVersion as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_nlsversioninfoex),
      "::",
      stringify!(guidCustomVersion)
    )
  );
}
pub type NLSVERSIONINFOEX = _nlsversioninfoex;
pub type LPNLSVERSIONINFOEX = *mut _nlsversioninfoex;
pub type GEOTYPE = DWORD;
pub type GEOCLASS = DWORD;
pub type GEOID = LONG;
pub mod SYSGEOTYPE {
  pub type Type = i32;
  pub const GEO_NATION: Type = 1;
  pub const GEO_LATITUDE: Type = 2;
  pub const GEO_LONGITUDE: Type = 3;
  pub const GEO_ISO2: Type = 4;
  pub const GEO_ISO3: Type = 5;
  pub const GEO_RFC1766: Type = 6;
  pub const GEO_LCID: Type = 7;
  pub const GEO_FRIENDLYNAME: Type = 8;
  pub const GEO_OFFICIALNAME: Type = 9;
  pub const GEO_TIMEZONES: Type = 10;
  pub const GEO_OFFICIALLANGUAGES: Type = 11;
  pub const GEO_ISO_UN_NUMBER: Type = 12;
  pub const GEO_PARENT: Type = 13;
  pub const GEO_DIALINGCODE: Type = 14;
  pub const GEO_CURRENCYCODE: Type = 15;
  pub const GEO_CURRENCYSYMBOL: Type = 16;
  pub const GEO_NAME: Type = 17;
  pub const GEO_ID: Type = 18;
}
pub mod SYSGEOCLASS {
  pub type Type = i32;
  pub const GEOCLASS_NATION: Type = 16;
  pub const GEOCLASS_REGION: Type = 14;
  pub const GEOCLASS_ALL: Type = 0;
}
pub mod _NORM_FORM {
  pub type Type = i32;
  pub const NormalizationOther: Type = 0;
  pub const NormalizationC: Type = 1;
  pub const NormalizationD: Type = 2;
  pub const NormalizationKC: Type = 5;
  pub const NormalizationKD: Type = 6;
}
pub use self::_NORM_FORM::Type as NORM_FORM;
pub type LANGUAGEGROUP_ENUMPROCA = ::core::option::Option<
  unsafe extern "C" fn(arg1: LGRPID, arg2: LPSTR, arg3: LPSTR, arg4: DWORD, arg5: LONG_PTR) -> BOOL,
>;
pub type LANGGROUPLOCALE_ENUMPROCA = ::core::option::Option<
  unsafe extern "C" fn(arg1: LGRPID, arg2: LCID, arg3: LPSTR, arg4: LONG_PTR) -> BOOL,
>;
pub type UILANGUAGE_ENUMPROCA =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: LONG_PTR) -> BOOL>;
pub type CODEPAGE_ENUMPROCA = ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCA = ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCEXA =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: CALID) -> BOOL>;
pub type TIMEFMT_ENUMPROCA = ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type CALINFO_ENUMPROCA = ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type CALINFO_ENUMPROCEXA =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: CALID) -> BOOL>;
pub type LOCALE_ENUMPROCA = ::core::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type LOCALE_ENUMPROCW = ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type LANGUAGEGROUP_ENUMPROCW = ::core::option::Option<
  unsafe extern "C" fn(
    arg1: LGRPID,
    arg2: LPWSTR,
    arg3: LPWSTR,
    arg4: DWORD,
    arg5: LONG_PTR,
  ) -> BOOL,
>;
pub type LANGGROUPLOCALE_ENUMPROCW = ::core::option::Option<
  unsafe extern "C" fn(arg1: LGRPID, arg2: LCID, arg3: LPWSTR, arg4: LONG_PTR) -> BOOL,
>;
pub type UILANGUAGE_ENUMPROCW =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LONG_PTR) -> BOOL>;
pub type CODEPAGE_ENUMPROCW = ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCW = ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCEXW =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID) -> BOOL>;
pub type TIMEFMT_ENUMPROCW = ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type CALINFO_ENUMPROCW = ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type CALINFO_ENUMPROCEXW =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID) -> BOOL>;
pub type GEO_ENUMPROC = ::core::option::Option<unsafe extern "C" fn(arg1: GEOID) -> BOOL>;
pub type GEO_ENUMNAMEPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: PWSTR, arg2: LPARAM) -> BOOL>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FILEMUIINFO {
  pub dwSize: DWORD,
  pub dwVersion: DWORD,
  pub dwFileType: DWORD,
  pub pChecksum: [BYTE; 16usize],
  pub pServiceChecksum: [BYTE; 16usize],
  pub dwLanguageNameOffset: DWORD,
  pub dwTypeIDMainSize: DWORD,
  pub dwTypeIDMainOffset: DWORD,
  pub dwTypeNameMainOffset: DWORD,
  pub dwTypeIDMUISize: DWORD,
  pub dwTypeIDMUIOffset: DWORD,
  pub dwTypeNameMUIOffset: DWORD,
  pub abBuffer: [BYTE; 8usize],
}
#[test]
fn bindgen_test_layout__FILEMUIINFO() {
  assert_eq!(
    ::core::mem::size_of::<_FILEMUIINFO>(),
    80usize,
    concat!("Size of: ", stringify!(_FILEMUIINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_FILEMUIINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILEMUIINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwFileType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwFileType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).pChecksum as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(pChecksum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).pServiceChecksum as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(pServiceChecksum)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwLanguageNameOffset as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwLanguageNameOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwTypeIDMainSize as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwTypeIDMainSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwTypeIDMainOffset as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwTypeIDMainOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwTypeNameMainOffset as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwTypeNameMainOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwTypeIDMUISize as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwTypeIDMUISize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwTypeIDMUIOffset as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwTypeIDMUIOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).dwTypeNameMUIOffset as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(dwTypeNameMUIOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FILEMUIINFO>())).abBuffer as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILEMUIINFO),
      "::",
      stringify!(abBuffer)
    )
  );
}
pub type FILEMUIINFO = _FILEMUIINFO;
pub type PFILEMUIINFO = *mut _FILEMUIINFO;
extern "C" {
  pub fn CompareStringEx(
    lpLocaleName: LPCWSTR, dwCmpFlags: DWORD, lpString1: LPCWCH, cchCount1: libc::c_int,
    lpString2: LPCWCH, cchCount2: libc::c_int, lpVersionInformation: LPNLSVERSIONINFO,
    lpReserved: LPVOID, lParam: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CompareStringOrdinal(
    lpString1: LPCWCH, cchCount1: libc::c_int, lpString2: LPCWCH, cchCount2: libc::c_int,
    bIgnoreCase: BOOL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn CompareStringW(
    Locale: LCID, dwCmpFlags: DWORD, lpString1: PCNZWCH, cchCount1: libc::c_int,
    lpString2: PCNZWCH, cchCount2: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn FoldStringW(
    dwMapFlags: DWORD, lpSrcStr: LPCWCH, cchSrc: libc::c_int, lpDestStr: LPWSTR,
    cchDest: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetStringTypeExW(
    Locale: LCID, dwInfoType: DWORD, lpSrcStr: LPCWCH, cchSrc: libc::c_int, lpCharType: LPWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetStringTypeW(
    dwInfoType: DWORD, lpSrcStr: LPCWCH, cchSrc: libc::c_int, lpCharType: LPWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn MultiByteToWideChar(
    CodePage: UINT, dwFlags: DWORD, lpMultiByteStr: LPCCH, cbMultiByte: libc::c_int,
    lpWideCharStr: LPWSTR, cchWideChar: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn WideCharToMultiByte(
    CodePage: UINT, dwFlags: DWORD, lpWideCharStr: LPCWCH, cchWideChar: libc::c_int,
    lpMultiByteStr: LPSTR, cbMultiByte: libc::c_int, lpDefaultChar: LPCCH,
    lpUsedDefaultChar: LPBOOL,
  ) -> libc::c_int;
}
extern "C" {
  pub fn IsValidCodePage(CodePage: UINT) -> BOOL;
}
extern "C" {
  pub fn GetACP() -> UINT;
}
extern "C" {
  pub fn GetOEMCP() -> UINT;
}
extern "C" {
  pub fn GetCPInfo(CodePage: UINT, lpCPInfo: LPCPINFO) -> BOOL;
}
extern "C" {
  pub fn GetCPInfoExA(CodePage: UINT, dwFlags: DWORD, lpCPInfoEx: LPCPINFOEXA) -> BOOL;
}
extern "C" {
  pub fn GetCPInfoExW(CodePage: UINT, dwFlags: DWORD, lpCPInfoEx: LPCPINFOEXW) -> BOOL;
}
extern "C" {
  pub fn CompareStringA(
    Locale: LCID, dwCmpFlags: DWORD, lpString1: PCNZCH, cchCount1: libc::c_int, lpString2: PCNZCH,
    cchCount2: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn FindNLSString(
    Locale: LCID, dwFindNLSStringFlags: DWORD, lpStringSource: LPCWSTR, cchSource: libc::c_int,
    lpStringValue: LPCWSTR, cchValue: libc::c_int, pcchFound: LPINT,
  ) -> libc::c_int;
}
extern "C" {
  pub fn LCMapStringW(
    Locale: LCID, dwMapFlags: DWORD, lpSrcStr: LPCWSTR, cchSrc: libc::c_int, lpDestStr: LPWSTR,
    cchDest: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn LCMapStringA(
    Locale: LCID, dwMapFlags: DWORD, lpSrcStr: LPCSTR, cchSrc: libc::c_int, lpDestStr: LPSTR,
    cchDest: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetLocaleInfoW(
    Locale: LCID, LCType: LCTYPE, lpLCData: LPWSTR, cchData: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetLocaleInfoA(
    Locale: LCID, LCType: LCTYPE, lpLCData: LPSTR, cchData: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SetLocaleInfoA(Locale: LCID, LCType: LCTYPE, lpLCData: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetLocaleInfoW(Locale: LCID, LCType: LCTYPE, lpLCData: LPCWSTR) -> BOOL;
}
extern "C" {
  pub fn GetCalendarInfoA(
    Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPSTR, cchData: libc::c_int,
    lpValue: LPDWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetCalendarInfoW(
    Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPWSTR, cchData: libc::c_int,
    lpValue: LPDWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn SetCalendarInfoA(
    Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn SetCalendarInfoW(
    Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn LoadStringByReference(
    Flags: DWORD, Language: PCWSTR, SourceString: PCWSTR, Buffer: PWSTR, cchBuffer: ULONG,
    Directory: PCWSTR, pcchBufferOut: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn IsDBCSLeadByte(TestChar: BYTE) -> BOOL;
}
extern "C" {
  pub fn IsDBCSLeadByteEx(CodePage: UINT, TestChar: BYTE) -> BOOL;
}
extern "C" {
  pub fn LCIDToLocaleName(
    Locale: LCID, lpName: LPWSTR, cchName: libc::c_int, dwFlags: DWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn LocaleNameToLCID(lpName: LPCWSTR, dwFlags: DWORD) -> LCID;
}
extern "C" {
  pub fn GetDurationFormat(
    Locale: LCID, dwFlags: DWORD, lpDuration: *const SYSTEMTIME, ullDuration: ULONGLONG,
    lpFormat: LPCWSTR, lpDurationStr: LPWSTR, cchDuration: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetNumberFormatA(
    Locale: LCID, dwFlags: DWORD, lpValue: LPCSTR, lpFormat: *const NUMBERFMTA, lpNumberStr: LPSTR,
    cchNumber: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetNumberFormatW(
    Locale: LCID, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: *const NUMBERFMTW,
    lpNumberStr: LPWSTR, cchNumber: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetCurrencyFormatA(
    Locale: LCID, dwFlags: DWORD, lpValue: LPCSTR, lpFormat: *const CURRENCYFMTA,
    lpCurrencyStr: LPSTR, cchCurrency: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetCurrencyFormatW(
    Locale: LCID, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: *const CURRENCYFMTW,
    lpCurrencyStr: LPWSTR, cchCurrency: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumCalendarInfoA(
    lpCalInfoEnumProc: CALINFO_ENUMPROCA, Locale: LCID, Calendar: CALID, CalType: CALTYPE,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumCalendarInfoW(
    lpCalInfoEnumProc: CALINFO_ENUMPROCW, Locale: LCID, Calendar: CALID, CalType: CALTYPE,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumCalendarInfoExA(
    lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXA, Locale: LCID, Calendar: CALID, CalType: CALTYPE,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumCalendarInfoExW(
    lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXW, Locale: LCID, Calendar: CALID, CalType: CALTYPE,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumTimeFormatsA(
    lpTimeFmtEnumProc: TIMEFMT_ENUMPROCA, Locale: LCID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumTimeFormatsW(
    lpTimeFmtEnumProc: TIMEFMT_ENUMPROCW, Locale: LCID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDateFormatsA(
    lpDateFmtEnumProc: DATEFMT_ENUMPROCA, Locale: LCID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDateFormatsW(
    lpDateFmtEnumProc: DATEFMT_ENUMPROCW, Locale: LCID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDateFormatsExA(
    lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXA, Locale: LCID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDateFormatsExW(
    lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXW, Locale: LCID, dwFlags: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn IsValidLanguageGroup(LanguageGroup: LGRPID, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetNLSVersion(
    Function: NLS_FUNCTION, Locale: LCID, lpVersionInformation: LPNLSVERSIONINFO,
  ) -> BOOL;
}
extern "C" {
  pub fn IsNLSDefinedString(
    Function: NLS_FUNCTION, dwFlags: DWORD, lpVersionInformation: LPNLSVERSIONINFO,
    lpString: LPCWSTR, cchStr: INT,
  ) -> BOOL;
}
extern "C" {
  pub fn IsValidLocale(Locale: LCID, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetGeoInfoA(
    Location: GEOID, GeoType: GEOTYPE, lpGeoData: LPSTR, cchData: libc::c_int, LangId: LANGID,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetGeoInfoW(
    Location: GEOID, GeoType: GEOTYPE, lpGeoData: LPWSTR, cchData: libc::c_int, LangId: LANGID,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetGeoInfoEx(
    location: PWSTR, geoType: GEOTYPE, geoData: PWSTR, geoDataCount: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumSystemGeoID(
    GeoClass: GEOCLASS, ParentGeoId: GEOID, lpGeoEnumProc: GEO_ENUMPROC,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumSystemGeoNames(
    geoClass: GEOCLASS, geoEnumProc: GEO_ENUMNAMEPROC, data: LPARAM,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUserGeoID(GeoClass: GEOCLASS) -> GEOID;
}
extern "C" {
  pub fn GetUserDefaultGeoName(geoName: LPWSTR, geoNameCount: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn SetUserGeoID(GeoId: GEOID) -> BOOL;
}
extern "C" {
  pub fn SetUserGeoName(geoName: PWSTR) -> BOOL;
}
extern "C" {
  pub fn ConvertDefaultLocale(Locale: LCID) -> LCID;
}
extern "C" {
  pub fn GetThreadLocale() -> LCID;
}
extern "C" {
  pub fn SetThreadLocale(Locale: LCID) -> BOOL;
}
extern "C" {
  pub fn GetSystemDefaultUILanguage() -> LANGID;
}
extern "C" {
  pub fn GetUserDefaultUILanguage() -> LANGID;
}
extern "C" {
  pub fn GetUserDefaultLangID() -> LANGID;
}
extern "C" {
  pub fn GetSystemDefaultLangID() -> LANGID;
}
extern "C" {
  pub fn GetSystemDefaultLCID() -> LCID;
}
extern "C" {
  pub fn GetUserDefaultLCID() -> LCID;
}
extern "C" {
  pub fn SetThreadUILanguage(LangId: LANGID) -> LANGID;
}
extern "C" {
  pub fn GetThreadUILanguage() -> LANGID;
}
extern "C" {
  pub fn GetProcessPreferredUILanguages(
    dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR,
    pcchLanguagesBuffer: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetProcessPreferredUILanguages(
    dwFlags: DWORD, pwszLanguagesBuffer: PCZZWSTR, pulNumLanguages: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUserPreferredUILanguages(
    dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR,
    pcchLanguagesBuffer: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetSystemPreferredUILanguages(
    dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR,
    pcchLanguagesBuffer: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetThreadPreferredUILanguages(
    dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR,
    pcchLanguagesBuffer: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn SetThreadPreferredUILanguages(
    dwFlags: DWORD, pwszLanguagesBuffer: PCZZWSTR, pulNumLanguages: PULONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileMUIInfo(
    dwFlags: DWORD, pcwszFilePath: PCWSTR, pFileMUIInfo: PFILEMUIINFO, pcbFileMUIInfo: *mut DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileMUIPath(
    dwFlags: DWORD, pcwszFilePath: PCWSTR, pwszLanguage: PWSTR, pcchLanguage: PULONG,
    pwszFileMUIPath: PWSTR, pcchFileMUIPath: PULONG, pululEnumerator: PULONGLONG,
  ) -> BOOL;
}
extern "C" {
  pub fn GetUILanguageInfo(
    dwFlags: DWORD, pwmszLanguage: PCZZWSTR, pwszFallbackLanguages: PZZWSTR,
    pcchFallbackLanguages: PDWORD, pAttributes: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn NotifyUILanguageChange(
    dwFlags: DWORD, pcwstrNewLanguage: PCWSTR, pcwstrPreviousLanguage: PCWSTR, dwReserved: DWORD,
    pdwStatusRtrn: PDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetStringTypeExA(
    Locale: LCID, dwInfoType: DWORD, lpSrcStr: LPCSTR, cchSrc: libc::c_int, lpCharType: LPWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetStringTypeA(
    Locale: LCID, dwInfoType: DWORD, lpSrcStr: LPCSTR, cchSrc: libc::c_int, lpCharType: LPWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FoldStringA(
    dwMapFlags: DWORD, lpSrcStr: LPCSTR, cchSrc: libc::c_int, lpDestStr: LPSTR,
    cchDest: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn EnumSystemLocalesA(lpLocaleEnumProc: LOCALE_ENUMPROCA, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn EnumSystemLocalesW(lpLocaleEnumProc: LOCALE_ENUMPROCW, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn EnumSystemLanguageGroupsA(
    lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCA, dwFlags: DWORD, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumSystemLanguageGroupsW(
    lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCW, dwFlags: DWORD, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumLanguageGroupLocalesA(
    lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCA, LanguageGroup: LGRPID, dwFlags: DWORD,
    lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumLanguageGroupLocalesW(
    lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCW, LanguageGroup: LGRPID, dwFlags: DWORD,
    lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumUILanguagesA(
    lpUILanguageEnumProc: UILANGUAGE_ENUMPROCA, dwFlags: DWORD, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumUILanguagesW(
    lpUILanguageEnumProc: UILANGUAGE_ENUMPROCW, dwFlags: DWORD, lParam: LONG_PTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumSystemCodePagesA(lpCodePageEnumProc: CODEPAGE_ENUMPROCA, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn EnumSystemCodePagesW(lpCodePageEnumProc: CODEPAGE_ENUMPROCW, dwFlags: DWORD) -> BOOL;
}
extern "C" {
  pub fn NormalizeString(
    NormForm: NORM_FORM, lpSrcString: LPCWSTR, cwSrcLength: libc::c_int, lpDstString: LPWSTR,
    cwDstLength: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn IsNormalizedString(NormForm: NORM_FORM, lpString: LPCWSTR, cwLength: libc::c_int) -> BOOL;
}
extern "C" {
  pub fn IdnToAscii(
    dwFlags: DWORD, lpUnicodeCharStr: LPCWSTR, cchUnicodeChar: libc::c_int, lpASCIICharStr: LPWSTR,
    cchASCIIChar: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn IdnToNameprepUnicode(
    dwFlags: DWORD, lpUnicodeCharStr: LPCWSTR, cchUnicodeChar: libc::c_int,
    lpNameprepCharStr: LPWSTR, cchNameprepChar: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn IdnToUnicode(
    dwFlags: DWORD, lpASCIICharStr: LPCWSTR, cchASCIIChar: libc::c_int, lpUnicodeCharStr: LPWSTR,
    cchUnicodeChar: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn VerifyScripts(
    dwFlags: DWORD, lpLocaleScripts: LPCWSTR, cchLocaleScripts: libc::c_int,
    lpTestScripts: LPCWSTR, cchTestScripts: libc::c_int,
  ) -> BOOL;
}
extern "C" {
  pub fn GetStringScripts(
    dwFlags: DWORD, lpString: LPCWSTR, cchString: libc::c_int, lpScripts: LPWSTR,
    cchScripts: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetLocaleInfoEx(
    lpLocaleName: LPCWSTR, LCType: LCTYPE, lpLCData: LPWSTR, cchData: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetCalendarInfoEx(
    lpLocaleName: LPCWSTR, Calendar: CALID, lpReserved: LPCWSTR, CalType: CALTYPE,
    lpCalData: LPWSTR, cchData: libc::c_int, lpValue: LPDWORD,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetNumberFormatEx(
    lpLocaleName: LPCWSTR, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: *const NUMBERFMTW,
    lpNumberStr: LPWSTR, cchNumber: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetCurrencyFormatEx(
    lpLocaleName: LPCWSTR, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: *const CURRENCYFMTW,
    lpCurrencyStr: LPWSTR, cchCurrency: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetUserDefaultLocaleName(lpLocaleName: LPWSTR, cchLocaleName: libc::c_int) -> libc::c_int;
}
extern "C" {
  pub fn GetSystemDefaultLocaleName(
    lpLocaleName: LPWSTR, cchLocaleName: libc::c_int,
  ) -> libc::c_int;
}
extern "C" {
  pub fn GetNLSVersionEx(
    function: NLS_FUNCTION, lpLocaleName: LPCWSTR, lpVersionInformation: LPNLSVERSIONINFOEX,
  ) -> BOOL;
}
extern "C" {
  pub fn IsValidNLSVersion(
    function: NLS_FUNCTION, lpLocaleName: LPCWSTR, lpVersionInformation: LPNLSVERSIONINFOEX,
  ) -> DWORD;
}
extern "C" {
  pub fn FindNLSStringEx(
    lpLocaleName: LPCWSTR, dwFindNLSStringFlags: DWORD, lpStringSource: LPCWSTR,
    cchSource: libc::c_int, lpStringValue: LPCWSTR, cchValue: libc::c_int, pcchFound: LPINT,
    lpVersionInformation: LPNLSVERSIONINFO, lpReserved: LPVOID, sortHandle: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn LCMapStringEx(
    lpLocaleName: LPCWSTR, dwMapFlags: DWORD, lpSrcStr: LPCWSTR, cchSrc: libc::c_int,
    lpDestStr: LPWSTR, cchDest: libc::c_int, lpVersionInformation: LPNLSVERSIONINFO,
    lpReserved: LPVOID, sortHandle: LPARAM,
  ) -> libc::c_int;
}
extern "C" {
  pub fn IsValidLocaleName(lpLocaleName: LPCWSTR) -> BOOL;
}
pub type CALINFO_ENUMPROCEXEX = ::core::option::Option<
  unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID, arg3: LPWSTR, arg4: LPARAM) -> BOOL,
>;
extern "C" {
  pub fn EnumCalendarInfoExEx(
    pCalInfoEnumProcExEx: CALINFO_ENUMPROCEXEX, lpLocaleName: LPCWSTR, Calendar: CALID,
    lpReserved: LPCWSTR, CalType: CALTYPE, lParam: LPARAM,
  ) -> BOOL;
}
pub type DATEFMT_ENUMPROCEXEX =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID, arg3: LPARAM) -> BOOL>;
extern "C" {
  pub fn EnumDateFormatsExEx(
    lpDateFmtEnumProcExEx: DATEFMT_ENUMPROCEXEX, lpLocaleName: LPCWSTR, dwFlags: DWORD,
    lParam: LPARAM,
  ) -> BOOL;
}
pub type TIMEFMT_ENUMPROCEX =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LPARAM) -> BOOL>;
extern "C" {
  pub fn EnumTimeFormatsEx(
    lpTimeFmtEnumProcEx: TIMEFMT_ENUMPROCEX, lpLocaleName: LPCWSTR, dwFlags: DWORD, lParam: LPARAM,
  ) -> BOOL;
}
pub type LOCALE_ENUMPROCEX =
  ::core::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: DWORD, arg3: LPARAM) -> BOOL>;
extern "C" {
  pub fn EnumSystemLocalesEx(
    lpLocaleEnumProcEx: LOCALE_ENUMPROCEX, dwFlags: DWORD, lParam: LPARAM, lpReserved: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn ResolveLocaleName(
    lpNameToResolve: LPCWSTR, lpLocaleName: LPWSTR, cchLocaleName: libc::c_int,
  ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _COORD {
  pub X: SHORT,
  pub Y: SHORT,
}
#[test]
fn bindgen_test_layout__COORD() {
  assert_eq!(
    ::core::mem::size_of::<_COORD>(),
    4usize,
    concat!("Size of: ", stringify!(_COORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_COORD>(),
    2usize,
    concat!("Alignment of ", stringify!(_COORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COORD>())).X as *const _ as usize },
    0usize,
    concat!("Offset of field: ", stringify!(_COORD), "::", stringify!(X))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_COORD>())).Y as *const _ as usize },
    2usize,
    concat!("Offset of field: ", stringify!(_COORD), "::", stringify!(Y))
  );
}
pub type COORD = _COORD;
pub type PCOORD = *mut _COORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SMALL_RECT {
  pub Left: SHORT,
  pub Top: SHORT,
  pub Right: SHORT,
  pub Bottom: SHORT,
}
#[test]
fn bindgen_test_layout__SMALL_RECT() {
  assert_eq!(
    ::core::mem::size_of::<_SMALL_RECT>(),
    8usize,
    concat!("Size of: ", stringify!(_SMALL_RECT))
  );
  assert_eq!(
    ::core::mem::align_of::<_SMALL_RECT>(),
    2usize,
    concat!("Alignment of ", stringify!(_SMALL_RECT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SMALL_RECT>())).Left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Left)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SMALL_RECT>())).Top as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Top)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SMALL_RECT>())).Right as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Right)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SMALL_RECT>())).Bottom as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Bottom)
    )
  );
}
pub type SMALL_RECT = _SMALL_RECT;
pub type PSMALL_RECT = *mut _SMALL_RECT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_EVENT_RECORD {
  pub bKeyDown: BOOL,
  pub wRepeatCount: WORD,
  pub wVirtualKeyCode: WORD,
  pub wVirtualScanCode: WORD,
  pub uChar: _KEY_EVENT_RECORD__bindgen_ty_1,
  pub dwControlKeyState: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KEY_EVENT_RECORD__bindgen_ty_1 {
  pub UnicodeChar: WCHAR,
  pub AsciiChar: CHAR,
  _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout__KEY_EVENT_RECORD__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_KEY_EVENT_RECORD__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(_KEY_EVENT_RECORD__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_KEY_EVENT_RECORD__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_KEY_EVENT_RECORD__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KEY_EVENT_RECORD__bindgen_ty_1>())).UnicodeChar as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD__bindgen_ty_1),
      "::",
      stringify!(UnicodeChar)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KEY_EVENT_RECORD__bindgen_ty_1>())).AsciiChar as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD__bindgen_ty_1),
      "::",
      stringify!(AsciiChar)
    )
  );
}
impl Default for _KEY_EVENT_RECORD__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _KEY_EVENT_RECORD__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_KEY_EVENT_RECORD__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__KEY_EVENT_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_KEY_EVENT_RECORD>(),
    16usize,
    concat!("Size of: ", stringify!(_KEY_EVENT_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_KEY_EVENT_RECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(_KEY_EVENT_RECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KEY_EVENT_RECORD>())).bKeyDown as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD),
      "::",
      stringify!(bKeyDown)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KEY_EVENT_RECORD>())).wRepeatCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD),
      "::",
      stringify!(wRepeatCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KEY_EVENT_RECORD>())).wVirtualKeyCode as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD),
      "::",
      stringify!(wVirtualKeyCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KEY_EVENT_RECORD>())).wVirtualScanCode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD),
      "::",
      stringify!(wVirtualScanCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_KEY_EVENT_RECORD>())).uChar as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD),
      "::",
      stringify!(uChar)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_KEY_EVENT_RECORD>())).dwControlKeyState as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_KEY_EVENT_RECORD),
      "::",
      stringify!(dwControlKeyState)
    )
  );
}
impl Default for _KEY_EVENT_RECORD {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _KEY_EVENT_RECORD {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "_KEY_EVENT_RECORD {{ bKeyDown: {:?}, wRepeatCount: {:?}, wVirtualKeyCode: {:?}, wVirtualScanCode: {:?}, uChar: {:?}, dwControlKeyState: {:?} }}" , self . bKeyDown , self . wRepeatCount , self . wVirtualKeyCode , self . wVirtualScanCode , self . uChar , self . dwControlKeyState )
  }
}
pub type KEY_EVENT_RECORD = _KEY_EVENT_RECORD;
pub type PKEY_EVENT_RECORD = *mut _KEY_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MOUSE_EVENT_RECORD {
  pub dwMousePosition: COORD,
  pub dwButtonState: DWORD,
  pub dwControlKeyState: DWORD,
  pub dwEventFlags: DWORD,
}
#[test]
fn bindgen_test_layout__MOUSE_EVENT_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_MOUSE_EVENT_RECORD>(),
    16usize,
    concat!("Size of: ", stringify!(_MOUSE_EVENT_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_MOUSE_EVENT_RECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(_MOUSE_EVENT_RECORD))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MOUSE_EVENT_RECORD>())).dwMousePosition as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MOUSE_EVENT_RECORD),
      "::",
      stringify!(dwMousePosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MOUSE_EVENT_RECORD>())).dwButtonState as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MOUSE_EVENT_RECORD),
      "::",
      stringify!(dwButtonState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MOUSE_EVENT_RECORD>())).dwControlKeyState as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MOUSE_EVENT_RECORD),
      "::",
      stringify!(dwControlKeyState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MOUSE_EVENT_RECORD>())).dwEventFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_MOUSE_EVENT_RECORD),
      "::",
      stringify!(dwEventFlags)
    )
  );
}
pub type MOUSE_EVENT_RECORD = _MOUSE_EVENT_RECORD;
pub type PMOUSE_EVENT_RECORD = *mut _MOUSE_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _WINDOW_BUFFER_SIZE_RECORD {
  pub dwSize: COORD,
}
#[test]
fn bindgen_test_layout__WINDOW_BUFFER_SIZE_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_WINDOW_BUFFER_SIZE_RECORD>(),
    4usize,
    concat!("Size of: ", stringify!(_WINDOW_BUFFER_SIZE_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_WINDOW_BUFFER_SIZE_RECORD>(),
    2usize,
    concat!("Alignment of ", stringify!(_WINDOW_BUFFER_SIZE_RECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_WINDOW_BUFFER_SIZE_RECORD>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_WINDOW_BUFFER_SIZE_RECORD),
      "::",
      stringify!(dwSize)
    )
  );
}
pub type WINDOW_BUFFER_SIZE_RECORD = _WINDOW_BUFFER_SIZE_RECORD;
pub type PWINDOW_BUFFER_SIZE_RECORD = *mut _WINDOW_BUFFER_SIZE_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MENU_EVENT_RECORD {
  pub dwCommandId: UINT,
}
#[test]
fn bindgen_test_layout__MENU_EVENT_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_MENU_EVENT_RECORD>(),
    4usize,
    concat!("Size of: ", stringify!(_MENU_EVENT_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_MENU_EVENT_RECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(_MENU_EVENT_RECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MENU_EVENT_RECORD>())).dwCommandId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MENU_EVENT_RECORD),
      "::",
      stringify!(dwCommandId)
    )
  );
}
pub type MENU_EVENT_RECORD = _MENU_EVENT_RECORD;
pub type PMENU_EVENT_RECORD = *mut _MENU_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _FOCUS_EVENT_RECORD {
  pub bSetFocus: BOOL,
}
#[test]
fn bindgen_test_layout__FOCUS_EVENT_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_FOCUS_EVENT_RECORD>(),
    4usize,
    concat!("Size of: ", stringify!(_FOCUS_EVENT_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_FOCUS_EVENT_RECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(_FOCUS_EVENT_RECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_FOCUS_EVENT_RECORD>())).bSetFocus as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FOCUS_EVENT_RECORD),
      "::",
      stringify!(bSetFocus)
    )
  );
}
pub type FOCUS_EVENT_RECORD = _FOCUS_EVENT_RECORD;
pub type PFOCUS_EVENT_RECORD = *mut _FOCUS_EVENT_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INPUT_RECORD {
  pub EventType: WORD,
  pub Event: _INPUT_RECORD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INPUT_RECORD__bindgen_ty_1 {
  pub KeyEvent: KEY_EVENT_RECORD,
  pub MouseEvent: MOUSE_EVENT_RECORD,
  pub WindowBufferSizeEvent: WINDOW_BUFFER_SIZE_RECORD,
  pub MenuEvent: MENU_EVENT_RECORD,
  pub FocusEvent: FOCUS_EVENT_RECORD,
  _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__INPUT_RECORD__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_INPUT_RECORD__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_INPUT_RECORD__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_INPUT_RECORD__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_INPUT_RECORD__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_INPUT_RECORD__bindgen_ty_1>())).KeyEvent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD__bindgen_ty_1),
      "::",
      stringify!(KeyEvent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_INPUT_RECORD__bindgen_ty_1>())).MouseEvent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD__bindgen_ty_1),
      "::",
      stringify!(MouseEvent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_INPUT_RECORD__bindgen_ty_1>())).WindowBufferSizeEvent as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD__bindgen_ty_1),
      "::",
      stringify!(WindowBufferSizeEvent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_INPUT_RECORD__bindgen_ty_1>())).MenuEvent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD__bindgen_ty_1),
      "::",
      stringify!(MenuEvent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_INPUT_RECORD__bindgen_ty_1>())).FocusEvent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD__bindgen_ty_1),
      "::",
      stringify!(FocusEvent)
    )
  );
}
impl Default for _INPUT_RECORD__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _INPUT_RECORD__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_INPUT_RECORD__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__INPUT_RECORD() {
  assert_eq!(
    ::core::mem::size_of::<_INPUT_RECORD>(),
    20usize,
    concat!("Size of: ", stringify!(_INPUT_RECORD))
  );
  assert_eq!(
    ::core::mem::align_of::<_INPUT_RECORD>(),
    4usize,
    concat!("Alignment of ", stringify!(_INPUT_RECORD))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_INPUT_RECORD>())).EventType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD),
      "::",
      stringify!(EventType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_INPUT_RECORD>())).Event as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_INPUT_RECORD),
      "::",
      stringify!(Event)
    )
  );
}
impl Default for _INPUT_RECORD {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _INPUT_RECORD {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_INPUT_RECORD {{ EventType: {:?}, Event: {:?} }}",
      self.EventType, self.Event
    )
  }
}
pub type INPUT_RECORD = _INPUT_RECORD;
pub type PINPUT_RECORD = *mut _INPUT_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CHAR_INFO {
  pub Char: _CHAR_INFO__bindgen_ty_1,
  pub Attributes: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CHAR_INFO__bindgen_ty_1 {
  pub UnicodeChar: WCHAR,
  pub AsciiChar: CHAR,
  _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout__CHAR_INFO__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_CHAR_INFO__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(_CHAR_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_CHAR_INFO__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(_CHAR_INFO__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CHAR_INFO__bindgen_ty_1>())).UnicodeChar as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CHAR_INFO__bindgen_ty_1),
      "::",
      stringify!(UnicodeChar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CHAR_INFO__bindgen_ty_1>())).AsciiChar as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CHAR_INFO__bindgen_ty_1),
      "::",
      stringify!(AsciiChar)
    )
  );
}
impl Default for _CHAR_INFO__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CHAR_INFO__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "_CHAR_INFO__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout__CHAR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CHAR_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_CHAR_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CHAR_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_CHAR_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CHAR_INFO>())).Char as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CHAR_INFO),
      "::",
      stringify!(Char)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CHAR_INFO>())).Attributes as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CHAR_INFO),
      "::",
      stringify!(Attributes)
    )
  );
}
impl Default for _CHAR_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _CHAR_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_CHAR_INFO {{ Char: {:?}, Attributes: {:?} }}",
      self.Char, self.Attributes
    )
  }
}
pub type CHAR_INFO = _CHAR_INFO;
pub type PCHAR_INFO = *mut _CHAR_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_SCREEN_BUFFER_INFO {
  pub dwSize: COORD,
  pub dwCursorPosition: COORD,
  pub wAttributes: WORD,
  pub srWindow: SMALL_RECT,
  pub dwMaximumWindowSize: COORD,
}
#[test]
fn bindgen_test_layout__CONSOLE_SCREEN_BUFFER_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_SCREEN_BUFFER_INFO>(),
    22usize,
    concat!("Size of: ", stringify!(_CONSOLE_SCREEN_BUFFER_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_SCREEN_BUFFER_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_CONSOLE_SCREEN_BUFFER_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFO>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFO),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFO>())).dwCursorPosition as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFO),
      "::",
      stringify!(dwCursorPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFO>())).wAttributes as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFO),
      "::",
      stringify!(wAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFO>())).srWindow as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFO),
      "::",
      stringify!(srWindow)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFO>())).dwMaximumWindowSize as *const _
        as usize
    },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFO),
      "::",
      stringify!(dwMaximumWindowSize)
    )
  );
}
pub type CONSOLE_SCREEN_BUFFER_INFO = _CONSOLE_SCREEN_BUFFER_INFO;
pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut _CONSOLE_SCREEN_BUFFER_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_SCREEN_BUFFER_INFOEX {
  pub cbSize: ULONG,
  pub dwSize: COORD,
  pub dwCursorPosition: COORD,
  pub wAttributes: WORD,
  pub srWindow: SMALL_RECT,
  pub dwMaximumWindowSize: COORD,
  pub wPopupAttributes: WORD,
  pub bFullscreenSupported: BOOL,
  pub ColorTable: [COLORREF; 16usize],
}
#[test]
fn bindgen_test_layout__CONSOLE_SCREEN_BUFFER_INFOEX() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_SCREEN_BUFFER_INFOEX>(),
    96usize,
    concat!("Size of: ", stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_SCREEN_BUFFER_INFOEX>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).cbSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).dwSize as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).dwCursorPosition as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(dwCursorPosition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).wAttributes as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(wAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).srWindow as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(srWindow)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).dwMaximumWindowSize as *const _
        as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(dwMaximumWindowSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).wPopupAttributes as *const _
        as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(wPopupAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).bFullscreenSupported as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(bFullscreenSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SCREEN_BUFFER_INFOEX>())).ColorTable as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SCREEN_BUFFER_INFOEX),
      "::",
      stringify!(ColorTable)
    )
  );
}
pub type CONSOLE_SCREEN_BUFFER_INFOEX = _CONSOLE_SCREEN_BUFFER_INFOEX;
pub type PCONSOLE_SCREEN_BUFFER_INFOEX = *mut _CONSOLE_SCREEN_BUFFER_INFOEX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_CURSOR_INFO {
  pub dwSize: DWORD,
  pub bVisible: BOOL,
}
#[test]
fn bindgen_test_layout__CONSOLE_CURSOR_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_CURSOR_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_CONSOLE_CURSOR_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_CURSOR_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_CURSOR_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_CURSOR_INFO>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_CURSOR_INFO),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_CURSOR_INFO>())).bVisible as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_CURSOR_INFO),
      "::",
      stringify!(bVisible)
    )
  );
}
pub type CONSOLE_CURSOR_INFO = _CONSOLE_CURSOR_INFO;
pub type PCONSOLE_CURSOR_INFO = *mut _CONSOLE_CURSOR_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_FONT_INFO {
  pub nFont: DWORD,
  pub dwFontSize: COORD,
}
#[test]
fn bindgen_test_layout__CONSOLE_FONT_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_FONT_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_CONSOLE_FONT_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_FONT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_FONT_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFO>())).nFont as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFO),
      "::",
      stringify!(nFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFO>())).dwFontSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFO),
      "::",
      stringify!(dwFontSize)
    )
  );
}
pub type CONSOLE_FONT_INFO = _CONSOLE_FONT_INFO;
pub type PCONSOLE_FONT_INFO = *mut _CONSOLE_FONT_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_FONT_INFOEX {
  pub cbSize: ULONG,
  pub nFont: DWORD,
  pub dwFontSize: COORD,
  pub FontFamily: UINT,
  pub FontWeight: UINT,
  pub FaceName: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout__CONSOLE_FONT_INFOEX() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_FONT_INFOEX>(),
    84usize,
    concat!("Size of: ", stringify!(_CONSOLE_FONT_INFOEX))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_FONT_INFOEX>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_FONT_INFOEX))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFOEX>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFOEX),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFOEX>())).nFont as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFOEX),
      "::",
      stringify!(nFont)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFOEX>())).dwFontSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFOEX),
      "::",
      stringify!(dwFontSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFOEX>())).FontFamily as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFOEX),
      "::",
      stringify!(FontFamily)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFOEX>())).FontWeight as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFOEX),
      "::",
      stringify!(FontWeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_FONT_INFOEX>())).FaceName as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_FONT_INFOEX),
      "::",
      stringify!(FaceName)
    )
  );
}
pub type CONSOLE_FONT_INFOEX = _CONSOLE_FONT_INFOEX;
pub type PCONSOLE_FONT_INFOEX = *mut _CONSOLE_FONT_INFOEX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_HISTORY_INFO {
  pub cbSize: UINT,
  pub HistoryBufferSize: UINT,
  pub NumberOfHistoryBuffers: UINT,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__CONSOLE_HISTORY_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_HISTORY_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_CONSOLE_HISTORY_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_HISTORY_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_HISTORY_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_HISTORY_INFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_HISTORY_INFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_HISTORY_INFO>())).HistoryBufferSize as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_HISTORY_INFO),
      "::",
      stringify!(HistoryBufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_HISTORY_INFO>())).NumberOfHistoryBuffers as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_HISTORY_INFO),
      "::",
      stringify!(NumberOfHistoryBuffers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_HISTORY_INFO>())).dwFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_HISTORY_INFO),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type CONSOLE_HISTORY_INFO = _CONSOLE_HISTORY_INFO;
pub type PCONSOLE_HISTORY_INFO = *mut _CONSOLE_HISTORY_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_SELECTION_INFO {
  pub dwFlags: DWORD,
  pub dwSelectionAnchor: COORD,
  pub srSelection: SMALL_RECT,
}
#[test]
fn bindgen_test_layout__CONSOLE_SELECTION_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_SELECTION_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_CONSOLE_SELECTION_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_SELECTION_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_SELECTION_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONSOLE_SELECTION_INFO>())).dwFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SELECTION_INFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SELECTION_INFO>())).dwSelectionAnchor as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SELECTION_INFO),
      "::",
      stringify!(dwSelectionAnchor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_SELECTION_INFO>())).srSelection as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_SELECTION_INFO),
      "::",
      stringify!(srSelection)
    )
  );
}
pub type CONSOLE_SELECTION_INFO = _CONSOLE_SELECTION_INFO;
pub type PCONSOLE_SELECTION_INFO = *mut _CONSOLE_SELECTION_INFO;
pub type PHANDLER_ROUTINE = ::core::option::Option<unsafe extern "C" fn(CtrlType: DWORD) -> BOOL>;
extern "C" {
  pub fn PeekConsoleInputW(
    hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleInputA(
    hConsoleInput: HANDLE, lpBuffer: *const INPUT_RECORD, nLength: DWORD,
    lpNumberOfEventsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleInputW(
    hConsoleInput: HANDLE, lpBuffer: *const INPUT_RECORD, nLength: DWORD,
    lpNumberOfEventsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleOutputA(
    hConsoleOutput: HANDLE, lpBuffer: PCHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD,
    lpReadRegion: PSMALL_RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleOutputW(
    hConsoleOutput: HANDLE, lpBuffer: PCHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD,
    lpReadRegion: PSMALL_RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleOutputA(
    hConsoleOutput: HANDLE, lpBuffer: *const CHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD,
    lpWriteRegion: PSMALL_RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleOutputW(
    hConsoleOutput: HANDLE, lpBuffer: *const CHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD,
    lpWriteRegion: PSMALL_RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleOutputCharacterA(
    hConsoleOutput: HANDLE, lpCharacter: LPSTR, nLength: DWORD, dwReadCoord: COORD,
    lpNumberOfCharsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleOutputCharacterW(
    hConsoleOutput: HANDLE, lpCharacter: LPWSTR, nLength: DWORD, dwReadCoord: COORD,
    lpNumberOfCharsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleOutputAttribute(
    hConsoleOutput: HANDLE, lpAttribute: LPWORD, nLength: DWORD, dwReadCoord: COORD,
    lpNumberOfAttrsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleOutputCharacterA(
    hConsoleOutput: HANDLE, lpCharacter: LPCSTR, nLength: DWORD, dwWriteCoord: COORD,
    lpNumberOfCharsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleOutputCharacterW(
    hConsoleOutput: HANDLE, lpCharacter: LPCWSTR, nLength: DWORD, dwWriteCoord: COORD,
    lpNumberOfCharsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleOutputAttribute(
    hConsoleOutput: HANDLE, lpAttribute: *const WORD, nLength: DWORD, dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FillConsoleOutputCharacterA(
    hConsoleOutput: HANDLE, cCharacter: CHAR, nLength: DWORD, dwWriteCoord: COORD,
    lpNumberOfCharsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FillConsoleOutputCharacterW(
    hConsoleOutput: HANDLE, cCharacter: WCHAR, nLength: DWORD, dwWriteCoord: COORD,
    lpNumberOfCharsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn FillConsoleOutputAttribute(
    hConsoleOutput: HANDLE, wAttribute: WORD, nLength: DWORD, dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetConsoleScreenBufferInfo(
    hConsoleOutput: HANDLE, lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE, lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
  ) -> BOOL;
}
extern "C" {
  pub fn SetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE, lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
  ) -> BOOL;
}
extern "C" {
  pub fn GetLargestConsoleWindowSize(hConsoleOutput: HANDLE) -> COORD;
}
extern "C" {
  pub fn GetConsoleCursorInfo(
    hConsoleOutput: HANDLE, lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCurrentConsoleFont(
    hConsoleOutput: HANDLE, bMaximumWindow: BOOL, lpConsoleCurrentFont: PCONSOLE_FONT_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn GetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE, bMaximumWindow: BOOL, lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
  ) -> BOOL;
}
extern "C" {
  pub fn SetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE, bMaximumWindow: BOOL, lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
  ) -> BOOL;
}
extern "C" {
  pub fn GetConsoleHistoryInfo(lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO) -> BOOL;
}
extern "C" {
  pub fn SetConsoleHistoryInfo(lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO) -> BOOL;
}
extern "C" {
  pub fn GetConsoleFontSize(hConsoleOutput: HANDLE, nFont: DWORD) -> COORD;
}
extern "C" {
  pub fn GetConsoleSelectionInfo(lpConsoleSelectionInfo: PCONSOLE_SELECTION_INFO) -> BOOL;
}
extern "C" {
  pub fn GetNumberOfConsoleMouseButtons(lpNumberOfMouseButtons: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SetConsoleActiveScreenBuffer(hConsoleOutput: HANDLE) -> BOOL;
}
extern "C" {
  pub fn FlushConsoleInputBuffer(hConsoleInput: HANDLE) -> BOOL;
}
extern "C" {
  pub fn SetConsoleScreenBufferSize(hConsoleOutput: HANDLE, dwSize: COORD) -> BOOL;
}
extern "C" {
  pub fn SetConsoleCursorPosition(hConsoleOutput: HANDLE, dwCursorPosition: COORD) -> BOOL;
}
extern "C" {
  pub fn SetConsoleCursorInfo(
    hConsoleOutput: HANDLE, lpConsoleCursorInfo: *const CONSOLE_CURSOR_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn ScrollConsoleScreenBufferA(
    hConsoleOutput: HANDLE, lpScrollRectangle: *const SMALL_RECT,
    lpClipRectangle: *const SMALL_RECT, dwDestinationOrigin: COORD, lpFill: *const CHAR_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn ScrollConsoleScreenBufferW(
    hConsoleOutput: HANDLE, lpScrollRectangle: *const SMALL_RECT,
    lpClipRectangle: *const SMALL_RECT, dwDestinationOrigin: COORD, lpFill: *const CHAR_INFO,
  ) -> BOOL;
}
extern "C" {
  pub fn SetConsoleWindowInfo(
    hConsoleOutput: HANDLE, bAbsolute: BOOL, lpConsoleWindow: *const SMALL_RECT,
  ) -> BOOL;
}
extern "C" {
  pub fn SetConsoleTextAttribute(hConsoleOutput: HANDLE, wAttributes: WORD) -> BOOL;
}
extern "C" {
  pub fn GenerateConsoleCtrlEvent(dwCtrlEvent: DWORD, dwProcessGroupId: DWORD) -> BOOL;
}
extern "C" {
  pub fn FreeConsole() -> BOOL;
}
extern "C" {
  pub fn AttachConsole(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
  pub fn GetConsoleTitleA(lpConsoleTitle: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetConsoleTitleW(lpConsoleTitle: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetConsoleOriginalTitleA(lpConsoleTitle: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetConsoleOriginalTitleW(lpConsoleTitle: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
  pub fn SetConsoleTitleA(lpConsoleTitle: LPCSTR) -> BOOL;
}
extern "C" {
  pub fn SetConsoleTitleW(lpConsoleTitle: LPCWSTR) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _CONSOLE_READCONSOLE_CONTROL {
  pub nLength: ULONG,
  pub nInitialChars: ULONG,
  pub dwCtrlWakeupMask: ULONG,
  pub dwControlKeyState: ULONG,
}
#[test]
fn bindgen_test_layout__CONSOLE_READCONSOLE_CONTROL() {
  assert_eq!(
    ::core::mem::size_of::<_CONSOLE_READCONSOLE_CONTROL>(),
    16usize,
    concat!("Size of: ", stringify!(_CONSOLE_READCONSOLE_CONTROL))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONSOLE_READCONSOLE_CONTROL>(),
    4usize,
    concat!("Alignment of ", stringify!(_CONSOLE_READCONSOLE_CONTROL))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_READCONSOLE_CONTROL>())).nLength as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_READCONSOLE_CONTROL),
      "::",
      stringify!(nLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_READCONSOLE_CONTROL>())).nInitialChars as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_READCONSOLE_CONTROL),
      "::",
      stringify!(nInitialChars)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_READCONSOLE_CONTROL>())).dwCtrlWakeupMask as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_READCONSOLE_CONTROL),
      "::",
      stringify!(dwCtrlWakeupMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_CONSOLE_READCONSOLE_CONTROL>())).dwControlKeyState as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONSOLE_READCONSOLE_CONTROL),
      "::",
      stringify!(dwControlKeyState)
    )
  );
}
pub type CONSOLE_READCONSOLE_CONTROL = _CONSOLE_READCONSOLE_CONTROL;
pub type PCONSOLE_READCONSOLE_CONTROL = *mut _CONSOLE_READCONSOLE_CONTROL;
extern "C" {
  pub fn AllocConsole() -> BOOL;
}
extern "C" {
  pub fn GetConsoleCP() -> UINT;
}
extern "C" {
  pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn GetConsoleOutputCP() -> UINT;
}
extern "C" {
  pub fn GetNumberOfConsoleInputEvents(hConsoleInput: HANDLE, lpNumberOfEvents: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn PeekConsoleInputA(
    hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleA(
    hConsoleInput: HANDLE, lpBuffer: LPVOID, nNumberOfCharsToRead: DWORD,
    lpNumberOfCharsRead: LPDWORD, pInputControl: PCONSOLE_READCONSOLE_CONTROL,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleW(
    hConsoleInput: HANDLE, lpBuffer: LPVOID, nNumberOfCharsToRead: DWORD,
    lpNumberOfCharsRead: LPDWORD, pInputControl: PCONSOLE_READCONSOLE_CONTROL,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleInputA(
    hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ReadConsoleInputW(
    hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn SetConsoleCtrlHandler(HandlerRoutine: PHANDLER_ROUTINE, Add: BOOL) -> BOOL;
}
extern "C" {
  pub fn SetConsoleMode(hConsoleHandle: HANDLE, dwMode: DWORD) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleA(
    hConsoleOutput: HANDLE, lpBuffer: *const libc::c_void, nNumberOfCharsToWrite: DWORD,
    lpNumberOfCharsWritten: LPDWORD, lpReserved: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn WriteConsoleW(
    hConsoleOutput: HANDLE, lpBuffer: *const libc::c_void, nNumberOfCharsToWrite: DWORD,
    lpNumberOfCharsWritten: LPDWORD, lpReserved: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateConsoleScreenBuffer(
    dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: *const SECURITY_ATTRIBUTES,
    dwFlags: DWORD, lpScreenBufferData: LPVOID,
  ) -> HANDLE;
}
extern "C" {
  pub fn SetConsoleCP(wCodePageID: UINT) -> BOOL;
}
extern "C" {
  pub fn SetConsoleOutputCP(wCodePageID: UINT) -> BOOL;
}
extern "C" {
  pub fn GetConsoleDisplayMode(lpModeFlags: LPDWORD) -> BOOL;
}
extern "C" {
  pub fn SetConsoleDisplayMode(
    hConsoleOutput: HANDLE, dwFlags: DWORD, lpNewScreenBufferDimensions: PCOORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetConsoleWindow() -> HWND;
}
extern "C" {
  pub fn GetConsoleProcessList(lpdwProcessList: LPDWORD, dwProcessCount: DWORD) -> DWORD;
}
extern "C" {
  pub fn AddConsoleAliasA(Source: LPSTR, Target: LPSTR, ExeName: LPSTR) -> BOOL;
}
extern "C" {
  pub fn AddConsoleAliasW(Source: LPWSTR, Target: LPWSTR, ExeName: LPWSTR) -> BOOL;
}
extern "C" {
  pub fn GetConsoleAliasA(
    Source: LPSTR, TargetBuffer: LPSTR, TargetBufferLength: DWORD, ExeName: LPSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasW(
    Source: LPWSTR, TargetBuffer: LPWSTR, TargetBufferLength: DWORD, ExeName: LPWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasesLengthA(ExeName: LPSTR) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasesLengthW(ExeName: LPWSTR) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasExesLengthA() -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasExesLengthW() -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasesA(AliasBuffer: LPSTR, AliasBufferLength: DWORD, ExeName: LPSTR) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasesW(
    AliasBuffer: LPWSTR, AliasBufferLength: DWORD, ExeName: LPWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasExesA(ExeNameBuffer: LPSTR, ExeNameBufferLength: DWORD) -> DWORD;
}
extern "C" {
  pub fn GetConsoleAliasExesW(ExeNameBuffer: LPWSTR, ExeNameBufferLength: DWORD) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagVS_FIXEDFILEINFO {
  pub dwSignature: DWORD,
  pub dwStrucVersion: DWORD,
  pub dwFileVersionMS: DWORD,
  pub dwFileVersionLS: DWORD,
  pub dwProductVersionMS: DWORD,
  pub dwProductVersionLS: DWORD,
  pub dwFileFlagsMask: DWORD,
  pub dwFileFlags: DWORD,
  pub dwFileOS: DWORD,
  pub dwFileType: DWORD,
  pub dwFileSubtype: DWORD,
  pub dwFileDateMS: DWORD,
  pub dwFileDateLS: DWORD,
}
#[test]
fn bindgen_test_layout_tagVS_FIXEDFILEINFO() {
  assert_eq!(
    ::core::mem::size_of::<tagVS_FIXEDFILEINFO>(),
    52usize,
    concat!("Size of: ", stringify!(tagVS_FIXEDFILEINFO))
  );
  assert_eq!(
    ::core::mem::align_of::<tagVS_FIXEDFILEINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagVS_FIXEDFILEINFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwSignature as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwSignature)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwStrucVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwStrucVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileVersionMS as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileVersionMS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileVersionLS as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileVersionLS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwProductVersionMS as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwProductVersionMS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwProductVersionLS as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwProductVersionLS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileFlagsMask as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileFlagsMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileFlags as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileOS as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileOS)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileType as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileSubtype as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileSubtype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileDateMS as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileDateMS)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagVS_FIXEDFILEINFO>())).dwFileDateLS as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVS_FIXEDFILEINFO),
      "::",
      stringify!(dwFileDateLS)
    )
  );
}
pub type VS_FIXEDFILEINFO = tagVS_FIXEDFILEINFO;
extern "C" {
  pub fn VerFindFileA(
    uFlags: DWORD, szFileName: LPCSTR, szWinDir: LPCSTR, szAppDir: LPCSTR, szCurDir: LPSTR,
    puCurDirLen: PUINT, szDestDir: LPSTR, puDestDirLen: PUINT,
  ) -> DWORD;
}
extern "C" {
  pub fn VerFindFileW(
    uFlags: DWORD, szFileName: LPCWSTR, szWinDir: LPCWSTR, szAppDir: LPCWSTR, szCurDir: LPWSTR,
    puCurDirLen: PUINT, szDestDir: LPWSTR, puDestDirLen: PUINT,
  ) -> DWORD;
}
extern "C" {
  pub fn VerInstallFileA(
    uFlags: DWORD, szSrcFileName: LPCSTR, szDestFileName: LPCSTR, szSrcDir: LPCSTR,
    szDestDir: LPCSTR, szCurDir: LPCSTR, szTmpFile: LPSTR, puTmpFileLen: PUINT,
  ) -> DWORD;
}
extern "C" {
  pub fn VerInstallFileW(
    uFlags: DWORD, szSrcFileName: LPCWSTR, szDestFileName: LPCWSTR, szSrcDir: LPCWSTR,
    szDestDir: LPCWSTR, szCurDir: LPCWSTR, szTmpFile: LPWSTR, puTmpFileLen: PUINT,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFileVersionInfoSizeA(lptstrFilename: LPCSTR, lpdwHandle: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn GetFileVersionInfoSizeW(lptstrFilename: LPCWSTR, lpdwHandle: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn GetFileVersionInfoA(
    lptstrFilename: LPCSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileVersionInfoW(
    lptstrFilename: LPCWSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileVersionInfoSizeExA(
    dwFlags: DWORD, lpwstrFilename: LPCSTR, lpdwHandle: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFileVersionInfoSizeExW(
    dwFlags: DWORD, lpwstrFilename: LPCWSTR, lpdwHandle: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn GetFileVersionInfoExA(
    dwFlags: DWORD, lpwstrFilename: LPCSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn GetFileVersionInfoExW(
    dwFlags: DWORD, lpwstrFilename: LPCWSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn VerLanguageNameA(wLang: DWORD, szLang: LPSTR, cchLang: DWORD) -> DWORD;
}
extern "C" {
  pub fn VerLanguageNameW(wLang: DWORD, szLang: LPWSTR, cchLang: DWORD) -> DWORD;
}
extern "C" {
  pub fn VerQueryValueA(
    pBlock: LPCVOID, lpSubBlock: LPCSTR, lplpBuffer: *mut LPVOID, puLen: PUINT,
  ) -> BOOL;
}
extern "C" {
  pub fn VerQueryValueW(
    pBlock: LPCVOID, lpSubBlock: LPCWSTR, lplpBuffer: *mut LPVOID, puLen: PUINT,
  ) -> BOOL;
}
pub type LSTATUS = LONG;
pub type REGSAM = ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct val_context {
  pub valuelen: libc::c_int,
  pub value_context: LPVOID,
  pub val_buff_ptr: LPVOID,
}
#[test]
fn bindgen_test_layout_val_context() {
  assert_eq!(
    ::core::mem::size_of::<val_context>(),
    24usize,
    concat!("Size of: ", stringify!(val_context))
  );
  assert_eq!(
    ::core::mem::align_of::<val_context>(),
    8usize,
    concat!("Alignment of ", stringify!(val_context))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<val_context>())).valuelen as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(val_context),
      "::",
      stringify!(valuelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<val_context>())).value_context as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(val_context),
      "::",
      stringify!(value_context)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<val_context>())).val_buff_ptr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(val_context),
      "::",
      stringify!(val_buff_ptr)
    )
  );
}
impl Default for val_context {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PVALCONTEXT = *mut val_context;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct pvalueA {
  pub pv_valuename: LPSTR,
  pub pv_valuelen: libc::c_int,
  pub pv_value_context: LPVOID,
  pub pv_type: DWORD,
}
#[test]
fn bindgen_test_layout_pvalueA() {
  assert_eq!(
    ::core::mem::size_of::<pvalueA>(),
    32usize,
    concat!("Size of: ", stringify!(pvalueA))
  );
  assert_eq!(
    ::core::mem::align_of::<pvalueA>(),
    8usize,
    concat!("Alignment of ", stringify!(pvalueA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueA>())).pv_valuename as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueA),
      "::",
      stringify!(pv_valuename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueA>())).pv_valuelen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueA),
      "::",
      stringify!(pv_valuelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueA>())).pv_value_context as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueA),
      "::",
      stringify!(pv_value_context)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueA>())).pv_type as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueA),
      "::",
      stringify!(pv_type)
    )
  );
}
impl Default for pvalueA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PVALUEA = pvalueA;
pub type PPVALUEA = *mut pvalueA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct pvalueW {
  pub pv_valuename: LPWSTR,
  pub pv_valuelen: libc::c_int,
  pub pv_value_context: LPVOID,
  pub pv_type: DWORD,
}
#[test]
fn bindgen_test_layout_pvalueW() {
  assert_eq!(
    ::core::mem::size_of::<pvalueW>(),
    32usize,
    concat!("Size of: ", stringify!(pvalueW))
  );
  assert_eq!(
    ::core::mem::align_of::<pvalueW>(),
    8usize,
    concat!("Alignment of ", stringify!(pvalueW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueW>())).pv_valuename as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueW),
      "::",
      stringify!(pv_valuename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueW>())).pv_valuelen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueW),
      "::",
      stringify!(pv_valuelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueW>())).pv_value_context as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueW),
      "::",
      stringify!(pv_value_context)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<pvalueW>())).pv_type as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(pvalueW),
      "::",
      stringify!(pv_type)
    )
  );
}
impl Default for pvalueW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type PVALUEW = pvalueW;
pub type PPVALUEW = *mut pvalueW;
pub type PVALUE = PVALUEA;
pub type PPVALUE = PPVALUEA;
pub type PQUERYHANDLER = ::core::option::Option<unsafe extern "C" fn() -> DWORD>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct provider_info {
  pub pi_R0_1val: PQUERYHANDLER,
  pub pi_R0_allvals: PQUERYHANDLER,
  pub pi_R3_1val: PQUERYHANDLER,
  pub pi_R3_allvals: PQUERYHANDLER,
  pub pi_flags: DWORD,
  pub pi_key_context: LPVOID,
}
#[test]
fn bindgen_test_layout_provider_info() {
  assert_eq!(
    ::core::mem::size_of::<provider_info>(),
    48usize,
    concat!("Size of: ", stringify!(provider_info))
  );
  assert_eq!(
    ::core::mem::align_of::<provider_info>(),
    8usize,
    concat!("Alignment of ", stringify!(provider_info))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<provider_info>())).pi_R0_1val as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(provider_info),
      "::",
      stringify!(pi_R0_1val)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<provider_info>())).pi_R0_allvals as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(provider_info),
      "::",
      stringify!(pi_R0_allvals)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<provider_info>())).pi_R3_1val as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(provider_info),
      "::",
      stringify!(pi_R3_1val)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<provider_info>())).pi_R3_allvals as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(provider_info),
      "::",
      stringify!(pi_R3_allvals)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<provider_info>())).pi_flags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(provider_info),
      "::",
      stringify!(pi_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<provider_info>())).pi_key_context as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(provider_info),
      "::",
      stringify!(pi_key_context)
    )
  );
}
impl Default for provider_info {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type REG_PROVIDER = provider_info;
pub type PPROVIDER = *mut provider_info;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct value_entA {
  pub ve_valuename: LPSTR,
  pub ve_valuelen: DWORD,
  pub ve_valueptr: DWORD_PTR,
  pub ve_type: DWORD,
}
#[test]
fn bindgen_test_layout_value_entA() {
  assert_eq!(
    ::core::mem::size_of::<value_entA>(),
    32usize,
    concat!("Size of: ", stringify!(value_entA))
  );
  assert_eq!(
    ::core::mem::align_of::<value_entA>(),
    8usize,
    concat!("Alignment of ", stringify!(value_entA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entA>())).ve_valuename as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entA),
      "::",
      stringify!(ve_valuename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entA>())).ve_valuelen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entA),
      "::",
      stringify!(ve_valuelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entA>())).ve_valueptr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entA),
      "::",
      stringify!(ve_valueptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entA>())).ve_type as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entA),
      "::",
      stringify!(ve_type)
    )
  );
}
impl Default for value_entA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type VALENTA = value_entA;
pub type PVALENTA = *mut value_entA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct value_entW {
  pub ve_valuename: LPWSTR,
  pub ve_valuelen: DWORD,
  pub ve_valueptr: DWORD_PTR,
  pub ve_type: DWORD,
}
#[test]
fn bindgen_test_layout_value_entW() {
  assert_eq!(
    ::core::mem::size_of::<value_entW>(),
    32usize,
    concat!("Size of: ", stringify!(value_entW))
  );
  assert_eq!(
    ::core::mem::align_of::<value_entW>(),
    8usize,
    concat!("Alignment of ", stringify!(value_entW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entW>())).ve_valuename as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entW),
      "::",
      stringify!(ve_valuename)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entW>())).ve_valuelen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entW),
      "::",
      stringify!(ve_valuelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entW>())).ve_valueptr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entW),
      "::",
      stringify!(ve_valueptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<value_entW>())).ve_type as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(value_entW),
      "::",
      stringify!(ve_type)
    )
  );
}
impl Default for value_entW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type VALENTW = value_entW;
pub type PVALENTW = *mut value_entW;
pub type VALENT = VALENTA;
pub type PVALENT = PVALENTA;
extern "C" {
  pub fn RegCloseKey(hKey: HKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegOverridePredefKey(hKey: HKEY, hNewHKey: HKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenUserClassesRoot(
    hToken: HANDLE, dwOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenCurrentUser(samDesired: REGSAM, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegDisablePredefinedCache() -> LSTATUS;
}
extern "C" {
  pub fn RegDisablePredefinedCacheEx() -> LSTATUS;
}
extern "C" {
  pub fn RegConnectRegistryA(lpMachineName: LPCSTR, hKey: HKEY, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegConnectRegistryW(lpMachineName: LPCWSTR, hKey: HKEY, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegConnectRegistryExA(
    lpMachineName: LPCSTR, hKey: HKEY, Flags: ULONG, phkResult: PHKEY,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegConnectRegistryExW(
    lpMachineName: LPCWSTR, hKey: HKEY, Flags: ULONG, phkResult: PHKEY,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegCreateKeyA(hKey: HKEY, lpSubKey: LPCSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegCreateKeyW(hKey: HKEY, lpSubKey: LPCWSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegCreateKeyExA(
    hKey: HKEY, lpSubKey: LPCSTR, Reserved: DWORD, lpClass: LPSTR, dwOptions: DWORD,
    samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY,
    lpdwDisposition: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegCreateKeyExW(
    hKey: HKEY, lpSubKey: LPCWSTR, Reserved: DWORD, lpClass: LPWSTR, dwOptions: DWORD,
    samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY,
    lpdwDisposition: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegCreateKeyTransactedA(
    hKey: HKEY, lpSubKey: LPCSTR, Reserved: DWORD, lpClass: LPSTR, dwOptions: DWORD,
    samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY,
    lpdwDisposition: LPDWORD, hTransaction: HANDLE, pExtendedParemeter: PVOID,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegCreateKeyTransactedW(
    hKey: HKEY, lpSubKey: LPCWSTR, Reserved: DWORD, lpClass: LPWSTR, dwOptions: DWORD,
    samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY,
    lpdwDisposition: LPDWORD, hTransaction: HANDLE, pExtendedParemeter: PVOID,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyA(hKey: HKEY, lpSubKey: LPCSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyW(hKey: HKEY, lpSubKey: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyExA(
    hKey: HKEY, lpSubKey: LPCSTR, samDesired: REGSAM, Reserved: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyExW(
    hKey: HKEY, lpSubKey: LPCWSTR, samDesired: REGSAM, Reserved: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyTransactedA(
    hKey: HKEY, lpSubKey: LPCSTR, samDesired: REGSAM, Reserved: DWORD, hTransaction: HANDLE,
    pExtendedParameter: PVOID,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyTransactedW(
    hKey: HKEY, lpSubKey: LPCWSTR, samDesired: REGSAM, Reserved: DWORD, hTransaction: HANDLE,
    pExtendedParameter: PVOID,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegDisableReflectionKey(hBase: HKEY) -> LONG;
}
extern "C" {
  pub fn RegEnableReflectionKey(hBase: HKEY) -> LONG;
}
extern "C" {
  pub fn RegQueryReflectionKey(hBase: HKEY, bIsReflectionDisabled: *mut BOOL) -> LONG;
}
extern "C" {
  pub fn RegDeleteValueA(hKey: HKEY, lpValueName: LPCSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteValueW(hKey: HKEY, lpValueName: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegEnumKeyA(hKey: HKEY, dwIndex: DWORD, lpName: LPSTR, cchName: DWORD) -> LSTATUS;
}
extern "C" {
  pub fn RegEnumKeyW(hKey: HKEY, dwIndex: DWORD, lpName: LPWSTR, cchName: DWORD) -> LSTATUS;
}
extern "C" {
  pub fn RegEnumKeyExA(
    hKey: HKEY, dwIndex: DWORD, lpName: LPSTR, lpcchName: LPDWORD, lpReserved: LPDWORD,
    lpClass: LPSTR, lpcchClass: LPDWORD, lpftLastWriteTime: PFILETIME,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegEnumKeyExW(
    hKey: HKEY, dwIndex: DWORD, lpName: LPWSTR, lpcchName: LPDWORD, lpReserved: LPDWORD,
    lpClass: LPWSTR, lpcchClass: LPDWORD, lpftLastWriteTime: PFILETIME,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegEnumValueA(
    hKey: HKEY, dwIndex: DWORD, lpValueName: LPSTR, lpcchValueName: LPDWORD, lpReserved: LPDWORD,
    lpType: LPDWORD, lpData: LPBYTE, lpcbData: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegEnumValueW(
    hKey: HKEY, dwIndex: DWORD, lpValueName: LPWSTR, lpcchValueName: LPDWORD, lpReserved: LPDWORD,
    lpType: LPDWORD, lpData: LPBYTE, lpcbData: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegFlushKey(hKey: HKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegGetKeySecurity(
    hKey: HKEY, SecurityInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpcbSecurityDescriptor: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegLoadKeyA(hKey: HKEY, lpSubKey: LPCSTR, lpFile: LPCSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegLoadKeyW(hKey: HKEY, lpSubKey: LPCWSTR, lpFile: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegNotifyChangeKeyValue(
    hKey: HKEY, bWatchSubtree: BOOL, dwNotifyFilter: DWORD, hEvent: HANDLE, fAsynchronous: BOOL,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenKeyA(hKey: HKEY, lpSubKey: LPCSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenKeyW(hKey: HKEY, lpSubKey: LPCWSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenKeyExA(
    hKey: HKEY, lpSubKey: LPCSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenKeyExW(
    hKey: HKEY, lpSubKey: LPCWSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenKeyTransactedA(
    hKey: HKEY, lpSubKey: LPCSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY,
    hTransaction: HANDLE, pExtendedParemeter: PVOID,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegOpenKeyTransactedW(
    hKey: HKEY, lpSubKey: LPCWSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY,
    hTransaction: HANDLE, pExtendedParemeter: PVOID,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryInfoKeyA(
    hKey: HKEY, lpClass: LPSTR, lpcchClass: LPDWORD, lpReserved: LPDWORD, lpcSubKeys: LPDWORD,
    lpcbMaxSubKeyLen: LPDWORD, lpcbMaxClassLen: LPDWORD, lpcValues: LPDWORD,
    lpcbMaxValueNameLen: LPDWORD, lpcbMaxValueLen: LPDWORD, lpcbSecurityDescriptor: LPDWORD,
    lpftLastWriteTime: PFILETIME,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryInfoKeyW(
    hKey: HKEY, lpClass: LPWSTR, lpcchClass: LPDWORD, lpReserved: LPDWORD, lpcSubKeys: LPDWORD,
    lpcbMaxSubKeyLen: LPDWORD, lpcbMaxClassLen: LPDWORD, lpcValues: LPDWORD,
    lpcbMaxValueNameLen: LPDWORD, lpcbMaxValueLen: LPDWORD, lpcbSecurityDescriptor: LPDWORD,
    lpftLastWriteTime: PFILETIME,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryValueA(hKey: HKEY, lpSubKey: LPCSTR, lpData: LPSTR, lpcbData: PLONG) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryValueW(hKey: HKEY, lpSubKey: LPCWSTR, lpData: LPWSTR, lpcbData: PLONG) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryMultipleValuesA(
    hKey: HKEY, val_list: PVALENTA, num_vals: DWORD, lpValueBuf: LPSTR, ldwTotsize: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryMultipleValuesW(
    hKey: HKEY, val_list: PVALENTW, num_vals: DWORD, lpValueBuf: LPWSTR, ldwTotsize: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryValueExA(
    hKey: HKEY, lpValueName: LPCSTR, lpReserved: LPDWORD, lpType: LPDWORD, lpData: LPBYTE,
    lpcbData: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegQueryValueExW(
    hKey: HKEY, lpValueName: LPCWSTR, lpReserved: LPDWORD, lpType: LPDWORD, lpData: LPBYTE,
    lpcbData: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegReplaceKeyA(
    hKey: HKEY, lpSubKey: LPCSTR, lpNewFile: LPCSTR, lpOldFile: LPCSTR,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegReplaceKeyW(
    hKey: HKEY, lpSubKey: LPCWSTR, lpNewFile: LPCWSTR, lpOldFile: LPCWSTR,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegRestoreKeyA(hKey: HKEY, lpFile: LPCSTR, dwFlags: DWORD) -> LSTATUS;
}
extern "C" {
  pub fn RegRestoreKeyW(hKey: HKEY, lpFile: LPCWSTR, dwFlags: DWORD) -> LSTATUS;
}
extern "C" {
  pub fn RegRenameKey(hKey: HKEY, lpSubKeyName: LPCWSTR, lpNewKeyName: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegSaveKeyA(
    hKey: HKEY, lpFile: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSaveKeyW(
    hKey: HKEY, lpFile: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSetKeySecurity(
    hKey: HKEY, SecurityInformation: SECURITY_INFORMATION,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSetValueA(
    hKey: HKEY, lpSubKey: LPCSTR, dwType: DWORD, lpData: LPCSTR, cbData: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSetValueW(
    hKey: HKEY, lpSubKey: LPCWSTR, dwType: DWORD, lpData: LPCWSTR, cbData: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSetValueExA(
    hKey: HKEY, lpValueName: LPCSTR, Reserved: DWORD, dwType: DWORD, lpData: *const BYTE,
    cbData: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSetValueExW(
    hKey: HKEY, lpValueName: LPCWSTR, Reserved: DWORD, dwType: DWORD, lpData: *const BYTE,
    cbData: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegUnLoadKeyA(hKey: HKEY, lpSubKey: LPCSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegUnLoadKeyW(hKey: HKEY, lpSubKey: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyValueA(hKey: HKEY, lpSubKey: LPCSTR, lpValueName: LPCSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteKeyValueW(hKey: HKEY, lpSubKey: LPCWSTR, lpValueName: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegSetKeyValueA(
    hKey: HKEY, lpSubKey: LPCSTR, lpValueName: LPCSTR, dwType: DWORD, lpData: LPCVOID,
    cbData: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSetKeyValueW(
    hKey: HKEY, lpSubKey: LPCWSTR, lpValueName: LPCWSTR, dwType: DWORD, lpData: LPCVOID,
    cbData: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteTreeA(hKey: HKEY, lpSubKey: LPCSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegDeleteTreeW(hKey: HKEY, lpSubKey: LPCWSTR) -> LSTATUS;
}
extern "C" {
  pub fn RegCopyTreeA(hKeySrc: HKEY, lpSubKey: LPCSTR, hKeyDest: HKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegGetValueA(
    hkey: HKEY, lpSubKey: LPCSTR, lpValue: LPCSTR, dwFlags: DWORD, pdwType: LPDWORD, pvData: PVOID,
    pcbData: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegGetValueW(
    hkey: HKEY, lpSubKey: LPCWSTR, lpValue: LPCWSTR, dwFlags: DWORD, pdwType: LPDWORD,
    pvData: PVOID, pcbData: LPDWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegCopyTreeW(hKeySrc: HKEY, lpSubKey: LPCWSTR, hKeyDest: HKEY) -> LSTATUS;
}
extern "C" {
  pub fn RegLoadMUIStringA(
    hKey: HKEY, pszValue: LPCSTR, pszOutBuf: LPSTR, cbOutBuf: DWORD, pcbData: LPDWORD,
    Flags: DWORD, pszDirectory: LPCSTR,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegLoadMUIStringW(
    hKey: HKEY, pszValue: LPCWSTR, pszOutBuf: LPWSTR, cbOutBuf: DWORD, pcbData: LPDWORD,
    Flags: DWORD, pszDirectory: LPCWSTR,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegLoadAppKeyA(
    lpFile: LPCSTR, phkResult: PHKEY, samDesired: REGSAM, dwOptions: DWORD, Reserved: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegLoadAppKeyW(
    lpFile: LPCWSTR, phkResult: PHKEY, samDesired: REGSAM, dwOptions: DWORD, Reserved: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn InitiateSystemShutdownA(
    lpMachineName: LPSTR, lpMessage: LPSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn InitiateSystemShutdownW(
    lpMachineName: LPWSTR, lpMessage: LPWSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn AbortSystemShutdownA(lpMachineName: LPSTR) -> BOOL;
}
extern "C" {
  pub fn AbortSystemShutdownW(lpMachineName: LPWSTR) -> BOOL;
}
extern "C" {
  pub fn InitiateSystemShutdownExA(
    lpMachineName: LPSTR, lpMessage: LPSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL, dwReason: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn InitiateSystemShutdownExW(
    lpMachineName: LPWSTR, lpMessage: LPWSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL, dwReason: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn InitiateShutdownA(
    lpMachineName: LPSTR, lpMessage: LPSTR, dwGracePeriod: DWORD, dwShutdownFlags: DWORD,
    dwReason: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn InitiateShutdownW(
    lpMachineName: LPWSTR, lpMessage: LPWSTR, dwGracePeriod: DWORD, dwShutdownFlags: DWORD,
    dwReason: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn CheckForHiberboot(pHiberboot: PBOOLEAN, bClearFlag: BOOLEAN) -> DWORD;
}
extern "C" {
  pub fn RegSaveKeyExA(
    hKey: HKEY, lpFile: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, Flags: DWORD,
  ) -> LSTATUS;
}
extern "C" {
  pub fn RegSaveKeyExW(
    hKey: HKEY, lpFile: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, Flags: DWORD,
  ) -> LSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _NETRESOURCEA {
  pub dwScope: DWORD,
  pub dwType: DWORD,
  pub dwDisplayType: DWORD,
  pub dwUsage: DWORD,
  pub lpLocalName: LPSTR,
  pub lpRemoteName: LPSTR,
  pub lpComment: LPSTR,
  pub lpProvider: LPSTR,
}
#[test]
fn bindgen_test_layout__NETRESOURCEA() {
  assert_eq!(
    ::core::mem::size_of::<_NETRESOURCEA>(),
    48usize,
    concat!("Size of: ", stringify!(_NETRESOURCEA))
  );
  assert_eq!(
    ::core::mem::align_of::<_NETRESOURCEA>(),
    8usize,
    concat!("Alignment of ", stringify!(_NETRESOURCEA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).dwScope as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(dwScope)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).dwType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).dwDisplayType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(dwDisplayType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).dwUsage as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(dwUsage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).lpLocalName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(lpLocalName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).lpRemoteName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(lpRemoteName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).lpComment as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(lpComment)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEA>())).lpProvider as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEA),
      "::",
      stringify!(lpProvider)
    )
  );
}
impl Default for _NETRESOURCEA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NETRESOURCEA = _NETRESOURCEA;
pub type LPNETRESOURCEA = *mut _NETRESOURCEA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _NETRESOURCEW {
  pub dwScope: DWORD,
  pub dwType: DWORD,
  pub dwDisplayType: DWORD,
  pub dwUsage: DWORD,
  pub lpLocalName: LPWSTR,
  pub lpRemoteName: LPWSTR,
  pub lpComment: LPWSTR,
  pub lpProvider: LPWSTR,
}
#[test]
fn bindgen_test_layout__NETRESOURCEW() {
  assert_eq!(
    ::core::mem::size_of::<_NETRESOURCEW>(),
    48usize,
    concat!("Size of: ", stringify!(_NETRESOURCEW))
  );
  assert_eq!(
    ::core::mem::align_of::<_NETRESOURCEW>(),
    8usize,
    concat!("Alignment of ", stringify!(_NETRESOURCEW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).dwScope as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(dwScope)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).dwType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).dwDisplayType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(dwDisplayType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).dwUsage as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(dwUsage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).lpLocalName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(lpLocalName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).lpRemoteName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(lpRemoteName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).lpComment as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(lpComment)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETRESOURCEW>())).lpProvider as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETRESOURCEW),
      "::",
      stringify!(lpProvider)
    )
  );
}
impl Default for _NETRESOURCEW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type NETRESOURCEW = _NETRESOURCEW;
pub type LPNETRESOURCEW = *mut _NETRESOURCEW;
pub type NETRESOURCE = NETRESOURCEA;
pub type LPNETRESOURCE = LPNETRESOURCEA;
extern "C" {
  pub fn WNetAddConnectionA(lpRemoteName: LPCSTR, lpPassword: LPCSTR, lpLocalName: LPCSTR)
    -> DWORD;
}
extern "C" {
  pub fn WNetAddConnectionW(
    lpRemoteName: LPCWSTR, lpPassword: LPCWSTR, lpLocalName: LPCWSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetAddConnection2A(
    lpNetResource: LPNETRESOURCEA, lpPassword: LPCSTR, lpUserName: LPCSTR, dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetAddConnection2W(
    lpNetResource: LPNETRESOURCEW, lpPassword: LPCWSTR, lpUserName: LPCWSTR, dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetAddConnection3A(
    hwndOwner: HWND, lpNetResource: LPNETRESOURCEA, lpPassword: LPCSTR, lpUserName: LPCSTR,
    dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetAddConnection3W(
    hwndOwner: HWND, lpNetResource: LPNETRESOURCEW, lpPassword: LPCWSTR, lpUserName: LPCWSTR,
    dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetCancelConnectionA(lpName: LPCSTR, fForce: BOOL) -> DWORD;
}
extern "C" {
  pub fn WNetCancelConnectionW(lpName: LPCWSTR, fForce: BOOL) -> DWORD;
}
extern "C" {
  pub fn WNetCancelConnection2A(lpName: LPCSTR, dwFlags: DWORD, fForce: BOOL) -> DWORD;
}
extern "C" {
  pub fn WNetCancelConnection2W(lpName: LPCWSTR, dwFlags: DWORD, fForce: BOOL) -> DWORD;
}
extern "C" {
  pub fn WNetGetConnectionA(lpLocalName: LPCSTR, lpRemoteName: LPSTR, lpnLength: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn WNetGetConnectionW(
    lpLocalName: LPCWSTR, lpRemoteName: LPWSTR, lpnLength: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetRestoreSingleConnectionW(hwndParent: HWND, lpDevice: LPCWSTR, fUseUI: BOOL) -> DWORD;
}
extern "C" {
  pub fn WNetUseConnectionA(
    hwndOwner: HWND, lpNetResource: LPNETRESOURCEA, lpPassword: LPCSTR, lpUserId: LPCSTR,
    dwFlags: DWORD, lpAccessName: LPSTR, lpBufferSize: LPDWORD, lpResult: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetUseConnectionW(
    hwndOwner: HWND, lpNetResource: LPNETRESOURCEW, lpPassword: LPCWSTR, lpUserId: LPCWSTR,
    dwFlags: DWORD, lpAccessName: LPWSTR, lpBufferSize: LPDWORD, lpResult: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetConnectionDialog(hwnd: HWND, dwType: DWORD) -> DWORD;
}
extern "C" {
  pub fn WNetDisconnectDialog(hwnd: HWND, dwType: DWORD) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CONNECTDLGSTRUCTA {
  pub cbStructure: DWORD,
  pub hwndOwner: HWND,
  pub lpConnRes: LPNETRESOURCEA,
  pub dwFlags: DWORD,
  pub dwDevNum: DWORD,
}
#[test]
fn bindgen_test_layout__CONNECTDLGSTRUCTA() {
  assert_eq!(
    ::core::mem::size_of::<_CONNECTDLGSTRUCTA>(),
    32usize,
    concat!("Size of: ", stringify!(_CONNECTDLGSTRUCTA))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONNECTDLGSTRUCTA>(),
    8usize,
    concat!("Alignment of ", stringify!(_CONNECTDLGSTRUCTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTA>())).cbStructure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTA),
      "::",
      stringify!(cbStructure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTA>())).hwndOwner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTA),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTA>())).lpConnRes as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTA),
      "::",
      stringify!(lpConnRes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTA>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTA>())).dwDevNum as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTA),
      "::",
      stringify!(dwDevNum)
    )
  );
}
impl Default for _CONNECTDLGSTRUCTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CONNECTDLGSTRUCTA = _CONNECTDLGSTRUCTA;
pub type LPCONNECTDLGSTRUCTA = *mut _CONNECTDLGSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _CONNECTDLGSTRUCTW {
  pub cbStructure: DWORD,
  pub hwndOwner: HWND,
  pub lpConnRes: LPNETRESOURCEW,
  pub dwFlags: DWORD,
  pub dwDevNum: DWORD,
}
#[test]
fn bindgen_test_layout__CONNECTDLGSTRUCTW() {
  assert_eq!(
    ::core::mem::size_of::<_CONNECTDLGSTRUCTW>(),
    32usize,
    concat!("Size of: ", stringify!(_CONNECTDLGSTRUCTW))
  );
  assert_eq!(
    ::core::mem::align_of::<_CONNECTDLGSTRUCTW>(),
    8usize,
    concat!("Alignment of ", stringify!(_CONNECTDLGSTRUCTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTW>())).cbStructure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTW),
      "::",
      stringify!(cbStructure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTW>())).hwndOwner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTW),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTW>())).lpConnRes as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTW),
      "::",
      stringify!(lpConnRes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTW>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_CONNECTDLGSTRUCTW>())).dwDevNum as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_CONNECTDLGSTRUCTW),
      "::",
      stringify!(dwDevNum)
    )
  );
}
impl Default for _CONNECTDLGSTRUCTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type CONNECTDLGSTRUCTW = _CONNECTDLGSTRUCTW;
pub type LPCONNECTDLGSTRUCTW = *mut _CONNECTDLGSTRUCTW;
pub type CONNECTDLGSTRUCT = CONNECTDLGSTRUCTA;
pub type LPCONNECTDLGSTRUCT = LPCONNECTDLGSTRUCTA;
extern "C" {
  pub fn WNetConnectionDialog1A(lpConnDlgStruct: LPCONNECTDLGSTRUCTA) -> DWORD;
}
extern "C" {
  pub fn WNetConnectionDialog1W(lpConnDlgStruct: LPCONNECTDLGSTRUCTW) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _DISCDLGSTRUCTA {
  pub cbStructure: DWORD,
  pub hwndOwner: HWND,
  pub lpLocalName: LPSTR,
  pub lpRemoteName: LPSTR,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__DISCDLGSTRUCTA() {
  assert_eq!(
    ::core::mem::size_of::<_DISCDLGSTRUCTA>(),
    40usize,
    concat!("Size of: ", stringify!(_DISCDLGSTRUCTA))
  );
  assert_eq!(
    ::core::mem::align_of::<_DISCDLGSTRUCTA>(),
    8usize,
    concat!("Alignment of ", stringify!(_DISCDLGSTRUCTA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTA>())).cbStructure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTA),
      "::",
      stringify!(cbStructure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTA>())).hwndOwner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTA),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTA>())).lpLocalName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTA),
      "::",
      stringify!(lpLocalName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTA>())).lpRemoteName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTA),
      "::",
      stringify!(lpRemoteName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTA>())).dwFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTA),
      "::",
      stringify!(dwFlags)
    )
  );
}
impl Default for _DISCDLGSTRUCTA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DISCDLGSTRUCTA = _DISCDLGSTRUCTA;
pub type LPDISCDLGSTRUCTA = *mut _DISCDLGSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _DISCDLGSTRUCTW {
  pub cbStructure: DWORD,
  pub hwndOwner: HWND,
  pub lpLocalName: LPWSTR,
  pub lpRemoteName: LPWSTR,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__DISCDLGSTRUCTW() {
  assert_eq!(
    ::core::mem::size_of::<_DISCDLGSTRUCTW>(),
    40usize,
    concat!("Size of: ", stringify!(_DISCDLGSTRUCTW))
  );
  assert_eq!(
    ::core::mem::align_of::<_DISCDLGSTRUCTW>(),
    8usize,
    concat!("Alignment of ", stringify!(_DISCDLGSTRUCTW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTW>())).cbStructure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTW),
      "::",
      stringify!(cbStructure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTW>())).hwndOwner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTW),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTW>())).lpLocalName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTW),
      "::",
      stringify!(lpLocalName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTW>())).lpRemoteName as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTW),
      "::",
      stringify!(lpRemoteName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_DISCDLGSTRUCTW>())).dwFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_DISCDLGSTRUCTW),
      "::",
      stringify!(dwFlags)
    )
  );
}
impl Default for _DISCDLGSTRUCTW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type DISCDLGSTRUCTW = _DISCDLGSTRUCTW;
pub type LPDISCDLGSTRUCTW = *mut _DISCDLGSTRUCTW;
pub type DISCDLGSTRUCT = DISCDLGSTRUCTA;
pub type LPDISCDLGSTRUCT = LPDISCDLGSTRUCTA;
extern "C" {
  pub fn WNetDisconnectDialog1A(lpConnDlgStruct: LPDISCDLGSTRUCTA) -> DWORD;
}
extern "C" {
  pub fn WNetDisconnectDialog1W(lpConnDlgStruct: LPDISCDLGSTRUCTW) -> DWORD;
}
extern "C" {
  pub fn WNetOpenEnumA(
    dwScope: DWORD, dwType: DWORD, dwUsage: DWORD, lpNetResource: LPNETRESOURCEA, lphEnum: LPHANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetOpenEnumW(
    dwScope: DWORD, dwType: DWORD, dwUsage: DWORD, lpNetResource: LPNETRESOURCEW, lphEnum: LPHANDLE,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetEnumResourceA(
    hEnum: HANDLE, lpcCount: LPDWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetEnumResourceW(
    hEnum: HANDLE, lpcCount: LPDWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetCloseEnum(hEnum: HANDLE) -> DWORD;
}
extern "C" {
  pub fn WNetGetResourceParentA(
    lpNetResource: LPNETRESOURCEA, lpBuffer: LPVOID, lpcbBuffer: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetResourceParentW(
    lpNetResource: LPNETRESOURCEW, lpBuffer: LPVOID, lpcbBuffer: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetResourceInformationA(
    lpNetResource: LPNETRESOURCEA, lpBuffer: LPVOID, lpcbBuffer: LPDWORD, lplpSystem: *mut LPSTR,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetResourceInformationW(
    lpNetResource: LPNETRESOURCEW, lpBuffer: LPVOID, lpcbBuffer: LPDWORD, lplpSystem: *mut LPWSTR,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UNIVERSAL_NAME_INFOA {
  pub lpUniversalName: LPSTR,
}
#[test]
fn bindgen_test_layout__UNIVERSAL_NAME_INFOA() {
  assert_eq!(
    ::core::mem::size_of::<_UNIVERSAL_NAME_INFOA>(),
    8usize,
    concat!("Size of: ", stringify!(_UNIVERSAL_NAME_INFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<_UNIVERSAL_NAME_INFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_UNIVERSAL_NAME_INFOA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UNIVERSAL_NAME_INFOA>())).lpUniversalName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNIVERSAL_NAME_INFOA),
      "::",
      stringify!(lpUniversalName)
    )
  );
}
impl Default for _UNIVERSAL_NAME_INFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UNIVERSAL_NAME_INFOA = _UNIVERSAL_NAME_INFOA;
pub type LPUNIVERSAL_NAME_INFOA = *mut _UNIVERSAL_NAME_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _UNIVERSAL_NAME_INFOW {
  pub lpUniversalName: LPWSTR,
}
#[test]
fn bindgen_test_layout__UNIVERSAL_NAME_INFOW() {
  assert_eq!(
    ::core::mem::size_of::<_UNIVERSAL_NAME_INFOW>(),
    8usize,
    concat!("Size of: ", stringify!(_UNIVERSAL_NAME_INFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<_UNIVERSAL_NAME_INFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_UNIVERSAL_NAME_INFOW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_UNIVERSAL_NAME_INFOW>())).lpUniversalName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_UNIVERSAL_NAME_INFOW),
      "::",
      stringify!(lpUniversalName)
    )
  );
}
impl Default for _UNIVERSAL_NAME_INFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type UNIVERSAL_NAME_INFOW = _UNIVERSAL_NAME_INFOW;
pub type LPUNIVERSAL_NAME_INFOW = *mut _UNIVERSAL_NAME_INFOW;
pub type UNIVERSAL_NAME_INFO = UNIVERSAL_NAME_INFOA;
pub type LPUNIVERSAL_NAME_INFO = LPUNIVERSAL_NAME_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _REMOTE_NAME_INFOA {
  pub lpUniversalName: LPSTR,
  pub lpConnectionName: LPSTR,
  pub lpRemainingPath: LPSTR,
}
#[test]
fn bindgen_test_layout__REMOTE_NAME_INFOA() {
  assert_eq!(
    ::core::mem::size_of::<_REMOTE_NAME_INFOA>(),
    24usize,
    concat!("Size of: ", stringify!(_REMOTE_NAME_INFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<_REMOTE_NAME_INFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_REMOTE_NAME_INFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REMOTE_NAME_INFOA>())).lpUniversalName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REMOTE_NAME_INFOA),
      "::",
      stringify!(lpUniversalName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REMOTE_NAME_INFOA>())).lpConnectionName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_REMOTE_NAME_INFOA),
      "::",
      stringify!(lpConnectionName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REMOTE_NAME_INFOA>())).lpRemainingPath as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_REMOTE_NAME_INFOA),
      "::",
      stringify!(lpRemainingPath)
    )
  );
}
impl Default for _REMOTE_NAME_INFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type REMOTE_NAME_INFOA = _REMOTE_NAME_INFOA;
pub type LPREMOTE_NAME_INFOA = *mut _REMOTE_NAME_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _REMOTE_NAME_INFOW {
  pub lpUniversalName: LPWSTR,
  pub lpConnectionName: LPWSTR,
  pub lpRemainingPath: LPWSTR,
}
#[test]
fn bindgen_test_layout__REMOTE_NAME_INFOW() {
  assert_eq!(
    ::core::mem::size_of::<_REMOTE_NAME_INFOW>(),
    24usize,
    concat!("Size of: ", stringify!(_REMOTE_NAME_INFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<_REMOTE_NAME_INFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_REMOTE_NAME_INFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REMOTE_NAME_INFOW>())).lpUniversalName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_REMOTE_NAME_INFOW),
      "::",
      stringify!(lpUniversalName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_REMOTE_NAME_INFOW>())).lpConnectionName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_REMOTE_NAME_INFOW),
      "::",
      stringify!(lpConnectionName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_REMOTE_NAME_INFOW>())).lpRemainingPath as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_REMOTE_NAME_INFOW),
      "::",
      stringify!(lpRemainingPath)
    )
  );
}
impl Default for _REMOTE_NAME_INFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type REMOTE_NAME_INFOW = _REMOTE_NAME_INFOW;
pub type LPREMOTE_NAME_INFOW = *mut _REMOTE_NAME_INFOW;
pub type REMOTE_NAME_INFO = REMOTE_NAME_INFOA;
pub type LPREMOTE_NAME_INFO = LPREMOTE_NAME_INFOA;
extern "C" {
  pub fn WNetGetUniversalNameA(
    lpLocalPath: LPCSTR, dwInfoLevel: DWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetUniversalNameW(
    lpLocalPath: LPCWSTR, dwInfoLevel: DWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetUserA(lpName: LPCSTR, lpUserName: LPSTR, lpnLength: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn WNetGetUserW(lpName: LPCWSTR, lpUserName: LPWSTR, lpnLength: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn WNetGetProviderNameA(
    dwNetType: DWORD, lpProviderName: LPSTR, lpBufferSize: LPDWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetProviderNameW(
    dwNetType: DWORD, lpProviderName: LPWSTR, lpBufferSize: LPDWORD,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _NETINFOSTRUCT {
  pub cbStructure: DWORD,
  pub dwProviderVersion: DWORD,
  pub dwStatus: DWORD,
  pub dwCharacteristics: DWORD,
  pub dwHandle: ULONG_PTR,
  pub wNetType: WORD,
  pub dwPrinters: DWORD,
  pub dwDrives: DWORD,
}
#[test]
fn bindgen_test_layout__NETINFOSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<_NETINFOSTRUCT>(),
    40usize,
    concat!("Size of: ", stringify!(_NETINFOSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<_NETINFOSTRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(_NETINFOSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).cbStructure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(cbStructure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).dwProviderVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(dwProviderVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).dwStatus as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(dwStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).dwCharacteristics as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(dwCharacteristics)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).dwHandle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(dwHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).wNetType as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(wNetType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).dwPrinters as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(dwPrinters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETINFOSTRUCT>())).dwDrives as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETINFOSTRUCT),
      "::",
      stringify!(dwDrives)
    )
  );
}
pub type NETINFOSTRUCT = _NETINFOSTRUCT;
pub type LPNETINFOSTRUCT = *mut _NETINFOSTRUCT;
extern "C" {
  pub fn WNetGetNetworkInformationA(lpProvider: LPCSTR, lpNetInfoStruct: LPNETINFOSTRUCT) -> DWORD;
}
extern "C" {
  pub fn WNetGetNetworkInformationW(lpProvider: LPCWSTR, lpNetInfoStruct: LPNETINFOSTRUCT)
    -> DWORD;
}
extern "C" {
  pub fn WNetGetLastErrorA(
    lpError: LPDWORD, lpErrorBuf: LPSTR, nErrorBufSize: DWORD, lpNameBuf: LPSTR,
    nNameBufSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn WNetGetLastErrorW(
    lpError: LPDWORD, lpErrorBuf: LPWSTR, nErrorBufSize: DWORD, lpNameBuf: LPWSTR,
    nNameBufSize: DWORD,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _NETCONNECTINFOSTRUCT {
  pub cbStructure: DWORD,
  pub dwFlags: DWORD,
  pub dwSpeed: DWORD,
  pub dwDelay: DWORD,
  pub dwOptDataSize: DWORD,
}
#[test]
fn bindgen_test_layout__NETCONNECTINFOSTRUCT() {
  assert_eq!(
    ::core::mem::size_of::<_NETCONNECTINFOSTRUCT>(),
    20usize,
    concat!("Size of: ", stringify!(_NETCONNECTINFOSTRUCT))
  );
  assert_eq!(
    ::core::mem::align_of::<_NETCONNECTINFOSTRUCT>(),
    4usize,
    concat!("Alignment of ", stringify!(_NETCONNECTINFOSTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETCONNECTINFOSTRUCT>())).cbStructure as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETCONNECTINFOSTRUCT),
      "::",
      stringify!(cbStructure)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETCONNECTINFOSTRUCT>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETCONNECTINFOSTRUCT),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETCONNECTINFOSTRUCT>())).dwSpeed as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETCONNECTINFOSTRUCT),
      "::",
      stringify!(dwSpeed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_NETCONNECTINFOSTRUCT>())).dwDelay as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETCONNECTINFOSTRUCT),
      "::",
      stringify!(dwDelay)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_NETCONNECTINFOSTRUCT>())).dwOptDataSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NETCONNECTINFOSTRUCT),
      "::",
      stringify!(dwOptDataSize)
    )
  );
}
pub type NETCONNECTINFOSTRUCT = _NETCONNECTINFOSTRUCT;
pub type LPNETCONNECTINFOSTRUCT = *mut _NETCONNECTINFOSTRUCT;
extern "C" {
  pub fn MultinetGetConnectionPerformanceA(
    lpNetResource: LPNETRESOURCEA, lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT,
  ) -> DWORD;
}
extern "C" {
  pub fn MultinetGetConnectionPerformanceW(
    lpNetResource: LPNETRESOURCEW, lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT,
  ) -> DWORD;
}
extern "C" {
  pub fn uaw_CharUpperW(String: LPUWSTR) -> LPUWSTR;
}
extern "C" {
  pub fn uaw_lstrcmpW(String1: PCUWSTR, String2: PCUWSTR) -> libc::c_int;
}
extern "C" {
  pub fn uaw_lstrcmpiW(String1: PCUWSTR, String2: PCUWSTR) -> libc::c_int;
}
extern "C" {
  pub fn uaw_lstrlenW(String: LPCUWSTR) -> libc::c_int;
}
extern "C" {
  pub fn uaw_wcschr(String: PCUWSTR, Character: WCHAR) -> PUWSTR;
}
extern "C" {
  pub fn uaw_wcscpy(Destination: PUWSTR, Source: PCUWSTR) -> PUWSTR;
}
extern "C" {
  pub fn uaw_wcsicmp(String1: PCUWSTR, String2: PCUWSTR) -> libc::c_int;
}
extern "C" {
  pub fn uaw_wcslen(String: PCUWSTR) -> usize;
}
extern "C" {
  pub fn uaw_wcsrchr(String: PCUWSTR, Character: WCHAR) -> PUWSTR;
}
pub type PUWSTR_C = *mut WCHAR;
extern "C" {
  #[link_name = "\u{1}NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID"]
  pub static NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID"]
  pub static NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}DOMAIN_JOIN_GUID"]
  pub static DOMAIN_JOIN_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}DOMAIN_LEAVE_GUID"]
  pub static DOMAIN_LEAVE_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}FIREWALL_PORT_OPEN_GUID"]
  pub static FIREWALL_PORT_OPEN_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}FIREWALL_PORT_CLOSE_GUID"]
  pub static FIREWALL_PORT_CLOSE_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}MACHINE_POLICY_PRESENT_GUID"]
  pub static MACHINE_POLICY_PRESENT_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}USER_POLICY_PRESENT_GUID"]
  pub static USER_POLICY_PRESENT_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}RPC_INTERFACE_EVENT_GUID"]
  pub static RPC_INTERFACE_EVENT_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}NAMED_PIPE_EVENT_GUID"]
  pub static NAMED_PIPE_EVENT_GUID: GUID;
}
extern "C" {
  #[link_name = "\u{1}CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID"]
  pub static CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SERVICE_TRIGGER_CUSTOM_STATE_ID {
  pub Data: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout_SERVICE_TRIGGER_CUSTOM_STATE_ID() {
  assert_eq!(
    ::core::mem::size_of::<SERVICE_TRIGGER_CUSTOM_STATE_ID>(),
    8usize,
    concat!("Size of: ", stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID))
  );
  assert_eq!(
    ::core::mem::align_of::<SERVICE_TRIGGER_CUSTOM_STATE_ID>(),
    4usize,
    concat!("Alignment of ", stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SERVICE_TRIGGER_CUSTOM_STATE_ID>())).Data as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID),
      "::",
      stringify!(Data)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
  pub u: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {
  pub CustomStateId: SERVICE_TRIGGER_CUSTOM_STATE_ID,
  pub s: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1 {
  pub DataOffset: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1>(
    ),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<
      _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
    >(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<
        _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
      >()))
      .DataOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(DataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<
        _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
      >()))
      .Data as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Data)
    )
  );
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>()))
        .CustomStateId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1),
      "::",
      stringify!(CustomStateId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>())).s
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1),
      "::",
      stringify!(s)
    )
  );
}
impl Default for _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {{ union }}"
    )
  }
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>())).u as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM),
      "::",
      stringify!(u)
    )
  );
}
impl Default for _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {{ u: {:?} }}",
      self.u
    )
  }
}
pub type SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM =
  _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
pub type LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM =
  *mut _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_DESCRIPTIONA {
  pub lpDescription: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_DESCRIPTIONA() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_DESCRIPTIONA>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_DESCRIPTIONA))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_DESCRIPTIONA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_DESCRIPTIONA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_DESCRIPTIONA>())).lpDescription as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DESCRIPTIONA),
      "::",
      stringify!(lpDescription)
    )
  );
}
impl Default for _SERVICE_DESCRIPTIONA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_DESCRIPTIONA = _SERVICE_DESCRIPTIONA;
pub type LPSERVICE_DESCRIPTIONA = *mut _SERVICE_DESCRIPTIONA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_DESCRIPTIONW {
  pub lpDescription: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_DESCRIPTIONW() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_DESCRIPTIONW>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_DESCRIPTIONW))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_DESCRIPTIONW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_DESCRIPTIONW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_DESCRIPTIONW>())).lpDescription as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DESCRIPTIONW),
      "::",
      stringify!(lpDescription)
    )
  );
}
impl Default for _SERVICE_DESCRIPTIONW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_DESCRIPTIONW = _SERVICE_DESCRIPTIONW;
pub type LPSERVICE_DESCRIPTIONW = *mut _SERVICE_DESCRIPTIONW;
pub type SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONA;
pub type LPSERVICE_DESCRIPTION = LPSERVICE_DESCRIPTIONA;
pub mod _SC_ACTION_TYPE {
  pub type Type = i32;
  pub const SC_ACTION_NONE: Type = 0;
  pub const SC_ACTION_RESTART: Type = 1;
  pub const SC_ACTION_REBOOT: Type = 2;
  pub const SC_ACTION_RUN_COMMAND: Type = 3;
  pub const SC_ACTION_OWN_RESTART: Type = 4;
}
pub use self::_SC_ACTION_TYPE::Type as SC_ACTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SC_ACTION {
  pub Type: SC_ACTION_TYPE,
  pub Delay: DWORD,
}
#[test]
fn bindgen_test_layout__SC_ACTION() {
  assert_eq!(
    ::core::mem::size_of::<_SC_ACTION>(),
    8usize,
    concat!("Size of: ", stringify!(_SC_ACTION))
  );
  assert_eq!(
    ::core::mem::align_of::<_SC_ACTION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SC_ACTION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SC_ACTION>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SC_ACTION),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SC_ACTION>())).Delay as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SC_ACTION),
      "::",
      stringify!(Delay)
    )
  );
}
impl Default for _SC_ACTION {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SC_ACTION = _SC_ACTION;
pub type LPSC_ACTION = *mut _SC_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_FAILURE_ACTIONSA {
  pub dwResetPeriod: DWORD,
  pub lpRebootMsg: LPSTR,
  pub lpCommand: LPSTR,
  pub cActions: DWORD,
  pub lpsaActions: *mut SC_ACTION,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONSA() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_FAILURE_ACTIONSA>(),
    40usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONSA))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_FAILURE_ACTIONSA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONSA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).dwResetPeriod as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(dwResetPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpRebootMsg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpRebootMsg)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpCommand as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).cActions as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(cActions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpsaActions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpsaActions)
    )
  );
}
impl Default for _SERVICE_FAILURE_ACTIONSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_FAILURE_ACTIONSA = _SERVICE_FAILURE_ACTIONSA;
pub type LPSERVICE_FAILURE_ACTIONSA = *mut _SERVICE_FAILURE_ACTIONSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_FAILURE_ACTIONSW {
  pub dwResetPeriod: DWORD,
  pub lpRebootMsg: LPWSTR,
  pub lpCommand: LPWSTR,
  pub cActions: DWORD,
  pub lpsaActions: *mut SC_ACTION,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONSW() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_FAILURE_ACTIONSW>(),
    40usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONSW))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_FAILURE_ACTIONSW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONSW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).dwResetPeriod as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(dwResetPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpRebootMsg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpRebootMsg)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpCommand as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).cActions as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(cActions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpsaActions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpsaActions)
    )
  );
}
impl Default for _SERVICE_FAILURE_ACTIONSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_FAILURE_ACTIONSW = _SERVICE_FAILURE_ACTIONSW;
pub type LPSERVICE_FAILURE_ACTIONSW = *mut _SERVICE_FAILURE_ACTIONSW;
pub type SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSA;
pub type LPSERVICE_FAILURE_ACTIONS = LPSERVICE_FAILURE_ACTIONSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_DELAYED_AUTO_START_INFO {
  pub fDelayedAutostart: BOOL,
}
#[test]
fn bindgen_test_layout__SERVICE_DELAYED_AUTO_START_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_DELAYED_AUTO_START_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_DELAYED_AUTO_START_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_DELAYED_AUTO_START_INFO>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_DELAYED_AUTO_START_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_DELAYED_AUTO_START_INFO>())).fDelayedAutostart as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DELAYED_AUTO_START_INFO),
      "::",
      stringify!(fDelayedAutostart)
    )
  );
}
pub type SERVICE_DELAYED_AUTO_START_INFO = _SERVICE_DELAYED_AUTO_START_INFO;
pub type LPSERVICE_DELAYED_AUTO_START_INFO = *mut _SERVICE_DELAYED_AUTO_START_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_FAILURE_ACTIONS_FLAG {
  pub fFailureActionsOnNonCrashFailures: BOOL,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONS_FLAG() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_FAILURE_ACTIONS_FLAG>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONS_FLAG))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_FAILURE_ACTIONS_FLAG>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONS_FLAG))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_FAILURE_ACTIONS_FLAG>())).fFailureActionsOnNonCrashFailures
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONS_FLAG),
      "::",
      stringify!(fFailureActionsOnNonCrashFailures)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONS_FLAG = _SERVICE_FAILURE_ACTIONS_FLAG;
pub type LPSERVICE_FAILURE_ACTIONS_FLAG = *mut _SERVICE_FAILURE_ACTIONS_FLAG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_SID_INFO {
  pub dwServiceSidType: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_SID_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_SID_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_SID_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_SID_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_SID_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_SID_INFO>())).dwServiceSidType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_SID_INFO),
      "::",
      stringify!(dwServiceSidType)
    )
  );
}
pub type SERVICE_SID_INFO = _SERVICE_SID_INFO;
pub type LPSERVICE_SID_INFO = *mut _SERVICE_SID_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
  pub pmszRequiredPrivileges: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_REQUIRED_PRIVILEGES_INFOA() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>())).pmszRequiredPrivileges
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA),
      "::",
      stringify!(pmszRequiredPrivileges)
    )
  );
}
impl Default for _SERVICE_REQUIRED_PRIVILEGES_INFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOA = _SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub type LPSERVICE_REQUIRED_PRIVILEGES_INFOA = *mut _SERVICE_REQUIRED_PRIVILEGES_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
  pub pmszRequiredPrivileges: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_REQUIRED_PRIVILEGES_INFOW() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>())).pmszRequiredPrivileges
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW),
      "::",
      stringify!(pmszRequiredPrivileges)
    )
  );
}
impl Default for _SERVICE_REQUIRED_PRIVILEGES_INFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOW = _SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub type LPSERVICE_REQUIRED_PRIVILEGES_INFOW = *mut _SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub type SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub type LPSERVICE_REQUIRED_PRIVILEGES_INFO = LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_PRESHUTDOWN_INFO {
  pub dwPreshutdownTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_PRESHUTDOWN_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_PRESHUTDOWN_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_PRESHUTDOWN_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_PRESHUTDOWN_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_PRESHUTDOWN_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_PRESHUTDOWN_INFO>())).dwPreshutdownTimeout as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PRESHUTDOWN_INFO),
      "::",
      stringify!(dwPreshutdownTimeout)
    )
  );
}
pub type SERVICE_PRESHUTDOWN_INFO = _SERVICE_PRESHUTDOWN_INFO;
pub type LPSERVICE_PRESHUTDOWN_INFO = *mut _SERVICE_PRESHUTDOWN_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
  pub dwDataType: DWORD,
  pub cbData: DWORD,
  pub pData: PBYTE,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).dwDataType as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(dwDataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).cbData as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).pData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(pData)
    )
  );
}
impl Default for _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub type PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = *mut _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_TRIGGER {
  pub dwTriggerType: DWORD,
  pub dwAction: DWORD,
  pub pTriggerSubtype: *mut GUID,
  pub cDataItems: DWORD,
  pub pDataItems: PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_TRIGGER>(),
    32usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_TRIGGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TRIGGER))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER>())).dwTriggerType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(dwTriggerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER>())).dwAction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(dwAction)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER>())).pTriggerSubtype as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(pTriggerSubtype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER>())).cDataItems as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(cDataItems)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER>())).pDataItems as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(pDataItems)
    )
  );
}
impl Default for _SERVICE_TRIGGER {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_TRIGGER = _SERVICE_TRIGGER;
pub type PSERVICE_TRIGGER = *mut _SERVICE_TRIGGER;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_TRIGGER_INFO {
  pub cTriggers: DWORD,
  pub pTriggers: PSERVICE_TRIGGER,
  pub pReserved: PBYTE,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_TRIGGER_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_TRIGGER_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TRIGGER_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER_INFO>())).cTriggers as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(cTriggers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER_INFO>())).pTriggers as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(pTriggers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TRIGGER_INFO>())).pReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(pReserved)
    )
  );
}
impl Default for _SERVICE_TRIGGER_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_TRIGGER_INFO = _SERVICE_TRIGGER_INFO;
pub type PSERVICE_TRIGGER_INFO = *mut _SERVICE_TRIGGER_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_PREFERRED_NODE_INFO {
  pub usPreferredNode: USHORT,
  pub fDelete: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SERVICE_PREFERRED_NODE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_PREFERRED_NODE_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_PREFERRED_NODE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_PREFERRED_NODE_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_SERVICE_PREFERRED_NODE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_PREFERRED_NODE_INFO>())).usPreferredNode as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PREFERRED_NODE_INFO),
      "::",
      stringify!(usPreferredNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_PREFERRED_NODE_INFO>())).fDelete as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PREFERRED_NODE_INFO),
      "::",
      stringify!(fDelete)
    )
  );
}
pub type SERVICE_PREFERRED_NODE_INFO = _SERVICE_PREFERRED_NODE_INFO;
pub type LPSERVICE_PREFERRED_NODE_INFO = *mut _SERVICE_PREFERRED_NODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_TIMECHANGE_INFO {
  pub liNewTime: LARGE_INTEGER,
  pub liOldTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__SERVICE_TIMECHANGE_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_TIMECHANGE_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TIMECHANGE_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_TIMECHANGE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TIMECHANGE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TIMECHANGE_INFO>())).liNewTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TIMECHANGE_INFO),
      "::",
      stringify!(liNewTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_TIMECHANGE_INFO>())).liOldTime as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TIMECHANGE_INFO),
      "::",
      stringify!(liOldTime)
    )
  );
}
impl Default for _SERVICE_TIMECHANGE_INFO {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for _SERVICE_TIMECHANGE_INFO {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "_SERVICE_TIMECHANGE_INFO {{ liNewTime: {:?}, liOldTime: {:?} }}",
      self.liNewTime, self.liOldTime
    )
  }
}
pub type SERVICE_TIMECHANGE_INFO = _SERVICE_TIMECHANGE_INFO;
pub type PSERVICE_TIMECHANGE_INFO = *mut _SERVICE_TIMECHANGE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_LAUNCH_PROTECTED_INFO {
  pub dwLaunchProtected: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_LAUNCH_PROTECTED_INFO() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_LAUNCH_PROTECTED_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_LAUNCH_PROTECTED_INFO))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_LAUNCH_PROTECTED_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_LAUNCH_PROTECTED_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_LAUNCH_PROTECTED_INFO>())).dwLaunchProtected as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_LAUNCH_PROTECTED_INFO),
      "::",
      stringify!(dwLaunchProtected)
    )
  );
}
pub type SERVICE_LAUNCH_PROTECTED_INFO = _SERVICE_LAUNCH_PROTECTED_INFO;
pub type PSERVICE_LAUNCH_PROTECTED_INFO = *mut _SERVICE_LAUNCH_PROTECTED_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SC_HANDLE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_SC_HANDLE__() {
  assert_eq!(
    ::core::mem::size_of::<SC_HANDLE__>(),
    4usize,
    concat!("Size of: ", stringify!(SC_HANDLE__))
  );
  assert_eq!(
    ::core::mem::align_of::<SC_HANDLE__>(),
    4usize,
    concat!("Alignment of ", stringify!(SC_HANDLE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SC_HANDLE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SC_HANDLE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type SC_HANDLE = *mut SC_HANDLE__;
pub type LPSC_HANDLE = *mut SC_HANDLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SERVICE_STATUS_HANDLE__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_SERVICE_STATUS_HANDLE__() {
  assert_eq!(
    ::core::mem::size_of::<SERVICE_STATUS_HANDLE__>(),
    4usize,
    concat!("Size of: ", stringify!(SERVICE_STATUS_HANDLE__))
  );
  assert_eq!(
    ::core::mem::align_of::<SERVICE_STATUS_HANDLE__>(),
    4usize,
    concat!("Alignment of ", stringify!(SERVICE_STATUS_HANDLE__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SERVICE_STATUS_HANDLE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SERVICE_STATUS_HANDLE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type SERVICE_STATUS_HANDLE = *mut SERVICE_STATUS_HANDLE__;
pub mod _SC_STATUS_TYPE {
  pub type Type = i32;
  pub const SC_STATUS_PROCESS_INFO: Type = 0;
}
pub use self::_SC_STATUS_TYPE::Type as SC_STATUS_TYPE;
pub mod _SC_ENUM_TYPE {
  pub type Type = i32;
  pub const SC_ENUM_PROCESS_INFO: Type = 0;
}
pub use self::_SC_ENUM_TYPE::Type as SC_ENUM_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_STATUS {
  pub dwServiceType: DWORD,
  pub dwCurrentState: DWORD,
  pub dwControlsAccepted: DWORD,
  pub dwWin32ExitCode: DWORD,
  pub dwServiceSpecificExitCode: DWORD,
  pub dwCheckPoint: DWORD,
  pub dwWaitHint: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_STATUS>(),
    28usize,
    concat!("Size of: ", stringify!(_SERVICE_STATUS))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwServiceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwCurrentState as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwControlsAccepted as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwControlsAccepted)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwWin32ExitCode as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwWin32ExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwServiceSpecificExitCode as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwServiceSpecificExitCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwCheckPoint as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwCheckPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS>())).dwWaitHint as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwWaitHint)
    )
  );
}
pub type SERVICE_STATUS = _SERVICE_STATUS;
pub type LPSERVICE_STATUS = *mut _SERVICE_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_STATUS_PROCESS {
  pub dwServiceType: DWORD,
  pub dwCurrentState: DWORD,
  pub dwControlsAccepted: DWORD,
  pub dwWin32ExitCode: DWORD,
  pub dwServiceSpecificExitCode: DWORD,
  pub dwCheckPoint: DWORD,
  pub dwWaitHint: DWORD,
  pub dwProcessId: DWORD,
  pub dwServiceFlags: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS_PROCESS() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_STATUS_PROCESS>(),
    36usize,
    concat!("Size of: ", stringify!(_SERVICE_STATUS_PROCESS))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_STATUS_PROCESS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_STATUS_PROCESS))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwCurrentState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwControlsAccepted as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwControlsAccepted)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwWin32ExitCode as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwWin32ExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceSpecificExitCode as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceSpecificExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwCheckPoint as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwCheckPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwWaitHint as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwWaitHint)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwProcessId as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceFlags as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceFlags)
    )
  );
}
pub type SERVICE_STATUS_PROCESS = _SERVICE_STATUS_PROCESS;
pub type LPSERVICE_STATUS_PROCESS = *mut _SERVICE_STATUS_PROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ENUM_SERVICE_STATUSA {
  pub lpServiceName: LPSTR,
  pub lpDisplayName: LPSTR,
  pub ServiceStatus: SERVICE_STATUS,
}
#[test]
fn bindgen_test_layout__ENUM_SERVICE_STATUSA() {
  assert_eq!(
    ::core::mem::size_of::<_ENUM_SERVICE_STATUSA>(),
    48usize,
    concat!("Size of: ", stringify!(_ENUM_SERVICE_STATUSA))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENUM_SERVICE_STATUSA>(),
    8usize,
    concat!("Alignment of ", stringify!(_ENUM_SERVICE_STATUSA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUSA>())).lpServiceName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUSA),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUSA>())).lpDisplayName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUSA),
      "::",
      stringify!(lpDisplayName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUSA>())).ServiceStatus as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUSA),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
impl Default for _ENUM_SERVICE_STATUSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ENUM_SERVICE_STATUSA = _ENUM_SERVICE_STATUSA;
pub type LPENUM_SERVICE_STATUSA = *mut _ENUM_SERVICE_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ENUM_SERVICE_STATUSW {
  pub lpServiceName: LPWSTR,
  pub lpDisplayName: LPWSTR,
  pub ServiceStatus: SERVICE_STATUS,
}
#[test]
fn bindgen_test_layout__ENUM_SERVICE_STATUSW() {
  assert_eq!(
    ::core::mem::size_of::<_ENUM_SERVICE_STATUSW>(),
    48usize,
    concat!("Size of: ", stringify!(_ENUM_SERVICE_STATUSW))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENUM_SERVICE_STATUSW>(),
    8usize,
    concat!("Alignment of ", stringify!(_ENUM_SERVICE_STATUSW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUSW>())).lpServiceName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUSW),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUSW>())).lpDisplayName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUSW),
      "::",
      stringify!(lpDisplayName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUSW>())).ServiceStatus as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUSW),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
impl Default for _ENUM_SERVICE_STATUSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ENUM_SERVICE_STATUSW = _ENUM_SERVICE_STATUSW;
pub type LPENUM_SERVICE_STATUSW = *mut _ENUM_SERVICE_STATUSW;
pub type ENUM_SERVICE_STATUS = ENUM_SERVICE_STATUSA;
pub type LPENUM_SERVICE_STATUS = LPENUM_SERVICE_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ENUM_SERVICE_STATUS_PROCESSA {
  pub lpServiceName: LPSTR,
  pub lpDisplayName: LPSTR,
  pub ServiceStatusProcess: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__ENUM_SERVICE_STATUS_PROCESSA() {
  assert_eq!(
    ::core::mem::size_of::<_ENUM_SERVICE_STATUS_PROCESSA>(),
    56usize,
    concat!("Size of: ", stringify!(_ENUM_SERVICE_STATUS_PROCESSA))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENUM_SERVICE_STATUS_PROCESSA>(),
    8usize,
    concat!("Alignment of ", stringify!(_ENUM_SERVICE_STATUS_PROCESSA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUS_PROCESSA>())).lpServiceName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUS_PROCESSA),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUS_PROCESSA>())).lpDisplayName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUS_PROCESSA),
      "::",
      stringify!(lpDisplayName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUS_PROCESSA>())).ServiceStatusProcess as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUS_PROCESSA),
      "::",
      stringify!(ServiceStatusProcess)
    )
  );
}
impl Default for _ENUM_SERVICE_STATUS_PROCESSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ENUM_SERVICE_STATUS_PROCESSA = _ENUM_SERVICE_STATUS_PROCESSA;
pub type LPENUM_SERVICE_STATUS_PROCESSA = *mut _ENUM_SERVICE_STATUS_PROCESSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _ENUM_SERVICE_STATUS_PROCESSW {
  pub lpServiceName: LPWSTR,
  pub lpDisplayName: LPWSTR,
  pub ServiceStatusProcess: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__ENUM_SERVICE_STATUS_PROCESSW() {
  assert_eq!(
    ::core::mem::size_of::<_ENUM_SERVICE_STATUS_PROCESSW>(),
    56usize,
    concat!("Size of: ", stringify!(_ENUM_SERVICE_STATUS_PROCESSW))
  );
  assert_eq!(
    ::core::mem::align_of::<_ENUM_SERVICE_STATUS_PROCESSW>(),
    8usize,
    concat!("Alignment of ", stringify!(_ENUM_SERVICE_STATUS_PROCESSW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUS_PROCESSW>())).lpServiceName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUS_PROCESSW),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUS_PROCESSW>())).lpDisplayName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUS_PROCESSW),
      "::",
      stringify!(lpDisplayName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_ENUM_SERVICE_STATUS_PROCESSW>())).ServiceStatusProcess as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_ENUM_SERVICE_STATUS_PROCESSW),
      "::",
      stringify!(ServiceStatusProcess)
    )
  );
}
impl Default for _ENUM_SERVICE_STATUS_PROCESSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type ENUM_SERVICE_STATUS_PROCESSW = _ENUM_SERVICE_STATUS_PROCESSW;
pub type LPENUM_SERVICE_STATUS_PROCESSW = *mut _ENUM_SERVICE_STATUS_PROCESSW;
pub type ENUM_SERVICE_STATUS_PROCESS = ENUM_SERVICE_STATUS_PROCESSA;
pub type LPENUM_SERVICE_STATUS_PROCESS = LPENUM_SERVICE_STATUS_PROCESSA;
pub type SC_LOCK = LPVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _QUERY_SERVICE_LOCK_STATUSA {
  pub fIsLocked: DWORD,
  pub lpLockOwner: LPSTR,
  pub dwLockDuration: DWORD,
}
#[test]
fn bindgen_test_layout__QUERY_SERVICE_LOCK_STATUSA() {
  assert_eq!(
    ::core::mem::size_of::<_QUERY_SERVICE_LOCK_STATUSA>(),
    24usize,
    concat!("Size of: ", stringify!(_QUERY_SERVICE_LOCK_STATUSA))
  );
  assert_eq!(
    ::core::mem::align_of::<_QUERY_SERVICE_LOCK_STATUSA>(),
    8usize,
    concat!("Alignment of ", stringify!(_QUERY_SERVICE_LOCK_STATUSA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_LOCK_STATUSA>())).fIsLocked as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_LOCK_STATUSA),
      "::",
      stringify!(fIsLocked)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_LOCK_STATUSA>())).lpLockOwner as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_LOCK_STATUSA),
      "::",
      stringify!(lpLockOwner)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_LOCK_STATUSA>())).dwLockDuration as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_LOCK_STATUSA),
      "::",
      stringify!(dwLockDuration)
    )
  );
}
impl Default for _QUERY_SERVICE_LOCK_STATUSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type QUERY_SERVICE_LOCK_STATUSA = _QUERY_SERVICE_LOCK_STATUSA;
pub type LPQUERY_SERVICE_LOCK_STATUSA = *mut _QUERY_SERVICE_LOCK_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _QUERY_SERVICE_LOCK_STATUSW {
  pub fIsLocked: DWORD,
  pub lpLockOwner: LPWSTR,
  pub dwLockDuration: DWORD,
}
#[test]
fn bindgen_test_layout__QUERY_SERVICE_LOCK_STATUSW() {
  assert_eq!(
    ::core::mem::size_of::<_QUERY_SERVICE_LOCK_STATUSW>(),
    24usize,
    concat!("Size of: ", stringify!(_QUERY_SERVICE_LOCK_STATUSW))
  );
  assert_eq!(
    ::core::mem::align_of::<_QUERY_SERVICE_LOCK_STATUSW>(),
    8usize,
    concat!("Alignment of ", stringify!(_QUERY_SERVICE_LOCK_STATUSW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_LOCK_STATUSW>())).fIsLocked as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_LOCK_STATUSW),
      "::",
      stringify!(fIsLocked)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_LOCK_STATUSW>())).lpLockOwner as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_LOCK_STATUSW),
      "::",
      stringify!(lpLockOwner)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_LOCK_STATUSW>())).dwLockDuration as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_LOCK_STATUSW),
      "::",
      stringify!(dwLockDuration)
    )
  );
}
impl Default for _QUERY_SERVICE_LOCK_STATUSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type QUERY_SERVICE_LOCK_STATUSW = _QUERY_SERVICE_LOCK_STATUSW;
pub type LPQUERY_SERVICE_LOCK_STATUSW = *mut _QUERY_SERVICE_LOCK_STATUSW;
pub type QUERY_SERVICE_LOCK_STATUS = QUERY_SERVICE_LOCK_STATUSA;
pub type LPQUERY_SERVICE_LOCK_STATUS = LPQUERY_SERVICE_LOCK_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _QUERY_SERVICE_CONFIGA {
  pub dwServiceType: DWORD,
  pub dwStartType: DWORD,
  pub dwErrorControl: DWORD,
  pub lpBinaryPathName: LPSTR,
  pub lpLoadOrderGroup: LPSTR,
  pub dwTagId: DWORD,
  pub lpDependencies: LPSTR,
  pub lpServiceStartName: LPSTR,
  pub lpDisplayName: LPSTR,
}
#[test]
fn bindgen_test_layout__QUERY_SERVICE_CONFIGA() {
  assert_eq!(
    ::core::mem::size_of::<_QUERY_SERVICE_CONFIGA>(),
    64usize,
    concat!("Size of: ", stringify!(_QUERY_SERVICE_CONFIGA))
  );
  assert_eq!(
    ::core::mem::align_of::<_QUERY_SERVICE_CONFIGA>(),
    8usize,
    concat!("Alignment of ", stringify!(_QUERY_SERVICE_CONFIGA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).dwServiceType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).dwStartType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(dwStartType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).dwErrorControl as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(dwErrorControl)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).lpBinaryPathName as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(lpBinaryPathName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).lpLoadOrderGroup as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(lpLoadOrderGroup)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).dwTagId as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(dwTagId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).lpDependencies as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(lpDependencies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).lpServiceStartName as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(lpServiceStartName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGA>())).lpDisplayName as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGA),
      "::",
      stringify!(lpDisplayName)
    )
  );
}
impl Default for _QUERY_SERVICE_CONFIGA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type QUERY_SERVICE_CONFIGA = _QUERY_SERVICE_CONFIGA;
pub type LPQUERY_SERVICE_CONFIGA = *mut _QUERY_SERVICE_CONFIGA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _QUERY_SERVICE_CONFIGW {
  pub dwServiceType: DWORD,
  pub dwStartType: DWORD,
  pub dwErrorControl: DWORD,
  pub lpBinaryPathName: LPWSTR,
  pub lpLoadOrderGroup: LPWSTR,
  pub dwTagId: DWORD,
  pub lpDependencies: LPWSTR,
  pub lpServiceStartName: LPWSTR,
  pub lpDisplayName: LPWSTR,
}
#[test]
fn bindgen_test_layout__QUERY_SERVICE_CONFIGW() {
  assert_eq!(
    ::core::mem::size_of::<_QUERY_SERVICE_CONFIGW>(),
    64usize,
    concat!("Size of: ", stringify!(_QUERY_SERVICE_CONFIGW))
  );
  assert_eq!(
    ::core::mem::align_of::<_QUERY_SERVICE_CONFIGW>(),
    8usize,
    concat!("Alignment of ", stringify!(_QUERY_SERVICE_CONFIGW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).dwServiceType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).dwStartType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(dwStartType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).dwErrorControl as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(dwErrorControl)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).lpBinaryPathName as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(lpBinaryPathName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).lpLoadOrderGroup as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(lpLoadOrderGroup)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).dwTagId as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(dwTagId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).lpDependencies as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(lpDependencies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).lpServiceStartName as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(lpServiceStartName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_QUERY_SERVICE_CONFIGW>())).lpDisplayName as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_QUERY_SERVICE_CONFIGW),
      "::",
      stringify!(lpDisplayName)
    )
  );
}
impl Default for _QUERY_SERVICE_CONFIGW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type QUERY_SERVICE_CONFIGW = _QUERY_SERVICE_CONFIGW;
pub type LPQUERY_SERVICE_CONFIGW = *mut _QUERY_SERVICE_CONFIGW;
pub type QUERY_SERVICE_CONFIG = QUERY_SERVICE_CONFIGA;
pub type LPQUERY_SERVICE_CONFIG = LPQUERY_SERVICE_CONFIGA;
pub type LPSERVICE_MAIN_FUNCTIONW = ::core::option::Option<
  unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPWSTR),
>;
pub type LPSERVICE_MAIN_FUNCTIONA = ::core::option::Option<
  unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPSTR),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_TABLE_ENTRYA {
  pub lpServiceName: LPSTR,
  pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONA,
}
#[test]
fn bindgen_test_layout__SERVICE_TABLE_ENTRYA() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_TABLE_ENTRYA>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TABLE_ENTRYA))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_TABLE_ENTRYA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TABLE_ENTRYA))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TABLE_ENTRYA>())).lpServiceName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYA),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TABLE_ENTRYA>())).lpServiceProc as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYA),
      "::",
      stringify!(lpServiceProc)
    )
  );
}
impl Default for _SERVICE_TABLE_ENTRYA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_TABLE_ENTRYA = _SERVICE_TABLE_ENTRYA;
pub type LPSERVICE_TABLE_ENTRYA = *mut _SERVICE_TABLE_ENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_TABLE_ENTRYW {
  pub lpServiceName: LPWSTR,
  pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONW,
}
#[test]
fn bindgen_test_layout__SERVICE_TABLE_ENTRYW() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_TABLE_ENTRYW>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TABLE_ENTRYW))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_TABLE_ENTRYW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TABLE_ENTRYW))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TABLE_ENTRYW>())).lpServiceName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYW),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_TABLE_ENTRYW>())).lpServiceProc as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYW),
      "::",
      stringify!(lpServiceProc)
    )
  );
}
impl Default for _SERVICE_TABLE_ENTRYW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_TABLE_ENTRYW = _SERVICE_TABLE_ENTRYW;
pub type LPSERVICE_TABLE_ENTRYW = *mut _SERVICE_TABLE_ENTRYW;
pub type SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYA;
pub type LPSERVICE_TABLE_ENTRY = LPSERVICE_TABLE_ENTRYA;
pub type LPHANDLER_FUNCTION = ::core::option::Option<unsafe extern "C" fn(dwControl: DWORD)>;
pub type LPHANDLER_FUNCTION_EX = ::core::option::Option<
  unsafe extern "C" fn(
    dwControl: DWORD,
    dwEventType: DWORD,
    lpEventData: LPVOID,
    lpContext: LPVOID,
  ) -> DWORD,
>;
pub type PFN_SC_NOTIFY_CALLBACK = ::core::option::Option<unsafe extern "C" fn(pParameter: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_NOTIFY_1 {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_1() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_NOTIFY_1>(),
    64usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_1))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_NOTIFY_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_1>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_1>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_1>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_1>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_1>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
impl Default for _SERVICE_NOTIFY_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_NOTIFY_1 = _SERVICE_NOTIFY_1;
pub type PSERVICE_NOTIFY_1 = *mut _SERVICE_NOTIFY_1;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_NOTIFY_2A {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
  pub dwNotificationTriggered: DWORD,
  pub pszServiceNames: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_2A() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_NOTIFY_2A>(),
    80usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_2A))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_NOTIFY_2A>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_2A))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(ServiceStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).dwNotificationTriggered as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwNotificationTriggered)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2A>())).pszServiceNames as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pszServiceNames)
    )
  );
}
impl Default for _SERVICE_NOTIFY_2A {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_NOTIFY_2A = _SERVICE_NOTIFY_2A;
pub type PSERVICE_NOTIFY_2A = *mut _SERVICE_NOTIFY_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_NOTIFY_2W {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
  pub dwNotificationTriggered: DWORD,
  pub pszServiceNames: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_2W() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_NOTIFY_2W>(),
    80usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_2W))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_NOTIFY_2W>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_2W))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(ServiceStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).dwNotificationTriggered as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwNotificationTriggered)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_NOTIFY_2W>())).pszServiceNames as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pszServiceNames)
    )
  );
}
impl Default for _SERVICE_NOTIFY_2W {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_NOTIFY_2W = _SERVICE_NOTIFY_2W;
pub type PSERVICE_NOTIFY_2W = *mut _SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2A;
pub type PSERVICE_NOTIFY_2 = PSERVICE_NOTIFY_2A;
pub type SERVICE_NOTIFYA = SERVICE_NOTIFY_2A;
pub type PSERVICE_NOTIFYA = *mut SERVICE_NOTIFY_2A;
pub type SERVICE_NOTIFYW = SERVICE_NOTIFY_2W;
pub type PSERVICE_NOTIFYW = *mut SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY = SERVICE_NOTIFYA;
pub type PSERVICE_NOTIFY = PSERVICE_NOTIFYA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
  pub dwReason: DWORD,
  pub pszComment: LPSTR,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_CONTROL_STATUS_REASON_PARAMSA() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).dwReason as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(dwReason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).pszComment as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(pszComment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).ServiceStatus as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
impl Default for _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSA = _SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub type PSERVICE_CONTROL_STATUS_REASON_PARAMSA = *mut _SERVICE_CONTROL_STATUS_REASON_PARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
  pub dwReason: DWORD,
  pub pszComment: LPWSTR,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_CONTROL_STATUS_REASON_PARAMSW() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).dwReason as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(dwReason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).pszComment as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(pszComment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).ServiceStatus as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
impl Default for _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSW = _SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub type PSERVICE_CONTROL_STATUS_REASON_PARAMSW = *mut _SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub type SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub type PSERVICE_CONTROL_STATUS_REASON_PARAMS = PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _SERVICE_START_REASON {
  pub dwReason: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_START_REASON() {
  assert_eq!(
    ::core::mem::size_of::<_SERVICE_START_REASON>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_START_REASON))
  );
  assert_eq!(
    ::core::mem::align_of::<_SERVICE_START_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_START_REASON))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SERVICE_START_REASON>())).dwReason as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_START_REASON),
      "::",
      stringify!(dwReason)
    )
  );
}
pub type SERVICE_START_REASON = _SERVICE_START_REASON;
pub type PSERVICE_START_REASON = *mut _SERVICE_START_REASON;
extern "C" {
  pub fn ChangeServiceConfigA(
    hService: SC_HANDLE, dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD,
    lpBinaryPathName: LPCSTR, lpLoadOrderGroup: LPCSTR, lpdwTagId: LPDWORD, lpDependencies: LPCSTR,
    lpServiceStartName: LPCSTR, lpPassword: LPCSTR, lpDisplayName: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ChangeServiceConfigW(
    hService: SC_HANDLE, dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD,
    lpBinaryPathName: LPCWSTR, lpLoadOrderGroup: LPCWSTR, lpdwTagId: LPDWORD,
    lpDependencies: LPCWSTR, lpServiceStartName: LPCWSTR, lpPassword: LPCWSTR,
    lpDisplayName: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ChangeServiceConfig2A(hService: SC_HANDLE, dwInfoLevel: DWORD, lpInfo: LPVOID) -> BOOL;
}
extern "C" {
  pub fn ChangeServiceConfig2W(hService: SC_HANDLE, dwInfoLevel: DWORD, lpInfo: LPVOID) -> BOOL;
}
extern "C" {
  pub fn CloseServiceHandle(hSCObject: SC_HANDLE) -> BOOL;
}
extern "C" {
  pub fn ControlService(
    hService: SC_HANDLE, dwControl: DWORD, lpServiceStatus: LPSERVICE_STATUS,
  ) -> BOOL;
}
extern "C" {
  pub fn CreateServiceA(
    hSCManager: SC_HANDLE, lpServiceName: LPCSTR, lpDisplayName: LPCSTR, dwDesiredAccess: DWORD,
    dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD, lpBinaryPathName: LPCSTR,
    lpLoadOrderGroup: LPCSTR, lpdwTagId: LPDWORD, lpDependencies: LPCSTR,
    lpServiceStartName: LPCSTR, lpPassword: LPCSTR,
  ) -> SC_HANDLE;
}
extern "C" {
  pub fn CreateServiceW(
    hSCManager: SC_HANDLE, lpServiceName: LPCWSTR, lpDisplayName: LPCWSTR, dwDesiredAccess: DWORD,
    dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD, lpBinaryPathName: LPCWSTR,
    lpLoadOrderGroup: LPCWSTR, lpdwTagId: LPDWORD, lpDependencies: LPCWSTR,
    lpServiceStartName: LPCWSTR, lpPassword: LPCWSTR,
  ) -> SC_HANDLE;
}
extern "C" {
  pub fn DeleteService(hService: SC_HANDLE) -> BOOL;
}
extern "C" {
  pub fn EnumDependentServicesA(
    hService: SC_HANDLE, dwServiceState: DWORD, lpServices: LPENUM_SERVICE_STATUSA,
    cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumDependentServicesW(
    hService: SC_HANDLE, dwServiceState: DWORD, lpServices: LPENUM_SERVICE_STATUSW,
    cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumServicesStatusA(
    hSCManager: SC_HANDLE, dwServiceType: DWORD, dwServiceState: DWORD,
    lpServices: LPENUM_SERVICE_STATUSA, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD,
    lpServicesReturned: LPDWORD, lpResumeHandle: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumServicesStatusW(
    hSCManager: SC_HANDLE, dwServiceType: DWORD, dwServiceState: DWORD,
    lpServices: LPENUM_SERVICE_STATUSW, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD,
    lpServicesReturned: LPDWORD, lpResumeHandle: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumServicesStatusExA(
    hSCManager: SC_HANDLE, InfoLevel: SC_ENUM_TYPE, dwServiceType: DWORD, dwServiceState: DWORD,
    lpServices: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD,
    lpResumeHandle: LPDWORD, pszGroupName: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn EnumServicesStatusExW(
    hSCManager: SC_HANDLE, InfoLevel: SC_ENUM_TYPE, dwServiceType: DWORD, dwServiceState: DWORD,
    lpServices: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD,
    lpResumeHandle: LPDWORD, pszGroupName: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn GetServiceKeyNameA(
    hSCManager: SC_HANDLE, lpDisplayName: LPCSTR, lpServiceName: LPSTR, lpcchBuffer: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetServiceKeyNameW(
    hSCManager: SC_HANDLE, lpDisplayName: LPCWSTR, lpServiceName: LPWSTR, lpcchBuffer: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetServiceDisplayNameA(
    hSCManager: SC_HANDLE, lpServiceName: LPCSTR, lpDisplayName: LPSTR, lpcchBuffer: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn GetServiceDisplayNameW(
    hSCManager: SC_HANDLE, lpServiceName: LPCWSTR, lpDisplayName: LPWSTR, lpcchBuffer: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn LockServiceDatabase(hSCManager: SC_HANDLE) -> SC_LOCK;
}
extern "C" {
  pub fn NotifyBootConfigStatus(BootAcceptable: BOOL) -> BOOL;
}
extern "C" {
  pub fn OpenSCManagerA(
    lpMachineName: LPCSTR, lpDatabaseName: LPCSTR, dwDesiredAccess: DWORD,
  ) -> SC_HANDLE;
}
extern "C" {
  pub fn OpenSCManagerW(
    lpMachineName: LPCWSTR, lpDatabaseName: LPCWSTR, dwDesiredAccess: DWORD,
  ) -> SC_HANDLE;
}
extern "C" {
  pub fn OpenServiceA(
    hSCManager: SC_HANDLE, lpServiceName: LPCSTR, dwDesiredAccess: DWORD,
  ) -> SC_HANDLE;
}
extern "C" {
  pub fn OpenServiceW(
    hSCManager: SC_HANDLE, lpServiceName: LPCWSTR, dwDesiredAccess: DWORD,
  ) -> SC_HANDLE;
}
extern "C" {
  pub fn QueryServiceConfigA(
    hService: SC_HANDLE, lpServiceConfig: LPQUERY_SERVICE_CONFIGA, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceConfigW(
    hService: SC_HANDLE, lpServiceConfig: LPQUERY_SERVICE_CONFIGW, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceConfig2A(
    hService: SC_HANDLE, dwInfoLevel: DWORD, lpBuffer: LPBYTE, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceConfig2W(
    hService: SC_HANDLE, dwInfoLevel: DWORD, lpBuffer: LPBYTE, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceLockStatusA(
    hSCManager: SC_HANDLE, lpLockStatus: LPQUERY_SERVICE_LOCK_STATUSA, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceLockStatusW(
    hSCManager: SC_HANDLE, lpLockStatus: LPQUERY_SERVICE_LOCK_STATUSW, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceObjectSecurity(
    hService: SC_HANDLE, dwSecurityInformation: SECURITY_INFORMATION,
    lpSecurityDescriptor: PSECURITY_DESCRIPTOR, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceStatus(hService: SC_HANDLE, lpServiceStatus: LPSERVICE_STATUS) -> BOOL;
}
extern "C" {
  pub fn QueryServiceStatusEx(
    hService: SC_HANDLE, InfoLevel: SC_STATUS_TYPE, lpBuffer: LPBYTE, cbBufSize: DWORD,
    pcbBytesNeeded: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn RegisterServiceCtrlHandlerA(
    lpServiceName: LPCSTR, lpHandlerProc: LPHANDLER_FUNCTION,
  ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
  pub fn RegisterServiceCtrlHandlerW(
    lpServiceName: LPCWSTR, lpHandlerProc: LPHANDLER_FUNCTION,
  ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
  pub fn RegisterServiceCtrlHandlerExA(
    lpServiceName: LPCSTR, lpHandlerProc: LPHANDLER_FUNCTION_EX, lpContext: LPVOID,
  ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
  pub fn RegisterServiceCtrlHandlerExW(
    lpServiceName: LPCWSTR, lpHandlerProc: LPHANDLER_FUNCTION_EX, lpContext: LPVOID,
  ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
  pub fn SetServiceObjectSecurity(
    hService: SC_HANDLE, dwSecurityInformation: SECURITY_INFORMATION,
    lpSecurityDescriptor: PSECURITY_DESCRIPTOR,
  ) -> BOOL;
}
extern "C" {
  pub fn SetServiceStatus(
    hServiceStatus: SERVICE_STATUS_HANDLE, lpServiceStatus: LPSERVICE_STATUS,
  ) -> BOOL;
}
extern "C" {
  pub fn StartServiceCtrlDispatcherA(lpServiceStartTable: *const SERVICE_TABLE_ENTRYA) -> BOOL;
}
extern "C" {
  pub fn StartServiceCtrlDispatcherW(lpServiceStartTable: *const SERVICE_TABLE_ENTRYW) -> BOOL;
}
extern "C" {
  pub fn StartServiceA(
    hService: SC_HANDLE, dwNumServiceArgs: DWORD, lpServiceArgVectors: *mut LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn StartServiceW(
    hService: SC_HANDLE, dwNumServiceArgs: DWORD, lpServiceArgVectors: *mut LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn UnlockServiceDatabase(ScLock: SC_LOCK) -> BOOL;
}
extern "C" {
  pub fn NotifyServiceStatusChangeA(
    hService: SC_HANDLE, dwNotifyMask: DWORD, pNotifyBuffer: PSERVICE_NOTIFYA,
  ) -> DWORD;
}
extern "C" {
  pub fn NotifyServiceStatusChangeW(
    hService: SC_HANDLE, dwNotifyMask: DWORD, pNotifyBuffer: PSERVICE_NOTIFYW,
  ) -> DWORD;
}
extern "C" {
  pub fn ControlServiceExA(
    hService: SC_HANDLE, dwControl: DWORD, dwInfoLevel: DWORD, pControlParams: PVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn ControlServiceExW(
    hService: SC_HANDLE, dwControl: DWORD, dwInfoLevel: DWORD, pControlParams: PVOID,
  ) -> BOOL;
}
extern "C" {
  pub fn QueryServiceDynamicInformation(
    hServiceStatus: SERVICE_STATUS_HANDLE, dwInfoLevel: DWORD, ppDynamicInfo: *mut PVOID,
  ) -> BOOL;
}
pub mod _SC_EVENT_TYPE {
  pub type Type = i32;
  pub const SC_EVENT_DATABASE_CHANGE: Type = 0;
  pub const SC_EVENT_PROPERTY_CHANGE: Type = 1;
  pub const SC_EVENT_STATUS_CHANGE: Type = 2;
}
pub use self::_SC_EVENT_TYPE::Type as SC_EVENT_TYPE;
pub type PSC_EVENT_TYPE = *mut _SC_EVENT_TYPE::Type;
pub type PSC_NOTIFICATION_CALLBACK = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SC_NOTIFICATION_REGISTRATION {
  _unused: [u8; 0],
}
pub type PSC_NOTIFICATION_REGISTRATION = *mut _SC_NOTIFICATION_REGISTRATION;
extern "C" {
  pub fn SubscribeServiceChangeNotifications(
    hService: SC_HANDLE, eEventType: SC_EVENT_TYPE, pCallback: PSC_NOTIFICATION_CALLBACK,
    pCallbackContext: PVOID, pSubscription: *mut PSC_NOTIFICATION_REGISTRATION,
  ) -> DWORD;
}
extern "C" {
  pub fn UnsubscribeServiceChangeNotifications(pSubscription: PSC_NOTIFICATION_REGISTRATION);
}
extern "C" {
  pub fn WaitServiceState(
    hService: SC_HANDLE, dwNotify: DWORD, dwTimeout: DWORD, hCancelEvent: HANDLE,
  ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MODEMDEVCAPS {
  pub dwActualSize: DWORD,
  pub dwRequiredSize: DWORD,
  pub dwDevSpecificOffset: DWORD,
  pub dwDevSpecificSize: DWORD,
  pub dwModemProviderVersion: DWORD,
  pub dwModemManufacturerOffset: DWORD,
  pub dwModemManufacturerSize: DWORD,
  pub dwModemModelOffset: DWORD,
  pub dwModemModelSize: DWORD,
  pub dwModemVersionOffset: DWORD,
  pub dwModemVersionSize: DWORD,
  pub dwDialOptions: DWORD,
  pub dwCallSetupFailTimer: DWORD,
  pub dwInactivityTimeout: DWORD,
  pub dwSpeakerVolume: DWORD,
  pub dwSpeakerMode: DWORD,
  pub dwModemOptions: DWORD,
  pub dwMaxDTERate: DWORD,
  pub dwMaxDCERate: DWORD,
  pub abVariablePortion: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__MODEMDEVCAPS() {
  assert_eq!(
    ::core::mem::size_of::<_MODEMDEVCAPS>(),
    80usize,
    concat!("Size of: ", stringify!(_MODEMDEVCAPS))
  );
  assert_eq!(
    ::core::mem::align_of::<_MODEMDEVCAPS>(),
    4usize,
    concat!("Alignment of ", stringify!(_MODEMDEVCAPS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwActualSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwActualSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwRequiredSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwRequiredSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwDevSpecificOffset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwDevSpecificOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwDevSpecificSize as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwDevSpecificSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemProviderVersion as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemProviderVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemManufacturerOffset as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemManufacturerOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemManufacturerSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemManufacturerSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemModelOffset as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemModelOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemModelSize as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemModelSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemVersionOffset as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemVersionOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemVersionSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemVersionSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwDialOptions as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwDialOptions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwCallSetupFailTimer as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwCallSetupFailTimer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwInactivityTimeout as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwInactivityTimeout)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwSpeakerVolume as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwSpeakerVolume)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwSpeakerMode as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwSpeakerMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwModemOptions as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwModemOptions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwMaxDTERate as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwMaxDTERate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).dwMaxDCERate as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(dwMaxDCERate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMDEVCAPS>())).abVariablePortion as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMDEVCAPS),
      "::",
      stringify!(abVariablePortion)
    )
  );
}
pub type MODEMDEVCAPS = _MODEMDEVCAPS;
pub type PMODEMDEVCAPS = *mut _MODEMDEVCAPS;
pub type LPMODEMDEVCAPS = *mut _MODEMDEVCAPS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _MODEMSETTINGS {
  pub dwActualSize: DWORD,
  pub dwRequiredSize: DWORD,
  pub dwDevSpecificOffset: DWORD,
  pub dwDevSpecificSize: DWORD,
  pub dwCallSetupFailTimer: DWORD,
  pub dwInactivityTimeout: DWORD,
  pub dwSpeakerVolume: DWORD,
  pub dwSpeakerMode: DWORD,
  pub dwPreferredModemOptions: DWORD,
  pub dwNegotiatedModemOptions: DWORD,
  pub dwNegotiatedDCERate: DWORD,
  pub abVariablePortion: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__MODEMSETTINGS() {
  assert_eq!(
    ::core::mem::size_of::<_MODEMSETTINGS>(),
    48usize,
    concat!("Size of: ", stringify!(_MODEMSETTINGS))
  );
  assert_eq!(
    ::core::mem::align_of::<_MODEMSETTINGS>(),
    4usize,
    concat!("Alignment of ", stringify!(_MODEMSETTINGS))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwActualSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwActualSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwRequiredSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwRequiredSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwDevSpecificOffset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwDevSpecificOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwDevSpecificSize as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwDevSpecificSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwCallSetupFailTimer as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwCallSetupFailTimer)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwInactivityTimeout as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwInactivityTimeout)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwSpeakerVolume as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwSpeakerVolume)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwSpeakerMode as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwSpeakerMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwPreferredModemOptions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwPreferredModemOptions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwNegotiatedModemOptions as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwNegotiatedModemOptions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).dwNegotiatedDCERate as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(dwNegotiatedDCERate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_MODEMSETTINGS>())).abVariablePortion as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_MODEMSETTINGS),
      "::",
      stringify!(abVariablePortion)
    )
  );
}
pub type MODEMSETTINGS = _MODEMSETTINGS;
pub type PMODEMSETTINGS = *mut _MODEMSETTINGS;
pub type LPMODEMSETTINGS = *mut _MODEMSETTINGS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HIMC__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HIMC__() {
  assert_eq!(
    ::core::mem::size_of::<HIMC__>(),
    4usize,
    concat!("Size of: ", stringify!(HIMC__))
  );
  assert_eq!(
    ::core::mem::align_of::<HIMC__>(),
    4usize,
    concat!("Alignment of ", stringify!(HIMC__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HIMC__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HIMC__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HIMC = *mut HIMC__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct HIMCC__ {
  pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_HIMCC__() {
  assert_eq!(
    ::core::mem::size_of::<HIMCC__>(),
    4usize,
    concat!("Size of: ", stringify!(HIMCC__))
  );
  assert_eq!(
    ::core::mem::align_of::<HIMCC__>(),
    4usize,
    concat!("Alignment of ", stringify!(HIMCC__))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<HIMCC__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HIMCC__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HIMCC = *mut HIMCC__;
pub type LPHKL = *mut HKL;
pub type LPUINT = *mut UINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCOMPOSITIONFORM {
  pub dwStyle: DWORD,
  pub ptCurrentPos: POINT,
  pub rcArea: RECT,
}
#[test]
fn bindgen_test_layout_tagCOMPOSITIONFORM() {
  assert_eq!(
    ::core::mem::size_of::<tagCOMPOSITIONFORM>(),
    28usize,
    concat!("Size of: ", stringify!(tagCOMPOSITIONFORM))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCOMPOSITIONFORM>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCOMPOSITIONFORM))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPOSITIONFORM>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPOSITIONFORM),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPOSITIONFORM>())).ptCurrentPos as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPOSITIONFORM),
      "::",
      stringify!(ptCurrentPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCOMPOSITIONFORM>())).rcArea as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCOMPOSITIONFORM),
      "::",
      stringify!(rcArea)
    )
  );
}
pub type COMPOSITIONFORM = tagCOMPOSITIONFORM;
pub type PCOMPOSITIONFORM = *mut tagCOMPOSITIONFORM;
pub type NPCOMPOSITIONFORM = *mut tagCOMPOSITIONFORM;
pub type LPCOMPOSITIONFORM = *mut tagCOMPOSITIONFORM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCANDIDATEFORM {
  pub dwIndex: DWORD,
  pub dwStyle: DWORD,
  pub ptCurrentPos: POINT,
  pub rcArea: RECT,
}
#[test]
fn bindgen_test_layout_tagCANDIDATEFORM() {
  assert_eq!(
    ::core::mem::size_of::<tagCANDIDATEFORM>(),
    32usize,
    concat!("Size of: ", stringify!(tagCANDIDATEFORM))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCANDIDATEFORM>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCANDIDATEFORM))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATEFORM>())).dwIndex as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATEFORM),
      "::",
      stringify!(dwIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATEFORM>())).dwStyle as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATEFORM),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATEFORM>())).ptCurrentPos as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATEFORM),
      "::",
      stringify!(ptCurrentPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATEFORM>())).rcArea as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATEFORM),
      "::",
      stringify!(rcArea)
    )
  );
}
pub type CANDIDATEFORM = tagCANDIDATEFORM;
pub type PCANDIDATEFORM = *mut tagCANDIDATEFORM;
pub type NPCANDIDATEFORM = *mut tagCANDIDATEFORM;
pub type LPCANDIDATEFORM = *mut tagCANDIDATEFORM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagCANDIDATELIST {
  pub dwSize: DWORD,
  pub dwStyle: DWORD,
  pub dwCount: DWORD,
  pub dwSelection: DWORD,
  pub dwPageStart: DWORD,
  pub dwPageSize: DWORD,
  pub dwOffset: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout_tagCANDIDATELIST() {
  assert_eq!(
    ::core::mem::size_of::<tagCANDIDATELIST>(),
    28usize,
    concat!("Size of: ", stringify!(tagCANDIDATELIST))
  );
  assert_eq!(
    ::core::mem::align_of::<tagCANDIDATELIST>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCANDIDATELIST))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwStyle as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwSelection as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwSelection)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwPageStart as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwPageStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwPageSize as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwPageSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagCANDIDATELIST>())).dwOffset as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCANDIDATELIST),
      "::",
      stringify!(dwOffset)
    )
  );
}
pub type CANDIDATELIST = tagCANDIDATELIST;
pub type PCANDIDATELIST = *mut tagCANDIDATELIST;
pub type NPCANDIDATELIST = *mut tagCANDIDATELIST;
pub type LPCANDIDATELIST = *mut tagCANDIDATELIST;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagREGISTERWORDA {
  pub lpReading: LPSTR,
  pub lpWord: LPSTR,
}
#[test]
fn bindgen_test_layout_tagREGISTERWORDA() {
  assert_eq!(
    ::core::mem::size_of::<tagREGISTERWORDA>(),
    16usize,
    concat!("Size of: ", stringify!(tagREGISTERWORDA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagREGISTERWORDA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagREGISTERWORDA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagREGISTERWORDA>())).lpReading as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagREGISTERWORDA),
      "::",
      stringify!(lpReading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagREGISTERWORDA>())).lpWord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagREGISTERWORDA),
      "::",
      stringify!(lpWord)
    )
  );
}
impl Default for tagREGISTERWORDA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type REGISTERWORDA = tagREGISTERWORDA;
pub type PREGISTERWORDA = *mut tagREGISTERWORDA;
pub type NPREGISTERWORDA = *mut tagREGISTERWORDA;
pub type LPREGISTERWORDA = *mut tagREGISTERWORDA;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tagREGISTERWORDW {
  pub lpReading: LPWSTR,
  pub lpWord: LPWSTR,
}
#[test]
fn bindgen_test_layout_tagREGISTERWORDW() {
  assert_eq!(
    ::core::mem::size_of::<tagREGISTERWORDW>(),
    16usize,
    concat!("Size of: ", stringify!(tagREGISTERWORDW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagREGISTERWORDW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagREGISTERWORDW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagREGISTERWORDW>())).lpReading as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagREGISTERWORDW),
      "::",
      stringify!(lpReading)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagREGISTERWORDW>())).lpWord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagREGISTERWORDW),
      "::",
      stringify!(lpWord)
    )
  );
}
impl Default for tagREGISTERWORDW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
pub type REGISTERWORDW = tagREGISTERWORDW;
pub type PREGISTERWORDW = *mut tagREGISTERWORDW;
pub type NPREGISTERWORDW = *mut tagREGISTERWORDW;
pub type LPREGISTERWORDW = *mut tagREGISTERWORDW;
pub type REGISTERWORD = REGISTERWORDA;
pub type PREGISTERWORD = PREGISTERWORDA;
pub type NPREGISTERWORD = NPREGISTERWORDA;
pub type LPREGISTERWORD = LPREGISTERWORDA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagRECONVERTSTRING {
  pub dwSize: DWORD,
  pub dwVersion: DWORD,
  pub dwStrLen: DWORD,
  pub dwStrOffset: DWORD,
  pub dwCompStrLen: DWORD,
  pub dwCompStrOffset: DWORD,
  pub dwTargetStrLen: DWORD,
  pub dwTargetStrOffset: DWORD,
}
#[test]
fn bindgen_test_layout_tagRECONVERTSTRING() {
  assert_eq!(
    ::core::mem::size_of::<tagRECONVERTSTRING>(),
    32usize,
    concat!("Size of: ", stringify!(tagRECONVERTSTRING))
  );
  assert_eq!(
    ::core::mem::align_of::<tagRECONVERTSTRING>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRECONVERTSTRING))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwStrLen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwStrLen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwStrOffset as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwStrOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwCompStrLen as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwCompStrLen)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwCompStrOffset as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwCompStrOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwTargetStrLen as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwTargetStrLen)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<tagRECONVERTSTRING>())).dwTargetStrOffset as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECONVERTSTRING),
      "::",
      stringify!(dwTargetStrOffset)
    )
  );
}
pub type RECONVERTSTRING = tagRECONVERTSTRING;
pub type PRECONVERTSTRING = *mut tagRECONVERTSTRING;
pub type NPRECONVERTSTRING = *mut tagRECONVERTSTRING;
pub type LPRECONVERTSTRING = *mut tagRECONVERTSTRING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSTYLEBUFA {
  pub dwStyle: DWORD,
  pub szDescription: [CHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagSTYLEBUFA() {
  assert_eq!(
    ::core::mem::size_of::<tagSTYLEBUFA>(),
    36usize,
    concat!("Size of: ", stringify!(tagSTYLEBUFA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSTYLEBUFA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLEBUFA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTYLEBUFA>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFA),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTYLEBUFA>())).szDescription as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFA),
      "::",
      stringify!(szDescription)
    )
  );
}
pub type STYLEBUFA = tagSTYLEBUFA;
pub type PSTYLEBUFA = *mut tagSTYLEBUFA;
pub type NPSTYLEBUFA = *mut tagSTYLEBUFA;
pub type LPSTYLEBUFA = *mut tagSTYLEBUFA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagSTYLEBUFW {
  pub dwStyle: DWORD,
  pub szDescription: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagSTYLEBUFW() {
  assert_eq!(
    ::core::mem::size_of::<tagSTYLEBUFW>(),
    68usize,
    concat!("Size of: ", stringify!(tagSTYLEBUFW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagSTYLEBUFW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLEBUFW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTYLEBUFW>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFW),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagSTYLEBUFW>())).szDescription as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFW),
      "::",
      stringify!(szDescription)
    )
  );
}
pub type STYLEBUFW = tagSTYLEBUFW;
pub type PSTYLEBUFW = *mut tagSTYLEBUFW;
pub type NPSTYLEBUFW = *mut tagSTYLEBUFW;
pub type LPSTYLEBUFW = *mut tagSTYLEBUFW;
pub type STYLEBUF = STYLEBUFA;
pub type PSTYLEBUF = PSTYLEBUFA;
pub type NPSTYLEBUF = NPSTYLEBUFA;
pub type LPSTYLEBUF = LPSTYLEBUFA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagIMEMENUITEMINFOA {
  pub cbSize: UINT,
  pub fType: UINT,
  pub fState: UINT,
  pub wID: UINT,
  pub hbmpChecked: HBITMAP,
  pub hbmpUnchecked: HBITMAP,
  pub dwItemData: DWORD,
  pub szString: [CHAR; 80usize],
  pub hbmpItem: HBITMAP,
}
#[test]
fn bindgen_test_layout_tagIMEMENUITEMINFOA() {
  assert_eq!(
    ::core::mem::size_of::<tagIMEMENUITEMINFOA>(),
    128usize,
    concat!("Size of: ", stringify!(tagIMEMENUITEMINFOA))
  );
  assert_eq!(
    ::core::mem::align_of::<tagIMEMENUITEMINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagIMEMENUITEMINFOA))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).fType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(fType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).fState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(fState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).wID as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(wID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).hbmpChecked as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(hbmpChecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).hbmpUnchecked as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(hbmpUnchecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).dwItemData as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(dwItemData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).szString as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(szString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOA>())).hbmpItem as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOA),
      "::",
      stringify!(hbmpItem)
    )
  );
}
impl Default for tagIMEMENUITEMINFOA {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagIMEMENUITEMINFOA {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagIMEMENUITEMINFOA {{ cbSize: {:?}, fType: {:?}, fState: {:?}, wID: {:?}, hbmpChecked: {:?}, hbmpUnchecked: {:?}, dwItemData: {:?}, szString: [...], hbmpItem: {:?} }}" , self . cbSize , self . fType , self . fState , self . wID , self . hbmpChecked , self . hbmpUnchecked , self . dwItemData , self . hbmpItem )
  }
}
impl ::core::cmp::PartialEq for tagIMEMENUITEMINFOA {
  fn eq(&self, other: &tagIMEMENUITEMINFOA) -> bool {
    self.cbSize == other.cbSize
      && self.fType == other.fType
      && self.fState == other.fState
      && self.wID == other.wID
      && self.hbmpChecked == other.hbmpChecked
      && self.hbmpUnchecked == other.hbmpUnchecked
      && self.dwItemData == other.dwItemData
      && &self.szString[..] == &other.szString[..]
      && self.hbmpItem == other.hbmpItem
  }
}
pub type IMEMENUITEMINFOA = tagIMEMENUITEMINFOA;
pub type PIMEMENUITEMINFOA = *mut tagIMEMENUITEMINFOA;
pub type NPIMEMENUITEMINFOA = *mut tagIMEMENUITEMINFOA;
pub type LPIMEMENUITEMINFOA = *mut tagIMEMENUITEMINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagIMEMENUITEMINFOW {
  pub cbSize: UINT,
  pub fType: UINT,
  pub fState: UINT,
  pub wID: UINT,
  pub hbmpChecked: HBITMAP,
  pub hbmpUnchecked: HBITMAP,
  pub dwItemData: DWORD,
  pub szString: [WCHAR; 80usize],
  pub hbmpItem: HBITMAP,
}
#[test]
fn bindgen_test_layout_tagIMEMENUITEMINFOW() {
  assert_eq!(
    ::core::mem::size_of::<tagIMEMENUITEMINFOW>(),
    208usize,
    concat!("Size of: ", stringify!(tagIMEMENUITEMINFOW))
  );
  assert_eq!(
    ::core::mem::align_of::<tagIMEMENUITEMINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagIMEMENUITEMINFOW))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).fType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(fType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).fState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(fState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).wID as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(wID)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).hbmpChecked as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(hbmpChecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).hbmpUnchecked as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(hbmpUnchecked)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).dwItemData as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(dwItemData)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).szString as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(szString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMEMENUITEMINFOW>())).hbmpItem as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMEMENUITEMINFOW),
      "::",
      stringify!(hbmpItem)
    )
  );
}
impl Default for tagIMEMENUITEMINFOW {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for tagIMEMENUITEMINFOW {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write ! ( f , "tagIMEMENUITEMINFOW {{ cbSize: {:?}, fType: {:?}, fState: {:?}, wID: {:?}, hbmpChecked: {:?}, hbmpUnchecked: {:?}, dwItemData: {:?}, szString: [...], hbmpItem: {:?} }}" , self . cbSize , self . fType , self . fState , self . wID , self . hbmpChecked , self . hbmpUnchecked , self . dwItemData , self . hbmpItem )
  }
}
impl ::core::cmp::PartialEq for tagIMEMENUITEMINFOW {
  fn eq(&self, other: &tagIMEMENUITEMINFOW) -> bool {
    self.cbSize == other.cbSize
      && self.fType == other.fType
      && self.fState == other.fState
      && self.wID == other.wID
      && self.hbmpChecked == other.hbmpChecked
      && self.hbmpUnchecked == other.hbmpUnchecked
      && self.dwItemData == other.dwItemData
      && &self.szString[..] == &other.szString[..]
      && self.hbmpItem == other.hbmpItem
  }
}
pub type IMEMENUITEMINFOW = tagIMEMENUITEMINFOW;
pub type PIMEMENUITEMINFOW = *mut tagIMEMENUITEMINFOW;
pub type NPIMEMENUITEMINFOW = *mut tagIMEMENUITEMINFOW;
pub type LPIMEMENUITEMINFOW = *mut tagIMEMENUITEMINFOW;
pub type IMEMENUITEMINFO = IMEMENUITEMINFOA;
pub type PIMEMENUITEMINFO = PIMEMENUITEMINFOA;
pub type NPIMEMENUITEMINFO = NPIMEMENUITEMINFOA;
pub type LPIMEMENUITEMINFO = LPIMEMENUITEMINFOA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tagIMECHARPOSITION {
  pub dwSize: DWORD,
  pub dwCharPos: DWORD,
  pub pt: POINT,
  pub cLineHeight: UINT,
  pub rcDocument: RECT,
}
#[test]
fn bindgen_test_layout_tagIMECHARPOSITION() {
  assert_eq!(
    ::core::mem::size_of::<tagIMECHARPOSITION>(),
    36usize,
    concat!("Size of: ", stringify!(tagIMECHARPOSITION))
  );
  assert_eq!(
    ::core::mem::align_of::<tagIMECHARPOSITION>(),
    4usize,
    concat!("Alignment of ", stringify!(tagIMECHARPOSITION))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMECHARPOSITION>())).dwSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMECHARPOSITION),
      "::",
      stringify!(dwSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMECHARPOSITION>())).dwCharPos as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMECHARPOSITION),
      "::",
      stringify!(dwCharPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMECHARPOSITION>())).pt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMECHARPOSITION),
      "::",
      stringify!(pt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMECHARPOSITION>())).cLineHeight as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMECHARPOSITION),
      "::",
      stringify!(cLineHeight)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagIMECHARPOSITION>())).rcDocument as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIMECHARPOSITION),
      "::",
      stringify!(rcDocument)
    )
  );
}
pub type IMECHARPOSITION = tagIMECHARPOSITION;
pub type PIMECHARPOSITION = *mut tagIMECHARPOSITION;
pub type NPIMECHARPOSITION = *mut tagIMECHARPOSITION;
pub type LPIMECHARPOSITION = *mut tagIMECHARPOSITION;
pub type IMCENUMPROC =
  ::core::option::Option<unsafe extern "C" fn(arg1: HIMC, arg2: LPARAM) -> BOOL>;
extern "C" {
  pub fn ImmInstallIMEA(lpszIMEFileName: LPCSTR, lpszLayoutText: LPCSTR) -> HKL;
}
extern "C" {
  pub fn ImmInstallIMEW(lpszIMEFileName: LPCWSTR, lpszLayoutText: LPCWSTR) -> HKL;
}
extern "C" {
  pub fn ImmGetDefaultIMEWnd(arg1: HWND) -> HWND;
}
extern "C" {
  pub fn ImmGetDescriptionA(arg1: HKL, lpszDescription: LPSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
  pub fn ImmGetDescriptionW(arg1: HKL, lpszDescription: LPWSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
  pub fn ImmGetIMEFileNameA(arg1: HKL, lpszFileName: LPSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
  pub fn ImmGetIMEFileNameW(arg1: HKL, lpszFileName: LPWSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
  pub fn ImmGetProperty(arg1: HKL, arg2: DWORD) -> DWORD;
}
extern "C" {
  pub fn ImmIsIME(arg1: HKL) -> BOOL;
}
extern "C" {
  pub fn ImmSimulateHotKey(arg1: HWND, arg2: DWORD) -> BOOL;
}
extern "C" {
  pub fn ImmCreateContext() -> HIMC;
}
extern "C" {
  pub fn ImmDestroyContext(arg1: HIMC) -> BOOL;
}
extern "C" {
  pub fn ImmGetContext(arg1: HWND) -> HIMC;
}
extern "C" {
  pub fn ImmReleaseContext(arg1: HWND, arg2: HIMC) -> BOOL;
}
extern "C" {
  pub fn ImmAssociateContext(arg1: HWND, arg2: HIMC) -> HIMC;
}
extern "C" {
  pub fn ImmAssociateContextEx(arg1: HWND, arg2: HIMC, arg3: DWORD) -> BOOL;
}
extern "C" {
  pub fn ImmGetCompositionStringA(arg1: HIMC, arg2: DWORD, lpBuf: LPVOID, dwBufLen: DWORD) -> LONG;
}
extern "C" {
  pub fn ImmGetCompositionStringW(arg1: HIMC, arg2: DWORD, lpBuf: LPVOID, dwBufLen: DWORD) -> LONG;
}
extern "C" {
  pub fn ImmSetCompositionStringA(
    arg1: HIMC, dwIndex: DWORD, lpComp: LPVOID, dwCompLen: DWORD, lpRead: LPVOID, dwReadLen: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmSetCompositionStringW(
    arg1: HIMC, dwIndex: DWORD, lpComp: LPVOID, dwCompLen: DWORD, lpRead: LPVOID, dwReadLen: DWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmGetCandidateListCountA(arg1: HIMC, lpdwListCount: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn ImmGetCandidateListCountW(arg1: HIMC, lpdwListCount: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn ImmGetCandidateListA(
    arg1: HIMC, deIndex: DWORD, lpCandList: LPCANDIDATELIST, dwBufLen: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn ImmGetCandidateListW(
    arg1: HIMC, deIndex: DWORD, lpCandList: LPCANDIDATELIST, dwBufLen: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn ImmGetGuideLineA(arg1: HIMC, dwIndex: DWORD, lpBuf: LPSTR, dwBufLen: DWORD) -> DWORD;
}
extern "C" {
  pub fn ImmGetGuideLineW(arg1: HIMC, dwIndex: DWORD, lpBuf: LPWSTR, dwBufLen: DWORD) -> DWORD;
}
extern "C" {
  pub fn ImmGetConversionStatus(
    arg1: HIMC, lpfdwConversion: LPDWORD, lpfdwSentence: LPDWORD,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmSetConversionStatus(arg1: HIMC, arg2: DWORD, arg3: DWORD) -> BOOL;
}
extern "C" {
  pub fn ImmGetOpenStatus(arg1: HIMC) -> BOOL;
}
extern "C" {
  pub fn ImmSetOpenStatus(arg1: HIMC, arg2: BOOL) -> BOOL;
}
extern "C" {
  pub fn ImmGetCompositionFontA(arg1: HIMC, lplf: LPLOGFONTA) -> BOOL;
}
extern "C" {
  pub fn ImmGetCompositionFontW(arg1: HIMC, lplf: LPLOGFONTW) -> BOOL;
}
extern "C" {
  pub fn ImmSetCompositionFontA(arg1: HIMC, lplf: LPLOGFONTA) -> BOOL;
}
extern "C" {
  pub fn ImmSetCompositionFontW(arg1: HIMC, lplf: LPLOGFONTW) -> BOOL;
}
extern "C" {
  pub fn ImmConfigureIMEA(arg1: HKL, arg2: HWND, arg3: DWORD, arg4: LPVOID) -> BOOL;
}
extern "C" {
  pub fn ImmConfigureIMEW(arg1: HKL, arg2: HWND, arg3: DWORD, arg4: LPVOID) -> BOOL;
}
extern "C" {
  pub fn ImmEscapeA(arg1: HKL, arg2: HIMC, arg3: UINT, arg4: LPVOID) -> LRESULT;
}
extern "C" {
  pub fn ImmEscapeW(arg1: HKL, arg2: HIMC, arg3: UINT, arg4: LPVOID) -> LRESULT;
}
extern "C" {
  pub fn ImmGetConversionListA(
    arg1: HKL, arg2: HIMC, lpSrc: LPCSTR, lpDst: LPCANDIDATELIST, dwBufLen: DWORD, uFlag: UINT,
  ) -> DWORD;
}
extern "C" {
  pub fn ImmGetConversionListW(
    arg1: HKL, arg2: HIMC, lpSrc: LPCWSTR, lpDst: LPCANDIDATELIST, dwBufLen: DWORD, uFlag: UINT,
  ) -> DWORD;
}
extern "C" {
  pub fn ImmNotifyIME(arg1: HIMC, dwAction: DWORD, dwIndex: DWORD, dwValue: DWORD) -> BOOL;
}
extern "C" {
  pub fn ImmGetStatusWindowPos(arg1: HIMC, lpptPos: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn ImmSetStatusWindowPos(arg1: HIMC, lpptPos: LPPOINT) -> BOOL;
}
extern "C" {
  pub fn ImmGetCompositionWindow(arg1: HIMC, lpCompForm: LPCOMPOSITIONFORM) -> BOOL;
}
extern "C" {
  pub fn ImmSetCompositionWindow(arg1: HIMC, lpCompForm: LPCOMPOSITIONFORM) -> BOOL;
}
extern "C" {
  pub fn ImmGetCandidateWindow(arg1: HIMC, arg2: DWORD, lpCandidate: LPCANDIDATEFORM) -> BOOL;
}
extern "C" {
  pub fn ImmSetCandidateWindow(arg1: HIMC, lpCandidate: LPCANDIDATEFORM) -> BOOL;
}
extern "C" {
  pub fn ImmIsUIMessageA(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> BOOL;
}
extern "C" {
  pub fn ImmIsUIMessageW(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> BOOL;
}
extern "C" {
  pub fn ImmGetVirtualKey(arg1: HWND) -> UINT;
}
pub type REGISTERWORDENUMPROCA = ::core::option::Option<
  unsafe extern "C" fn(
    lpszReading: LPCSTR,
    arg1: DWORD,
    lpszString: LPCSTR,
    arg2: LPVOID,
  ) -> libc::c_int,
>;
pub type REGISTERWORDENUMPROCW = ::core::option::Option<
  unsafe extern "C" fn(
    lpszReading: LPCWSTR,
    arg1: DWORD,
    lpszString: LPCWSTR,
    arg2: LPVOID,
  ) -> libc::c_int,
>;
extern "C" {
  pub fn ImmRegisterWordA(
    arg1: HKL, lpszReading: LPCSTR, arg2: DWORD, lpszRegister: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmRegisterWordW(
    arg1: HKL, lpszReading: LPCWSTR, arg2: DWORD, lpszRegister: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmUnregisterWordA(
    arg1: HKL, lpszReading: LPCSTR, arg2: DWORD, lpszUnregister: LPCSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmUnregisterWordW(
    arg1: HKL, lpszReading: LPCWSTR, arg2: DWORD, lpszUnregister: LPCWSTR,
  ) -> BOOL;
}
extern "C" {
  pub fn ImmGetRegisterWordStyleA(arg1: HKL, nItem: UINT, lpStyleBuf: LPSTYLEBUFA) -> UINT;
}
extern "C" {
  pub fn ImmGetRegisterWordStyleW(arg1: HKL, nItem: UINT, lpStyleBuf: LPSTYLEBUFW) -> UINT;
}
extern "C" {
  pub fn ImmEnumRegisterWordA(
    arg1: HKL, arg2: REGISTERWORDENUMPROCA, lpszReading: LPCSTR, arg3: DWORD, lpszRegister: LPCSTR,
    arg4: LPVOID,
  ) -> UINT;
}
extern "C" {
  pub fn ImmEnumRegisterWordW(
    arg1: HKL, arg2: REGISTERWORDENUMPROCW, lpszReading: LPCWSTR, arg3: DWORD,
    lpszRegister: LPCWSTR, arg4: LPVOID,
  ) -> UINT;
}
extern "C" {
  pub fn ImmDisableIME(arg1: DWORD) -> BOOL;
}
extern "C" {
  pub fn ImmEnumInputContext(idThread: DWORD, lpfn: IMCENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
  pub fn ImmGetImeMenuItemsA(
    arg1: HIMC, arg2: DWORD, arg3: DWORD, lpImeParentMenu: LPIMEMENUITEMINFOA,
    lpImeMenu: LPIMEMENUITEMINFOA, dwSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn ImmGetImeMenuItemsW(
    arg1: HIMC, arg2: DWORD, arg3: DWORD, lpImeParentMenu: LPIMEMENUITEMINFOW,
    lpImeMenu: LPIMEMENUITEMINFOW, dwSize: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn ImmDisableTextFrameService(idThread: DWORD) -> BOOL;
}
extern "C" {
  pub fn ImmDisableLegacyIME() -> BOOL;
}
pub mod SDL_SYSWM_TYPE {
  #[doc = "  These are the various supported windowing subsystems"]
  pub type Type = i32;
  pub const SDL_SYSWM_UNKNOWN: Type = 0;
  pub const SDL_SYSWM_WINDOWS: Type = 1;
  pub const SDL_SYSWM_X11: Type = 2;
  pub const SDL_SYSWM_DIRECTFB: Type = 3;
  pub const SDL_SYSWM_COCOA: Type = 4;
  pub const SDL_SYSWM_UIKIT: Type = 5;
  pub const SDL_SYSWM_WAYLAND: Type = 6;
  pub const SDL_SYSWM_MIR: Type = 7;
  pub const SDL_SYSWM_WINRT: Type = 8;
  pub const SDL_SYSWM_ANDROID: Type = 9;
  pub const SDL_SYSWM_VIVANTE: Type = 10;
  pub const SDL_SYSWM_OS2: Type = 11;
}
#[doc = "  The custom event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg {
  pub version: SDL_version,
  pub subsystem: SDL_SYSWM_TYPE::Type,
  pub msg: SDL_SysWMmsg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMmsg__bindgen_ty_1 {
  pub win: SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1,
  pub dummy: libc::c_int,
  _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
  #[doc = "< The window for the message"]
  pub hwnd: HWND,
  #[doc = "< The type of message"]
  pub msg: UINT,
  #[doc = "< WORD message parameter"]
  pub wParam: WPARAM,
  #[doc = "< LONG message parameter"]
  pub lParam: LPARAM,
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>())).hwnd as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>())).msg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(msg)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>())).wParam as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wParam)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>())).lParam as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(lParam)
    )
  );
}
impl Default for SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1>(),
    32usize,
    concat!("Size of: ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1>())).win as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1),
      "::",
      stringify!(win)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1>())).dummy as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg__bindgen_ty_1),
      "::",
      stringify!(dummy)
    )
  );
}
impl Default for SDL_SysWMmsg__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMmsg__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_SysWMmsg__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMmsg>(),
    40usize,
    concat!("Size of: ", stringify!(SDL_SysWMmsg))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMmsg>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_SysWMmsg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).subsystem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg),
      "::",
      stringify!(subsystem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).msg as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMmsg),
      "::",
      stringify!(msg)
    )
  );
}
impl Default for SDL_SysWMmsg {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMmsg {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_SysWMmsg {{ version: {:?}, subsystem: {:?}, msg: {:?} }}",
      self.version, self.subsystem, self.msg
    )
  }
}
#[doc = "  The custom window manager information structure."]
#[doc = ""]
#[doc = "  When this structure is returned, it holds information about which"]
#[doc = "  low level system it is using, and will be one of SDL_SYSWM_TYPE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo {
  pub version: SDL_version,
  pub subsystem: SDL_SYSWM_TYPE::Type,
  pub info: SDL_SysWMinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMinfo__bindgen_ty_1 {
  pub win: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1,
  pub dummy: [Uint8; 64usize],
  _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
  #[doc = "< The window handle"]
  pub window: HWND,
  #[doc = "< The window device context"]
  pub hdc: HDC,
  #[doc = "< The instance handle"]
  pub hinstance: HINSTANCE,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).window as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(window)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).hdc as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hdc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).hinstance as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(hinstance)
    )
  );
}
impl Default for SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1>(),
    64usize,
    concat!("Size of: ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).win as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1),
      "::",
      stringify!(win)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).dummy as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo__bindgen_ty_1),
      "::",
      stringify!(dummy)
    )
  );
}
impl Default for SDL_SysWMinfo__bindgen_ty_1 {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMinfo__bindgen_ty_1 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(f, "SDL_SysWMinfo__bindgen_ty_1 {{ union }}")
  }
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo() {
  assert_eq!(
    ::core::mem::size_of::<SDL_SysWMinfo>(),
    72usize,
    concat!("Size of: ", stringify!(SDL_SysWMinfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SDL_SysWMinfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SDL_SysWMinfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).subsystem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo),
      "::",
      stringify!(subsystem)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).info as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SDL_SysWMinfo),
      "::",
      stringify!(info)
    )
  );
}
impl Default for SDL_SysWMinfo {
  fn default() -> Self {
    unsafe { ::core::mem::zeroed() }
  }
}
impl ::core::fmt::Debug for SDL_SysWMinfo {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    write!(
      f,
      "SDL_SysWMinfo {{ version: {:?}, subsystem: {:?}, info: {:?} }}",
      self.version, self.subsystem, self.info
    )
  }
}
extern "C" {
  #[doc = "  \\brief This function allows access to driver-dependent window information."]
  #[doc = ""]
  #[doc = "  \\param window The window about which information is being requested"]
  #[doc = "  \\param info This structure must be initialized with the SDL version, and is"]
  #[doc = "              then filled in with information about the given window."]
  #[doc = ""]
  #[doc = "  \\return SDL_TRUE if the function is implemented and the version member of"]
  #[doc = "          the \\c info struct is valid, SDL_FALSE otherwise."]
  #[doc = ""]
  #[doc = "  You typically use this function like this:"]
  #[doc = "  \\code"]
  #[doc = "  SDL_SysWMinfo info;"]
  #[doc = "  SDL_VERSION(&info.version);"]
  #[doc = "  if ( SDL_GetWindowWMInfo(window, &info) ) { ... }"]
  #[doc = "  \\endcode"]
  pub fn SDL_GetWindowWMInfo(window: *mut SDL_Window, info: *mut SDL_SysWMinfo) -> SDL_bool::Type;
}
pub type __builtin_va_list = *mut libc::c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __crt_locale_data {
  pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __crt_multibyte_data {
  pub _address: u8,
}
#[doc = "< Private"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct SDL_BlitMap {
  pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct _ACTIVATION_CONTEXT {
  pub _address: u8,
}
